/*
Type: PE
Platform: windows-x86
Architecture: x86

Libraries: 
  KERNEL32.dll

Compiler(s) Used: 
  Imported Functions (91 objects)
  VS2003 v7.1 SP1 .NET build 6030 and MASM 6.13.7299 (4 objects)
  MASM 6.13.7299 (24 objects)
  VS97 v5.0 SP3 link 5.10.7303 and VS98 v6.0 RTM/SP1/SP2 build 8168 (3 objects)
  VS98 v6.0 RTM/SP1/SP2 build 8168 (181 objects)

Segments:
r--  0x00400000-0x00401000 
r-x  0x00401000-0x0042845c  {Code}
r--  0x00429000-0x0042a31e  {Data}
rw-  0x0042b000-0x00431000  {Data}
rw-  0x00431000-0x028249b8  {Data}
---  0x028249c0-0x02824af0 
---  0x02824af0-0x02824b04 

Sections:
0x00401000-0x0042845c  .text  {Code}
0x00429000-0x0042a31e  .rdata  {Read-only data}
0x0042b000-0x028249b8  .data  {Writable data}
0x028249c0-0x02824af0  .extern  {External}
0x02824af0-0x02824b04  .synthetic_builtins  {External}
*/
00400000  struct DOS_Header __dos_header = 
00400000  {
00400000      char e_magic[0x2] = "MZ"
00400002      uint16_t e_cblp = 0x90
00400004      uint16_t e_cp = 0x3
00400006      uint16_t e_crlc = 0x0
00400008      uint16_t e_cparhdr = 0x4
0040000a      uint16_t e_minalloc = 0x0
0040000c      uint16_t e_maxalloc = 0xffff
0040000e      uint16_t e_ss = 0x0
00400010      uint16_t e_sp = 0xb8
00400012      uint16_t e_csum = 0x0
00400014      uint16_t e_ip = 0x0
00400016      uint16_t e_cs = 0x0
00400018      uint16_t e_lfarlc = 0x40
0040001a      uint16_t e_ovno = 0x0
0040001c      char e_res1[0x8] = "\x00\x00\x00\x00\x00\x00\x00", 0
00400024      uint16_t e_oemid = 0x0
00400026      uint16_t e_oeminfo = 0x0
00400028      char e_res2[0x14] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 0
0040003c      uint32_t e_lfanew = 0xd8
00400040  }

00400040  __dos_stub:
00400040  0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f  ........!..L.!This program canno
00400060  74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00  t be run in DOS mode....$.......

00400080  struct Rich_Header __rich_header = 
00400080  {
00400080      uint32_t e_magic__DanS = 0x582e2c2a
00400084      uint32_t e_align[0x3] = 
00400084      {
00400084          [0x0] =  0x0b404d6e
00400088          [0x1] =  0x0b404d6e
0040008c          [0x2] =  0x0b404d6e
00400090      }
00400090      uint32_t e_entry_id0__000c1c7b = 0xb4c5115
00400094      uint32_t e_entry_count0__4 = 0xb404d6a
00400098      uint32_t e_entry_id1__000b1fe8 = 0xb4b5286
0040009c      uint32_t e_entry_count1__1 = 0xb404d6f
004000a0      uint32_t e_entry_id2__000e1c83 = 0xb4e51ed
004000a4      uint32_t e_entry_count2__24 = 0xb404d76
004000a8      uint32_t e_entry_id3__00131f62 = 0xb53520c
004000ac      uint32_t e_entry_count3__3 = 0xb404d6d
004000b0      uint32_t e_entry_id4__00010000 = 0xb414d6e
004000b4      uint32_t e_entry_count4__91 = 0xb404d35
004000b8      uint32_t e_entry_id5__000a1fe8 = 0xb4a5286
004000bc      uint32_t e_entry_count5__180 = 0xb404dda
004000c0      char e_magic[0x4] = "Rich"
004000c4      uint32_t e_checksum = 0xb404d6e
004000c8  }

004000c8                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                  ................

004000d8  struct COFF_Header __coff_header = 
004000d8  {
004000d8      char magic[0x4] = "PE\x00", 0
004000dc      enum coff_machine machine = IMAGE_FILE_MACHINE_I386
004000de      uint16_t numberOfSections = 0x3
004000e0      uint32_t timeDateStamp = 0x37440d0f
004000e4      uint32_t pointerToSymbolTable = 0x0
004000e8      uint32_t numberOfSymbols = 0x0
004000ec      uint16_t sizeOfOptionalHeader = 0xe0
004000ee      enum coff_characteristics characteristics = IMAGE_FILE_RELOCS_STRIPPED | IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED | IMAGE_FILE_32BIT_MACHINE
004000f0  }
004000f0  struct PE32_Optional_Header __pe32_optional_header = 
004000f0  {
004000f0      enum pe_magic magic = PE_32BIT
004000f2      uint8_t majorLinkerVersion = 0x6
004000f3      uint8_t minorLinkerVersion = 0x0
004000f4      uint32_t sizeOfCode = 0x28000
004000f8      uint32_t sizeOfInitializedData = 0x23fc000
004000fc      uint32_t sizeOfUninitializedData = 0x0
00400100      uint32_t addressOfEntryPoint = 0x1f8d5
00400104      uint32_t baseOfCode = 0x1000
00400108      uint32_t baseOfData = 0x29000
0040010c      uint32_t imageBase = 0x400000
00400110      uint32_t sectionAlignment = 0x1000
00400114      uint32_t fileAlignment = 0x1000
00400118      uint16_t majorOperatingSystemVersion = 0x4
0040011a      uint16_t minorOperatingSystemVersion = 0x0
0040011c      uint16_t majorImageVersion = 0x0
0040011e      uint16_t minorImageVersion = 0x0
00400120      uint16_t majorSubsystemVersion = 0x4
00400122      uint16_t minorSubsystemVersion = 0x0
00400124      uint32_t win32VersionValue = 0x0
00400128      uint32_t sizeOfImage = 0x2425000
0040012c      uint32_t sizeOfHeaders = 0x1000
00400130      uint32_t checkSum = 0x0
00400134      enum pe_subsystem subsystem = IMAGE_SUBSYSTEM_WINDOWS_CUI
00400136      enum pe_dll_characteristics dllCharacteristics = 0
00400138      uint32_t sizeOfStackReserve = 0x100000
0040013c      uint32_t sizeOfStackCommit = 0x1000
00400140      uint32_t sizeOfHeapReserve = 0x100000
00400144      uint32_t sizeOfHeapCommit = 0x1000
00400148      uint32_t loaderFlags = 0x0
0040014c      uint32_t numberOfRvaAndSizes = 0x10
00400150      struct PE_Data_Directory_Entry exportTableEntry = 
00400150      {
00400150          uint32_t virtualAddress = 0x0
00400154          uint32_t size = 0x0
00400158      }
00400158      struct PE_Data_Directory_Entry importTableEntry = 
00400158      {
00400158          uint32_t virtualAddress = 0x29c58
0040015c          uint32_t size = 0x28
00400160      }
00400160      struct PE_Data_Directory_Entry resourceTableEntry = 
00400160      {
00400160          uint32_t virtualAddress = 0x0
00400164          uint32_t size = 0x0
00400168      }
00400168      struct PE_Data_Directory_Entry exceptionTableEntry = 
00400168      {
00400168          uint32_t virtualAddress = 0x0
0040016c          uint32_t size = 0x0
00400170      }
00400170      struct PE_Data_Directory_Entry certificateTableEntry = 
00400170      {
00400170          uint32_t virtualAddress = 0x0
00400174          uint32_t size = 0x0
00400178      }
00400178      struct PE_Data_Directory_Entry baseRelocationTableEntry = 
00400178      {
00400178          uint32_t virtualAddress = 0x0
0040017c          uint32_t size = 0x0
00400180      }
00400180      struct PE_Data_Directory_Entry debugEntry = 
00400180      {
00400180          uint32_t virtualAddress = 0x0
00400184          uint32_t size = 0x0
00400188      }
00400188      struct PE_Data_Directory_Entry architectureEntry = 
00400188      {
00400188          uint32_t virtualAddress = 0x0
0040018c          uint32_t size = 0x0
00400190      }
00400190      struct PE_Data_Directory_Entry globalPtrEntry = 
00400190      {
00400190          uint32_t virtualAddress = 0x0
00400194          uint32_t size = 0x0
00400198      }
00400198      struct PE_Data_Directory_Entry tlsTableEntry = 
00400198      {
00400198          uint32_t virtualAddress = 0x0
0040019c          uint32_t size = 0x0
004001a0      }
004001a0      struct PE_Data_Directory_Entry loadConfigTableEntry = 
004001a0      {
004001a0          uint32_t virtualAddress = 0x0
004001a4          uint32_t size = 0x0
004001a8      }
004001a8      struct PE_Data_Directory_Entry boundImportEntry = 
004001a8      {
004001a8          uint32_t virtualAddress = 0x0
004001ac          uint32_t size = 0x0
004001b0      }
004001b0      struct PE_Data_Directory_Entry iatEntry = 
004001b0      {
004001b0          uint32_t virtualAddress = 0x29000
004001b4          uint32_t size = 0x134
004001b8      }
004001b8      struct PE_Data_Directory_Entry delayImportDescriptorEntry = 
004001b8      {
004001b8          uint32_t virtualAddress = 0x0
004001bc          uint32_t size = 0x0
004001c0      }
004001c0      struct PE_Data_Directory_Entry clrRuntimeHeaderEntry = 
004001c0      {
004001c0          uint32_t virtualAddress = 0x0
004001c4          uint32_t size = 0x0
004001c8      }
004001c8      struct PE_Data_Directory_Entry reservedEntry = 
004001c8      {
004001c8          uint32_t virtualAddress = 0x0
004001cc          uint32_t size = 0x0
004001d0      }
004001d0  }
004001d0  struct Section_Header __section_headers[0x3] = 
004001d0  {
004001d0      [0x0] = 
004001d0      {
004001d0          char name[0x8] = ".text\x00\x00", 0
004001d8          uint32_t virtualSize = 0x2745c
004001dc          uint32_t virtualAddress = 0x1000
004001e0          uint32_t sizeOfRawData = 0x28000
004001e4          uint32_t pointerToRawData = 0x1000
004001e8          uint32_t pointerToRelocations = 0x0
004001ec          uint32_t pointerToLineNumbers = 0x0
004001f0          uint16_t numberOfRelocations = 0x0
004001f2          uint16_t numberOfLineNumbers = 0x0
004001f4          enum pe_section_flags characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ
004001f8      }
004001f8      [0x1] = 
004001f8      {
004001f8          char name[0x8] = ".rdata\x00", 0
00400200          uint32_t virtualSize = 0x131e
00400204          uint32_t virtualAddress = 0x29000
00400208          uint32_t sizeOfRawData = 0x2000
0040020c          uint32_t pointerToRawData = 0x29000
00400210          uint32_t pointerToRelocations = 0x0
00400214          uint32_t pointerToLineNumbers = 0x0
00400218          uint16_t numberOfRelocations = 0x0
0040021a          uint16_t numberOfLineNumbers = 0x0
0040021c          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ
00400220      }
00400220      [0x2] = 
00400220      {
00400220          char name[0x8] = ".data\x00\x00", 0
00400228          uint32_t virtualSize = 0x23f99b8
0040022c          uint32_t virtualAddress = 0x2b000
00400230          uint32_t sizeOfRawData = 0x6000
00400234          uint32_t pointerToRawData = 0x2b000
00400238          uint32_t pointerToRelocations = 0x0
0040023c          uint32_t pointerToLineNumbers = 0x0
00400240          uint16_t numberOfRelocations = 0x0
00400242          uint16_t numberOfLineNumbers = 0x0
00400244          enum pe_section_flags characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE
00400248      }
00400248  }

00400248                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
00400260  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400280  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004002a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004002c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004002e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400300  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400320  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400340  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004003a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004003c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004003e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400400  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400460  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004004a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004004c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004004e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004005a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004005c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004005e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400600  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400620  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400640  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400660  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400680  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004006a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004006c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004006e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400700  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400720  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400760  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004007a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004007c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004007e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400800  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400820  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400860  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400880  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004008a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004008c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004008e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400900  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400920  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400940  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400960  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400980  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004009a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004009c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004009e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400a80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400aa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ac0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ae0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400b80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ba0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400bc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400be0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400c80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ca0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400cc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ce0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400d80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400da0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400dc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400de0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400e80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ea0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ec0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400ee0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400f80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400fa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400fc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00400fe0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

.text section started  {0x401000-0x42845c}

00401000    int32_t sub_401000(int32_t arg1)

00401007  if (arg1 == 0)
0040100c      return 0
0040100c  
0040100d  if (arg1 s>= 0)
00401034      int32_t eax_2 = data_282361c
00401039      int32_t edx_1 = arg1 * 3
00401041      void* edi = eax_2 + (edx_1 << 2)
00401045      int32_t eax_3 = sub_401000(*(eax_2 + (edx_1 << 2) + 4))
0040104a      int32_t edx_2 = *(edi + 8)
0040104d      *(edi + 4) = eax_3
00401059      *(edi + 8) = sub_401000(edx_2)
00401060      return arg1
00401060  
00401017  int32_t i_1 = neg.d(arg1)
0040102e  int32_t i
0040102e  
0040102e  do
00401025      i = *(data_282360c + i_1 * 0x1c + 0x14)
00401025      
0040102a      if (i == 0)
0040102a          break
0040102a      
0040102c      i_1 = i
0040102e  while (i != 0)
00401033  return neg.d(i_1)

00401061     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00401070    int32_t sub_401070(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4)

0040107a  int32_t* edx = arg1[1]
00401084  int32_t eax_1 = *arg1 ^ arg3
00401086  int32_t* ebp = arg2[1]
004010a2  int32_t esi_3 = 0
004010ad  void* edi_1 = (*arg2 ^ arg4) * 0x1c + &data_239e0c0
004010b4  int32_t ecx_3 = *edx
004010b8  int32_t eax_3
004010b8  
004010b8  if (ecx_3 s> 0)
004010ba      void* edx_1 = &edx[2]
004010ba      
004010e7      do
004010d1          long double x87_r7_5 = fconvert.t(*(edx_1 - 4)) * fconvert.t(*edi_1)
004010d1              + fconvert.t(*(edx_1 + 4)) * fconvert.t(*(edi_1 + 8))
004010d1              + fconvert.t(*edx_1) * fconvert.t(*(edi_1 + 4)) - fconvert.t(*(edi_1 + 0xc))
004010d4          long double temp0_1 = fconvert.t(-0.29999999999999999)
004010d4          x87_r7_5 - temp0_1
004010da          eax_3.w = (x87_r7_5 < temp0_1 ? 1 : 0) << 8
004010da              | (is_unordered.t(x87_r7_5, temp0_1) ? 1 : 0) << 0xa
004010da              | (x87_r7_5 == temp0_1 ? 1 : 0) << 0xe
004010da          
004010df          if ((eax_3:1.b & 1) != 0)
00401131              return 1
00401131          
004010e1          esi_3 += 1
004010e2          edx_1 += 0xc
004010e7      while (esi_3 s< ecx_3)
004010e7  
004010e9  int32_t esi_4 = *ebp
004010ec  int32_t edx_2 = 0
004010ec  
004010f0  if (esi_4 s<= 0)
00401127      return 0
00401127  
004010f2  void* ecx_4 = &ebp[2]
004010f2  
00401109  while (true)
00401109      long double x87_r7_10 =
00401109          fconvert.t(*(ecx_4 + 4)) * fconvert.t(*(eax_1 * 0x1c + &data_239e0c8))
00401109          + fconvert.t(*(ecx_4 - 4)) * fconvert.t(*(eax_1 * 0x1c + &data_239e0c0))
00401109          + fconvert.t(*ecx_4) * fconvert.t(*(eax_1 * 0x1c + &data_239e0c4))
00401109          - fconvert.t(*(eax_1 * 0x1c + &data_239e0cc))
0040110c      long double temp1_1 = fconvert.t(-0.29999999999999999)
0040110c      x87_r7_10 - temp1_1
00401112      eax_3.w = (x87_r7_10 < temp1_1 ? 1 : 0) << 8
00401112          | (is_unordered.t(x87_r7_10, temp1_1) ? 1 : 0) << 0xa
00401112          | (x87_r7_10 == temp1_1 ? 1 : 0) << 0xe
00401112      
00401117      if ((eax_3:1.b & 1) != 0)
00401131          return 1
00401131      
00401119      edx_2 += 1
0040111a      ecx_4 += 0xc
0040111a      
0040111f      if (edx_2 s>= esi_4)
00401127          return 0

00401132                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00401140    int32_t sub_401140(int32_t* arg1)

0040114e  int32_t edi = data_282360c
00401167  int32_t* ebx = edi + arg1[2] * 0x1c
0040116a  int32_t ecx_2 = arg1[3] * 7
00401173  int32_t* var_8 = ebx
00401177  int32_t* edi_1 = edi + (ecx_2 << 2)
0040117c  arg1 = edi_1
0040117c  
00401180  if (ebx[2] != *(edi + (ecx_2 << 2) + 8))
0040118b      return 0
0040118b  
00401194  if (ebx[3] != edi_1[3])
0040119f      return 0
0040119f  
004011a0  int32_t* i = ebx[1]
004011a3  char ecx_4 = 0
004011a5  char eax_6 = 0
004011a7  int32_t var_c = 0
004011ad  int32_t var_10 = 0
004011ad  
004011b1  if (i != 0)
004012d8      do
004011b7          int32_t ecx_5 = i[2]
004011ba          int32_t eax_7 = *ebx
004011c0          int32_t edx_3
004011c0          edx_3.b = ecx_5 != eax_7
004011c0          
004011d0          if (ecx_5 != eax_7 && i[3] != eax_7)
004011d7              sub_40f970("face does not belong to area1")
004011d7          
004011df          int32_t eax_8 = i[2]
004011e2          int32_t ecx_6 = *ebx
004011e6          int32_t* edi_2
004011e6          
004011e6          if (eax_8 != ecx_6)
004011f9              edi_2 = arg1
004011fd              label_4011fd:
004011fd              
00401204              if (eax_8 != *edi_2 || i[3] != ecx_6)
00401215                  var_c |= i[4]
00401215                  
00401223                  if (sub_401730(i, edx_3) != 0)
00401229                      int32_t eax_11
00401229                      eax_11.b = var_c.b | 8
0040122b                      var_c = eax_11
0040122b                  
0040122f                  int32_t* esi_2 = edi_2[1]
0040122f                  
00401234                  if (esi_2 != 0)
00401240                      while (true)
00401240                          int32_t ecx_9 = esi_2[2]
00401243                          int32_t eax_12 = *edi_2
00401249                          int32_t edx_5
00401249                          edx_5.b = ecx_9 != eax_12
00401249                          
00401255                          if (ecx_9 != eax_12 && esi_2[3] != eax_12)
0040125c                              sub_40f970("face does not belong to area2")
0040125c                          
00401264                          int32_t eax_13 = esi_2[2]
00401267                          int32_t ecx_10 = *ebx
00401267                          
0040126b                          if (eax_13 == ecx_10)
00401276                              ebx = var_8
00401276                          
00401287                          if ((eax_13 != ecx_10 || esi_2[3] != *arg1)
00401287                                  && (eax_13 != *arg1 || esi_2[3] != ecx_10))
00401294                              var_10 |= esi_2[4]
00401294                              
004012a2                              if (sub_401730(esi_2, edx_5) != 0)
004012a8                                  int32_t eax_16
004012a8                                  eax_16.b = var_10.b | 8
004012aa                                  var_10 = eax_16
004012aa                              
004012c0                              if (sub_401070(i, esi_2, edx_3, edx_5) != 0)
00401305                                  return 0
00401305                          
004012c2                          esi_2 = esi_2[edx_5 + 8]
004012c2                          
004012c8                          if (esi_2 == 0)
004012c8                              break
004012c8                          
0040123c                          edi_2 = arg1
004011e6          else
004011e8              edi_2 = arg1
004011e8              
004011f1              if (i[3] != *edi_2)
004011f1                  goto label_4011fd
004012d2          i = i[edx_3 + 8]
004012d8      while (i != 0)
004012d8      
004012de      edi_1 = arg1
004012e2      eax_6 = var_10.b
004012e6      ecx_4 = var_c.b
004012e6  
004012f1  if ((ecx_4 & 4) != 0 && (eax_6 & 8) != 0)
00401305      return 0
00401305  
004012fa  if ((eax_6 & 4) != 0 && (ecx_4 & 8) != 0)
00401305      return 0
00401305  
00401306  int32_t eax_19 = data_2823608
00401306  
00401310  if (eax_19 s>= 0x10000)
00401317      sub_40f970("AAS_MAX_AREAS")
0040131c      eax_19 = data_2823608
0040131c  
00401333  int32_t* ebp = data_282360c + eax_19 * 0x1c
00401336  *ebp = eax_19
00401340  data_2823608 += 1
00401349  ebp[2] = ebx[2]
0040134f  ebp[3] = ebx[3]
00401352  ebp[1] = 0
00401359  void* i_1 = ebx[1]
00401359  
0040135e  if (i_1 != 0)
004013ae      do
00401360          int32_t eax_21 = *(i_1 + 8)
00401363          int32_t ecx_15 = *ebx
00401369          int32_t edx_13
00401369          edx_13.b = eax_21 != ecx_15
00401370          void* i_3 = *(i_1 + (edx_13 << 2) + 0x20)
00401370          
00401378          if (eax_21 == ecx_15)
00401383              ebx = var_8
00401383          
00401394          if ((eax_21 != ecx_15 || *(i_1 + 0xc) != *arg1)
00401394                  && (eax_21 != *arg1 || *(i_1 + 0xc) != ecx_15))
00401398              sub_4018d0(i_1, ebx)
004013a0              sub_401850(i_1, edx_13, ebp)
004013a0          
004013a8          i_1 = i_3
004013ae      while (i_1 != 0)
004013ae      
004013b0      edi_1 = arg1
004013b0  
004013b4  void* i_2 = edi_1[1]
004013b4  
004013b9  while (i_2 != 0)
004013bb      int32_t eax_22 = *(i_2 + 8)
004013be      int32_t ecx_16 = *edi_1
004013c4      int32_t edx_16
004013c4      edx_16.b = eax_22 != ecx_16
004013c9      void* i_4 = *(i_2 + (edx_16 << 2) + 0x20)
004013d1      int32_t edx_17 = *ebx
004013d1      
004013e3      if ((eax_22 != edx_17 || *(i_2 + 0xc) != ecx_16)
004013e3              && (eax_22 != ecx_16 || *(i_2 + 0xc) != edx_17))
004013eb          sub_4018d0(i_2, arg1)
004013f3          sub_401850(i_2, edx_16, ebp)
004013f3      
004013fb      i_2 = i_4
004013ff      edi_1 = arg1
004013ff  
0040140f  ebx[5] = *ebp
00401412  ebx[4] = 1
00401415  int32_t edx_18 = *ebp
00401418  edi_1[4] = 1
0040141b  edi_1[5] = edx_18
00401422  sub_401970(*ebp)
0040142b  sub_401b00(*ebp)
0040143c  return 1

0040143d                                                                                         90 90 90                               ...

00401440    int32_t sub_401440()

0040144c  int32_t var_c = 0
00401454  sub_410080("AAS_MergeAreas")
00401459  int32_t var_24 = 1
00401460  sub_40fa00("%6d areas merged")
00401465  int32_t eax = data_2823608
0040146a  int32_t ebx = 1
0040146a  
00401474  if (eax s> 1)
0040147a      void* edi_1 = 0x1c
0040147f      int32_t var_8_1 = 0x14
00401487      void* var_4_1 = 0x1c
00401487      
0040152b      do
00401490          int32_t* edi_2 = edi_1 + data_282360c
00401490          
004014a8          if (edi_2[4] == 0 && (*(var_8_1 + data_2823614 + 4) & 1) != 0)
004014af              int32_t ecx_2
004014af              
004014af              for (int32_t* i = edi_2[1]; i != 0; i = i[ecx_2 + 8])
004014b1                  int32_t eax_3 = i[2]
004014ba                  ecx_2.b = eax_3 != *edi_2
004014ba                  
004014c1                  if (eax_3 != 0)
004014c3                      int32_t ecx_3 = i[3]
004014c3                      
004014c8                      if (ecx_3 != 0)
004014cc                          if (eax_3 == ebx)
004014ce                              eax_3 = ecx_3
004014ce                          
004014dd                          if ((*(data_2823614 + eax_3 * 0x14 + 4) & 1) != 0
004014dd                                  && sub_401140(i) != 0)
004014fb                              int32_t var_20_2 = var_c + 1
00401501                              var_c += 1
00401505                              sub_40fa00("\r%6d")
0040150a                              break
0040150a          
00401515          eax = data_2823608
0040151a          ebx += 1
0040151b          edi_1 = var_4_1 + 0x1c
00401523          var_4_1 = edi_1
00401527          var_8_1 += 0x14
0040152b      while (ebx s< eax)
0040152b  
00401534  int32_t var_4_2 = 1
00401534  
0040153c  if (eax s> 1)
0040153e      void* ebx_1 = 0x1c
004015b6      bool cond:2_1
004015b6      
004015b6      do
00401543          int32_t ecx_4 = data_282360c
0040154d          int32_t* edi_4 = ebx_1 + ecx_4
0040154d          
00401552          if (*(ebx_1 + ecx_4 + 0x10) == 0)
00401559              int32_t edx_6
00401559              
00401559              for (int32_t* i_1 = edi_4[1]; i_1 != 0; i_1 = i_1[edx_6 + 8])
0040155b                  int32_t eax_9 = i_1[2]
00401564                  edx_6.b = eax_9 != *edi_4
00401564                  
00401572                  if (eax_9 != 0 && i_1[3] != 0 && sub_401140(i_1) != 0)
00401590                      int32_t var_20_4 = var_c + 1
00401596                      var_c += 1
0040159a                      sub_40fa00("\r%6d")
0040159f                      break
0040159f          
004015ad          ebx_1 += 0x1c
004015b0          cond:2_1 = var_4_2 + 1 s< data_2823608
004015b2          var_4_2 += 1
004015b6      while (cond:2_1)
004015b6  
004015bc  int32_t var_20_5 = var_c
004015c2  sub_410030("\r%6d areas merged\n")
004015d8  return sub_401000(1)

004015d9                                                                             90 90 90 90 90 90 90                           .......

004015e0    int32_t* sub_4015e0()

004015e8  data_2823600 = 0
004015ee  void* eax = sub_410570(&data_9c4000)
004015fe  void* ecx_1 = data_430310 + &data_9c4000
00401604  data_2823604 = eax
00401609  data_430310 = ecx_1
0040160f  data_2823608 = 0
00401615  void* eax_1 = sub_410570(0x1c0000)
00401625  int32_t ecx_3 = data_430310 + 0x1c0000
0040162b  data_282360c = eax_1
00401630  data_430310 = ecx_3
00401636  data_2823610 = 0
0040163c  void* eax_2 = sub_410570(0x140000)
0040164c  int32_t ecx_5 = data_430310 + 0x140000
00401652  data_2823614 = eax_2
00401657  data_430310 = ecx_5
0040165d  data_2823618 = 0
00401663  void* eax_3 = sub_410570(0x2ee000)
00401673  int32_t edx_1 = data_430310 + 0x2ee000
00401679  data_282361c = eax_3
0040167e  data_430310 = edx_1
00401684  sub_410030("allocated ")
0040168f  sub_4105f0(data_430310)
004016a2  return sub_410030(" of tmp AAS memory\n")

004016a3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

004016b0    int32_t* sub_4016b0()

004016b0  void* eax_1 = data_2823604
004016b9  data_2823600 = 0
004016bf  sub_4105e0(eax_1)
004016c4  void* ecx = data_282360c
004016ca  data_2823608 = 0
004016d1  sub_4105e0(ecx)
004016d6  void* edx = data_2823614
004016dc  data_2823610 = 0
004016e3  sub_4105e0(edx)
004016e8  void* eax = data_282361c
004016ed  data_2823618 = 0
004016f4  sub_4105e0(eax)
004016fe  sub_410030("freed ")
0040170a  sub_4105f0(data_430310)
00401714  int32_t* result = sub_410030(" of tmp AAS memory\n")
0040171c  data_430310 = 0
00401723  return result

00401724              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00401730    int32_t sub_401730(int32_t* arg1, int32_t arg2)

0040173c  if ((arg1[4].b & 5) == 0)
00401743      float ecx_1 = data_42b16c
00401749      float edx_1 = data_42b170
0040174f      float var_c = data_42b168
00401760      sub_4104d0(&var_c)
0040177d      int32_t eax_4 = (*arg1 ^ arg2) * 0x1c
0040179c      long double x87_r7_4 = fconvert.t(edx_1) * fconvert.t(*(eax_4 + &data_239e0c8))
0040179c          + fconvert.t(ecx_1) * fconvert.t(*(eax_4 + &data_239e0c4))
0040179c          + fconvert.t(var_c) * fconvert.t(*(eax_4 + &data_239e0c0))
0040179e      long double temp0_1 = fconvert.t((*"333?)")[0].d)
0040179e      x87_r7_4 - temp0_1
004017a4      eax_4.w = (x87_r7_4 < temp0_1 ? 1 : 0) << 8
004017a4          | (is_unordered.t(x87_r7_4, temp0_1) ? 1 : 0) << 0xa
004017a4          | (x87_r7_4 == temp0_1 ? 1 : 0) << 0xe
004017a4      
004017a9      if ((eax_4:1.b & 0x41) == 0)
004017b4          return 1
004017b4  
004017bb  return 0

004017bc                                                                                      90 90 90 90                              ....

004017c0    int32_t sub_4017c0(int32_t* arg1)

004017cc  if ((arg1[4].b & 1) != 0)
004017d3      float ecx_1 = data_42b16c
004017d9      float edx_1 = data_42b170
004017df      float var_c = data_42b168
004017f0      sub_4104d0(&var_c)
00401807      int32_t eax_4 = *arg1 * 0x1c
00401826      long double x87_r7_4 = fconvert.t(edx_1) * fconvert.t(*(eax_4 + &data_239e0c8))
00401826          + fconvert.t(ecx_1) * fconvert.t(*(eax_4 + &data_239e0c4))
00401826          + fconvert.t(var_c) * fconvert.t(*(eax_4 + &data_239e0c0))
00401828      long double temp0_1 = fconvert.t((*"333?)")[0].d)
00401828      x87_r7_4 - temp0_1
0040182e      eax_4.w = (x87_r7_4 < temp0_1 ? 1 : 0) << 8
0040182e          | (is_unordered.t(x87_r7_4, temp0_1) ? 1 : 0) << 0xa
0040182e          | (x87_r7_4 == temp0_1 ? 1 : 0) << 0xe
0040182e      
00401833      if ((eax_4:1.b & 0x41) == 0)
0040183e          return 1
0040183e  
00401845  return 0

00401846                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00401850    int32_t* sub_401850(void* arg1, int32_t arg2, int32_t* arg3)

0040185c  int32_t* result
0040185c  
0040185c  if (arg2 == 0)
00401882      if (*(arg1 + 8) != 0)
00401889          sub_40f970("AAS_AddFaceSideToArea: already a…")
00401889      
00401891      result = arg3
00401897      *(arg1 + 8) = *result
0040185c  else
00401863      if (*(arg1 + 0xc) != 0)
0040186a          sub_40f970("AAS_AddFaceSideToArea: already a…")
0040186a      
00401872      result = arg3
00401878      *(arg1 + 0xc) = *result
00401878  
0040189a  void* ecx_2 = result[1]
0040189a  
0040189f  if (ecx_2 != 0)
004018ac      int32_t ebx_1
004018ac      ebx_1.b = *(ecx_2 + 8) != *result
004018b0      *(ecx_2 + (ebx_1 << 2) + 0x18) = arg1
004018b0  
004018b8  *(arg1 + (arg2 << 2) + 0x20) = result[1]
004018bc  *(arg1 + (arg2 << 2) + 0x18) = 0
004018c4  result[1] = arg1
004018c9  return result

004018ca                                90 90 90 90 90 90                                                            ......

004018d0    int32_t sub_4018d0(void* arg1, int32_t* arg2)

004018dc  int32_t eax = *arg2
004018dc  
004018e7  if (*(arg1 + 8) != eax && *(arg1 + 0xc) != eax)
004018ee      sub_40f970("AAS_RemoveFaceFromArea: face not…")
004018ee  
004018f6  int32_t edi = *arg2
00401900  int32_t result
00401900  result.b = *(arg1 + 8) != edi
00401905  int32_t ecx_1 = *(arg1 + (result << 2) + 0x18)
00401905  
0040190b  if (ecx_1 == 0)
00401923      arg2[1] = *(arg1 + (result << 2) + 0x20)
0040190b  else
00401916      int32_t ebx_1
00401916      ebx_1.b = *(ecx_1 + 8) != edi
00401919      *(ecx_1 + (ebx_1 << 2) + 0x20) = *(arg1 + (result << 2) + 0x20)
00401919  
00401926  void* ecx_3 = *(arg1 + (result << 2) + 0x20)
00401926  
0040192c  if (ecx_3 != 0)
0040193a      int32_t ebx_2
0040193a      ebx_2.b = *(ecx_3 + 8) != *arg2
0040193d      *(ecx_3 + (ebx_2 << 2) + 0x18) = *(arg1 + (result << 2) + 0x18)
0040193d  
00401943  if (result != 0)
00401945      *(arg1 + 0xc) = 0
00401948      *(arg1 + (result << 2) + 0x18) = 0
0040194c      *(arg1 + (result << 2) + 0x20) = 0
00401954      return result
00401954  
00401955  *(arg1 + 8) = 0
00401958  *(arg1 + (result << 2) + 0x18) = 0
0040195c  *(arg1 + (result << 2) + 0x20) = 0
00401964  return result

00401965                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00401970    int32_t* sub_401970(float arg1)

00401973  int32_t ecx = data_282360c
0040197b  float ebp = arg1
00401988  float var_24 = 0f
00401990  int32_t eax_1 = ebp i* 7
00401992  float var_20 = 0f
0040199a  float var_1c = 0f
004019a2  int32_t* edi = ecx + (eax_1 << 2)
004019a5  int32_t* result = *(ecx + (eax_1 << 2) + 0x10)
004019a5  
004019ab  if (result != 0)
004019b2      result = sub_410030("AAS_CheckArea: invalid area\n")
004019b2  
004019ba  void* i = edi[1]
004019bd  arg1 = 0f
004019bd  
004019c7  while (i != 0)
004019db      int32_t ebx_1
004019db      ebx_1.b = *(i + 8) != *edi
004019de      float var_18
004019de      result = sub_410b00(*(i + 4), &var_18)
004019eb      i = *(i + (ebx_1 << 2) + 0x20)
004019f4      var_24 = fconvert.s(fconvert.t(var_18) + fconvert.t(var_24))
00401a00      float var_14
00401a00      var_20 = fconvert.s(fconvert.t(var_14) + fconvert.t(var_20))
00401a0c      float var_10
00401a0c      var_1c = fconvert.s(fconvert.t(var_10) + fconvert.t(var_1c))
00401a1a      arg1 = fconvert.s(fconvert.t(arg1) + fconvert.t(1f))
00401a1a  
00401a26  long double x87_r7_10 = fconvert.t(1f) / fconvert.t(arg1)
00401a2a  int32_t* i_1 = edi[1]
00401a35  float var_24_1 = fconvert.s(x87_r7_10 * fconvert.t(var_24))
00401a3f  float var_20_1 = fconvert.s(x87_r7_10 * fconvert.t(var_20))
00401a47  float var_1c_1 = fconvert.s(x87_r7_10 * fconvert.t(var_1c))
00401a4b  int32_t ebx_2
00401a4b  
00401a4b  for (; i_1 != 0; i_1 = i_1[ebx_2 + 8])
00401a5c      ebx_2.b = i_1[2] != *edi
00401a6c      int32_t ecx_3 = (*i_1 ^ ebx_2) * 7
00401a91      long double x87_r7_16 =
00401a91          fconvert.t(var_1c_1) * fconvert.t(*((ecx_3 << 2) + &data_239e0c8))
00401a91          + fconvert.t(var_20_1) * fconvert.t(*((ecx_3 << 2) + &data_239e0c4))
00401a91          + fconvert.t(var_24_1) * fconvert.t(*((ecx_3 << 2) + &data_239e0c0))
00401a91          - fconvert.t(*((ecx_3 << 2) + &data_239e0cc))
00401a94      long double temp0_1 = fconvert.t(0f)
00401a94      x87_r7_16 - temp0_1
00401a9a      float* eax_6
00401a9a      eax_6.w = (x87_r7_16 < temp0_1 ? 1 : 0) << 8
00401a9a          | (is_unordered.t(x87_r7_16, temp0_1) ? 1 : 0) << 0xa
00401a9a          | (x87_r7_16 == temp0_1 ? 1 : 0) << 0xe
00401a9a      
00401a9f      if ((eax_6:1.b & 1) != 0)
00401ab0          int32_t eax_7
00401ab0          int32_t edx_4
00401ab0          edx_4:eax_7 = muls.dp.d(0x66666667, i_1 - data_2823604)
00401ab2          int32_t edx_5 = edx_4 s>> 4
00401abc          int32_t var_3c_2 = edx_5 + (edx_5 u>> 0x1f)
00401abd          float var_40_2 = ebp
00401ac3          sub_410030("AAS_CheckArea: area %d face %d i…")
00401ac3      
00401ad9      float var_28
00401ad9      float var_c
00401ad9      result = sub_410940(i_1[1], &var_c, &var_28)
00401ad9  
00401af4  return result

00401af5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00401b00    float* sub_401b00(float arg1)

00401b03  int32_t ecx = data_282360c
00401b0a  float ebx = arg1
00401b10  float var_24 = 0f
00401b1f  float var_20 = 0f
00401b27  float* result = ebx i* 7
00401b29  float var_1c = 0f
00401b31  arg1 = 0f
00401b39  void* i = *(ecx + (result << 2) + 4)
00401b3d  int32_t* edi = ecx + (result << 2)
00401b42  int32_t* var_2c = edi
00401b42  
00401b46  while (i != 0)
00401b51      if (*(i + 8) == 0)
00401b62          int32_t eax_2
00401b62          int32_t edx_2
00401b62          edx_2:eax_2 = muls.dp.d(0x66666667, i - data_2823604)
00401b64          int32_t edx_3 = edx_2 s>> 4
00401b6e          int32_t __saved_ebp_1 = edx_3 + (edx_3 u>> 0x1f)
00401b74          sub_40f970("face %d has no front area\n")
00401b74      
00401b8c      int32_t edx_5
00401b8c      edx_5.b = *(i + 8) != *edi
00401b93      float var_18
00401b93      result = sub_410b00(*(i + 4), &var_18)
00401ba0      i = *(i + (edx_5 << 2) + 0x20)
00401ba4      edi = var_2c
00401bad      var_24 = fconvert.s(fconvert.t(var_18) + fconvert.t(var_24))
00401bb9      float var_14
00401bb9      var_20 = fconvert.s(fconvert.t(var_14) + fconvert.t(var_20))
00401bc5      float var_10
00401bc5      var_1c = fconvert.s(fconvert.t(var_10) + fconvert.t(var_1c))
00401bd3      arg1 = fconvert.s(fconvert.t(arg1) + fconvert.t(1f))
00401bd3  
00401be3  long double x87_r7_10 = fconvert.t(1f) / fconvert.t(arg1)
00401be7  int32_t* i_1 = edi[1]
00401bf2  float var_24_1 = fconvert.s(x87_r7_10 * fconvert.t(var_24))
00401bfc  float var_20_1 = fconvert.s(x87_r7_10 * fconvert.t(var_20))
00401c04  float var_1c_1 = fconvert.s(x87_r7_10 * fconvert.t(var_1c))
00401c08  int32_t eax_6
00401c08  
00401c08  for (; i_1 != 0; i_1 = i_1[eax_6 + 8])
00401c18      eax_6.b = i_1[2] != *edi
00401c2c      int32_t ecx_6 = (*i_1 ^ eax_6) * 7
00401c51      long double x87_r7_16 =
00401c51          fconvert.t(var_1c_1) * fconvert.t(*((ecx_6 << 2) + &data_239e0c8))
00401c51          + fconvert.t(var_20_1) * fconvert.t(*((ecx_6 << 2) + &data_239e0c4))
00401c51          + fconvert.t(var_24_1) * fconvert.t(*((ecx_6 << 2) + &data_239e0c0))
00401c51          - fconvert.t(*((ecx_6 << 2) + &data_239e0cc))
00401c54      long double temp0_1 = fconvert.t(0f)
00401c54      x87_r7_16 - temp0_1
00401c5a      float* eax_9
00401c5a      eax_9.w = (x87_r7_16 < temp0_1 ? 1 : 0) << 8
00401c5a          | (is_unordered.t(x87_r7_16, temp0_1) ? 1 : 0) << 0xa
00401c5a          | (x87_r7_16 == temp0_1 ? 1 : 0) << 0xe
00401c5a      
00401c5f      if ((eax_9:1.b & 1) != 0)
00401c67          int32_t var_40_2 = i_1[3]
00401c70          int32_t var_44_1 = i_1[2]
00401c78          int32_t eax_11
00401c78          int32_t edx_9
00401c78          edx_9:eax_11 = muls.dp.d(0x66666667, i_1 - data_2823604)
00401c7a          int32_t edx_10 = edx_9 s>> 4
00401c84          int32_t var_48_1 = edx_10 + (edx_10 u>> 0x1f)
00401c85          float var_4c_1 = ebx
00401c8b          sub_410030("area %d face %d flipped: front a…")
00401c92          int32_t* edi_2 = i_1[1]
00401c99          *i_1 ^= 1
00401ca1          i_1[1] = sub_410e00(edi_2)
00401ca4          sub_410740(edi_2)
00401ca9          edi = var_2c
00401ca9      
00401cbe      float var_28
00401cbe      float var_c
00401cbe      sub_410940(i_1[1], &var_c, &var_28)
00401cd3      void* edx_13 = *i_1 * 7
00401ce3      long double x87_r7_19 =
00401ce3          fabs(fconvert.t(var_28) - fconvert.t(*((edx_13 << 2) + &data_239e0cc)))
00401ce5      long double temp1_1 = fconvert.t(0.40000000000000002)
00401ce5      x87_r7_19 - temp1_1
00401ceb      result.w = (x87_r7_19 < temp1_1 ? 1 : 0) << 8
00401ceb          | (is_unordered.t(x87_r7_19, temp1_1) ? 1 : 0) << 0xa
00401ceb          | (x87_r7_19 == temp1_1 ? 1 : 0) << 0xe
00401ceb      
00401cf0      if ((result:1.b & 0x41) == 0)
00401d42          label_401d42:
00401d42          int32_t eax_13
00401d42          int32_t edx_15
00401d42          edx_15:eax_13 = muls.dp.d(0x66666667, i_1 - data_2823604)
00401d44          int32_t edx_16 = edx_15 s>> 4
00401d4e          int32_t var_40_4 = edx_16 + (edx_16 u>> 0x1f)
00401d4f          float var_44_3 = ebx
00401d55          result = sub_410080("area %d face %d winding plane un…")
00401cf0      else
00401cf8          long double x87_r7_22 =
00401cf8              fabs(fconvert.t(var_c) - fconvert.t(*((edx_13 << 2) + &data_239e0c0)))
00401cfa          long double temp2_1 = fconvert.t(0.0001)
00401cfa          x87_r7_22 - temp2_1
00401d00          result.w = (x87_r7_22 < temp2_1 ? 1 : 0) << 8
00401d00              | (is_unordered.t(x87_r7_22, temp2_1) ? 1 : 0) << 0xa
00401d00              | (x87_r7_22 == temp2_1 ? 1 : 0) << 0xe
00401d00          
00401d05          if ((result:1.b & 0x41) == 0)
00401d05              goto label_401d42
00401d05          
00401d0e          float var_8
00401d0e          long double x87_r7_25 =
00401d0e              fabs(fconvert.t(var_8) - fconvert.t(*((edx_13 << 2) + &data_239e0c4)))
00401d10          long double temp3_1 = fconvert.t(0.0001)
00401d10          x87_r7_25 - temp3_1
00401d16          result.w = (x87_r7_25 < temp3_1 ? 1 : 0) << 8
00401d16              | (is_unordered.t(x87_r7_25, temp3_1) ? 1 : 0) << 0xa
00401d16              | (x87_r7_25 == temp3_1 ? 1 : 0) << 0xe
00401d16          
00401d1b          if ((result:1.b & 0x41) == 0)
00401d1b              goto label_401d42
00401d1b          
00401d24          float var_4
00401d24          long double x87_r7_28 =
00401d24              fabs(fconvert.t(var_4) - fconvert.t(*((edx_13 << 2) + &data_239e0c8)))
00401d26          long double temp4_1 = fconvert.t(0.0001)
00401d26          x87_r7_28 - temp4_1
00401d2c          result.w = (x87_r7_28 < temp4_1 ? 1 : 0) << 8
00401d2c              | (is_unordered.t(x87_r7_28, temp4_1) ? 1 : 0) << 0xa
00401d2c              | (x87_r7_28 == temp4_1 ? 1 : 0) << 0xe
00401d2c          
00401d31          if ((result:1.b & 0x41) == 0)
00401d31              goto label_401d42
00401d31  
00401d70  return result

00401d71                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00401d80    int32_t sub_401d80()

00401d80  int32_t ecx
00401d80  int32_t var_4 = ecx
00401d87  int32_t i = 1
00401d8e  int32_t i_1 = 1
00401d8e  
00401d92  if (data_2823608 s> 1)
00401d98      int32_t ebp_1 = 0x1c
00401d98      
00401de1      do
00401d9d          void* eax = data_282360c
00401dab          int32_t ebx_1
00401dab          
00401dab          for (void* j = *(eax + ebp_1 + 4); j != 0; j = *(j + (ebx_1 << 2) + 0x20))
00401dba              ebx_1.b = *(j + 8) != *(eax + ebp_1)
00401dbd              sub_4107c0(*(j + 4))
00401dbd              int16_t top = top - 1
00401dbd              unimplemented  {call sub_4107c0}
00401dbd          
00401dd7          i = i_1 + 1
00401dd8          ebp_1 += 0x1c
00401ddd          i_1 = i
00401de1      while (i s< data_2823608)
00401de1  
00401de8  return i

00401de9                             90 90 90 90 90 90 90                                                           .......

00401df0    int32_t sub_401df0()

00401df0  void* ecx
00401df0  void* var_4 = ecx
00401df7  sub_410080("AAS_RemoveTinyFaces")
00401dfc  int32_t result = data_2823608
00401e01  int32_t ebx = 1
00401e01  
00401e0b  if (result s> 1)
00401e12      void* ebp_1 = 0x1c
00401e19      var_4 = 0x1c
00401e19      
00401ee4      do
00401e22          int32_t* ebp_2 = ebp_1 + data_282360c
00401e24          void* i_1 = ebp_2[1]
00401e24          
00401e29          if (i_1 != 0)
00401ecb              void* i
00401ecb              
00401ecb              do
00401e3d                  int32_t edx_1
00401e3d                  edx_1.b = *(i_1 + 8) != *ebp_2
00401e40                  i = *(i_1 + (edx_1 << 2) + 0x20)
00401e44                  long double st0_1 = sub_410a50(*(i_1 + 4))
00401e49                  long double temp0_1 = fconvert.t(1f)
00401e49                  st0_1 - temp0_1
00401e49                  
00401e57                  if ((((st0_1 < temp0_1 ? 1 : 0) << 8
00401e57                          | (is_unordered.t(st0_1, temp0_1) ? 1 : 0) << 0xa
00401e57                          | (st0_1 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
00401e59                      int32_t eax_3 = *(i_1 + 8)
00401e59                      
00401e5e                      if (eax_3 != 0)
00401e74                          sub_4018d0(i_1, data_282360c + eax_3 * 0x1c)
00401e74                      
00401e7c                      int32_t eax_5 = *(i_1 + 0xc)
00401e7c                      
00401e81                      if (eax_5 != 0)
00401e97                          sub_4018d0(i_1, data_282360c + eax_5 * 0x1c)
00401e97                      
00401eac                      int32_t eax_7
00401eac                      int32_t edx_4
00401eac                      edx_4:eax_7 = muls.dp.d(0x66666667, i_1 - data_2823604)
00401eae                      int32_t edx_5 = edx_4 s>> 4
00401eb8                      int32_t var_18_4 = edx_5 + (edx_5 u>> 0x1f)
00401eb9                      int32_t var_1c_3 = ebx
00401ebf                      sub_410080("area %d face %d is tiny")
00401ebf                  
00401ec9                  i_1 = i
00401ecb              while (i != 0)
00401ecb          
00401ed5          result = data_2823608
00401eda          ebx += 1
00401edb          ebp_1 = var_4 + 0x1c
00401ee0          var_4 = ebp_1
00401ee4      while (ebx s< result)
00401ee4  
00401eef  return result


00401ef0    int32_t sub_401ef0()

00401ef9  sub_410080("AAS_CreateAreaSettings")
00401efe  int32_t i = 1
00401f03  int32_t __saved_esi = 1
00401f09  sub_40fa00("%6d areas provided with settings")
00401f09  
00401f18  if (data_2823608 s> 1)
00401f20      void* ecx_1 = 0x14
00401f25      void* esi_1 = 0x1c
00401f2b      void* var_4_1 = 0x14
00401f2f      void* var_8_1 = 0x1c
00401f2f      
00401fdb      do
00401f3f          int32_t* esi_2 = esi_1 + data_282360c
00401f41          data_2823610 += 1
00401f41          
00401f4c          if (esi_2[4] == 0)
00401f57              int32_t* ecx_2 = ecx_1 + data_2823614
00401f59              int32_t edx_4 = 0
00401f5b              *ecx_2 = esi_2[3]
00401f62              int32_t ebx_2
00401f62              
00401f62              for (void* j = esi_2[1]; j != 0; j = *(j + (ebx_2 << 2) + 0x20))
00401f69                  edx_4 |= *(j + 0x10)
00401f70                  ebx_2.b = *(j + 8) != *esi_2
00401f70              
00401f7e              ecx_2[1] = 0
00401f7e              
00401f85              if ((edx_4.b & 4) != 0)
00401f87                  ecx_2[1] = 1
00401f87              
00401f91              if ((edx_4.b & 2) != 0)
00401f96                  int32_t eax_4
00401f96                  eax_4.b = ecx_2[1].b | 2
00401f98                  ecx_2[1] = eax_4
00401f98              
00401f9f              if ((esi_2[3].b & 7) != 0)
00401fa4                  int32_t eax_5
00401fa4                  eax_5.b = ecx_2[1].b | 4
00401fa6                  ecx_2[1] = eax_5
00401fa6              
00401fac              int32_t i_1 = i
00401fb2              ecx_2[2] = esi_2[2]
00401fb5              sub_40fa00("\r%6d")
00401fb5          
00401fca          i += 1
00401fcb          esi_1 = var_8_1 + 0x1c
00401fce          ecx_1 = var_4_1 + 0x14
00401fd3          var_8_1 = esi_1
00401fd7          var_4_1 = ecx_1
00401fdb      while (i s< data_2823608)
00401fdb  
00401ff5  return sub_40fa00(&data_42b33c)

00401ff6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00402000    int32_t sub_402000(void* arg1)

00402000  int32_t eax = data_2823608
00402000  
0040200d  if (eax s>= 0x10000)
00402014      sub_40f970("AAS_MAX_AREAS")
00402019      eax = data_2823608
00402019  
00402029  if (eax == 0)
0040202b      eax = 1
00402030      data_2823608 = 1
00402030  
0040203b  void* esi = arg1
00402046  int32_t var_8 = 0
0040204c  int32_t* ebp = data_282360c + eax * 0x1c
0040204f  *ebp = eax
00402052  ebp[1] = 0
0040205a  int32_t ebx_1
0040205a  
0040205a  for (void* i = *(esi + 0x50); i != 0; i = *(i + (ebx_1 << 2) + 0x28))
00402063      int32_t eax_1 = *(i + 0x44)
0040206a      ebx_1.b = *(i + 0x24) == esi
0040206a      
0040206f      if (eax_1 == 0)
0040208e          int32_t eax_3 = data_2823600
0040208e          
00402095          if (eax_3 == 0)
00402097              eax_3 = 1
00402095          else if (eax_3 s>= 0x3e800)
004020aa              sub_40f970("AAS_MAX_FACES")
004020af              eax_3 = data_2823600
004020af          
004020ba          data_2823600 = eax_3 + 1
004020c1          int32_t eax_6
004020c1          int32_t edx_3
004020c1          edx_3:eax_6 = sx.q(eax_3)
004020da          int32_t* esi_1 = data_2823604 + ((eax_6 ^ edx_3) - edx_3) * 0x28
004020dd          *esi_1 = *(i + 0x48) ^ ebx_1
004020df          int32_t* eax_11
004020df          
004020df          if (ebx_1 == 0)
004020f0              eax_11 = sub_410dd0(*(i + 0x30))
004020df          else
004020e5              eax_11 = sub_410e00(*(i + 0x30))
004020e5          
004020fc          int32_t edx_6
004020fc          edx_6.b = ebx_1 == 0
004020ff          esi_1[1] = eax_11
00402111          int32_t eax_13
00402111          
00402111          if ((*(*(i + (edx_6 << 2) + 0x20) + 0x3c) & 0x10001) != 0)
00402116              eax_13.b = esi_1[4].b | 1
00402136              esi_1[4] = eax_13
00402111          else if ((*(arg1 + 0x3c) & 0x38) != 0)
00402127              eax_13.b = esi_1[4].b | 0x10
00402129              esi_1[4] = eax_13
00402129              
00402132              if ((*(*(i + (edx_6 << 2) + 0x20) + 0x3c) & 0x38) == 0)
00402134                  eax_13.b |= 0x20
00402136                  esi_1[4] = eax_13
00402136          
0040214c          if ((*(*(i + (ebx_1 << 2) + 0x20) + 0x3c) & 0x20000000) != 0
0040214c                  || (*(*(i + (edx_6 << 2) + 0x20) + 0x3c) & 0x20000000) != 0)
00402151              int32_t eax_14
00402151              eax_14.b = esi_1[4].b | 2
00402153              esi_1[4] = eax_14
00402153          
00402161          if (sub_4017c0(esi_1) != 0)
00402166              int32_t eax_16
00402166              eax_16.b = esi_1[4].b | 4
00402168              esi_1[4] = eax_16
00402168          
00402177          int32_t ecx_9 = var_8 | esi_1[4]
0040217b          esi_1[5] = 0
00402183          var_8 = ecx_9
00402187          *(i + 0x44) = eax_3
0040218a          sub_401850(esi_1, 0, ebp)
0040218f          esi = arg1
0040206f      else
00402081          sub_401850(data_2823604 + eax_1 * 0x28, 1, ebp)
00402081  
004021a7  int32_t var_1c_6 = *ebp
004021ad  sub_40fa00("\r%6d")
004021bd  int32_t edx_13 = not.d(*(esi + 0x58)) & data_42b164
004021bf  ebp[3] = 0
004021c2  ebp[2] = edx_13
004021c2  
004021d3  if (((*(esi + 0x3c)).w:1.b & 0x80) != 0)
004021d5      ebp[3] = 8
004021d5  
004021dc  if ((*(esi + 0x3c) & 0x20) != 0)
004021de      ebp[3] |= 1
004021de  
004021e5  if ((*(esi + 0x3c) & 8) != 0)
004021ea      int32_t eax_18
004021ea      eax_18.b = ebp[3].b | 2
004021ec      ebp[3] = eax_18
004021ec  
004021f3  if ((*(esi + 0x3c) & 0x10) != 0)
004021f8      int32_t eax_19
004021f8      eax_19.b = ebp[3].b | 4
004021fa      ebp[3] = eax_19
004021fa  
00402201  sub_401b00(*ebp)
0040220a  sub_401970(*ebp)
00402218  int32_t ecx_14 = data_2823608 + 1
00402221  data_2823608 = ecx_14
0040222d  return 1 - ecx_14

0040222e                                            90 90                                                                ..

00402230    int32_t sub_402230(int32_t* arg1)

00402238  if (*arg1 == 0xffffffff)
004022a2      if ((arg1[0xf].b & 1) == 0)
004022b2          return sub_402000(arg1)
004022b2      
004022a7      return 0
004022a7  
0040223a  int32_t result = data_2823618
0040223a  
00402241  if (result == 0)
00402243      result = 1
00402241  else if (result s>= 0x3e800)
00402256      sub_40f970("AAS_MAX_NODES")
0040225b      result = data_2823618
0040225b  
00402271  int32_t* esi = data_282361c + result * 0xc
00402274  data_2823618 = result + 1
0040227b  *esi = *arg1
00402286  esi[1] = sub_402230(arg1[0xb])
00402295  esi[2] = sub_402230(arg1[0xc])
0040229d  return result

004022b3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

004022c0    int32_t* sub_4022c0(int32_t* arg1)

004022c5  sub_410080("AAS_CreateConvexAreas")
004022ca  int32_t var_8 = 0
004022d1  sub_40fa00("%6d areas created")
004022d1  
004022e6  if (sub_402230(arg1) != 1)
004022ed      sub_41dc50("BUG: didn't end with root node\n")
004022ed  
004022fa  sub_40fa00(&data_42b33c)
00402305  int32_t var_8_1 = data_2823608
00402313  return sub_410080("%6d areas created")

00402314                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00402320    int32_t* sub_402320(int32_t arg1, int32_t* arg2)

00402320  int32_t ecx
00402320  int32_t var_4_1 = ecx
0040232f  int32_t esi = 0
00402333  int32_t* i = data_282360c
00402339  int32_t* ebx = &i[arg1 * 7]
0040233c  int32_t* var_4 = ebx
0040233c  
00402343  if (ebx[4] == 0)
00402349      int32_t* edi_1 = arg2
00402349      
0040235a      if (i[edi_1 * 7 + 4] == 0)
00402360          i = ebx[1]
00402363          arg2 = nullptr
00402363          
00402369          if (i != 0)
0040238f              do
00402371                  int32_t ecx_3 = i[2]
00402378                  int32_t edx_3
00402378                  edx_3.b = ecx_3 != *ebx
00402378                  
00402382                  if (i[3] == edi_1 || ecx_3 == edi_1)
00402384                      arg2 = i
00402388                      esi += 1
00402388                  
00402389                  i = i[edx_3 + 8]
0040238f              while (i != 0)
0040238f              
00402391              i = arg2
00402391              
0040239c              if (i != 0 && esi s> 1)
004023a2                  int32_t var_18_1 = esi
004023a3                  int32_t* var_1c_1 = edi_1
004023a4                  int32_t var_20_1 = arg1
004023aa                  i = sub_410080("---- tmp area %d and %d have %d …")
004023af                  int32_t* esi_1 = ebx[1]
004023af                  
004023b7                  if (esi_1 != 0)
004023bf                      while (true)
004023bf                          i = esi_1[2]
004023c8                          int32_t ecx_4
004023c8                          ecx_4.b = i != *ebx
004023cd                          int32_t ecx_5 = esi_1[3]
004023cd                          
004023d6                          if (ecx_5 == edi_1 || i == edi_1)
004023da                              int32_t var_18_2 = ecx_5
004023db                              int32_t* i_1 = i
004023dc                              int32_t var_20_2 = *esi_1
004023ec                              int32_t eax_2
004023ec                              int32_t edx_6
004023ec                              edx_6:eax_2 = muls.dp.d(0x66666667, esi_1 - data_2823604)
004023ee                              int32_t edx_7 = edx_6 s>> 4
004023f8                              int32_t var_24_1 = edx_7 + (edx_7 u>> 0x1f)
004023fe                              i = sub_410080("face %d, planenum = %d, face->fr…")
004023fe                          
00402406                          esi_1 = esi_1[ecx_4 + 8]
00402406                          
0040240c                          if (esi_1 == 0)
0040240c                              break
0040240c                          
004023bb                          ebx = var_4
004023bb  
00402413  return i

00402414                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00402420    int32_t sub_402420()

00402420  int32_t result = data_2823608
00402426  int32_t edi = 1
00402426  
0040242d  if (result s> 1)
00402454      do
00402430          int32_t* esi_1 = 1
00402430          
00402437          if (result s> 1)
0040244f              do
0040243b                  if (edi != esi_1)
0040243f                      sub_402320(edi, esi_1)
00402444                      result = data_2823608
00402444                  
0040244c                  esi_1 += 1
0040244f              while (esi_1 s< result)
0040244f          
00402451          edi += 1
00402454      while (edi s< result)
00402454  
00402458  return result

00402459                                                                             90 90 90 90 90 90 90                           .......

00402460    void sub_402460(int32_t* arg1)

00402467  int32_t ebx = arg1[2]
0040246a  int32_t ebp = arg1[3]
0040246a  
00402473  if (ebx != 0 && ebp != 0)
00402476      int32_t* edi_1 = arg1[1]
00402480      arg1[1] = sub_410e00(edi_1)
00402483      sub_410740(edi_1)
00402496      *arg1 ^= 1
0040249d      int32_t edi_4 = ebx * 0x1c
004024a5      sub_4018d0(arg1, edi_4 + data_282360c)
004024b9      int32_t ebx_3 = ebp * 0x1c
004024c1      sub_4018d0(arg1, ebx_3 + data_282360c)
004024d2      sub_401850(arg1, 1, edi_4 + data_282360c)
004024e3      sub_401850(arg1, 0, ebx_3 + data_282360c)


004024f0    void* sub_4024f0(int32_t arg1, int32_t arg2)

00402501  int32_t esi = 0
00402503  int32_t ecx_1 = arg1 * 7
00402505  void* i = data_282360c
0040250f  int32_t* ecx_2 = i + (ecx_1 << 2)
0040250f  
00402518  if (*(i + (ecx_1 << 2) + 0x10) == 0)
0040251e      int32_t edi_1 = arg2
0040251e      
0040252f      if (*(i + edi_1 * 0x1c + 0x10) == 0)
00402535          i = ecx_2[1]
00402538          void* i_2 = nullptr
0040253c          arg2 = 0
00402540          int32_t var_c_1 = 0
00402540          
00402544          if (i != 0)
00402584              do
00402550                  int32_t ecx_4 = *(i + 8)
0040255e                  int32_t edx_3
0040255e                  edx_3.b = ecx_4 != *ecx_2
0040255e                  
00402567                  if (*(i + 0xc) == edi_1 || ecx_4 == edi_1)
0040256d                      esi += 1
00402570                      i_2 = i
00402570                      
00402572                      if (ecx_4 != arg1)
0040257a                          var_c_1 += 1
00402572                      else
00402574                          arg2 += 1
00402574                  
0040257e                  i = *(i + (edx_3 << 2) + 0x20)
00402584              while (i != 0)
00402584              
00402599              if (i_2 != 0 && esi s> 1 && esi != arg2 && esi != var_c_1)
004025d7                  int32_t* i_1
004025d7                  
004025d7                  do
0040259f                      i_1 = ecx_2[1]
0040259f                      
004025a4                      if (i_1 == 0)
004025a4                          break
004025a4                      
004025a6                      int32_t edx_4 = *ecx_2
004025a6                      
004025a9                      while (true)
004025a9                          i = i_1[2]
004025b3                          int32_t ecx_5
004025b3                          ecx_5.b = i != edx_4
004025b3                          
004025c0                          if ((i_1[3] == edi_1 || i == edi_1) && i != edx_4)
004025c0                              break
004025c0                          
004025c2                          i_1 = i_1[ecx_5 + 8]
004025c2                          
004025c8                          if (i_1 == 0)
004025e0                              return i
004025e0                      
004025cd                      i = sub_402460(i_1)
004025d7                  while (i_1 != 0)
004025d7  
004025e0  return i

004025e1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

004025f0    int32_t* sub_4025f0()

004025f1  int32_t __saved_esi = 0
004025f8  sub_40fa00("%6d areas checked for shared fac…")
004025fd  int32_t eax = data_2823608
00402602  int32_t __saved_esi_2 = 1
00402602  
0040260c  if (eax s> 1)
00402646      do
0040260f          int32_t esi_1 = 1
0040260f          
00402616          if (eax s> 1)
0040262e              do
0040261a                  if (__saved_esi_2 != esi_1)
0040261e                      sub_4024f0(__saved_esi_2, esi_1)
00402623                      eax = data_2823608
00402623                  
0040262b                  esi_1 += 1
0040262e              while (esi_1 s< eax)
0040262e          
00402630          int32_t __saved_esi_3 = __saved_esi_2
00402636          sub_40fa00("\r%6d")
0040263b          eax = data_2823608
00402643          __saved_esi_2 += 1
00402646      while (__saved_esi_2 s< eax)
00402646  
00402649  int32_t __saved_esi_1 = __saved_esi_2
00402658  return sub_410030("\r%6d areas checked for shared f…")

00402659                                                                             90 90 90 90 90 90 90                           .......

00402660    int32_t* sub_402660(int32_t arg1)

00402669  int32_t ecx
00402669  double var_8 = fconvert.d(sub_40fae0(ecx))
0040266d  sub_4141f0()
00402672  void* eax = data_256ee8c
00402677  int32_t ecx_1 = data_256ee90
0040267d  data_279befc = 0
0040268c  void** eax_1
0040268c  int32_t ecx_2
0040268c  eax_1, ecx_2 = sub_409fa0(eax, eax + ecx_1)
0040268c  
0040269d  if (data_279bf00 != 0)
004026ac      return sub_41cee0(eax_1)
004026ac  
004026b9  void* var_14
004026b9  var_14.q = fconvert.d(sub_40fae0(ecx_2) - fconvert.t(var_8))
004026c1  sub_410030("BSP tree created in %5.0f second…")
004026c9  sub_41d060(*eax_1)
004026c9  
004026d9  if (data_279bf00 != 0)
004026e7      return sub_41cee0(eax_1)
004026e7  
004026e8  sub_41b8e0(eax_1)
004026e8  
004026f8  if (data_279bf00 != 0)
00402706      return sub_41cee0(eax_1)
00402706  
00402711  if (sub_41bb50(eax_1) == 0)
004027e2      return sub_410030("**** leaked ****\n")
004027e2  
0040271a  sub_41bd90(*eax_1)
0040271f  sub_4015e0()
00402727  sub_4022c0(*eax_1)
0040272f  sub_402b70()
00402734  sub_4041a0()
00402739  sub_402b70()
0040273e  sub_401d80()
00402743  sub_401440()
00402748  sub_4052c0()
0040274d  sub_4025f0()
00402752  sub_401d80()
00402757  sub_402b70()
0040275c  sub_404510()
00402761  sub_402990()
00402766  sub_401df0()
0040276b  sub_401ef0()
00402770  sub_402420()
00402770  
0040277c  if (data_279bf00 != 0)
0040277f      sub_41cee0(eax_1)
00402790      return sub_4016b0()
00402790  
00402798  if (data_279c320 != 0)
0040279b      sub_41cee0(eax_1)
0040279b  
004027a8  sub_406440(arg1)
004027b2  int32_t ecx_5
004027b2  long double st0_3
004027b2  st0_3, ecx_5 = sub_40fae0(sub_4016b0())
004027bb  int32_t var_14_2 = ecx_5
004027bc  var_14_2.q = fconvert.d(st0_3 - fconvert.t(var_8))
004027d0  return sub_410030("\nAAS created in %5.0f seconds\n")

004027e3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

004027f0    void sub_4027f0(int32_t* arg1, void* arg2)

004027f6  int32_t* esi = arg1
00402800  int32_t var_8 = 0
00402800  
00402806  if (esi[1] == 0)
00402817      int32_t eax_1
00402817      int32_t edx_1
00402817      edx_1:eax_1 = muls.dp.d(0x66666667, esi - data_2823604)
00402819      int32_t edx_2 = edx_1 s>> 4
00402823      int32_t var_1c_1 = edx_2 + (edx_2 u>> 0x1f)
00402829      sub_40f970("face1 %d without winding")
00402829  
00402838  if (*(arg2 + 4) == 0)
00402849      int32_t eax_4
00402849      int32_t edx_5
00402849      edx_5:eax_4 = muls.dp.d(0x66666667, arg2 - data_2823604)
0040284b      int32_t edx_6 = edx_5 s>> 4
00402855      int32_t var_1c_2 = edx_6 + (edx_6 u>> 0x1f)
0040285b      sub_40f970("face2 %d without winding")
0040285b  
00402865  int32_t* ebx_1 = *(arg2 + 4)
00402868  arg1 = nullptr
00402879  void* ebp_2 = *esi * 0x1c + &data_239e0c0
00402880  arg2 = ebp_2
00402880  
00402884  if (*ebx_1 s<= 0)
004028f8      return 
004028f8  
00402886  void* edi = &ebx_1[1]
004028e1  bool cond:1_1
004028e1  
004028e1  do
00402898      int32_t var_4
00402898      int32_t eax_7
00402898      int80_t st0_1
00402898      st0_1, eax_7 = sub_411ba0(esi[1], ebp_2, *(ebp_2 + 0xc), edi, &var_4)
00402898      
004028a2      if (eax_7 != 0)
004028ae          void* eax_9 = sub_411b10(esi[1], edi, var_4)
004028b9          sub_410740(esi[1])
004028c6          esi[1] = eax_9
004028c9          ebp_2 = arg2
004028cd          var_8 += 1
004028cd      
004028d8      edi += 0xc
004028db      cond:1_1 = arg1 + 1 s< *ebx_1
004028dd      arg1 += 1
004028e1  while (cond:1_1)

004028f9                                                                             90 90 90 90 90 90 90                           .......

00402900    int32_t sub_402900(int32_t arg1)

00402900  int32_t ecx
00402900  int32_t var_4 = ecx
00402907  int32_t result = 0
00402910  int32_t result_1 = 0
00402914  int32_t edx_1 = arg1 * 7
00402916  int32_t eax_1 = data_282360c
0040291b  int32_t* i = *(eax_1 + (edx_1 << 2) + 4)
0040291f  int32_t* ebx = eax_1 + (edx_1 << 2)
0040291f  
00402924  if (i == 0)
0040298a      return 0
0040298a  
0040297b  do
00402931      void* j = ebx[1]
00402934      int32_t eax_2
00402934      eax_2.b = i[2] != *ebx
00402934      
0040293d      if (j != 0)
0040296b          do
00402948              int32_t edx_3
00402948              edx_3.b = *(j + 8) != *ebx
00402948              
0040294f              if (i != j)
00402953                  int32_t eax_3 = sub_4027f0(i, j)
00402953                  int16_t top = top - 1
00402953                  unimplemented  {call sub_4027f0}
00402961                  result_1 += eax_3
00402961              
00402965              j = *(j + (edx_3 << 2) + 0x20)
0040296b          while (j != 0)
0040296b          
0040296d          result = result_1
0040296d      
00402975      i = i[eax_2 + 8]
0040297b  while (i != 0)
0040297b  
00402984  return result

0040298b                                   90 90 90 90 90                                                             .....

00402990    int32_t* sub_402990()

00402997  int32_t edi = 0
00402999  sub_410080("AAS_MeltAreaFaceWindings")
0040299e  int32_t var_10 = 0
004029a4  sub_40fa00("%6d edges melted")
004029ae  int32_t i = 1
004029ae  
004029b8  if (data_2823608 s> 1)
004029d8      do
004029c0          edi += sub_402900(i)
004029c2          int32_t var_10_1 = edi
004029c8          sub_40fa00("\r%6d")
004029d5          i += 1
004029d8      while (i s< data_2823608)
004029d8  
004029da  int32_t var_c_2 = edi
004029ea  return sub_410030("\r%6d edges melted\n")

004029eb                                   90 90 90 90 90                                                             .....

004029f0    int32_t sub_4029f0(int32_t* arg1, int32_t* arg2)

004029fc  if (arg1[1] == 0)
00402a0d      int32_t eax_1
00402a0d      int32_t edx_1
00402a0d      edx_1:eax_1 = muls.dp.d(0x66666667, arg1 - data_2823604)
00402a0f      int32_t edx_2 = edx_1 s>> 4
00402a19      int32_t var_10_1 = edx_2 + (edx_2 u>> 0x1f)
00402a1f      sub_40f970("face1 %d without winding")
00402a1f  
00402a30  if (arg2[1] == 0)
00402a41      int32_t eax_5
00402a41      int32_t edx_5
00402a41      edx_5:eax_5 = muls.dp.d(0x66666667, arg2 - data_2823604)
00402a43      int32_t edx_6 = edx_5 s>> 4
00402a4d      int32_t var_10_2 = edx_6 + (edx_6 u>> 0x1f)
00402a53      sub_40f970("face2 %d without winding")
00402a53  
00402a7f  if (arg1[4] == arg2[4] && arg1[2] == arg2[2] && arg1[3] == arg2[3])
00402a85      int32_t eax_9 = *arg1
00402a87      int32_t ecx_9 = *arg2
00402a87      
00402a8b      if (eax_9 == ecx_9)
00402aaa          int32_t* eax_11 = sub_411460(arg1[1], arg2[1], eax_9 * 0x1c + &data_239e0c0)
00402aaa          
00402ab6          if (eax_11 != 0)
00402ac0              sub_410740(arg1[1])
00402ac5              arg1[1] = eax_11
00402ac8              int32_t eax_13 = arg2[2]
00402ac8              
00402ad0              if (eax_13 != 0)
00402ae6                  sub_4018d0(arg2, data_282360c + eax_13 * 0x1c)
00402ae6              
00402aee              int32_t eax_15 = arg2[3]
00402aee              
00402af3              if (eax_15 != 0)
00402b09                  sub_4018d0(arg2, data_282360c + eax_15 * 0x1c)
00402b09              
00402b19              return 1
00402a8b      else if (((ecx_9 ^ eax_9) & 0xfffffffe) == 0)
00402b24          int32_t ecx_16 = data_2823604
00402b44          int32_t var_10_7 = (arg2 - ecx_16) s/ 0x28
00402b51          int32_t var_14_4 = (arg1 - ecx_16) s/ 0x28
00402b57          sub_410080("face %d and %d, same front and b…")
00402b57  
00402b64  return 0

00402b65                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00402b70    int32_t* sub_402b70()

00402b74  int32_t __saved_ebx_1 = 0
00402b7b  int32_t __saved_ebx_3 = 0
00402b7f  sub_410080("AAS_MergeAreaFaces")
00402b84  int32_t __saved_ebp = 0
00402b8a  sub_40fa00("%6d face merges")
00402b9f  float var_10 = 1.40129846e-45f
00402b9f  
00402ba3  if (data_2823608 s> 1)
00402bab      void* ebp_1 = 0x1c
00402bb1      void* var_c_1 = 0x1c
00402c6c      bool cond:1_1
00402c6c      
00402c6c      do
00402bba          int32_t* ebp_2 = ebp_1 + data_282360c
00402bba          
00402bc1          if (ebp_2[4] == 0)
00402bcc              int32_t eax_3
00402bcc              
00402bcc              for (int32_t* i = ebp_2[1]; i != 0; i = i[eax_3 + 8])
00402bd8                  eax_3.b = i[2] != *ebp_2
00402bdf                  int32_t* esi = i[eax_3 + 8]
00402bdf                  
00402be5                  if (esi != 0)
00402bf3                      while (true)
00402bf3                          int32_t ebx_1
00402bf3                          ebx_1.b = esi[2] != *ebp_2
00402bf3                          
00402c00                          if (sub_4029f0(i, esi) != 0)
00402c22                              __saved_ebx_3 += 1
00402c26                              sub_401970(var_10)
00402c36                              var_10 -= 1
00402c3a                              var_c_1 -= 0x1c
00402c3a                              break
00402c3a                          
00402c02                          esi = esi[ebx_1 + 8]
00402c02                          
00402c08                          if (esi == 0)
00402c08                              goto label_402c0e
00402c08                      
00402c00                      break
00402c00                  
00402c0e                  label_402c0e:
00402c0e              
00402c3e              __saved_ebx_1 = __saved_ebx_3
00402c42              int32_t __saved_ebx_2 = __saved_ebx_1
00402c48              sub_40fa00("\r%6d")
00402c48          
00402c5f          ebp_1 = var_c_1 + 0x1c
00402c62          cond:1_1 = var_10 i+ 1 s< data_2823608
00402c64          var_10 += 1
00402c68          var_c_1 = ebp_1
00402c6c      while (cond:1_1)
00402c6c  
00402c75  int32_t __saved_ebx = __saved_ebx_1
00402c87  return sub_410030("\r%6d face merges\n")

00402c88                          90 90 90 90 90 90 90 90                                                          ........

00402c90    int32_t sub_402c90()

00402c90  int32_t ecx
00402c90  int32_t var_4_1 = ecx
00402c98  int32_t i = 0
00402c98  
00402c9e  if (data_2823584 s> 0)
00402ca4      int32_t* edi_1 = nullptr
00402ca4      
00402d40      do
00402cba          *(edi_1 + data_2823588) = sub_40ff30(*(edi_1 + data_2823588))
00402cd5          void* esi_1 = &edi_1[5]
00402cd8          int32_t j_5 = 3
00402cdd          *(edi_1 + data_2823588 + 4) = sub_40ff30(*(edi_1 + data_2823588 + 4))
00402d33          int32_t j
00402d33          
00402d33          do
00402cea              int32_t eax_6
00402cea              int16_t x87control
00402cea              int16_t x87control_1
00402cea              eax_6, x87control_1 =
00402cea                  __ftol(x87control, fconvert.t(*(esi_1 + data_2823588 - 0xc)))
00402d03              *(esi_1 + data_2823588 - 0xc) = fconvert.s(float.t(sub_40ff30(eax_6)))
00402d10              int32_t eax_8
00402d10              eax_8, x87control = __ftol(x87control_1, fconvert.t(*(esi_1 + data_2823588)))
00402d2b              esi_1 += 4
00402d2e              j = j_5
00402d2e              j_5 -= 1
00402d2f              *(esi_1 + data_2823588 - 4) = fconvert.s(float.t(sub_40ff30(eax_8)))
00402d33          while (j != 1)
00402d3a          i += 1
00402d3b          edi_1 = &edi_1[8]
00402d40      while (i s< data_2823584)
00402d40  
00402d4b  int32_t i_1 = 0
00402d4b  
00402d4f  if (data_282358c s> 0)
00402d51      int32_t* esi_2 = nullptr
00402d51      
00402d80      do
00402d53          int32_t j_9 = 3
00402d76          int32_t j_1
00402d76          
00402d76          do
00402d6f              *(esi_2 + data_2823590) = fconvert.s(sub_40ff20(*(esi_2 + data_2823590)))
00402d72              esi_2 = &esi_2[1]
00402d75              j_1 = j_9
00402d75              j_9 -= 1
00402d76          while (j_1 != 1)
00402d7d          i_1 += 1
00402d80      while (i_1 s< data_282358c)
00402d80  
00402d87  int32_t i_2 = 0
00402d87  
00402d8b  if (data_2823594 s> 0)
00402d8d      int32_t* edi_2 = nullptr
00402d8d      
00402df7      do
00402d8f          int32_t* esi_3 = edi_2
00402d91          int32_t j_6 = 3
00402db4          int32_t j_2
00402db4          
00402db4          do
00402dad              *(esi_3 + data_2823598) = fconvert.s(sub_40ff20(*(esi_3 + data_2823598)))
00402db0              esi_3 = &esi_3[1]
00402db3              j_2 = j_6
00402db3              j_6 -= 1
00402db4          while (j_2 != 1)
00402dcb          *(edi_2 + data_2823598 + 0xc) =
00402dcb              fconvert.s(sub_40ff20(*(edi_2 + data_2823598 + 0xc)))
00402de8          i_2 += 1
00402de9          *(edi_2 + data_2823598 + 0x10) = sub_40ff30(*(edi_2 + data_2823598 + 0x10))
00402df2          edi_2 = &edi_2[5]
00402df7      while (i_2 s< data_2823594)
00402df7  
00402dfe  int32_t i_3 = 0
00402dfe  
00402e02  if (data_282359c s> 0)
00402e41      do
00402e19          *(data_28235a0 + (i_3 << 3)) = sub_40ff30(*(data_28235a0 + (i_3 << 3)))
00402e35          *(data_28235a0 + (i_3 << 3) + 4) = sub_40ff30(*(data_28235a0 + (i_3 << 3) + 4))
00402e3e          i_3 += 1
00402e41      while (i_3 s< data_282359c)
00402e41  
00402e48  int32_t i_4 = 0
00402e48  
00402e4c  if (data_28235a4 s> 0)
00402e71      do
00402e66          *(data_28235a8 + (i_4 << 2)) = sub_40ff30(*(data_28235a8 + (i_4 << 2)))
00402e6e          i_4 += 1
00402e71      while (i_4 s< data_28235a4)
00402e71  
00402e78  int32_t i_5 = 0
00402e78  
00402e7c  if (data_28235ac s> 0)
00402e82      int32_t* esi_4 = nullptr
00402e82      
00402f2c      do
00402e99          *(esi_4 + data_28235b0) = sub_40ff30(*(esi_4 + data_28235b0))
00402eb2          *(esi_4 + data_28235b0 + 4) = sub_40ff30(*(esi_4 + data_28235b0 + 4))
00402ecc          *(esi_4 + data_28235b0 + 8) = sub_40ff30(*(esi_4 + data_28235b0 + 8))
00402ee6          *(esi_4 + data_28235b0 + 0xc) = sub_40ff30(*(esi_4 + data_28235b0 + 0xc))
00402f00          *(esi_4 + data_28235b0 + 0x10) = sub_40ff30(*(esi_4 + data_28235b0 + 0x10))
00402f1d          i_5 += 1
00402f1e          *(esi_4 + data_28235b0 + 0x14) = sub_40ff30(*(esi_4 + data_28235b0 + 0x14))
00402f27          esi_4 = &esi_4[6]
00402f2c      while (i_5 s< data_28235ac)
00402f2c  
00402f37  int32_t i_6 = 0
00402f37  
00402f3b  if (data_28235b4 s> 0)
00402f60      do
00402f55          *(data_28235b8 + (i_6 << 2)) = sub_40ff30(*(data_28235b8 + (i_6 << 2)))
00402f5d          i_6 += 1
00402f60      while (i_6 s< data_28235b4)
00402f60  
00402f67  int32_t i_7 = 0
00402f67  
00402f6b  if (data_28235bc s> 0)
00402f71      int32_t* edi_3 = nullptr
00402f71      
0040302a      do
00402f88          *(edi_3 + data_28235c0) = sub_40ff30(*(edi_3 + data_28235c0))
00402fa1          *(edi_3 + data_28235c0 + 4) = sub_40ff30(*(edi_3 + data_28235c0 + 4))
00402fbe          void* esi_5 = &edi_3[6]
00402fc1          int32_t j_7 = 3
00402fc6          *(edi_3 + data_28235c0 + 8) = sub_40ff30(*(edi_3 + data_28235c0 + 8))
0040301d          int32_t j_3
0040301d          
0040301d          do
00402fe0              *(esi_5 + data_28235c0 - 0xc) =
00402fe0                  fconvert.s(sub_40ff20(*(esi_5 + data_28235c0 - 0xc)))
00402ff9              *(esi_5 + data_28235c0) = fconvert.s(sub_40ff20(*(esi_5 + data_28235c0)))
00403015              *(esi_5 + data_28235c0 + 0xc) =
00403015                  fconvert.s(sub_40ff20(*(esi_5 + data_28235c0 + 0xc)))
00403019              esi_5 += 4
0040301c              j_3 = j_7
0040301c              j_7 -= 1
0040301d          while (j_3 != 1)
00403024          i_7 += 1
00403025          edi_3 = &edi_3[0xc]
0040302a      while (i_7 s< data_28235bc)
0040302a  
00403035  int32_t i_8 = 0
00403035  
00403039  if (data_28235c4 s> 0)
0040303f      int32_t* esi_6 = nullptr
0040303f      
00403103      do
00403056          *(esi_6 + data_28235c8) = sub_40ff30(*(esi_6 + data_28235c8))
0040306f          *(esi_6 + data_28235c8 + 4) = sub_40ff30(*(esi_6 + data_28235c8 + 4))
00403089          *(esi_6 + data_28235c8 + 8) = sub_40ff30(*(esi_6 + data_28235c8 + 8))
004030a3          *(esi_6 + data_28235c8 + 0xc) = sub_40ff30(*(esi_6 + data_28235c8 + 0xc))
004030bd          *(esi_6 + data_28235c8 + 0x10) = sub_40ff30(*(esi_6 + data_28235c8 + 0x10))
004030d7          *(esi_6 + data_28235c8 + 0x14) = sub_40ff30(*(esi_6 + data_28235c8 + 0x14))
004030f4          i_8 += 1
004030f5          *(esi_6 + data_28235c8 + 0x18) = sub_40ff30(*(esi_6 + data_28235c8 + 0x18))
004030fe          esi_6 = &esi_6[7]
00403103      while (i_8 s< data_28235c4)
00403103  
0040310e  int32_t i_9 = 0
0040310e  
00403112  if (data_28235cc s> 0)
00403118      int32_t* esi_7 = nullptr
00403118      
004031f0      do
0040312f          *(esi_7 + data_28235d0) = sub_40ff30(*(esi_7 + data_28235d0))
00403148          *(esi_7 + data_28235d0 + 4) = sub_40ff30(*(esi_7 + data_28235d0 + 4))
00403165          void* edi_4 = &esi_7[6]
00403168          int32_t j_8 = 3
0040316d          *(esi_7 + data_28235d0 + 8) = sub_40ff30(*(esi_7 + data_28235d0 + 8))
004031aa          int32_t j_4
004031aa          
004031aa          do
00403187              *(edi_4 + data_28235d0 - 0xc) =
00403187                  fconvert.s(sub_40ff20(*(edi_4 + data_28235d0 - 0xc)))
004031a3              *(edi_4 + data_28235d0) = fconvert.s(sub_40ff20(*(edi_4 + data_28235d0)))
004031a6              edi_4 += 4
004031a9              j_4 = j_8
004031a9              j_8 -= 1
004031aa          while (j_4 != 1)
004031c2          *(esi_7 + data_28235d0 + 0x24) = sub_40ff30(*(esi_7 + data_28235d0 + 0x24))
004031cc          int32_t eax_85
004031cc          eax_85.w = *(esi_7 + data_28235d0 + 0x28)
004031e0          i_9 += 1
004031e1          *(esi_7 + data_28235d0 + 0x28) = sub_40ff10(eax_85.w)
004031eb          esi_7 = &esi_7[0xb]
004031f0      while (i_9 s< data_28235cc)
004031f0  
004031fb  int32_t i_10 = 0
004031fb  
004031ff  if (data_28235d4 s> 0)
00403201      int32_t* esi_8 = nullptr
00403201      
0040325d      do
00403218          *(esi_8 + data_28235d8) = sub_40ff30(*(esi_8 + data_28235d8))
00403231          *(esi_8 + data_28235d8 + 4) = sub_40ff30(*(esi_8 + data_28235d8 + 4))
0040324e          i_10 += 1
0040324f          *(esi_8 + data_28235d8 + 8) = sub_40ff30(*(esi_8 + data_28235d8 + 8))
00403258          esi_8 = &esi_8[3]
0040325d      while (i_10 s< data_28235d4)
0040325d  
00403264  int32_t i_11 = 0
00403264  
00403268  if (data_28235dc s> 0)
0040326e      int32_t* esi_9 = nullptr
0040326e      
004032fe      do
00403285          *(esi_9 + data_28235e0) = sub_40ff30(*(esi_9 + data_28235e0))
0040329e          *(esi_9 + data_28235e0 + 4) = sub_40ff30(*(esi_9 + data_28235e0 + 4))
004032b8          *(esi_9 + data_28235e0 + 8) = sub_40ff30(*(esi_9 + data_28235e0 + 8))
004032d2          *(esi_9 + data_28235e0 + 0xc) = sub_40ff30(*(esi_9 + data_28235e0 + 0xc))
004032ef          i_11 += 1
004032f0          *(esi_9 + data_28235e0 + 0x10) = sub_40ff30(*(esi_9 + data_28235e0 + 0x10))
004032f9          esi_9 = &esi_9[5]
004032fe      while (i_11 s< data_28235dc)
004032fe  
00403309  int32_t i_12 = 0
00403309  
0040330d  if (data_28235e4 s> 0)
00403332      do
00403327          *(data_28235e8 + (i_12 << 2)) = sub_40ff30(*(data_28235e8 + (i_12 << 2)))
0040332f          i_12 += 1
00403332      while (i_12 s< data_28235e4)
00403332  
00403334  int32_t result = data_28235ec
00403339  int32_t edi_5 = 0
00403339  
0040333d  if (result s> 0)
0040333f      int32_t* esi_10 = nullptr
0040333f      
0040339b      do
00403356          *(esi_10 + data_28235f0) = sub_40ff30(*(esi_10 + data_28235f0))
0040336f          *(esi_10 + data_28235f0 + 4) = sub_40ff30(*(esi_10 + data_28235f0 + 4))
0040338c          edi_5 += 1
0040338d          *(esi_10 + data_28235f0 + 8) = sub_40ff30(*(esi_10 + data_28235f0 + 8))
00403391          result = data_28235ec
00403396          esi_10 = &esi_10[3]
0040339b      while (edi_5 s< result)
0040339b  
004033a2  return result

004033a3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

004033b0    int32_t sub_4033b0(int32_t* arg1, int32_t arg2, int32_t arg3, char* arg4, int32_t arg5)

004033d0  *(arg2 + (arg3 << 3) + 8) = sub_40ff30(sub_41e085(arg1))
004033dd  *(arg2 + (arg3 << 3) + 0xc) = sub_40ff30(arg5)
004033dd  
004033e3  if (arg5 s> 0 && sub_41df4c(arg4, arg5, 1, arg1) u< 1)
004033fb      int32_t var_14_2 = arg3
00403401      sub_410030("error writing lump %s\n")
00403407      sub_41ddd2(arg1)
00403415      return 0
00403415  
0040341f  return 1


00403420    int32_t sub_403420(int32_t arg1)

0040342d  int32_t var_88 = arg1
00403433  sub_410030("writing %s\n")
00403438  sub_402c90()
00403448  int32_t var_90
00403448  __builtin_strncpy(dest: &var_90, src: "EAAS", n: 4)
0040344d  int32_t s
0040344d  __builtin_memset(&s, c: 0, n: 0x78)
00403454  int32_t var_94 = 3
00403456  s = sub_40ff30(var_90)
0040345f  void* var_98 = &data_42b640
00403465  int32_t var_74 = sub_40ff30(var_94)
00403469  int32_t* eax_2 = sub_41df39(arg1, var_98)
00403469  
00403475  if (eax_2 == 0)
00403477      int32_t var_88_1 = arg1
0040347d      sub_410030("error opening %s\n")
0040348d      return 0
0040348d  
004034a3  if (sub_41df4c(&s, 0x78, 1, eax_2) u< 1)
004034a6      sub_41ddd2(eax_2)
004034b6      return 0
004034b6  
004034d0  int32_t eax_6 = sub_4033b0(eax_2, &s, 0, data_2823588, data_2823584 << 5)
004034d0  
004034da  if (eax_6 == 0)
004034e2      return eax_6
004034e2  
004034fe  int32_t eax_8 = sub_4033b0(eax_2, &s, 1, data_2823590, data_282358c * 0xc)
004034fe  
00403508  if (eax_8 == 0)
00403510      return eax_8
00403510  
0040352c  int32_t eax_10 = sub_4033b0(eax_2, &s, 2, data_2823598, data_2823594 * 0x14)
0040352c  
00403536  if (eax_10 == 0)
0040353e      return eax_10
0040353e  
0040355b  int32_t eax_12 = sub_4033b0(eax_2, &s, 3, data_28235a0, data_282359c << 3)
0040355b  
00403565  if (eax_12 == 0)
0040356d      return eax_12
0040356d  
0040358b  int32_t eax_14 = sub_4033b0(eax_2, &s, 4, data_28235a8, data_28235a4 << 2)
0040358b  
00403595  if (eax_14 == 0)
0040359d      return eax_14
0040359d  
004035b9  int32_t eax_18 = sub_4033b0(eax_2, &s, 5, data_28235b0, data_28235ac * 0x18)
004035b9  
004035c3  if (eax_18 == 0)
004035cb      return eax_18
004035cb  
004035e8  int32_t eax_20 = sub_4033b0(eax_2, &s, 6, data_28235b8, data_28235b4 << 2)
004035e8  
004035f2  if (eax_20 == 0)
004035fa      return eax_20
004035fa  
00403616  int32_t eax_22 = sub_4033b0(eax_2, &s, 7, data_28235c0, data_28235bc * 0x30)
00403616  
00403620  if (eax_22 == 0)
00403628      return eax_22
00403628  
0040364a  int32_t eax_24 = sub_4033b0(eax_2, &s, 8, data_28235c8, data_28235c4 * 0x1c)
0040364a  
00403654  if (eax_24 == 0)
0040365c      return eax_24
0040365c  
0040367a  int32_t eax_27 = sub_4033b0(eax_2, &s, 9, data_28235d0, data_28235cc * 0x2c)
0040367a  
00403684  if (eax_27 == 0)
0040368c      return eax_27
0040368c  
004036a7  int32_t eax_30 = sub_4033b0(eax_2, &s, 0xa, data_28235d8, data_28235d4 * 0xc)
004036a7  
004036b1  if (eax_30 == 0)
004036b9      return eax_30
004036b9  
004036d4  int32_t eax_33 = sub_4033b0(eax_2, &s, 0xb, data_28235e0, data_28235dc * 0x14)
004036d4  
004036de  if (eax_33 == 0)
004036e6      return eax_33
004036e6  
00403704  int32_t eax_35 = sub_4033b0(eax_2, &s, 0xc, data_28235e8, data_28235e4 << 2)
00403704  
0040370e  if (eax_35 == 0)
00403716      return eax_35
00403716  
00403732  int32_t eax_39 = sub_4033b0(eax_2, &s, 0xd, data_28235f0, data_28235ec * 0xc)
00403732  
0040373c  if (eax_39 == 0)
00403744      return eax_39
00403744  
0040374a  sub_41de4f(eax_2, nullptr, FILE_BEGIN)
0040374a  
00403765  if (sub_41df4c(&s, 0x78, 1, eax_2) u< 1)
00403767      sub_41ddd2(eax_2)
00403777      return 0
00403777  
00403778  sub_41ddd2(eax_2)
0040378b  return 1

0040378c                                      90 90 90 90                                                              ....

00403790    int80_t sub_403790(int32_t* arg1, float* arg2, float arg3, int32_t* arg4, int32_t* arg5)

00403795  int32_t* ebx = arg5
0040379a  int32_t* esi = arg4
004037b0  *ebx = 0
004037b7  *esi = 0
004037c8  int80_t result = sub_410e60(arg1[1], arg2, arg3, 0.200000003f, &arg5, &arg4)
004037cd  int32_t* eax_1 = arg5
004037cd  
004037d6  if (eax_1 != 0 && sub_406f30(eax_1) != 0)
004037ea      sub_410080("AAS_SplitFace: tiny back face")
004037f4      sub_410740(arg5)
004037fc      arg5 = nullptr
004037fc  
00403804  int32_t* eax_3 = arg4
00403804  
0040380a  if (eax_3 != 0 && sub_406f30(eax_3) != 0)
0040381e      sub_410080("AAS_SplitFace: tiny back face")
00403828      sub_410740(arg4)
00403830      arg4 = nullptr
00403830  
0040383e  if (arg5 != 0)
00403840      int32_t eax_7 = data_2823600
00403840      
0040384a      if (eax_7 s>= 0x3e800)
00403851          sub_40f970("AAS_MAX_FACES")
00403856          eax_7 = data_2823600
00403856      
0040386a      *esi = data_2823604 + eax_7 * 0x28
00403872      data_2823600 += 1
0040387b      **esi = *arg1
00403883      *(*esi + 4) = arg5
0040388b      *(*esi + 0x10) = arg1[4]
0040388b  
00403894  if (arg4 != 0)
00403896      int32_t eax_14 = data_2823600
00403896      
004038a0      if (eax_14 s>= 0x3e800)
004038a7          sub_40f970("AAS_MAX_FACES")
004038ac          eax_14 = data_2823600
004038ac      
004038c0      *ebx = data_2823604 + eax_14 * 0x28
004038c8      data_2823600 += 1
004038d1      **ebx = *arg1
004038d9      *(*ebx + 4) = arg4
004038e1      *(*ebx + 0x10) = arg1[4]
004038e1  
004038e7  return result

004038e8                          90 90 90 90 90 90 90 90                                                          ........

004038f0    void* sub_4038f0(void* arg1, int32_t arg2)

0040390a  int32_t* ebx = data_282360c + arg1 * 0x1c
00403914  int32_t ecx_3 = arg2 * 7
00403926  void* i
00403926  int80_t st0
00403926  st0, i = sub_410b70((ecx_3 << 2) + &data_239e0c0, *((ecx_3 << 2) + &data_239e0cc))
00403926  int16_t top = 0xffff
0040392b  arg1 = i
0040392f  int32_t* esi = ebx[1]
0040392f  
00403937  if (esi != 0)
0040393b      while (i != 0)
0040394a          int32_t ecx_4
0040394a          ecx_4.b = esi[2] != *ebx
00403958          int32_t edx_3 = (*esi ^ ecx_4) * 7
0040396f          sub_4111c0(&arg1, (edx_3 << 2) + &data_239e0c0, *((edx_3 << 2) + &data_239e0cc), 
0040396f              0f)
0040396f          top -= 1
0040396f          unimplemented  {call sub_4111c0}
00403974          esi = esi[ecx_4 + 8]
00403978          i = arg1
00403978          
00403981          if (esi == 0)
00403981              break
00403981  
00403986  return i

00403987                       90 90 90 90 90 90 90 90 90                                                         .........

00403990    void* sub_403990(void* arg1, float* arg2, float arg3, int32_t* arg4, int32_t* arg5, int32_t* arg6)

004039a6  float* ebx = arg2
004039aa  *arg6 = 0
004039b0  *arg5 = 0
004039bd  *arg4 = 0
004039d0  float var_20 = arg3
004039d2  int32_t* edi = data_282360c + arg1 * 0x1c
004039d5  int32_t* var_c = edi
004039de  int32_t ebp = sub_414ae0(ebx)
004039e2  int32_t var_8 = ebp
004039e6  void* result = sub_4038f0(arg1, ebp)
004039e6  
004039f0  if (result == 0)
004039f9      return result
004039f9  
004039fb  sub_410740(result)
00403a00  int32_t* ecx_2 = edi[1]
00403a00  
00403a08  if (ecx_2 != 0)
00403a23      while (true)
00403a23          int32_t edx_2
00403a23          edx_2.b = ecx_2[2] != *edi
00403a23          
00403a31          if (((*ecx_2 ^ ebp) & 0xfffffffe) == 0)
00403b41              sub_410030("AAS_TestSplitPlane: tried face p…")
00403b52              return 0
00403b52          
00403a37          int32_t* eax_7 = ecx_2[1]
00403a3a          int32_t ebp_1 = 0
00403a3c          int32_t edi_1 = 0
00403a3e          arg2 = nullptr
00403a46          int32_t i_1 = *eax_7
00403a48          arg1 = nullptr
00403a48          
00403a52          if (i_1 s> 0)
00403a54              void* edx_3 = &eax_7[2]
00403ab5              int32_t i
00403ab5              
00403ab5              do
00403a6b                  long double x87_r7_5 = fconvert.t(*(edx_3 - 4)) * fconvert.t(*ebx)
00403a6b                      + fconvert.t(*(edx_3 + 4)) * fconvert.t(ebx[2])
00403a6b                      + fconvert.t(ebx[1]) * fconvert.t(*edx_3) - fconvert.t(arg3)
00403a6f                  long double temp3_1 = fconvert.t(arg1)
00403a6f                  x87_r7_5 - temp3_1
00403a73                  eax_7.w = (x87_r7_5 < temp3_1 ? 1 : 0) << 8
00403a73                      | (is_unordered.t(x87_r7_5, temp3_1) ? 1 : 0) << 0xa
00403a73                      | (x87_r7_5 == temp3_1 ? 1 : 0) << 0xe | 0x3800
00403a73                  
00403a78                  if ((eax_7:1.b & 0x41) == 0)
00403a7a                      arg1 = fconvert.s(x87_r7_5)
00403a7a                  
00403a7e                  long double temp5_1 = fconvert.t(arg2)
00403a7e                  x87_r7_5 - temp5_1
00403a82                  eax_7.w = (x87_r7_5 < temp5_1 ? 1 : 0) << 8
00403a82                      | (is_unordered.t(x87_r7_5, temp5_1) ? 1 : 0) << 0xa
00403a82                      | (x87_r7_5 == temp5_1 ? 1 : 0) << 0xe | 0x3800
00403a82                  
00403a87                  if ((eax_7:1.b & 1) != 0)
00403a89                      arg2 = fconvert.s(x87_r7_5)
00403a89                  
00403a8d                  long double temp6_1 = fconvert.t(0.40000000000000002)
00403a8d                  x87_r7_5 - temp6_1
00403a93                  eax_7.w = (x87_r7_5 < temp6_1 ? 1 : 0) << 8
00403a93                      | (is_unordered.t(x87_r7_5, temp6_1) ? 1 : 0) << 0xa
00403a93                      | (x87_r7_5 == temp6_1 ? 1 : 0) << 0xe | 0x3800
00403a93                  
00403a98                  if ((eax_7:1.b & 0x41) == 0)
00403a9a                      edi_1 = 1
00403a9a                  
00403a9f                  long double temp7_1 = fconvert.t(-0.40000000000000002)
00403a9f                  x87_r7_5 - temp7_1
00403aa5                  eax_7.w = (x87_r7_5 < temp7_1 ? 1 : 0) << 8
00403aa5                      | (is_unordered.t(x87_r7_5, temp7_1) ? 1 : 0) << 0xa
00403aa5                      | (x87_r7_5 == temp7_1 ? 1 : 0) << 0xe
00403aa5                  
00403aaa                  if ((eax_7:1.b & 1) != 0)
00403aac                      ebp_1 = 1
00403aac                  
00403ab1                  edx_3 += 0xc
00403ab4                  i = i_1
00403ab4                  i_1 -= 1
00403ab5              while (i != 1)
00403ab5          
00403ab7          long double x87_r7_6 = fconvert.t(arg1)
00403abb          long double temp0_1 = fconvert.t(0.20000000000000001)
00403abb          x87_r7_6 - temp0_1
00403ac1          eax_7.w = (x87_r7_6 < temp0_1 ? 1 : 0) << 8
00403ac1              | (is_unordered.t(x87_r7_6, temp0_1) ? 1 : 0) << 0xa
00403ac1              | (x87_r7_6 == temp0_1 ? 1 : 0) << 0xe
00403ac1          
00403ac6          if ((eax_7:1.b & 0x41) != 0)
00403ad9              label_403ad9:
00403ad9              long double x87_r7_8 = fconvert.t(arg2)
00403add              long double temp1_1 = fconvert.t(-0.20000000000000001)
00403add              x87_r7_8 - temp1_1
00403ae3              eax_7.w = (x87_r7_8 < temp1_1 ? 1 : 0) << 8
00403ae3                  | (is_unordered.t(x87_r7_8, temp1_1) ? 1 : 0) << 0xa
00403ae3                  | (x87_r7_8 == temp1_1 ? 1 : 0) << 0xe
00403ae3              
00403ae8              if ((eax_7:1.b & 1) != 0)
00403aea                  long double x87_r7_9 = fconvert.t(arg2)
00403aee                  long double temp4_1 = fconvert.t(-1.0)
00403aee                  x87_r7_9 - temp4_1
00403af4                  eax_7.w = (x87_r7_9 < temp4_1 ? 1 : 0) << 8
00403af4                      | (is_unordered.t(x87_r7_9, temp4_1) ? 1 : 0) << 0xa
00403af4                      | (x87_r7_9 == temp4_1 ? 1 : 0) << 0xe
00403af4                  
00403af9                  if ((eax_7:1.b & 0x41) == 0)
00403aff                      *arg6 += 1
00403ac6          else
00403ac8              long double x87_r7_7 = fconvert.t(arg1)
00403acc              long double temp2_1 = fconvert.t(1.0)
00403acc              x87_r7_7 - temp2_1
00403ad2              eax_7.w = (x87_r7_7 < temp2_1 ? 1 : 0) << 8
00403ad2                  | (is_unordered.t(x87_r7_7, temp2_1) ? 1 : 0) << 0xa
00403ad2                  | (x87_r7_7 == temp2_1 ? 1 : 0) << 0xe
00403ad2              
00403ad7              if ((eax_7:1.b & 1) == 0)
00403ad7                  goto label_403ad9
00403ad7              
00403aff              *arg6 += 1
00403aff          
00403b07          if (edi_1 != 0 && ebp_1 != 0)
00403b10              *arg4 += 1
00403b12              int32_t* eax_9
00403b12              eax_9.b = ecx_2[4].b
00403b12              
00403b17              if ((eax_9.b & 4) != 0)
00403b1d                  *arg5 += 1
00403b1d          
00403b23          ecx_2 = ecx_2[edx_2 + 8]
00403b23          
00403b29          if (ecx_2 == 0)
00403b29              break
00403b29          
00403a10          edi = var_c
00403a14          ebp = var_8
00403a14  
00403b3b  return 1

00403b53                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00403b60    int32_t sub_403b60(float arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)

00403b7b  int32_t* ebx = data_282360c + arg1 i* 0x1c
00403b7e  int32_t* var_c = ebx
00403b82  sub_401b00(arg1)
00403b88  sub_401970(arg1)
00403b9c  void* eax_2 = arg2 * 0x1c + &data_239e0c0
00403ba7  void* eax_3 = sub_4038f0(arg1, arg2)
00403ba7  
00403bb3  if (eax_3 == 0)
00403bb5      float var_28_1 = arg1
00403bbb      sub_40f970("AAS_SplitArea: no split winding …")
00403bbb  
00403bc3  int32_t eax_4 = data_2823600
00403bc3  
00403bcd  if (eax_4 s>= 0x3e800)
00403bd4      sub_40f970("AAS_MAX_FACES")
00403bd9      eax_4 = data_2823600
00403bd9  
00403beb  int32_t* esi_1 = data_2823604 + eax_4 * 0x28
00403bee  data_2823600 = eax_4 + 1
00403bf3  *esi_1 = arg2
00403bf5  esi_1[1] = eax_3
00403bf8  int32_t eax_6 = data_2823608
00403bf8  
00403c02  if (eax_6 s>= 0xffff)
00403c09      sub_40f970("AAS_MAX_AREAS")
00403c0e      eax_6 = data_2823608
00403c0e  
00403c25  int32_t* ebp_1 = data_282360c + eax_6 * 0x1c
00403c2b  *ebp_1 = eax_6
00403c36  data_2823608 += 1
00403c3f  ebp_1[2] = ebx[2]
00403c45  ebp_1[3] = ebx[3]
00403c48  ebp_1[1] = 0
00403c4f  int32_t eax_8 = data_2823608
00403c63  int32_t* edi_1 = data_282360c + eax_8 * 0x1c
00403c6a  *edi_1 = eax_8
00403c72  data_2823608 += 1
00403c7a  edi_1[2] = ebx[2]
00403c80  edi_1[3] = ebx[3]
00403c83  edi_1[1] = 0
00403c8a  sub_401850(esi_1, 0, ebp_1)
00403c93  sub_401850(esi_1, 1, edi_1)
00403c98  int32_t* esi_2 = ebx[1]
00403c98  
00403ca0  if (esi_2 != 0)
00403cac      while (true)
00403cac          float edi_2 = esi_2[2]
00403cb3          float eax_12 = esi_2[3]
00403cb8          arg1 = eax_12
00403cbc          int32_t ecx_6
00403cbc          ecx_6.b = edi_2 != *ebx
00403cc3          int32_t* edx_10 = esi_2[ecx_6 + 8]
00403cc3          
00403ccb          if (edi_2 != 0)
00403ce1              sub_4018d0(esi_2, data_282360c + edi_2 i* 0x1c)
00403ce6              eax_12 = arg1
00403ce6          
00403cef          if (eax_12 != 0)
00403d05              sub_4018d0(esi_2, data_282360c + eax_12 i* 0x1c)
00403d05          
00403d21          int32_t var_14
00403d21          int32_t var_10
00403d21          sub_403790(esi_2, eax_2, *(eax_2 + 0xc), &var_14, &var_10)
00403d21          int16_t top = top - 1
00403d21          unimplemented  {call sub_403790}
00403d29          float esi_3 = edi_2
00403d29          
00403d2d          if (ecx_6 == 0)
00403d2f              esi_3 = arg1
00403d2f          
00403d35          if (esi_3 != 0)
00403d37              int32_t eax_17 = var_14
00403d37              
00403d3d              if (eax_17 != 0)
00403d55                  int32_t ecx_12
00403d55                  ecx_12.b = ecx_6 == 0
00403d5b                  sub_401850(eax_17, ecx_12, data_282360c + esi_3 i* 0x1c)
00403d5b              
00403d63              int32_t eax_18 = var_10
00403d63              
00403d69              if (eax_18 != 0)
00403d81                  int32_t ecx_14
00403d81                  ecx_14.b = ecx_6 == 0
00403d87                  sub_401850(eax_18, ecx_14, data_282360c + esi_3 i* 0x1c)
00403d87          
00403d8f          int32_t eax_19 = var_14
00403d8f          
00403d95          if (eax_19 != 0)
00403d9a              sub_401850(eax_19, ecx_6, ebp_1)
00403d9a          
00403da2          void* eax_20 = var_10
00403da2          
00403da8          if (eax_20 != 0)
00403db1              sub_401850(eax_20, ecx_6, edi_1)
00403db1          
00403db9          esi_2 = edx_10
00403db9          
00403dbf          if (esi_2 == 0)
00403dbf              break
00403dbf          
00403ca8          ebx = var_c
00403ca8      
00403dc9      ebx = var_c
00403dc9  
00403dd2  if (ebp_1[1] == 0)
00403dd9      sub_410030("AAS_SplitArea: front area withou…")
00403dd9  
00403de6  if (edi_1[1] == 0)
00403ded      sub_410030("AAS_SplitArea: back area without…")
00403ded  
00403df5  ebx[4] = 1
00403e00  sub_401b00(*ebp_1)
00403e08  sub_401b00(*edi_1)
00403e11  sub_401970(*ebp_1)
00403e19  sub_401970(*edi_1)
00403e28  *arg3 = *ebp_1
00403e2a  int32_t result = *edi_1
00403e33  *arg4 = result
00403e39  return result

00403e3a                                                                                90 90 90 90 90 90                            ......

00403e40    int32_t sub_403e40(void* arg1, float* arg2, float* arg3)

00403e48  int32_t ecx = data_42b16c
00403e4e  int32_t edx = data_42b170
00403e54  float var_18 = data_42b168
00403e5f  int32_t var_14 = ecx
00403e63  int32_t var_10 = edx
00403e67  sub_4104d0(&var_18)
00403e6c  void* esi = arg1
00403e70  int32_t edx_1 = data_282360c
00403e82  int32_t result = 0
00403e86  void* ecx_2 = esi * 7
00403e88  float var_30 = -999999f
00403e90  int32_t* edi = *(edx_1 + (ecx_2 << 2) + 4)
00403e94  int32_t* ecx_3 = edx_1 + (ecx_2 << 2)
00403e99  int32_t* var_38 = ecx_3
00403e99  
00403e9d  if (edi == 0)
0040407c      return 0
0040407c  
00403ebf  while (true)
00403ebf      float* edx_2
00403ebf      edx_2.b = edi[2] != *ecx_3
00403ebf      
00403ed3      if (sub_406f30(edi[1]) == 0)
00403eec          int32_t eax_5
00403eec          
00403eec          if ((edi[4].b & 4) == 0)
00403ef0              eax_5 = sub_401730(edi, edx_2)
00403ef0          
00403efa          if ((edi[4].b & 4) != 0 || eax_5 != 0)
00403f06              int32_t edx_3
00403f06              
00403f06              for (int32_t* i = edi[&edx_2[2]]; i != 0; i = i[edx_3 + 8])
00403f1c                  edx_3.b = i[2] != *var_38
00403f1c                  
00403f2c                  if (sub_406f30(edi[1]) == 0)
00403f49                      int32_t eax_8
00403f49                      
00403f49                      if ((i[4].b & 4) == 0)
00403f4d                          eax_8 = sub_401730(i, edx_3)
00403f4d                      
00403f57                      if ((i[4].b & 4) != 0 || eax_8 != 0)
00403f61                          int32_t eax_9
00403f61                          
00403f61                          if ((edi[4].b & 4) != 0)
00403f65                              eax_9 = sub_401730(i, edx_3)
00403f65                          
00403f6f                          if ((edi[4].b & 4) != 0 && eax_9 != 0)
00403fa8                              label_403fa8:
00403fa8                              float var_34
00403fa8                              float var_c
00403fa8                              int32_t eax_12 =
00403fa8                                  sub_411dc0(edi[1], i[1], &var_18, &var_c, &var_34)
00403fa8                              int16_t top = top - 1
00403fa8                              unimplemented  {call sub_411dc0}
00403fb2                              int32_t var_28
00403fb2                              int32_t var_24
00403fb2                              int32_t var_1c
00403fb2                              
00403fb2                              if (eax_12 != 0 && sub_403990(arg1, &var_c, var_34, &var_24, 
00403fb2                                      &var_28, &var_1c) != 0)
00403ff5                                  int32_t var_20_1 = ((0x32 - var_28) << 1) - var_24
00403ff9                                  int32_t eax_18 = var_1c
00403ffd                                  unimplemented  {fild st0, dword [esp+0x28]}
00403ffd                                  
00404003                                  if (eax_18 != 0)
00404040                                      void* var_4c_11 = arg1
00404041                                      int32_t var_50_7 = eax_18
00404047                                      unimplemented  {fstp st0, st0}
00404047                                      unimplemented  {fstp st0, st0}
00404049                                      sub_410080("found %d epsilon faces trying to…")
00404003                                  else
00404005                                      long double temp0_1 = fconvert.t(var_30)
00404005                                      unimplemented  {fcom st0, dword [esp+0x18]} f- temp0_1
00404005                                      bool c0_1 =
00404005                                          unimplemented  {fcom st0, dword [esp+0x18]}
00404005                                          f< temp0_1
00404005                                      bool c2_1 = is_unordered.t(
00404005                                          unimplemented  {fcom st0, dword [esp+0x18]}, 
00404005                                          temp0_1)
00404005                                      bool c3_1 =
00404005                                          unimplemented  {fcom st0, dword [esp+0x18]}
00404005                                          f== temp0_1
00404009                                      eax_18.w = (c0_1 ? 1 : 0) << 8 | (c2_1 ? 1 : 0) << 0xa
00404009                                          | (c3_1 ? 1 : 0) << 0xe | ((top - 1) & 7) << 0xb
00404009                                      
0040400e                                      if ((eax_18:1.b & 0x41) != 0)
00404053                                          unimplemented  {fstp st0, st0}
00404053                                          unimplemented  {fstp st0, st0}
0040400e                                      else
00404014                                          float ecx_7 = var_c
0040401c                                          int32_t var_8
0040401c                                          arg2[1] = var_8
00404023                                          *arg2 = ecx_7
00404025                                          float ecx_8 = var_34
00404029                                          int32_t var_4
00404029                                          arg2[2] = var_4
0040402c                                          var_30 = fconvert.s(unimplemented  {fstp dword [
0040402c                                              esp+0x18], st0})
0040402c                                          unimplemented  {fstp dword [esp+0x18], st0}
00404030                                          *arg3 = ecx_8
00404032                                          result = 1
00403f6f                          else if ((i[4].b & 4) != 0 && sub_401730(edi, edx_2) != 0)
00403f8b                              goto label_403fa8
00403f2c                  else
00403f32                      void* var_4c_5 = arg1
00403f38                      sub_410080("gsubdiv: area %d has a tiny wind…")
00403ed3      else
00403ed5          void* var_4c_2 = esi
00403edb          sub_410080("gsubdiv: area %d has a tiny wind…")
00403edb      
00404065      edi = edi[&edx_2[2]]
00404065      
0040406b      if (edi == 0)
0040406b          break
0040406b      
00403eab      esi = arg1
00403eaf      ecx_3 = var_38
00403eaf  
00404071  return result

0040407d                                                                                         90 90 90                               ...

00404080    int32_t sub_404080(void* arg1)

0040408c  void* esi = arg1
0040409d  float var_c
0040409d  
0040409d  if (sub_403e40(esi, &var_c, &arg1) == 0)
0040414d      return neg.d(esi)
0040414d  
004040a8  int32_t __saved_edi_2 = data_430314 + 1
004040a9  int32_t __saved_edi_1 = __saved_edi_2
004040af  data_430314 = __saved_edi_2
004040b4  sub_40fa00("\r%6d")
004040c1  void* var_24_1 = arg1
004040d4  int32_t var_14
004040d4  int32_t var_10
004040d4  sub_403b60(esi, sub_414ae0(&var_c), &var_14, &var_10)
004040d9  int32_t result = data_2823618
004040d9  
004040e6  if (result s>= 0x3e800)
004040ed      sub_40f970("AAS_MAX_NODES")
004040f2      result = data_2823618
004040f2  
004040fa  int32_t edx_1 = data_282361c
00404107  data_2823618 = result + 1
00404110  int32_t* esi_1 = edx_1 + result * 0xc
00404117  void* var_20_1 = arg1
0040411e  *esi_1 = sub_414ae0(&var_c)
0040412a  esi_1[1] = sub_404080(var_14)
0040413a  esi_1[2] = sub_404080(var_10)
00404144  return result

0040414e                                            90 90                                                                ..

00404150    int32_t sub_404150(int32_t arg1)

00404157  if (arg1 == 0)
0040415c      return 0
0040415c  
0040415d  if (arg1 s< 0)
00404161      int32_t eax_2
00404161      int32_t edx
00404161      edx:eax_2 = sx.q(arg1)
00404170      return sub_404080((eax_2 ^ edx) - edx)
00404170  
00404171  int32_t ecx = data_282361c
00404177  int32_t eax_6 = arg1 * 3
0040417f  void* esi = ecx + (eax_6 << 2)
00404188  *(esi + 4) = sub_404150(*(ecx + (eax_6 << 2) + 4))
00404197  *(esi + 8) = sub_404150(*(esi + 8))
0040419e  return arg1

0040419f                                                                                               90                                 .

004041a0    int32_t* sub_4041a0()

004041a5  sub_410080("AAS_GravitationalSubdivision")
004041aa  int32_t var_8 = 0
004041b1  data_430314 = 0
004041bb  sub_40fa00("%6i gravitational subdivisions")
004041c2  sub_404150(1)
004041cc  sub_40fa00(&data_42b33c)
004041d6  int32_t var_18 = data_430314
004041e4  return sub_410080("%6i gravitational subdivisions")

004041e5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

004041f0    int32_t sub_4041f0(int32_t arg1, int32_t arg2, int32_t arg3)

004041f7  if (arg1 == 0)
004041fc      return 0
004041fc  
004041fd  if (arg1 s< 0)
00404209      if (neg.d(arg1) != arg2)
00404214          return arg1
00404214      
00404210      return arg3
00404210  
00404215  int32_t edx = data_282361c
00404220  int32_t ecx_1 = arg1 * 3
0040422d  void* esi = edx + (ecx_1 << 2)
00404233  int32_t eax_6 = sub_4041f0(*(edx + (ecx_1 << 2) + 4), arg2, arg3)
00404238  int32_t ecx_2 = *(esi + 8)
0040423e  *(esi + 4) = eax_6
00404249  *(esi + 8) = sub_4041f0(ecx_2, arg2, arg3)
00404252  return arg1

00404253                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00404260    int32_t sub_404260(void* arg1)

00404263  void* edx = arg1
00404267  int32_t ecx = data_282360c
0040426d  float var_c = 0f
00404275  int32_t var_8 = 0
00404284  int32_t var_4 = 0x3f800000
00404291  int32_t* eax_2 = ecx + edx * 0x1c
00404291  
004042a3  if ((eax_2[3].b & 7) == 0 && (eax_2[2].b & 2) != 0)
004042a9      long double x87_r7_1 = fconvert.t(99999f)
004042af      int32_t ebx_1 = 0
004042b1      float* var_20 = nullptr
004042b5      int32_t* i = eax_2[1]
004042ba      int32_t* i_2 = i
004042ba      
004042be      if (i != 0)
004042c4          int32_t ebp_1 = *eax_2
00404349          float var_18
00404349          int32_t* var_14
00404349          
00404349          do
004042cd              int32_t eax_3
004042cd              eax_3.b = i[2] != ebp_1
004042d2              char eax_4 = (i[4]).b
004042d2              
004042d7              if ((eax_4 & 2) != 0)
004042e4                  long double x87_r6_1 = fconvert.t(*(*i * 0x1c + &data_239e0c8))
004042f2                  long double temp0_1 = fconvert.t(-0.10000000000000001)
004042f2                  x87_r6_1 - temp0_1
004042f2                  
004042fd                  if ((((x87_r6_1 < temp0_1 ? 1 : 0) << 8
004042fd                          | (is_unordered.t(x87_r6_1, temp0_1) ? 1 : 0) << 0xa
004042fd                          | (x87_r6_1 == temp0_1 ? 1 : 0) << 0xe | 0x3800):1.b & 0x41) == 0)
004042ff                      int32_t* eax_7 = i[1]
00404302                      ebx_1 = 1
00404307                      int32_t j_1 = *eax_7
00404307                      
0040430b                      if (j_1 s> 0)
0040430d                          void* edx_1 = &eax_7[3]
0040432f                          int32_t j
0040432f                          
0040432f                          do
00404310                              long double temp1_1 = fconvert.t(*edx_1)
00404310                              x87_r7_1 - temp1_1
00404312                              eax_7.w = (x87_r7_1 < temp1_1 ? 1 : 0) << 8
00404312                                  | (is_unordered.t(x87_r7_1, temp1_1) ? 1 : 0) << 0xa
00404312                                  | (x87_r7_1 == temp1_1 ? 1 : 0) << 0xe | 0x3800
00404312                              
00404317                              if ((eax_7:1.b & 0x41) == 0)
0040431c                                  var_18 = *(edx_1 - 8)
00404325                                  x87_r7_1 = fconvert.t(*edx_1)
00404327                                  var_14 = *(edx_1 - 4)
00404327                              
0040432b                              edx_1 += 0xc
0040432e                              j = j_1
0040432e                              j_1 -= 1
0040432f                          while (j != 1)
00404331                          edx = arg1
004042d7              else if ((eax_4 & 4) != 0)
0040433b                  var_20 = 1
0040433b              
00404343              i = i[eax_3 + 8]
00404349          while (i != 0)
00404349          
0040435d          if (ebx_1 != 0 && var_20 != 0)
00404369              int32_t edx_2
00404369              
00404369              for (int32_t* i_1 = i_2; i_1 != 0; i_1 = i_1[edx_2 + 8])
0040436e                  float* eax_9
0040436e                  eax_9.b = i_1[4].b
00404375                  edx_2.b = i_1[2] != ebp_1
00404375                  
0040437a                  if ((eax_9.b & 4) != 0)
00404389                      int32_t esi_5 = *i_1 * 7
004043a8                      long double x87_r6_6 =
004043a8                          fconvert.t(var_14) * fconvert.t(*((esi_5 << 2) + &data_239e0c4))
004043a8                          + x87_r7_1 * fconvert.t(*((esi_5 << 2) + &data_239e0c8))
004043a8                          + fconvert.t(var_18)
004043a8                          * fconvert.t(*((esi_5 << 2) + &data_239e0c0))
004043a8                          - fconvert.t(*((esi_5 << 2) + &data_239e0cc))
004043ab                      long double temp3_1 = fconvert.t(-1f)
004043ab                      x87_r6_6 - temp3_1
004043b1                      eax_9.w = (x87_r6_6 < temp3_1 ? 1 : 0) << 8
004043b1                          | (is_unordered.t(x87_r6_6, temp3_1) ? 1 : 0) << 0xa
004043b1                          | (x87_r6_6 == temp3_1 ? 1 : 0) << 0xe | 0x3000
004043b1                      
004043b6                      if ((eax_9:1.b & 0x41) != 0)
004043c7                          x87_r7_1 = x87_r6_6
004043b6                      else
004043b8                          long double temp4_1 = fconvert.t(1f)
004043b8                          x87_r6_6 - temp4_1
004043be                          eax_9.w = (x87_r6_6 < temp4_1 ? 1 : 0) << 8
004043be                              | (is_unordered.t(x87_r6_6, temp4_1) ? 1 : 0) << 0xa
004043be                              | (x87_r6_6 == temp4_1 ? 1 : 0) << 0xe | 0x3800
004043be                          
004043c3                          if ((eax_9:1.b & 1) != 0)
00404413                              return neg.d(arg1)
00404413              
004043d1              i_2 = fconvert.s(x87_r7_1)
004043dd              int32_t* i_3 = i_2
004043e8              int32_t* ebx_2 = sub_414ae0(&var_c)
004043ec              void* eax_12 = sub_4038f0(arg1, ebx_2)
004043ec              
004043f6              if (eax_12 == 0)
00404403                  return neg.d(arg1)
00404403              
00404415              sub_410740(eax_12)
0040441f              int32_t eax_18 = data_430318 + 1
00404420              int32_t var_38_1 = eax_18
00404426              data_430318 = eax_18
0040442b              sub_40fa00("\r%6d")
0040443c              sub_403b60(arg1, ebx_2, &i_2, &var_20)
00404441              int32_t result = data_2823618
00404441              
0040444e              if (result s>= 0x3e800)
00404455                  sub_40f970("AAS_MAX_NODES")
0040445a                  result = data_2823618
0040445a              
0040446e              int32_t* esi_6 = data_282361c + result * 0xc
00404471              data_2823618 = result + 1
00404476              *esi_6 = ebx_2
00404482              esi_6[1] = sub_404260(i_2)
00404493              esi_6[2] = sub_404260(var_20)
00404496              sub_4041f0(1, arg1, result)
004044a7              return result
004044a7  
004044b5  return neg.d(edx)

004044b6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

004044c0    int32_t sub_4044c0(int32_t arg1)

004044c7  if (arg1 == 0)
004044cc      return 0
004044cc  
004044cd  if (arg1 s< 0)
004044d1      int32_t eax_2
004044d1      int32_t edx
004044d1      edx:eax_2 = sx.q(arg1)
004044e0      return sub_404260((eax_2 ^ edx) - edx)
004044e0  
004044e1  int32_t ecx = data_282361c
004044e7  int32_t eax_6 = arg1 * 3
004044ef  void* esi = ecx + (eax_6 << 2)
004044f8  *(esi + 4) = sub_4044c0(*(ecx + (eax_6 << 2) + 4))
00404507  *(esi + 8) = sub_4044c0(*(esi + 8))
0040450e  return arg1

0040450f                                               90                                                                 .

00404510    int32_t* sub_404510()

00404515  sub_410080("AAS_LadderSubdivision")
0040451a  int32_t var_8 = 0
00404521  data_430318 = 0
0040452b  sub_40fa00("%6i ladder subdivisions")
00404532  sub_4044c0(1)
0040453c  sub_40fa00(&data_42b33c)
00404546  int32_t var_18 = data_430318
00404554  return sub_410080("%6i ladder subdivisions")

00404555                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00404560    long double sub_404560(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00404571  float* ecx = arg1
00404573  float var_c
00404573  int32_t eax
00404573  
00404573  if (arg4 == 0)
004045d9      int32_t edx_1 = &var_c - arg1
004045db      int32_t i_3 = 3
00404619      int32_t i
00404619      
00404619      do
004045e0          long double x87_r7_3 = fconvert.t(*ecx)
004045e2          long double temp0_1 = fconvert.t(0.0001)
004045e2          x87_r7_3 - temp0_1
004045e8          eax.w = (x87_r7_3 < temp0_1 ? 1 : 0) << 8
004045e8              | (is_unordered.t(x87_r7_3, temp0_1) ? 1 : 0) << 0xa
004045e8              | (x87_r7_3 == temp0_1 ? 1 : 0) << 0xe
004045e8          
004045ed          if ((eax:1.b & 0x41) != 0)
004045f7              long double x87_r7_4 = fconvert.t(*ecx)
004045f9              long double temp2_1 = fconvert.t(-0.0001)
004045f9              x87_r7_4 - temp2_1
004045ff              eax.w = (x87_r7_4 < temp2_1 ? 1 : 0) << 8
004045ff                  | (is_unordered.t(x87_r7_4, temp2_1) ? 1 : 0) << 0xa
004045ff                  | (x87_r7_4 == temp2_1 ? 1 : 0) << 0xe
004045ff              
00404604              if ((eax:1.b & 1) == 0)
0040460e                  *(ecx + edx_1) = 0
00404604              else
00404609                  *(ecx + edx_1) = *(ecx + arg3 - arg1)
004045ed          else
004045f2              *(ecx + edx_1) = *(ecx + arg2 - arg1)
004045f2          
00404615          ecx = &ecx[1]
00404618          i = i_3
00404618          i_3 -= 1
00404619      while (i != 1)
00404573  else
00404585      void* edx = &var_c - arg1
00404587      int32_t i_2 = 3
004045c5      int32_t i_1
004045c5      
004045c5      do
0040458c          long double x87_r7_1 = fconvert.t(*ecx)
0040458e          long double temp1_1 = fconvert.t(0.0001)
0040458e          x87_r7_1 - temp1_1
00404594          eax.w = (x87_r7_1 < temp1_1 ? 1 : 0) << 8
00404594              | (is_unordered.t(x87_r7_1, temp1_1) ? 1 : 0) << 0xa
00404594              | (x87_r7_1 == temp1_1 ? 1 : 0) << 0xe
00404594          
00404599          if ((eax:1.b & 0x41) != 0)
004045a3              long double x87_r7_2 = fconvert.t(*ecx)
004045a5              long double temp3_1 = fconvert.t(-0.0001)
004045a5              x87_r7_2 - temp3_1
004045ab              eax.w = (x87_r7_2 < temp3_1 ? 1 : 0) << 8
004045ab                  | (is_unordered.t(x87_r7_2, temp3_1) ? 1 : 0) << 0xa
004045ab                  | (x87_r7_2 == temp3_1 ? 1 : 0) << 0xe
004045ab              
004045b0              if ((eax:1.b & 1) == 0)
004045ba                  *(edx + ecx) = 0
004045b0              else
004045b5                  *(edx + ecx) = *(arg2 - arg1 + ecx)
00404599          else
0040459e              *(edx + ecx) = *(arg3 - arg1 + ecx)
0040459e          
004045c1          ecx = &ecx[1]
004045c4          i_1 = i_2
004045c4          i_2 -= 1
004045c5      while (i_1 != 1)
0040461d  float edx_2 = arg1[1]
00404620  float eax_1 = arg1[2]
00404623  float var_18 = *arg1
00404634  sub_4104d0(&var_18)
0040465f  float var_8
0040465f  float var_4
0040465f  return fconvert.t(var_4) * fconvert.t(eax_1) + fconvert.t(var_8) * fconvert.t(edx_2)
0040465f      + fconvert.t(var_c) * fconvert.t(var_18)


00404660    void* sub_404660(void* arg1, int32_t arg2, int32_t arg3)

00404660  float ecx
00404660  float var_4_1 = ecx
00404661  void* result = arg1
00404666  int32_t ebx = 0
00404666  
0040466d  if (*(result + 0x2c) s> 0)
00404672      int32_t ebp_1 = 0
00404672      
004046e3      do
00404681          int32_t* esi_2 = *(arg1 + 0x30) + ebp_1
0040468d          int32_t edx_2 = *esi_2 * 7
004046b8          float var_28_1 = fconvert.s(
004046b8              sub_404560((edx_2 << 2) + &data_239e0c0, arg2, arg3, 0)
004046b8              + fconvert.t(*((edx_2 << 2) + &data_239e0cc)))
004046ba          int32_t eax_3 = sub_414ae0((edx_2 << 2) + &data_239e0c0)
004046bf          int32_t edi_2 = esi_2[6]
004046c6          esi_2[7].w &= 0xfffb
004046d5          *esi_2 = eax_3
004046d7          esi_2[6] = edi_2 & 0xfffffdff
004046da          result = *(arg1 + 0x2c)
004046dd          ebx += 1
004046de          ebp_1 += 0x20
004046e3      while (ebx s< result)
004046e3  
004046ea  return result

004046eb                                   90 90 90 90 90                                                             .....

004046f0    int32_t sub_4046f0(void* arg1)

004046fc  int32_t i
004046fc  
004046fc  if ((*(arg1 + 8) & 0x2001803a) == 0)
00404721      i = *(arg1 + 0x2c)
00404724      int32_t esi_3 = 0
00404724      
00404728      if (i s> 0)
0040472a          int32_t edx_3 = 0
0040472a          
00404750          do
0040472f              void* eax_1 = *(arg1 + 0x30) + edx_3
0040472f              
00404735              if ((*(eax_1 + 0x1c) & 0xc) == 0)
00404740                  *(eax_1 + 4) = 0xffffffff
00404735              else
00404737                  *(eax_1 + 4) = 0
00404737              
00404747              i = *(arg1 + 0x2c)
0040474a              esi_3 += 1
0040474b              edx_3 += 0x20
00404750          while (esi_3 s< i)
004046fc  else
00404701      i = 0
00404701      
00404705      if (*(arg1 + 0x2c) s> 0)
00404707          int32_t edx_2 = 0
00404707          
0040471d          do
0040470c              i += 1
0040470d              *(*(arg1 + 0x30) + edx_2 + 4) = 0
00404718              edx_2 += 0x20
0040471d          while (i s< *(arg1 + 0x2c))
0040471d  
00404753  return i

00404754                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00404760    int32_t sub_404760(void* arg1)

00404766  int32_t ebx = 0
00404768  int32_t result = *(arg1 + 0x2c)
00404768  
0040476d  if (result s> 0)
00404770      int32_t esi_1 = 0
00404770      
00404790      do
00404777          int32_t* eax_2 = *(*(arg1 + 0x30) + esi_1 + 8)
00404777          
0040477c          if (eax_2 != 0)
0040477f              sub_410740(eax_2)
0040477f          
00404787          result = *(arg1 + 0x2c)
0040478a          ebx += 1
0040478b          esi_1 += 0x20
00404790      while (ebx s< result)
00404790  
00404795  return result

00404796                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

004047a0    int32_t sub_4047a0(int32_t* arg1)

004047a3  int32_t __saved_ebx_1
004047a3  int32_t __saved_ebx = __saved_ebx_1
004047a4  int32_t __saved_ebp_1
004047a4  int32_t __saved_ebp = __saved_ebp_1
004047a5  int32_t __saved_esi_1
004047a5  int32_t __saved_esi = __saved_esi_1
004047a6  int32_t* esi = arg1
004047aa  int32_t __saved_edi_1
004047aa  int32_t __saved_edi = __saved_edi_1
004047b3  sub_4104f0(&esi[5], &esi[8])
004047c2  arg1 = nullptr
004047c6  int64_t var_2c
004047c6  int16_t top
004047c6  
004047c6  if (esi[0xb] s> 0)
004047cc      int32_t var_4_1 = 0
004048bb      bool cond:4_1
004048bb      
004048bb      do
004047e1          int32_t edx_2 = *(esi[0xc] + var_4_1) * 7
004047f3          int32_t* i =
004047f3              sub_410b70((edx_2 << 2) + &data_239e0c0, *((edx_2 << 2) + &data_239e0cc))
004047f3          top -= 1
004047f3          unimplemented  {call sub_410b70}
004047f8          int32_t ecx_3 = esi[0xb]
004047fe          int32_t edi = 0
00404800          int32_t* i_6 = i
00404800          
00404806          if (ecx_3 s> 0)
00404808              int32_t ebx = 0
00404808              
0040480c              while (i != 0)
00404812                  if (arg1 != edi)
00404814                      void* edx_3 = esi[0xc]
00404817                      int32_t* ecx_4 = edx_3 + ebx
0040481a                      edx_3.b = *(edx_3 + ebx + 0x1c)
0040481a                      
00404821                      if ((edx_3.b & 4) == 0)
00404825                          int32_t var_1c_2 = 0
00404831                          int32_t ecx_6 = (*ecx_4 ^ 1) * 7
00404841                          int32_t var_20_2 = *((ecx_6 << 2) + &data_239e0cc)
00404842                          void* var_24_1 = (ecx_6 << 2) + &data_239e0c0
00404847                          var_2c:4.d = &i_6
00404848                          sub_4111c0()
00404848                          top -= 1
00404848                          unimplemented  {call sub_4111c0}
0040484d                          i = i_6
0040484d                  
00404857                  edi += 1
00404858                  ebx += 0x20
00404858                  
0040485d                  if (edi s>= esi[0xb])
0040485d                      break
0040485d          
00404866          void* ecx_9 = esi[0xc] + var_4_1
00404868          *(ecx_9 + 8) = i
00404868          
00404871          if (i_6 != 0)
00404873              *(ecx_9 + 0x1c) |= 2
00404877              int32_t* i_8 = i_6
0040487b              int32_t i_1 = 0
0040487b              
00404880              if (*i_8 s> 0)
00404882                  int32_t ebx_1 = 0
00404882                  
004048a0                  do
0040488e                      sub_410520(ebx_1 + i_8 + 4, &esi[5], &esi[8])
0040488e                      unimplemented  {call sub_410520}
00404893                      i_8 = i_6
0040489a                      i_1 += 1
0040489b                      ebx_1 += 0xc
004048a0                  while (i_1 s< *i_8)
004048a0          
004048b1          cond:4_1 = arg1 + 1 s< esi[0xb]
004048b3          arg1 += 1
004048b7          var_4_1 += 0x20
004048bb      while (cond:4_1)
004048bb  
004048c1  int32_t eax_10 = esi[0xb]
004048c4  int32_t ebp_1 = 0
004048c8  arg1 = nullptr
004048c8  
004048cc  if (eax_10 s> 0)
00404962      bool cond:3_1
00404962      
00404962      do
004048d2          int32_t i_2 = 0
004048d6          int32_t i_7 = 0
004048d6          
004048da          if (eax_10 s> 0)
004048dc              int32_t* edi_1 = nullptr
004048dc              
0040494f              do
004048e2                  if (arg1 != i_2)
004048e4                      int32_t* eax_11 = esi[0xc]
004048e7                      int32_t ecx_13 = *(eax_11 + ebp_1)
00404904                      int32_t ebx_3 = *(edi_1 + eax_11) * 7
0040491e                      var_2c:4.d = ecx_13 * 0x1c + &data_239e0c0
00404923                      var_2c.d = *(edi_1 + eax_11 + 8)
00404923                      
0040492f                      if (sub_412170(*(eax_11 + ebp_1 + 8), var_2c, 
0040492f                              (ebx_3 << 2) + &data_239e0c0, 
0040492f                              *(ecx_13 * 0x1c + &data_239e0cc), 
0040492f                              *((ebx_3 << 2) + &data_239e0cc)) != 0)
00404931                          char* var_1c_5 = "non convex brush"
00404936                          sub_410030("non convex brush")
00404936                  
00404945                  i_2 = i_7 + 1
00404946                  edi_1 = &edi_1[8]
0040494b                  i_7 = i_2
0040494f              while (i_2 s< esi[0xb])
0040494f          
00404955          eax_10 = esi[0xb]
00404959          ebp_1 += 0x20
0040495c          cond:3_1 = arg1 + 1 s< eax_10
0040495e          arg1 += 1
00404962      while (cond:3_1)
00404962  
0040496a  int32_t i_3 = 0
0040496c  void* ecx_19 = &esi[8]
0040496c  
004049b4  do
0040496f      unimplemented  {fld st0, dword [ecx-0xc]}
00404972      long double temp0_1 = fconvert.t(-5000f)
00404972      unimplemented  {fcomp st0, dword [&data_4291ac]} f- temp0_1
00404972      bool c0_1 = unimplemented  {fcomp st0, dword [&data_4291ac]} f< temp0_1
00404972      bool c2_1 = is_unordered.t(unimplemented  {fcomp st0, dword [&data_4291ac]}, temp0_1)
00404972      bool c3_1 = unimplemented  {fcomp st0, dword [&data_4291ac]} f== temp0_1
00404972      unimplemented  {fcomp st0, dword [&data_4291ac]}
00404978      eax_10.w = (c0_1 ? 1 : 0) << 8 | (c2_1 ? 1 : 0) << 0xa | (c3_1 ? 1 : 0) << 0xe
00404978          | (top & 7) << 0xb
0040497d      char* var_24_4
0040497d      int32_t var_20_5
0040497d      
0040497d      if ((eax_10:1.b & 1) != 0)
004049d6          label_4049d6:
004049d6          int32_t var_1c_7 = esi[1]
004049d7          var_20_5 = *esi
004049d8          var_24_4 = "entity %i, brush %i: bounds out …"
004049dd          label_4049dd:
004049dd          sub_410030(var_24_4)
004049e2          unimplemented  {fld st0, dword [esi+edi*4+0x20]}
004049e9          var_20_5.q = fconvert.d(unimplemented  {fstp qword [esp], st0})
004049e9          unimplemented  {fstp qword [esp], st0}
004049ec          unimplemented  {fld st0, dword [esi+edi*4+0x14]}
004049f0          int32_t i_5 = i_3
004049f4          double var_2c_1 = fconvert.d(unimplemented  {fstp qword [esp], st0})
004049f4          unimplemented  {fstp qword [esp], st0}
004049f7          int32_t i_4 = i_3
004049f8          char* var_34 = "ob->mins[%d] = %f, ob->maxs[%d] …"
004049fd          sub_410030("ob->mins[%d] = %f, ob->maxs[%d] …")
00404a05          esi[0xb] = 0
00404a14          return 1
00404a14      
0040497f      int16_t top_2 = top - 1
0040497f      unimplemented  {fld st0, dword [ecx]}
00404981      long double temp1_1 = fconvert.t(5000f)
00404981      unimplemented  {fcomp st0, dword [&data_4291a8]} f- temp1_1
00404981      bool c0_2 = unimplemented  {fcomp st0, dword [&data_4291a8]} f< temp1_1
00404981      bool c2_2 = is_unordered.t(unimplemented  {fcomp st0, dword [&data_4291a8]}, temp1_1)
00404981      bool c3_2 = unimplemented  {fcomp st0, dword [&data_4291a8]} f== temp1_1
00404981      unimplemented  {fcomp st0, dword [&data_4291a8]}
00404987      eax_10.w = (c0_2 ? 1 : 0) << 8 | (c2_2 ? 1 : 0) << 0xa | (c3_2 ? 1 : 0) << 0xe
00404987          | ((top_2 + 1) & 7) << 0xb
00404987      
0040498c      if ((eax_10:1.b & 0x41) == 0)
0040498c          goto label_4049d6
0040498c      
0040498e      unimplemented  {fld st0, dword [ecx-0xc]}
00404991      long double temp2_1 = fconvert.t(5000f)
00404991      unimplemented  {fcomp st0, dword [&data_4291a8]} f- temp2_1
00404991      bool c0_3 = unimplemented  {fcomp st0, dword [&data_4291a8]} f< temp2_1
00404991      bool c2_3 = is_unordered.t(unimplemented  {fcomp st0, dword [&data_4291a8]}, temp2_1)
00404991      bool c3_3 = unimplemented  {fcomp st0, dword [&data_4291a8]} f== temp2_1
00404991      unimplemented  {fcomp st0, dword [&data_4291a8]}
00404997      eax_10.w = (c0_3 ? 1 : 0) << 8 | (c2_3 ? 1 : 0) << 0xa | (c3_3 ? 1 : 0) << 0xe
00404997          | ((top_2 + 1) & 7) << 0xb
00404997      
0040499c      if ((eax_10:1.b & 0x41) == 0)
004049c8          label_4049c8:
004049c8          int32_t var_1c_6 = esi[1]
004049c9          var_20_5 = *esi
004049ca          var_24_4 = "entity %i, brush %i: no visible …"
004049cf          goto label_4049dd
004049cf      
0040499e      unimplemented  {fld st0, dword [ecx]}
004049a0      long double temp3_1 = fconvert.t(-5000f)
004049a0      unimplemented  {fcomp st0, dword [&data_4291ac]} f- temp3_1
004049a0      bool c0_4 = unimplemented  {fcomp st0, dword [&data_4291ac]} f< temp3_1
004049a0      bool c2_4 = is_unordered.t(unimplemented  {fcomp st0, dword [&data_4291ac]}, temp3_1)
004049a0      bool c3_4 = unimplemented  {fcomp st0, dword [&data_4291ac]} f== temp3_1
004049a0      unimplemented  {fcomp st0, dword [&data_4291ac]}
004049a0      top = top_2 + 1
004049a6      eax_10.w = (c0_4 ? 1 : 0) << 8 | (c2_4 ? 1 : 0) << 0xa | (c3_4 ? 1 : 0) << 0xe
004049a6          | (top & 7) << 0xb
004049a6      
004049ab      if ((eax_10:1.b & 1) != 0)
004049ab          goto label_4049c8
004049ab      
004049ad      i_3 += 1
004049ae      ecx_19 += 4
004049b4  while (i_3 s< 3)
004049b4  
004049c2  return 1

00404a15                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00404a20    void* sub_404a20(int32_t* arg1, void* arg2)

00404a20  int32_t eax = data_dde044
00404a20  
00404a2a  if (eax s>= 0x4000)
00404a31      sub_40f970("MAX_MAPFILE_BRUSHES")
00404a36      eax = data_dde044
00404a36  
00404a60  int32_t i = 0
00404a62  *(eax * 0x34 + &data_4b6030) = (data_255e0c0 << 5) + 0x1f9e0a0
00404a67  void* eax_4 = arg2
00404a6b  *(eax * 0x34 + &data_4b6000) = *arg1
00404a76  *(eax * 0x34 + 0x4b6004) = data_dde044 - *(eax_4 + 0xc)
00404a7c  *(eax * 0x34 + &data_4b602c) = arg1[0xb]
00404a82  *(eax * 0x34 + 0x4b6008) = arg1[2]
00404a82  
00404a8a  if (arg1[0xb] s> 0)
00404a8c      int32_t edi_1 = 0
00404a8c      
00404aeb      do
00404a98          if (data_255e0c0 s>= 0x20000)
00404a9f              sub_40f970("MAX_MAPFILE_BRUSHSIDES")
00404a9f          
00404aad          int32_t* eax_6 = *(eax * 0x34 + &data_4b6030) + edi_1
00404aaf          int32_t* ecx_5 = arg1[0xc] + edi_1
00404ab3          edi_1 += 0x20
00404ab6          eax_6[3] = 0
00404ab9          eax_6[2] = 0
00404abf          eax_6[5] = ecx_5[5]
00404ac2          int32_t edx_4
00404ac2          edx_4.w = ecx_5[7].w
00404ac6          eax_6[7].w = edx_4.w
00404acd          eax_6[6] = ecx_5[6]
00404ad2          *eax_6 = *ecx_5
00404ad7          eax_6[1] = ecx_5[1]
00404ae0          i += 1
00404ae1          data_255e0c0 += 1
00404aeb      while (i s< arg1[0xb])
00404aeb      
00404aed      eax_4 = arg2
00404aed  
00404afa  data_dde044 += 1
00404b05  *(eax_4 + 0x10) += 1
00404b0b  return eax * 0x34 + &data_4b6000

00404b0c                                      90 90 90 90                                                              ....

00404b10    int32_t sub_404b10(char* arg1)

00404b18  char* edi = arg1
00404b1a  int32_t i = 0xffffffff
00404b1a  
00404b1f  while (i != 0)
00404b1f      bool cond:0_1 = 0 != *edi
00404b1f      edi = &edi[1]
00404b1f      i -= 1
00404b1f      
00404b1f      if (not(cond:0_1))
00404b1f          break
00404b1f  
00404b24  if (not.d(i) != 1)
00404b2f      int32_t ebp_1 = 0
00404b2f      
00404b33      if (data_2584ecc s> 0)
00404b39          void* edi_1 = &data_256ee80
00404b39          
00404b4c          while (true)
00404b4c              char* esi_1 = sub_40e6a0(edi_1, "target")
00404b4e              char* ecx_2 = arg1
00404b50              int32_t eax_4
00404b50              
00404b50              while (true)
00404b50                  char edx_1 = *ecx_2
00404b52                  char* eax_2
00404b52                  eax_2.b = edx_1
00404b54                  char temp1_1 = *esi_1
00404b54                  bool c_1 = edx_1 u< temp1_1
00404b54                  
00404b56                  if (edx_1 == temp1_1)
00404b5a                      if (eax_2.b == 0)
00404b70                          eax_4 = 0
00404b72                          break
00404b72                      
00404b5c                      edx_1 = ecx_2[1]
00404b5f                      eax_2.b = edx_1
00404b61                      char temp4_1 = esi_1[1]
00404b61                      c_1 = edx_1 u< temp4_1
00404b61                      
00404b64                      if (edx_1 == temp4_1)
00404b66                          ecx_2 = &ecx_2[2]
00404b69                          esi_1 = &esi_1[2]
00404b69                          
00404b6e                          if (eax_2.b != 0)
00404b6e                              continue
00404b6e                          
00404b70                          eax_4 = 0
00404b72                          break
00404b72                  
00404b74                  bool c_2 = unimplemented  {sbb eax, eax}
00404b76                  eax_4 = sbb.d(sbb.d(eax_2, eax_2, c_1), 0xffffffff, c_2)
00404b76                  break
00404b76              
00404b7b              if (eax_4 == 0 && (sub_41e293(sub_40e6a0(edi_1, "spawnflags")):1.b & 8) == 0)
00404ba4                  char* esi_2 = sub_40e6a0(edi_1, "classname")
00404ba6                  char* ecx_3 = "trigger_always"
00404bab                  int32_t eax_9
00404bab                  
00404bab                  while (true)
00404bab                      char edx_2 = *ecx_3
00404bad                      char* eax_7
00404bad                      eax_7.b = edx_2
00404baf                      char temp5_1 = *esi_2
00404baf                      bool c_3 = edx_2 u< temp5_1
00404baf                      
00404bb1                      if (edx_2 == temp5_1)
00404bb5                          if (eax_7.b == 0)
00404bcb                              eax_9 = 0
00404bcd                              break
00404bcd                          
00404bb7                          edx_2 = ecx_3[1]
00404bba                          eax_7.b = edx_2
00404bbc                          char temp8_1 = esi_2[1]
00404bbc                          c_3 = edx_2 u< temp8_1
00404bbc                          
00404bbf                          if (edx_2 == temp8_1)
00404bc1                              ecx_3 = &ecx_3[2]
00404bc4                              esi_2 = &esi_2[2]
00404bc4                              
00404bc9                              if (eax_7.b != 0)
00404bc9                                  continue
00404bc9                              
00404bcb                              eax_9 = 0
00404bcd                              break
00404bcd                      
00404bcf                      bool c_4 = unimplemented  {sbb eax, eax}
00404bd1                      eax_9 = sbb.d(sbb.d(eax_7, eax_7, c_3), 0xffffffff, c_4)
00404bd1                      break
00404bd1                  
00404bd6                  int32_t eax_11
00404bd6                  
00404bd6                  if (eax_9 != 0)
00404be4                      eax_11 = sub_404b10(sub_40e6a0(edi_1, "targetname"))
00404be4                  
00404bee                  if (eax_9 == 0 || eax_11 != 0)
00404c11                      return 1
00404c11              
00404bf5              ebp_1 += 1
00404bf6              edi_1 += 0x2c
00404bf6              
00404bfb              if (ebp_1 s>= data_2584ecc)
00404bfb                  break
00404bfb  
00404c07  return 0

00404c12                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00404c20    int32_t sub_404c20(void* arg1)

00404c20  int32_t ebx
00404c20  int32_t var_4 = ebx
00404c20  
00404c2d  if (arg1 == &data_256ee80)
00404c37      return 1
00404c37  
00404c46  char* esi = sub_40e6a0(arg1, "classname")
00404c48  char* ecx = "func_wall"
00404c4d  int32_t eax_3
00404c4d  
00404c4d  while (true)
00404c4d      char edx_1 = *ecx
00404c4f      ebx.b = *esi
00404c51      char* eax_1
00404c51      eax_1.b = edx_1
00404c53      bool c_1 = edx_1 u< ebx.b
00404c53      
00404c55      if (edx_1 == ebx.b)
00404c59          if (eax_1.b == 0)
00404c71              eax_3 = 0
00404c73              break
00404c73          
00404c5b          edx_1 = ecx[1]
00404c5e          ebx.b = esi[1]
00404c61          eax_1.b = edx_1
00404c63          c_1 = edx_1 u< ebx.b
00404c63          
00404c65          if (edx_1 == ebx.b)
00404c67              ecx = &ecx[2]
00404c6a              esi = &esi[2]
00404c6a              
00404c6f              if (eax_1.b != 0)
00404c6f                  continue
00404c6f              
00404c71              eax_3 = 0
00404c73              break
00404c73      
00404c75      bool c_2 = unimplemented  {sbb eax, eax}
00404c77      eax_3 = sbb.d(sbb.d(eax_1, eax_1, c_1), 0xffffffff, c_2)
00404c77      break
00404c77  
00404c7c  if (eax_3 != 0)
00404cb2      char* esi_1 = sub_40e6a0(arg1, "classname")
00404cb4      char* ecx_1 = "func_door_rotating"
00404cb9      int32_t eax_9
00404cb9      
00404cb9      while (true)
00404cb9          char edx_2 = *ecx_1
00404cbb          ebx.b = *esi_1
00404cbd          char* eax_7
00404cbd          eax_7.b = edx_2
00404cbf          bool c_3 = edx_2 u< ebx.b
00404cbf          
00404cc1          if (edx_2 == ebx.b)
00404cc5              if (eax_7.b == 0)
00404cdd                  eax_9 = 0
00404cdf                  break
00404cdf              
00404cc7              edx_2 = ecx_1[1]
00404cca              ebx.b = esi_1[1]
00404ccd              eax_7.b = edx_2
00404ccf              c_3 = edx_2 u< ebx.b
00404ccf              
00404cd1              if (edx_2 == ebx.b)
00404cd3                  ecx_1 = &ecx_1[2]
00404cd6                  esi_1 = &esi_1[2]
00404cd6                  
00404cdb                  if (eax_7.b != 0)
00404cdb                      continue
00404cdb                  
00404cdd                  eax_9 = 0
00404cdf                  break
00404cdf          
00404ce1          bool c_4 = unimplemented  {sbb eax, eax}
00404ce3          eax_9 = sbb.d(sbb.d(eax_7, eax_7, c_3), 0xffffffff, c_4)
00404ce3          break
00404ce3      
00404ce8      if (eax_9 == 0 && (sub_41e293(sub_40e6a0(arg1, "spawnflags")):1.b & 8) == 0
00404ce8              && sub_404b10(sub_40e6a0(arg1, "targetname")) != 0)
00404d23          return 1
00404c7c  else if ((sub_41e293(sub_40e6a0(arg1, "spawnflags")):1.b & 8) == 0)
00404ca3      return 1
00404ca3  
00404d29  return 0

00404d2a                                90 90 90 90 90 90                                                            ......

00404d30    int32_t sub_404d30(float arg1, float* arg2, float arg3)

00404d41  int32_t esi_2 = arg1 i* 0x1c
00404d4a  float ecx = *(esi_2 + &data_239e0c4)
00404d50  float edx = *(esi_2 + &data_239e0c8)
00404d56  float var_30 = *(esi_2 + &data_239e0c0)
00404d6c  float var_24[0x9]
00404d6c  sub_410200(arg3, &var_24)
00404d7b  sub_4101b0(&var_30, &var_24)
00404dae  float var_48 = fconvert.s(fconvert.t(edx) * fconvert.t(arg2[2])
00404dae      + fconvert.t(ecx) * fconvert.t(arg2[1]) + fconvert.t(var_30) * fconvert.t(*arg2)
00404dae      + fconvert.t(*(esi_2 + &data_239e0cc)))
00404dbc  return sub_414ae0(&var_30)

00404dbd                                                                                         90 90 90                               ...

00404dc0    int32_t sub_404dc0(float* arg1, int32_t* arg2)

00404dc3  int32_t __saved_ebx_1
00404dc3  int32_t __saved_ebx = __saved_ebx_1
00404dc4  int32_t __saved_esi_1
00404dc4  int32_t __saved_esi = __saved_esi_1
00404dc9  int32_t __saved_edi_1
00404dc9  int32_t __saved_edi = __saved_edi_1
00404dca  char* __saved_ebp = "spawnflags"
00404dd8  int16_t x87control
00404dd8  char eax = __ftol(x87control, sub_40e710(arg1, "spawnflags"))
00404ddf  int32_t var_28 = 0
00404dea  int32_t var_2c = 0
00404df2  float var_30 = 0f
00404df2  
00404dfa  if ((eax & 0x40) != 0)
00404dfc      int32_t var_28_1 = 0x3f800000
00404dfa  else if ((eax & 0x80) == 0)
00404e15      int32_t var_2c_1 = 0x3f800000
00404e09  else
00404e0b      var_30 = 1f
00404e0b  
00404e20  if ((eax & 2) != 0)
00404e27      sub_4104d0(&var_30)
00404e27  
00404e2f  char* __saved_ebp_2 = "distance"
00404e35  long double st0_1 = sub_40e710(arg1, "distance")
00404e3a  float var_34 = fconvert.s(st0_1)
00404e3e  long double temp0 = fconvert.t(0f)
00404e3e  st0_1 - temp0
00404e3e  
00404e4c  if ((((st0_1 < temp0 ? 1 : 0) << 8 | (is_unordered.t(st0_1, temp0) ? 1 : 0) << 0xa
00404e4c          | (st0_1 == temp0 ? 1 : 0) << 0xe):1.b & 0x40) != 0)
00404e4e      var_34 = 90f
00404e4e  
00404e5a  float var_24
00404e5a  float* __saved_ebp_3 = &var_24
00404e5b  char* var_48_2 = "angles"
00404e60  float* var_4c = arg1
00404e61  sub_40e730()
00404e66  float edx = var_24
00404e9c  float var_18
00404e9c  sub_4103e0(&var_24, fconvert.d(fneg(fconvert.t(var_34))), &var_30, &var_18)
00404e9c  
00404ea7  if ((eax & 1) != 0)
00404eb5      var_24 = var_18
00404ebd      int32_t var_14
00404ebd      int32_t var_20_1 = var_14
00404ec5      var_18 = edx
00404ec9      int32_t var_10
00404ec9      int32_t var_1c_1 = var_10
00404ed5      int32_t var_20
00404ed5      int32_t var_14_1 = var_20
00404eda      int32_t var_1c
00404eda      int32_t var_10_1 = var_1c
00404ede      sub_4104d0(&var_30)
00404ede  
00404eea  int32_t i = 0
00404ef1  double var_50_1
00404ef1  
00404ef1  if (arg2[0xb] s> 0)
00404ef3      int32_t __saved_ebp_8
00404ef3      int32_t __saved_ebp_6 = __saved_ebp_8
00404ef4      int32_t ebp = 0
00404ef4      
00404f1b      do
00404efd          int32_t* esi_2 = arg2[0xc] + ebp
00404f07          var_50_1.d = *esi_2
00404f10          *esi_2 = sub_404d30(var_50_1.d, arg1, &var_18)
00404f15          i += 1
00404f16          ebp += 0x20
00404f1b      while (i s< arg2[0xb])
00404f1b  
00404f1f  sub_404760(arg2)
00404f25  sub_4047a0(arg2)
00404f2a  int32_t* var_4c_2 = arg2
00404f2b  sub_414c80()
00404f30  var_50_1.d = arg2
00404f3f  return sub_404760(var_50_1.d)


00404f40    int32_t sub_404f40(float arg1, int32_t* arg2)

00404f40  int32_t ebx
00404f40  int32_t var_4 = ebx
00404f43  float* edi = arg1
00404f4d  char* esi = "func_door_rotating"
00404f52  char* eax = sub_40e6a0(edi, "classname")
00404f5a  int32_t result
00404f5a  
00404f5a  while (true)
00404f5a      char edx_1 = *eax
00404f5c      ebx.b = *esi
00404f60      bool c_1 = edx_1 u< ebx.b
00404f60      
00404f62      if (edx_1 == ebx.b)
00404f66          if (edx_1 == 0)
00404f7e              result = 0
00404f80              break
00404f80          
00404f68          edx_1 = eax[1]
00404f6b          ebx.b = esi[1]
00404f70          c_1 = edx_1 u< ebx.b
00404f70          
00404f72          if (edx_1 == ebx.b)
00404f74              eax = &eax[2]
00404f77              esi = &esi[2]
00404f77              
00404f7c              if (edx_1 != 0)
00404f7c                  continue
00404f7c              
00404f7e              result = 0
00404f80              break
00404f80      
00404f82      bool c_2 = unimplemented  {sbb eax, eax}
00404f84      result = sbb.d(sbb.d(eax, eax, c_1), 0xffffffff, c_2)
00404f84      break
00404f84  
00404f89  if (result == 0)
00404f9c      return sub_404dc0(edi, arg2)
00404f9c  
00404f9d  long double x87_r7 = fconvert.t(*edi)
00404f9f  long double temp2 = fconvert.t(0f)
00404f9f  x87_r7 - temp2
00404fa5  result.w = (x87_r7 < temp2 ? 1 : 0) << 8 | (is_unordered.t(x87_r7, temp2) ? 1 : 0) << 0xa
00404fa5      | (x87_r7 == temp2 ? 1 : 0) << 0xe
00404fa5  
00404faa  if ((result:1.b & 0x40) == 0)
00404fd0      label_404fd0:
00404fd0      int32_t ebx_2 = 0
00404fd2      result = arg2[0xb]
00404fd2      
00404fd7      if (result s> 0)
00404fda          int32_t ebp_1 = 0
00404fda          
0040503a          do
00404fe3              int32_t* esi_2 = arg2[0xc] + ebp_1
00404ff0              int32_t eax_6 = *esi_2 * 0x1c
00405021              float var_14_2 = fconvert.s(
00405021                  fconvert.t(*(eax_6 + &data_239e0c8)) * fconvert.t(edi[2])
00405021                  + fconvert.t(*(eax_6 + &data_239e0c4)) * fconvert.t(edi[1])
00405021                  + fconvert.t(*(eax_6 + &data_239e0c0)) * fconvert.t(*edi)
00405021                  + fconvert.t(*(eax_6 + &data_239e0cc)))
0040502f              *esi_2 = sub_414ae0(eax_6 + &data_239e0c0)
00405031              ebx_2 += 1
00405032              result = arg2[0xb]
00405035              ebp_1 += 0x20
0040503a          while (ebx_2 s< result)
00404faa  else
00404fac      long double x87_r7_1 = fconvert.t(edi[1])
00404faf      long double temp3_1 = fconvert.t(0f)
00404faf      x87_r7_1 - temp3_1
00404fb5      result.w = (x87_r7_1 < temp3_1 ? 1 : 0) << 8
00404fb5          | (is_unordered.t(x87_r7_1, temp3_1) ? 1 : 0) << 0xa
00404fb5          | (x87_r7_1 == temp3_1 ? 1 : 0) << 0xe
00404fb5      
00404fba      if ((result:1.b & 0x40) == 0)
00404fba          goto label_404fd0
00404fba      
00404fbc      long double x87_r7_2 = fconvert.t(edi[2])
00404fbf      long double temp4_1 = fconvert.t(0f)
00404fbf      x87_r7_2 - temp4_1
00404fc5      result.w = (x87_r7_2 < temp4_1 ? 1 : 0) << 8
00404fc5          | (is_unordered.t(x87_r7_2, temp4_1) ? 1 : 0) << 0xa
00404fc5          | (x87_r7_2 == temp4_1 ? 1 : 0) << 0xe
00404fc5      
00404fca      if ((result:1.b & 0x40) == 0)
00404fca          goto label_404fd0
00404fca  
00405040  return result

00405041     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00405050    int32_t* sub_405050(int32_t* arg1, float arg2, int32_t arg3)

00405066  if (sub_404c20(arg2) == 0)
0040507b      data_255e0c0 -= arg1[0xb]
00405081      arg1[0xb] = 0
0040508b      return arg1
0040508b  
00405092  sub_404f40(arg2, arg1)
00405098  sub_4046f0(arg1)
004050a3  int32_t edi_2 = arg1[2] & 0xf7ffffff
004050ae  arg1[2] = edi_2
004050ae  
004050b4  if ((edi_2.w:1.b & 0x80) != 0)
004050b6      arg1[2] = 0x8000
004050bd      arg1[4] = 0xffffffff
004050bd  
004050c0  int32_t eax_3 = arg1[2]
004050c0  
004050c8  if ((eax_3 & 0x10002) != 0)
004050cf      arg1[4] = 0xffffffff
004050d2      int32_t eax_4
004050d2      eax_4.b = (eax_3 & 0xfffefffd).b | 1
004050d4      arg1[2] = eax_4
004050d4  
004050de  if ((arg1[2] & 0x20008039) == 0)
004050e8      int32_t eax_6 = data_255e0c0 - arg1[0xb]
004050eb      data_255e0c0 = eax_6
004050f0      arg1[0xb] = 0
004050fd      return eax_6
004050fd  
00405102  int32_t ebx = 0
00405102  
00405106  if (arg3 != 0)
00405109      sub_4047a0(arg1)
0040510f      sub_414c80(arg1)
00405115      sub_404760(arg1)
00405115  
0040512a  int32_t edx_4 = data_256ee90 + 1
0040512b  data_dde044 += 1
00405131  data_256ee90 = edx_4
00405137  int32_t eax_8 = arg1[2]
00405137  
0040513c  if ((eax_8.b & 0x38) != 0)
00405149      arg1[3] = 0
0040514c      sub_404660(arg1, &data_42b0cc, 0x42b0d8)
00405152      sub_415210(arg1)
00405161      return 1
00405161  
00405165  if ((eax_8:1.b & 0x80) != 0)
00405168      arg1[3] = 0
0040516b      sub_4047a0(arg1)
0040517a      return 1
0040517a  
00405180  if ((eax_8 & 0x20000001) != 0)
00405182      eax_8 = data_42b0c0
00405187      int32_t edi_5 = 1
0040518e      int32_t* var_40 = arg1
0040518e      
00405192      if (eax_8 s> 1)
00405194          void var_3c
00405194          void** ebp_1 = &var_3c
00405194          
004051b4          do
004051a6              *ebp_1 = sub_404a20(arg1, &data_256ee80)
004051a9              eax_8 = data_42b0c0
004051ae              edi_5 += 1
004051af              ebp_1 = &ebp_1[1]
004051b4          while (edi_5 s< eax_8)
004051b4      
004051b8      if (eax_8 s> 0)
004051ba          int32_t** ebp_2 = &var_40
004051be          void* esi_1 = &data_42b0cc
004051be          
004051ee          do
004051c3              int32_t* edi_6 = *ebp_2
004051cc              sub_404660(edi_6, esi_1, esi_1 + 0xc)
004051d5              edi_6[3] = *(esi_1 - 8)
004051d8              sub_4047a0(edi_6)
004051dd              eax_8 = data_42b0c0
004051e5              ebx += 1
004051e6              esi_1 += 0x20
004051e9              ebp_2 = &ebp_2[1]
004051ee          while (ebx s< eax_8)
004051ee  
004051f7  return eax_8

004051f8                                                                          90 90 90 90 90 90 90 90                          ........

00405200    int32_t sub_405200(int32_t arg1)

00405209  if (arg1 s> 0)
0040520f      int32_t ecx_1 = data_282361c
00405215      int32_t eax_1 = arg1 * 3
0040521d      void* esi_1 = ecx_1 + (eax_1 << 2)
00405226      *(esi_1 + 4) = sub_405200(*(ecx_1 + (eax_1 << 2) + 4))
0040522d      int32_t eax_4 = sub_405200(*(esi_1 + 8))
00405237      *(esi_1 + 8) = eax_4
0040523a      int32_t esi_2 = *(esi_1 + 4)
0040523d      bool cond:0_1 = esi_2 != 0
0040523d      
0040523f      if (esi_2 s< 0)
00405243          if (eax_4 s< 0)
00405248              int32_t edi_1 = data_282360c
0040524e              int32_t i_2 = neg.d(esi_2)
00405265              int32_t i
00405265              
00405265              do
0040525c                  i = *(edi_1 + i_2 * 0x1c + 0x14)
0040525c                  
00405261                  if (i == 0)
00405261                      break
00405261                  
00405263                  i_2 = i
00405265              while (i != 0)
00405269              int32_t i_3 = neg.d(eax_4)
00405280              int32_t i_1
00405280              
00405280              do
00405277                  i_1 = *(edi_1 + i_3 * 0x1c + 0x14)
00405277                  
0040527c                  if (i_1 == 0)
0040527c                      break
0040527c                  
0040527e                  i_3 = i_1
00405280              while (i_1 != 0)
00405280              
00405285              if (i_2 == i_3)
00405290                  data_28235f4 += 1
00405299                  return neg.d(i_2)
00405299          
0040529a          cond:0_1 = esi_2 != 0
0040529a      
004052a0      if (not(cond:0_1) && eax_4 == 0)
004052aa          data_28235f4 += 1
004052b2          return 0
004052b2  
004052b8  return arg1

004052b9                                                                             90 90 90 90 90 90 90                           .......

004052c0    int32_t* sub_4052c0()

004052c5  sub_410080("AAS_PruneNodes")
004052cc  sub_405200(1)
004052d6  int32_t var_c = data_28235f4
004052e4  return sub_410030("%6d nodes pruned\n")

004052e5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

004052f0    int32_t sub_4052f0()

004052f2  int32_t i_2 = data_2823600
004052fa  int32_t edx = 0
004052fa  
004052fe  if (i_2 s> 0)
00405306      int32_t i_1 = i_2
00405308      int32_t* ecx_1 = data_2823604 + 4
00405317      int32_t i
00405317      
00405317      do
0040530b          int32_t eax_2 = *ecx_1
0040530b          
0040530f          if (eax_2 != 0)
00405311              edx += *eax_2
00405311          
00405313          ecx_1 = &ecx_1[0xa]
00405316          i = i_1
00405316          i_1 -= 1
00405317      while (i != 1)
00405317  
0040531a  int32_t ecx_2 = data_255e0e8
00405323  data_27e2544 = edx + 1
00405328  data_27e254c = edx + 1
00405333  data_27e2554 = i_2 + 0xa
0040533a  data_27e2548 = ecx_2
00405340  int32_t ecx_3 = data_2823608
00405346  data_27e2550 = (edx + 1) * 3
0040534c  int32_t edx_2 = data_2823610
00405352  data_27e2558 = (i_2 + 0xa) * 2
00405362  int32_t result = data_2823618 + 0xa
00405365  data_27e2564 = 0
0040536b  data_27e256c = 0
00405371  data_27e2570 = 0
00405377  data_27e2574 = 0
0040537e  data_27e2540 = 5
00405388  data_27e255c = ecx_3 + 0xa
0040538e  data_27e2560 = edx_2 + 0xa
00405394  data_27e2568 = result
0040539a  return result

0040539b                                                                                   90 90 90 90 90                             .....

004053a0    int32_t sub_4053a0()

004053a2  sub_4052f0()
004053ae  int32_t eax_1 = data_27e2540 << 5
004053b2  data_2823584 = 0
004053b8  void* eax_2 = sub_410570(eax_1)
004053c3  int32_t edx = data_43031c
004053c9  int32_t ecx_1 = data_27e2540 << 5
004053cc  data_2823588 = eax_2
004053d1  int32_t eax_3 = data_27e2544
004053d8  data_282358c = 0
004053de  data_43031c = edx + ecx_1
004053eb  void* eax_4 = sub_410570(eax_3 * 0xc)
004053f0  int32_t ecx_2 = data_43031c
004053f6  data_2823590 = eax_4
004053fb  int32_t eax_5 = data_27e2544
00405400  data_2823594 = 0
0040540c  int32_t eax_7 = data_27e2548
00405411  data_43031c = ecx_2 + eax_5 * 0xc
0040541e  void* eax_10 = sub_410570(eax_7 * 0x14)
00405423  int32_t edx_5 = data_43031c
00405429  data_2823598 = eax_10
0040542e  int32_t eax_11 = data_27e2548
00405433  data_282359c = 0
0040543f  int32_t ecx_4 = data_27e254c
00405445  data_43031c = edx_5 + eax_11 * 0x14
00405452  void* eax_13 = sub_410570(ecx_4 << 3)
00405457  int32_t ecx_5 = data_27e254c
0040545d  data_28235a0 = eax_13
00405462  int32_t eax_14 = data_43031c
00405467  data_28235a4 = 0
00405470  int32_t eax_15 = data_27e2550
00405475  data_43031c = eax_14 + (ecx_5 << 3)
00405483  void* eax_16 = sub_410570(eax_15 << 2)
00405488  int32_t edx_8 = data_43031c
0040548e  data_28235a8 = eax_16
00405493  int32_t eax_17 = data_27e2550
00405498  data_28235ac = 0
004054a1  int32_t eax_18 = data_27e2554
004054a6  data_43031c = edx_8 + (eax_17 << 2)
004054b3  void* eax_19 = sub_410570(eax_18 * 0x18)
004054b8  int32_t ecx_8 = data_43031c
004054be  data_28235b0 = eax_19
004054c3  int32_t eax_20 = data_27e2554
004054c8  data_28235b4 = 0
004054d4  int32_t eax_22 = data_27e2558
004054d9  data_43031c = ecx_8 + eax_20 * 0x18
004054e7  void* eax_23 = sub_410570(eax_22 << 2)
004054ec  int32_t edx_12 = data_43031c
004054f2  data_28235b8 = eax_23
004054ff  data_43031c = edx_12 + (data_27e2558 << 2)
00405505  int32_t eax_25 = data_27e255c
0040550a  data_28235bc = 0
00405517  void* eax_26 = sub_410570(eax_25 * 0x30)
0040551c  int32_t edi = data_43031c
00405522  data_28235c0 = eax_26
00405527  int32_t eax_27 = data_27e255c
0040552c  data_28235c4 = 0
0040553a  int32_t eax_30 = data_27e2560
0040553f  data_43031c = edi + eax_27 * 0x30
00405557  data_28235c8 = sub_410570(eax_30 * 0x1c)
0040555c  int32_t eax_32 = data_27e2560
00405561  data_28235cc = 0
00405578  int32_t eax_34 = data_27e2564
0040557d  data_43031c += eax_32 * 0x1c
00405592  data_28235d0 = sub_410570(eax_34 * 0x2c)
00405597  int32_t eax_38 = data_27e2564
0040559c  data_28235d4 = 0
004055b0  int32_t eax_40 = data_27e2568
004055b5  data_43031c += eax_38 * 0x2c
004055c2  void* eax_41 = sub_410570(eax_40 * 0xc)
004055c7  int32_t ecx_17 = data_43031c
004055cd  data_28235d8 = eax_41
004055d2  int32_t eax_42 = data_27e2568
004055d7  data_28235dc = 0
004055e3  int32_t eax_44 = data_27e256c
004055e8  data_43031c = ecx_17 + eax_42 * 0xc
004055f5  void* eax_47 = sub_410570(eax_44 * 0x14)
004055fa  int32_t edx_22 = data_43031c
00405600  data_28235e0 = eax_47
00405605  int32_t eax_48 = data_27e256c
0040560a  data_28235e4 = 0
00405616  int32_t ecx_19 = data_27e2570
0040561c  data_43031c = edx_22 + eax_48 * 0x14
00405629  void* eax_50 = sub_410570(ecx_19 << 2)
0040562e  int32_t ecx_20 = data_27e2570
00405634  data_28235e8 = eax_50
00405639  int32_t eax_51 = data_43031c
0040563e  data_28235ec = 0
00405647  int32_t eax_52 = data_27e2574
0040564c  data_43031c = eax_51 + (ecx_20 << 2)
00405659  void* eax_55 = sub_410570(eax_52 * 0xc)
0040565e  int32_t edx_25 = data_43031c
00405664  data_28235f0 = eax_55
00405679  data_43031c = edx_25 + data_27e2574 * 0xc
0040567e  sub_410030("allocated ")
0040568a  sub_4105f0(data_43031c)
00405697  sub_410030(" of AAS memory\n")
004056ac  __builtin_memset(s: &data_27e3580, c: 0xffffffff, n: 0x40000)
004056bb  __builtin_memset(s: &data_279c3a0, c: 0xffffffff, n: 0x6184)
004056ca  __builtin_memset(s: &data_27a2540, c: 0xffffffff, n: 0x40000)
004056d9  __builtin_memset(s: &data_27e2580, c: 0xffffffff, n: 0x1000)
004056dd  return 0xffffffff

004056de                                                                                            90 90                                ..

004056e0    int32_t* sub_4056e0()

004056e0  void* eax_4 = data_2823588
004056e9  data_2823584 = 0
004056ef  sub_4105e0(eax_4)
004056f4  void* ecx = data_2823590
004056fa  data_282358c = 0
00405701  sub_4105e0(ecx)
00405706  void* edx = data_2823598
0040570c  data_2823594 = 0
00405713  sub_4105e0(edx)
00405718  void* eax = data_28235a0
0040571d  data_282359c = 0
00405724  sub_4105e0(eax)
00405729  void* ecx_1 = data_28235a8
0040572f  data_28235a4 = 0
00405736  sub_4105e0(ecx_1)
0040573b  void* edx_1 = data_28235b0
00405741  data_28235ac = 0
00405748  sub_4105e0(edx_1)
0040574d  void* eax_1 = data_28235b8
00405752  data_28235b4 = 0
00405759  sub_4105e0(eax_1)
0040575e  void* ecx_2 = data_28235c0
00405764  data_28235bc = 0
0040576b  sub_4105e0(ecx_2)
00405770  void* edx_2 = data_28235c8
00405776  data_28235c4 = 0
0040577d  sub_4105e0(edx_2)
00405782  void* eax_2 = data_28235d0
00405787  data_28235cc = 0
0040578e  sub_4105e0(eax_2)
00405793  void* ecx_3 = data_28235d8
00405799  data_28235d4 = 0
004057a0  sub_4105e0(ecx_3)
004057a5  void* edx_3 = data_28235e0
004057ab  data_28235dc = 0
004057b2  sub_4105e0(edx_3)
004057b7  void* eax_3 = data_28235e8
004057bc  data_28235e4 = 0
004057c3  sub_4105e0(eax_3)
004057c8  void* ecx_4 = data_28235f0
004057ce  data_28235ec = 0
004057d5  sub_4105e0(ecx_4)
004057df  sub_410030("freed ")
004057eb  sub_4105f0(data_43031c)
004057f8  int32_t* result = sub_410030(" of AAS memory\n")
00405800  data_43031c = 0
00405807  return result

00405808                          90 90 90 90 90 90 90 90                                                          ........

00405810    int32_t sub_405810(float* arg1)

0040581a  long double x87_r7 = fconvert.t(*arg1)
0040581c  double var_8 = fconvert.d(x87_r7)
00405826  int32_t eax
00405826  int16_t x87control
00405826  int16_t x87control_1
00405826  eax, x87control_1 = __ftol(x87control, x87_r7 + fconvert.t(0.5))
0040582b  long double x87_r7_2 = fconvert.t(arg1[1])
00405830  double var_10 = fconvert.d(x87_r7_2)
00405840  int32_t edi_2 = (eax + 0x1388) s>> 7
00405850  int32_t esi_2 = (__ftol(x87control_1, x87_r7_2 + fconvert.t(0.5)) + 0x1388) s>> 7
00405850  
00405863  if (edi_2 s< 0 || edi_2 s>= 0x4f || esi_2 s< 0 || esi_2 s>= 0x4f)
00405877      double var_24_1 = fconvert.d(fconvert.t(arg1[2]))
0040587a      int32_t var_28_1 = var_10:4.d
0040587f      int32_t var_2c_1 = var_10.d
00405880      int32_t var_30_1 = var_8:4.d
00405881      int32_t var_34_1 = var_8.d
00405887      sub_40f970("HashVec: point %f %f %f outside …")
00405887  
0040589f  return esi_2 * 0x4f + edi_2


004058a0    int32_t sub_4058a0(float arg1, int32_t* arg2)

004058a5  int32_t* esi = arg1
004058ae  int32_t i_2 = 3
004058b3  float var_c
004058b3  void* edi = &var_c - esi
004058f4  int32_t i
004058f4  
004058f4  do
004058b5      float eax_1 = *esi
004058ca      long double x87_r7_3 = fabs(fconvert.t(eax_1) - sub_4103c0(eax_1))
004058cc      long double temp0_1 = fconvert.t(0.01)
004058cc      x87_r7_3 - temp0_1
004058cc      
004058d7      if ((((x87_r7_3 < temp0_1 ? 1 : 0) << 8
004058d7              | (is_unordered.t(x87_r7_3, temp0_1) ? 1 : 0) << 0xa
004058d7              | (x87_r7_3 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
004058ed          *(edi + esi) = *esi
004058d7      else
004058e3          *(edi + esi) = fconvert.s(sub_4103c0(eax_1))
004058e3      
004058f0      esi = &esi[1]
004058f3      i = i_2
004058f3      i_2 -= 1
004058f4  while (i != 1)
004058fb  int32_t eax_4 = sub_405810(&var_c)
00405900  int32_t edi_1 = data_2823590
00405906  int32_t esi_1 = eax_4
00405914  float var_8
00405914  float var_4
00405914  
00405914  for (int32_t i_1 = *((esi_1 << 2) + &data_279c3a0); i_1 s>= 0; 
00405914          i_1 = *((i_1 << 2) + &data_27e3580))
00405916      int32_t edx_2 = i_1 * 3
00405920      void* edx_3 = edi_1 + (edx_2 << 2)
00405923      long double x87_r7_7 = fabs(fconvert.t(*(edi_1 + (edx_2 << 2))) - fconvert.t(var_c))
00405925      long double temp2_1 = fconvert.t(0.10000000000000001)
00405925      x87_r7_7 - temp2_1
0040592b      eax_4.w = (x87_r7_7 < temp2_1 ? 1 : 0) << 8
0040592b          | (is_unordered.t(x87_r7_7, temp2_1) ? 1 : 0) << 0xa
0040592b          | (x87_r7_7 == temp2_1 ? 1 : 0) << 0xe
0040592b      
00405930      if ((eax_4:1.b & 1) != 0)
00405939          long double x87_r7_10 = fabs(fconvert.t(*(edx_3 + 4)) - fconvert.t(var_8))
0040593b          long double temp3_1 = fconvert.t(0.10000000000000001)
0040593b          x87_r7_10 - temp3_1
00405941          eax_4.w = (x87_r7_10 < temp3_1 ? 1 : 0) << 8
00405941              | (is_unordered.t(x87_r7_10, temp3_1) ? 1 : 0) << 0xa
00405941              | (x87_r7_10 == temp3_1 ? 1 : 0) << 0xe
00405941          
00405946          if ((eax_4:1.b & 1) != 0)
0040594f              long double x87_r7_13 = fabs(fconvert.t(*(edx_3 + 8)) - fconvert.t(var_4))
00405951              long double temp4_1 = fconvert.t(0.10000000000000001)
00405951              x87_r7_13 - temp4_1
00405957              eax_4.w = (x87_r7_13 < temp4_1 ? 1 : 0) << 8
00405957                  | (is_unordered.t(x87_r7_13, temp4_1) ? 1 : 0) << 0xa
00405957                  | (x87_r7_13 == temp4_1 ? 1 : 0) << 0xe
00405957              
0040595c              if ((eax_4:1.b & 1) != 0)
00405a05                  *arg2 = i_1
00405a0f                  return 1
00405a0f  
0040596d  int32_t eax_5 = data_282358c
00405972  int32_t ecx_2 = data_27e2544
00405972  
0040597a  if (eax_5 s>= ecx_2)
0040597c      int32_t var_1c_4 = ecx_2
00405982      sub_40f970("AAS_MAX_VERTEXES = %d")
00405987      eax_5 = data_282358c
0040598c      edi_1 = data_2823590
0040598c  
0040599c  *(edi_1 + eax_5 * 0xc) = fconvert.s(fconvert.t(var_c))
004059b1  *(data_2823590 + data_282358c * 0xc + 4) = fconvert.s(fconvert.t(var_8))
004059c7  *(data_2823590 + data_282358c * 0xc + 8) = fconvert.s(fconvert.t(var_4))
004059d4  *arg2 = data_282358c
004059d6  int32_t eax_10 = data_282358c
004059db  int32_t edx_6 = *((esi_1 << 2) + &data_279c3a0)
004059e2  *((esi_1 << 2) + &data_279c3a0) = eax_10
004059e9  *((eax_10 << 2) + &data_27e3580) = edx_6
004059f1  data_282358c = eax_10 + 1
004059fd  return 0


00405a10    int32_t __convention("regparm") sub_405a10(int32_t arg1, int32_t arg2, int32_t arg3, float arg4, int32_t* arg5)

00405a10  int32_t var_4 = arg3
00405a10  
00405a18  if (data_282359c == 0)
00405a1a      data_282359c = 1
00405a1a  
00405a31  float arg_4
00405a31  int32_t eax_1 = sub_4058a0(arg_4, &arg_4)
00405a42  int32_t eax_3 = sub_4058a0(arg4, &var_4)
00405a47  float edi = arg_4
00405a4b  int32_t ebx = var_4
00405a4b  
00405a56  if (edi == ebx)
00405a5e      *arg5 = 0
00405a6b      return 1
00405a6b  
00405a6e  int32_t esi_2 = data_282359c
00405a6e  
00405a74  if ((eax_1 & eax_3) != 0)
00405a76      int32_t ecx_3 = 1
00405a76      
00405a7d      if (esi_2 s> 1)
00405a85          void* eax_5 = data_28235a0 + 8
00405a85          
00405aa4          do
00405a88              int32_t edx_1 = *eax_5
00405a88              
00405a8c              if (edx_1 != edi)
00405a9c                  if (*(eax_5 + 4) == edi && edx_1 == ebx)
00405b18                      *arg5 = neg.d(ecx_3)
00405b21                      return 1
00405a8c              else if (*(eax_5 + 4) == ebx)
00405b06                  *arg5 = ecx_3
00405b0f                  return 1
00405b0f              
00405a9e              ecx_3 += 1
00405a9f              eax_5 += 8
00405aa4          while (ecx_3 s< esi_2)
00405aa4  
00405aa6  int32_t eax_6 = data_27e254c
00405aa6  
00405aad  if (esi_2 s>= eax_6)
00405aaf      int32_t var_14_1 = eax_6
00405ab5      sub_40f970("AAS_MAX_EDGES = %d")
00405aba      edi = arg_4
00405abe      esi_2 = data_282359c
00405abe  
00405acc  *(data_28235a0 + (esi_2 << 3)) = edi
00405ae0  *(data_28235a0 + (data_282359c << 3) + 4) = var_4
00405aee  *arg5 = data_282359c
00405af7  data_282359c += 1
00405aff  return 0

00405b22        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00405b30    int32_t sub_405b30(int32_t arg1)

00405b49  int32_t eax_2
00405b49  int32_t edx
00405b49  int16_t x87control
00405b49  edx:eax_2 =
00405b49      sx.q(__ftol(x87control, fabs(fconvert.t(*(data_2823598 + arg1 * 0x14 + 0xc)))))
00405b52  int32_t result = (eax_2 + (edx & 7)) s>> 3 & 0x3ff
00405b57  int32_t edx_2 = *((result << 2) + &data_27e2580)
00405b5e  *((result << 2) + &data_27e2580) = arg1
00405b65  *((arg1 << 2) + &data_27a2540) = edx_2
00405b6d  return result

00405b6e                                            90 90                                                                ..

00405b70    void sub_405b70(float* arg1, float arg2, int32_t arg3)

00405b74  int32_t ecx = data_2823598
00405b7e  int32_t eax = arg3 * 5
00405b81  long double x87_r7_1 = fconvert.t(arg2) - fconvert.t(*(ecx + (eax << 2) + 0xc))
00405b85  float* ecx_1 = ecx + (eax << 2)
00405b88  long double temp0 = fconvert.t(-0.050000000000000003)
00405b88  x87_r7_1 - temp0
00405b8e  eax.w = (x87_r7_1 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7_1, temp0) ? 1 : 0) << 0xa
00405b8e      | (x87_r7_1 == temp0 ? 1 : 0) << 0xe | 0x3800
00405b8e  
00405b93  if ((eax:1.b & 0x41) == 0)
00405b95      long double temp1_1 = fconvert.t(0.050000000000000003)
00405b95      x87_r7_1 - temp1_1
00405b9b      eax.w = (x87_r7_1 < temp1_1 ? 1 : 0) << 8
00405b9b          | (is_unordered.t(x87_r7_1, temp1_1) ? 1 : 0) << 0xa
00405b9b          | (x87_r7_1 == temp1_1 ? 1 : 0) << 0xe
00405b9b      
00405ba0      if ((eax:1.b & 1) != 0)
00405ba8          x87_r7_1 = fconvert.t(*arg1) - fconvert.t(*ecx_1)
00405baa          long double temp2_1 = fconvert.t(-0.0001)
00405baa          x87_r7_1 - temp2_1
00405bb0          eax.w = (x87_r7_1 < temp2_1 ? 1 : 0) << 8
00405bb0              | (is_unordered.t(x87_r7_1, temp2_1) ? 1 : 0) << 0xa
00405bb0              | (x87_r7_1 == temp2_1 ? 1 : 0) << 0xe | 0x3800
00405bb0          
00405bb5          if ((eax:1.b & 0x41) == 0)
00405bb7              long double temp3_1 = fconvert.t(0.0001)
00405bb7              x87_r7_1 - temp3_1
00405bbd              eax.w = (x87_r7_1 < temp3_1 ? 1 : 0) << 8
00405bbd                  | (is_unordered.t(x87_r7_1, temp3_1) ? 1 : 0) << 0xa
00405bbd                  | (x87_r7_1 == temp3_1 ? 1 : 0) << 0xe
00405bbd              
00405bc2              if ((eax:1.b & 1) != 0)
00405bc7                  x87_r7_1 = fconvert.t(arg1[1]) - fconvert.t(ecx_1[1])
00405bca                  long double temp4_1 = fconvert.t(-0.0001)
00405bca                  x87_r7_1 - temp4_1
00405bd0                  eax.w = (x87_r7_1 < temp4_1 ? 1 : 0) << 8
00405bd0                      | (is_unordered.t(x87_r7_1, temp4_1) ? 1 : 0) << 0xa
00405bd0                      | (x87_r7_1 == temp4_1 ? 1 : 0) << 0xe | 0x3800
00405bd0                  
00405bd5                  if ((eax:1.b & 0x41) == 0)
00405bd7                      long double temp5_1 = fconvert.t(0.0001)
00405bd7                      x87_r7_1 - temp5_1
00405bdd                      eax.w = (x87_r7_1 < temp5_1 ? 1 : 0) << 8
00405bdd                          | (is_unordered.t(x87_r7_1, temp5_1) ? 1 : 0) << 0xa
00405bdd                          | (x87_r7_1 == temp5_1 ? 1 : 0) << 0xe
00405bdd                      
00405be2                      if ((eax:1.b & 1) != 0)
00405be7                          x87_r7_1 = fconvert.t(arg1[2]) - fconvert.t(ecx_1[2])
00405bea                          long double temp6_1 = fconvert.t(-0.0001)
00405bea                          x87_r7_1 - temp6_1
00405bf0                          eax.w = (x87_r7_1 < temp6_1 ? 1 : 0) << 8
00405bf0                              | (is_unordered.t(x87_r7_1, temp6_1) ? 1 : 0) << 0xa
00405bf0                              | (x87_r7_1 == temp6_1 ? 1 : 0) << 0xe | 0x3800
00405bf0                          
00405bf5                          if ((eax:1.b & 0x41) == 0)
00405bf7                              long double temp7_1 = fconvert.t(0.0001)
00405bf7                              x87_r7_1 - temp7_1
00405bfd                              eax.w = (x87_r7_1 < temp7_1 ? 1 : 0) << 8
00405bfd                                  | (is_unordered.t(x87_r7_1, temp7_1) ? 1 : 0) << 0xa
00405bfd                                  | (x87_r7_1 == temp7_1 ? 1 : 0) << 0xe

00405c0f                                               90                                                                 .

00405c10    void sub_405c10(float* arg1, float arg2, int32_t* arg3)

00405c1f  int32_t eax_1
00405c1f  int32_t edx
00405c1f  int16_t x87control
00405c1f  edx:eax_1 = sx.q(__ftol(x87control, fabs(fconvert.t(arg2))))
00405c1f  
00405c6c  for (int32_t i = 0xffffffff; i s<= 1; i += 1)
00405c48      for (int32_t j = *((((i + ((eax_1 + (edx & 7)) s>> 3 & 0x3ff)) & 0x3ff) << 2) +
00405c48              &data_27e2580); j s>= 0; j = *((j << 2) + &data_27a2540))
00405c51          int32_t eax_5
00405c51          int80_t st0_1
00405c51          st0_1, eax_5 = sub_405b70(arg1, arg2, j)
00405c51          
00405c5b          if (eax_5 != 0)
00405c7f              *arg3 = j
00405c84              return 

00405c85                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00405c90    int32_t sub_405c90(int32_t* arg1, float arg2, int32_t* arg3)

00405ca3  float var_28 = arg2
00405ca5  int32_t eax
00405ca5  int80_t st0
00405ca5  st0, eax = sub_405c10(arg1, var_28, arg3)
00405ca5  
00405caf  if (eax != 0)
00405cbc      return 1
00405cbc  
00405cbd  int32_t __saved_edi_4 = data_27e2548
00405cc3  int32_t eax_2 = data_2823594
00405cc3  
00405ccd  if (eax_2 s>= __saved_edi_4 - 1)
00405ccf      int32_t __saved_edi_1 = __saved_edi_4
00405cd0      var_28 = "AAS_MAX_PLANES = %d"
00405cd5      sub_40f970(var_28)
00405cda      eax_2 = data_2823594
00405cda  
00405ced  int32_t* __saved_edi_5 = data_2823598 + eax_2 * 0x14
00405cf0  float __saved_edi_2 = __saved_edi_5
00405cf1  *__saved_edi_5 = *arg1
00405cfa  __saved_edi_5[1] = arg1[1]
00405cfd  int32_t ecx_1 = arg1[2]
00405d00  __saved_edi_5[3] = arg2
00405d03  __saved_edi_5[2] = ecx_1
00405d06  int32_t eax_5 = sub_414710(__saved_edi_2)
00405d0b  __saved_edi_5[9] = eax_5
00405d0e  __saved_edi_5[4] = eax_5
00405d19  __saved_edi_5[5] = *arg1
00405d1e  long double x87_r7 = fconvert.t(__saved_edi_5[5])
00405d20  __saved_edi_5[6] = arg1[1]
00405d23  int32_t eax_7 = arg1[2]
00405d28  __saved_edi_5[5] = fconvert.s(fneg(x87_r7))
00405d2f  __saved_edi_5[6] = fconvert.s(fneg(fconvert.t(__saved_edi_5[6])))
00405d32  __saved_edi_5[7] = eax_7
00405d3a  __saved_edi_5[7] = fconvert.s(fneg(fconvert.t(__saved_edi_5[7])))
00405d43  __saved_edi_5[8] = fconvert.s(fneg(fconvert.t(arg2)))
00405d4f  data_2823594 += 2
00405d4f  
00405d5b  if (__saved_edi_5[4] s< 3)
00405d5d      long double x87_r7_8 = fconvert.t(*__saved_edi_5)
00405d5f      long double temp0_1 = fconvert.t(0f)
00405d5f      x87_r7_8 - temp0_1
00405d65      int32_t eax_8
00405d65      eax_8.w = (x87_r7_8 < temp0_1 ? 1 : 0) << 8
00405d65          | (is_unordered.t(x87_r7_8, temp0_1) ? 1 : 0) << 0xa
00405d65          | (x87_r7_8 == temp0_1 ? 1 : 0) << 0xe
00405d65      
00405d6a      if ((eax_8:1.b & 1) != 0)
00405d98          label_405d98:
00405d98          void var_14
00405d98          __builtin_memcpy(dest: &var_14, src: __saved_edi_5, n: 0x14)
00405da3          __builtin_memcpy(dest: __saved_edi_5, src: &__saved_edi_5[5], n: 0x14)
00405db0          __builtin_memcpy(dest: &__saved_edi_5[5], src: &var_14, n: 0x14)
00405dbb          *arg3 = data_2823594 - 1
00405dc5          return 0
00405dc5      
00405d6c      long double x87_r7_9 = fconvert.t(__saved_edi_5[1])
00405d6f      long double temp1_1 = fconvert.t(0f)
00405d6f      x87_r7_9 - temp1_1
00405d75      eax_8.w = (x87_r7_9 < temp1_1 ? 1 : 0) << 8
00405d75          | (is_unordered.t(x87_r7_9, temp1_1) ? 1 : 0) << 0xa
00405d75          | (x87_r7_9 == temp1_1 ? 1 : 0) << 0xe
00405d75      
00405d7a      if ((eax_8:1.b & 1) != 0)
00405d7a          goto label_405d98
00405d7a      
00405d7c      long double x87_r7_10 = fconvert.t(__saved_edi_5[2])
00405d7f      long double temp2_1 = fconvert.t(0f)
00405d7f      x87_r7_10 - temp2_1
00405d85      eax_8.w = (x87_r7_10 < temp2_1 ? 1 : 0) << 8
00405d85          | (is_unordered.t(x87_r7_10, temp2_1) ? 1 : 0) << 0xa
00405d85          | (x87_r7_10 == temp2_1 ? 1 : 0) << 0xe
00405d85      
00405d8a      if ((eax_8:1.b & 1) != 0)
00405d8a          goto label_405d98
00405d8a  
00405dcf  *arg3 = data_2823594 - 2
00405dd9  sub_405b30(data_2823594 - 1)
00405de7  var_28 = data_2823594 - 2
00405de8  sub_405b30(var_28)
00405df8  return 0

00405df9                                                                             90 90 90 90 90 90 90                           .......

00405e00    int32_t __convention("regparm") sub_405e00(int32_t arg1, int32_t arg2, int32_t arg3, int32_t* arg4, void* arg5, int32_t* arg6)

00405e00  int32_t var_4 = arg3
00405e01  int32_t eax = data_28235ac
00405e07  int32_t* i = nullptr
00405e07  
00405e0e  if (eax == 0)
00405e10      eax = 1
00405e15      data_28235ac = 1
00405e15  
00405e1a  int32_t ecx = data_27e2554
00405e1a  
00405e22  if (eax s>= ecx)
00405e24      int32_t var_18_1 = ecx
00405e2a      sub_40f970("AAS_MAX_FACES = %d")
00405e2f      eax = data_28235ac
00405e2f  
00405e40  int32_t* edi = data_28235b0 + eax * 0x18
00405e4d  sub_405c90(arg5, *(arg5 + 0xc), edi)
00405e56  edi[1] = 0
00405e59  int32_t eax_3 = data_28235a4
00405e5e  edi[4] = 0
00405e61  edi[3] = eax_3
00405e64  edi[5] = 0
00405e67  edi[2] = 0
00405e67  
00405e72  if (*arg4 s> 0)
00405e7b      arg5 = &arg4[1]
00405e7b      
00405f19      do
00405e7f          int32_t eax_5 = data_27e2550
00405e7f          
00405e8c          if (data_28235a4 s>= eax_5)
00405e8e              int32_t var_18_3 = eax_5
00405e94              sub_40f970("AAS_MAX_EDGEINDEXSIZE = %d")
00405e94          
00405ea4          int32_t temp1_1 = mods.dp.d(sx.q(i + 1), *arg4)
00405ead          int32_t* var_18_4 = &var_4
00405eb2          int32_t eax_8 = temp1_1 * 3
00405ebb          sub_405a10(eax_8, arg5, &arg4[eax_8 + 1], arg5, &arg4[eax_8 + 1])
00405ec0          int32_t eax_9 = var_4
00405ec0          
00405ec9          if (eax_9 == 0)
00405ef5              int32_t var_18_5 = temp1_1
00405ef6              int32_t* i_1 = i
00405ef7              int32_t var_20_2 = data_28235ac
00405efd              sub_410080("AAS_GetFace: face %d had degener…")
00405ec9          else
00405ed7              *(data_28235a8 + (data_28235a4 << 2)) = eax_9
00405ee1              data_28235a4 += 1
00405eeb              edi[2] += 1
00405eeb          
00405f09          i += 1
00405f15          arg5 += 0xc
00405f19      while (i s< *arg4)
00405f19  
00405f29  if (edi[2] s>= 1)
00405f6d      *arg6 = data_28235ac
00405f77      data_28235ac += 1
00405f7f      return 1
00405f7f  
00405f44  __builtin_memset(s: data_28235b0 + data_28235ac * 0x18, c: 0, n: 0x18)
00405f4b  int32_t var_18_6 = data_28235ac
00405f51  sub_410080("AAS_GetFace: face %d was tiny")
00405f60  return 0


00405f80    int32_t sub_405f80(int32_t arg1)

00405f8d  int32_t* edx = data_2823614 + arg1 * 0x14
00405f90  int32_t eax_1 = data_28235c4
00405f90  
00405f97  if (eax_1 == 0)
00405f99      eax_1 = 1
00405f99  
00405faf  int32_t* ecx_3 = data_28235c8 + eax_1 * 0x1c
00405fb2  data_28235c4 = eax_1 + 1
00405fbb  ecx_3[1] = edx[1]
00405fbe  int32_t result = edx[2]
00405fc1  ecx_3[2] = result
00405fc6  *ecx_3 = *edx
00405fc8  return result

00405fc9                             90 90 90 90 90 90 90                                                           .......

00405fd0    void sub_405fd0(int32_t arg1)

00405fd0  int32_t ecx_18 = data_282360c
00405ffe  int32_t* var_18_1
00405ffe  int32_t* ebx_1
00405ffe  int32_t i
00405ffe  
00405ffe  do
00405fe9      int32_t edx_2 = arg1 * 7
00405feb      i = *(ecx_18 + (edx_2 << 2) + 0x14)
00405ff1      ebx_1 = ecx_18 + (edx_2 << 2)
00405ff4      var_18_1 = ebx_1
00405ff4      
00405ff8      if (i == 0)
00405ff8          break
00405ff8      
00405ffa      arg1 = i
00405ffe  while (i != 0)
00405ffe  
00406003  if (ebx_1[4] != 0)
0040600a      sub_40f970("AAS_StoreArea: tried to store in…")
0040600a  
00406017  if (ebx_1[6] != 0)
00406021      return 
00406021  
00406022  int32_t eax_4 = data_28235bc
00406027  int32_t __saved_esi_3 = data_27e255c
00406027  
0040602f  if (eax_4 s>= __saved_esi_3)
00406031      int32_t __saved_esi_1 = __saved_esi_3
00406037      sub_40f970("AAS_MAX_AREAS = %d")
0040603c      eax_4 = data_28235bc
0040603c  
00406046  if (eax_4 == 0)
00406048      eax_4 = 1
0040604d      data_28235bc = 1
0040604d  
0040605e  int32_t* edi_2 = eax_4 * 0x30 + data_28235c0
00406061  *edi_2 = eax_4
00406063  edi_2[1] = 0
0040606e  edi_2[2] = data_28235b4
00406076  sub_4104f0(&edi_2[3], &edi_2[6])
0040607b  int32_t ecx_2 = *edi_2
0040607d  edi_2[0xb] = 0
00406080  edi_2[0xa] = 0
00406083  edi_2[9] = 0
00406086  int32_t* esi = ebx_1[1]
0040608e  ebx_1[6] = ecx_2
00406091  int32_t* var_1c = esi
00406091  
00406095  if (esi != 0)
004060ae      while (true)
004060ae          int32_t eax_7
004060ae          eax_7.b = esi[2] != *ebx_1
004060b3          int32_t eax_8 = esi[5]
004060bc          int32_t var_24
004060bc          void* ebp_2
004060bc          
004060bc          if (eax_8 != 0)
004060c0              var_24 = neg.d(eax_8)
004060c4              int32_t eax_10 = esi[5]
004060c4              
004060d1              if (eax_10 s< 0 || eax_10 s> data_27e2554)
004060d8                  sub_40f970("AAS_CreateTree_r: face number ou…")
004060d8              
004060ee              ebp_2 = data_28235b0 + esi[5] * 0x18
004060f1              *(ebp_2 + 0x14) = *edi_2
004060f4              goto label_406183
004060f4          
00406104          int32_t ecx_5 = (*esi ^ eax_7) * 7
00406108          void* ebp_3 = (ecx_5 << 2) + &data_239e0c0
0040610f          int32_t* var_14
0040610f          
0040610f          if (eax_7 != 0)
00406111              int32_t* eax_15 = esi[1]
00406115              var_14 = eax_15
00406119              int32_t* eax_16
00406119              eax_16, ecx_5 = sub_410e00(eax_15)
00406121              esi[1] = eax_16
00406121          
00406124          int32_t* eax_17 = esi[1]
0040612b          int32_t* var_38_2 = &var_24
0040612b          
0040613a          if (sub_405e00(eax_17, &var_24, ecx_5, eax_17, ebp_3, nullptr) != 0)
00406142              if (eax_7 != 0)
00406148                  sub_410740(esi[1])
00406154                  esi[1] = var_14
00406154              
00406166              ebp_2 = data_28235b0 + var_24 * 0x18
00406169              *(ebp_2 + 0x10) = *edi_2
0040616c              *(ebp_2 + 0x14) = 0
00406176              *(ebp_2 + 4) = esi[4]
0040617d              esi[5] = var_24
00406183              label_406183:
00406183              float var_4_1 = 0f
0040618d              float var_8_1 = 0f
00406195              float var_c_1 = 0f
0040619d              int32_t var_20_1 = 0
0040619d              
004061a5              if (*(ebp_2 + 8) s> 0)
004061ab                  int32_t ecx_9 = data_2823590
00406231                  bool cond:9_1
00406231                  
00406231                  do
004061bf                      int32_t i_2 = 2
004061c7                      int32_t eax_26
004061c7                      int32_t edx_10
004061c7                      edx_10:eax_26 =
004061c7                          sx.q(*(data_28235a8 + ((var_20_1 + *(ebp_2 + 0xc)) << 2)))
004061d2                      int32_t* esi_1 = data_28235a0 + (((eax_26 ^ edx_10) - edx_10) << 3)
00406221                      int32_t i_1
00406221                      
00406221                      do
004061e6                          sub_410520(ecx_9 + *esi_1 * 0xc, &edi_2[3], &edi_2[6])
004061ed                          ecx_9 = data_2823590
004061f7                          int32_t edx_12 = *esi_1 * 3
004061fd                          esi_1 = &esi_1[1]
00406200                          i_1 = i_2
00406200                          i_2 -= 1
00406204                          void* eax_34 = ecx_9 + (edx_12 << 2)
00406207                          var_c_1 = fconvert.s(fconvert.t(var_c_1)
00406207                              + fconvert.t(*(ecx_9 + (edx_12 << 2))))
00406212                          var_8_1 =
00406212                              fconvert.s(fconvert.t(var_8_1) + fconvert.t(*(eax_34 + 4)))
0040621d                          var_4_1 =
0040621d                              fconvert.s(fconvert.t(var_4_1) + fconvert.t(*(eax_34 + 8)))
00406221                      while (i_1 != 1)
0040622b                      cond:9_1 = var_20_1 + 1 s< *(ebp_2 + 8)
0040622d                      var_20_1 += 1
00406231                  while (cond:9_1)
0040623b                  esi = var_1c
0040623b              
0040623f              long double x87_r7_7 = float.t(*(ebp_2 + 8))
00406244              long double x87_r7_9 = fconvert.t(1.0) / (x87_r7_7 + x87_r7_7)
0040625a              float var_8_2 = fconvert.s(fconvert.t(var_8_1) * x87_r7_9)
00406269              edi_2[9] = fconvert.s(fconvert.t(fconvert.s(fconvert.t(var_c_1) * x87_r7_9))
00406269                  + fconvert.t(edi_2[9]))
00406273              edi_2[0xa] = fconvert.s(fconvert.t(var_8_2) + fconvert.t(edi_2[0xa]))
00406279              edi_2[0xb] =
00406279                  fconvert.s(x87_r7_9 * fconvert.t(var_4_1) + fconvert.t(edi_2[0xb]))
0040627c              int32_t eax_37 = data_27e2558
0040627c              
00406289              if (data_28235b4 s>= eax_37)
0040628b                  int32_t var_38_5 = eax_37
00406291                  sub_40f970("AAS_MAX_FACEINDEXSIZE = %d")
00406291              
004062a9              *(data_28235b8 + (data_28235b4 << 2)) = var_24
004062b3              data_28235b4 += 1
004062bd              edi_2[1] += 1
004062bd          
004062c0          int32_t* esi_2 = esi[eax_7 + 8]
004062c6          var_1c = esi_2
004062c6          
004062ca          if (esi_2 == 0)
004062ca              break
004062ca          
0040609d          esi = var_1c
004060a1          ebx_1 = var_18_1
004060a1  
004062d0  int32_t eax_41 = edi_2[1]
004062d0  
004062da  if (eax_41 == 0)
004062e2      return 
004062e2  
004062ec  long double x87_r7_13 = fconvert.t(1.0) / float.t(eax_41)
004062f7  edi_2[9] = fconvert.s(fconvert.t(edi_2[9]) * x87_r7_13)
004062ff  edi_2[0xa] = fconvert.s(fconvert.t(edi_2[0xa]) * x87_r7_13)
00406307  edi_2[0xb] = fconvert.s(fconvert.t(edi_2[0xb]) * x87_r7_13)
0040630c  sub_405f80(arg1)
00406313  int32_t var_38_6 = *edi_2
00406319  sub_40fa00("\r%6d")
0040632f  data_28235bc += 1

0040633c                                                                                      90 90 90 90                              ....

00406340    int32_t sub_406340(int32_t arg1)

00406346  if (arg1 == 0)
00406348      return arg1
00406348  
00406349  if (arg1 s< 0)
0040634e      int32_t eax_1
0040634e      int80_t st0
0040634e      st0, eax_1 = sub_405fd0(neg.d(arg1))
00406356      return eax_1
00406356  
00406363  int32_t* edi = data_282361c + arg1 * 0xc
00406366  int32_t eax_3 = data_28235d4
00406366  
0040636d  if (eax_3 == 0)
0040636f      eax_3 = 1
00406374      data_28235d4 = 1
00406374  
00406379  int32_t ecx_1 = data_27e2568
00406379  
00406381  if (eax_3 s>= ecx_1)
00406383      int32_t var_10_1 = ecx_1
00406389      sub_40f970("AAS_MAX_NODES = %d")
0040638e      eax_3 = data_28235d4
0040638e  
00406396  int32_t ecx_2 = data_28235d8
004063a2  data_28235d4 = eax_3 + 1
004063a9  int32_t* esi = ecx_2 + eax_3 * 0xc
004063b4  int32_t edx_2 = *edi * 7
004063c6  sub_405c90((edx_2 << 2) + &data_239e0c0, *((edx_2 << 2) + &data_239e0cc), esi)
004063d4  esi[1] = sub_406340(edi[1])
004063e3  esi[2] = sub_406340(edi[2])
004063eb  return eax_3

004063ec                                      90 90 90 90                                                              ....

004063f0    int32_t sub_4063f0()

004063f0  int32_t ecx = data_42b0c0
004063f6  int32_t __saved_esi_2 = data_27e2540
004063f6  
004063fd  if (ecx s> __saved_esi_2)
004063ff      int32_t __saved_esi_1 = __saved_esi_2
00406405      sub_40f970("more than %d bounding boxes")
0040640a      ecx = data_42b0c0
0040640a  
00406413  data_2823584 = ecx
0040641a  int32_t result = ecx << 5
0040642e  int32_t esi
0040642e  int32_t edi_1
0040642e  edi_1, esi = __builtin_memcpy(dest: data_2823588, src: 0x42b0c4, n: result u>> 2 << 2)
00406435  __builtin_memcpy(dest: edi_1, src: esi, n: result & 3)
00406439  return result

0040643a                                                                                90 90 90 90 90 90                            ......

00406440    int32_t* sub_406440(int32_t arg1)

00406440  sub_4053a0()
0040644a  sub_410080("AAS_StoreFile")
0040644f  sub_4063f0()
00406454  int32_t var_8 = 0
0040645b  sub_40fa00("%6d areas stored")
0040645b  
0040646d  if (sub_406340(1) != 1)
00406474      sub_410030("BUG: didn't end with root\n")
00406474  
00406482  sub_40fa00(&data_42b33c)
0040648c  int32_t var_c = data_28235bc
00406492  sub_410080("%6d areas stored")
00406492  
004064a6  if (sub_403420(arg1) == 0)
004064a8      int32_t var_8_1 = arg1
004064ae      sub_40f970("error writing %s\n")
004064ae  
004064bc  return sub_4056e0()

004064bd                                                                                         90 90 90                               ...

004064c0    int32_t sub_4064c0()

004064c7  data_279c388 = 0
004064d1  data_279c394 = 0
004064d6  __builtin_memset(s: &data_279c370, c: 0, n: 0x14)
004064db  data_279c364 = 0
004064e0  data_279c390 = 0
004064ef  return 0


004064f0    void sub_4064f0(void** arg1)

004064fc  for (void** i = arg1; i != 0; i = *i)
00406509      int32_t j = 0
00406509      
0040650d      if (i[0xa] s> 0)
0040650f          void* esi_1 = &i[0xd]
0040650f          
0040653e          do
00406512              int32_t eax_1 = *esi_1
00406512              
00406516              if (eax_1 != 0)
0040651c                  if (*(esi_1 - 4) == 0xffffffff)
0040651e                      int32_t var_14_1 = 1
0040651c                  else if ((*(esi_1 + 0x14) & 2) != 0)
0040652a                      int32_t var_14_3 = 0
00406525                  else
00406527                      int32_t var_14_2 = 2
00406527                  
0040652c                  int32_t var_18_1 = eax_1
0040652c              
00406538              j += 1
00406539              esi_1 += 0x20
0040653e          while (j s< i[0xa])


00406550    void sub_406550(void* arg1)

00406555  void* edi = arg1
00406559  void* ebp = edi + 0x10
00406561  sub_4104f0(edi + 4, ebp)
0040656e  int32_t var_4 = 0
0040656e  
00406576  if (*(edi + 0x28) s> 0)
0040657d      void* var_8_1 = edi + 0x34
004065cf      bool cond:1_1
004065cf      
004065cf      do
00406585          int32_t* ebx_1 = *var_8_1
00406585          
00406589          if (ebx_1 != 0)
0040658d              int32_t i = 0
0040658d              
00406591              if (*ebx_1 s> 0)
00406593                  void* edi_1 = &ebx_1[1]
00406593                  
004065b0                  do
004065a0                      sub_410520(edi_1, arg1 + 4, ebp)
004065aa                      i += 1
004065ab                      edi_1 += 0xc
004065b0                  while (i s< *ebx_1)
004065b0                  
004065b2                  edi = arg1
004065b2          
004065c5          cond:1_1 = var_4 + 1 s< *(edi + 0x28)
004065c7          var_4 += 1
004065cb          var_8_1 += 0x20
004065cf      while (cond:1_1)

004065d9                                                                             90 90 90 90 90 90 90                           .......

004065e0    int32_t sub_4065e0(void* arg1)

004065e0  int32_t ecx
004065e0  int32_t var_4_1 = ecx
004065e2  void* ebp = arg1
004065e6  int32_t var_4 = 0
004065e6  
004065f3  if (*(ebp + 0x28) s> 0)
004065fc      void* ebx_1 = ebp + 0x2c
00406692      bool cond:0_1
00406692      
00406692      do
00406608          int32_t ecx_2 = *ebx_1 * 7
0040661a          void* i =
0040661a              sub_410b70((ecx_2 << 2) + &data_239e0c0, *((ecx_2 << 2) + &data_239e0cc))
0040661a          int16_t top = top - 1
0040661a          unimplemented  {call sub_410b70}
0040661f          int32_t ecx_3 = *(ebp + 0x28)
00406625          int32_t edi_1 = 0
00406627          arg1 = i
00406627          
0040662d          if (ecx_3 s> 0)
0040662f              void* esi_1 = ebp + 0x2c
0040662f              
00406634              while (i != 0)
00406640                  if (var_4 != edi_1 && (*(esi_1 + 0x1c) & 4) == 0)
00406650                      int32_t ecx_5 = (*esi_1 ^ 1) * 7
00406667                      sub_4111c0(&arg1, (ecx_5 << 2) + &data_239e0c0, 
00406667                          *((ecx_5 << 2) + &data_239e0cc), 0f)
00406667                      top -= 1
00406667                      unimplemented  {call sub_4111c0}
0040666c                      i = arg1
0040666c                  
00406676                  edi_1 += 1
00406677                  esi_1 += 0x20
00406677                  
0040667c                  if (edi_1 s>= *(ebp + 0x28))
0040667c                      break
0040667c          
0040667e          *(ebx_1 + 8) = i
00406689          ebx_1 += 0x20
0040668c          cond:0_1 = var_4 + 1 s< *(ebp + 0x28)
0040668e          var_4 += 1
00406692      while (cond:0_1)
00406692  
0040669c  int32_t result = sub_406550(ebp)
0040669c  unimplemented  {call sub_406550}
004066a6  return result

004066a7                       90 90 90 90 90 90 90 90 90                                                         .........

004066b0    void* sub_4066b0(int32_t arg1, float arg2)

004066b9  void* result = sub_4068f0(6)
004066ca  *(result + 0x28) = 6
004066d1  void* edi = result + 0x8c
004066e2  float var_c
004066e2  void* ebx_1 = arg2 i- &var_c
004066e4  float* esi = &var_c
004066e8  void* ebp_1 = arg1 - &var_c
004066ea  arg1 = 3
0040675b  bool cond:0_1
0040675b  
0040675b  do
004066f9      int32_t var_4_1 = 0
00406709      int32_t var_8_1 = 0
00406711      float var_24_1 = fconvert.s(fconvert.t(*(ebx_1 + esi)))
00406712      var_c = 0f
0040671b      *esi = 1f
00406726      *(edi - 0x60) = sub_414ae0(&var_c)
00406732      arg2 = fconvert.s(fneg(fconvert.t(*(esi + ebp_1))))
0040673a      *esi = -1f
00406740      float var_2c_1 = arg2
00406747      *edi = sub_414ae0(&var_c)
00406750      esi = &esi[1]
00406753      edi += 0x20
00406756      cond:0_1 = arg1 != 1
00406757      arg1 -= 1
0040675b  while (cond:0_1)
00406762  sub_4065e0(result)
00406773  return result

00406774                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00406780    long double sub_406780(float arg1)

00406784  float ebx = arg1
00406784  
0040678b  if (ebx == 0)
00406798      return fconvert.t(0f)
00406798  
00406799  int32_t edx = *(ebx i+ 0x28)
0040679c  int32_t i = 0
0040679c  
004067a0  if (edx s> 0)
004067a2      void* ecx_1 = ebx i+ 0x34
004067a2      
004067b1      do
004067a5          void* eax_1 = *ecx_1
004067a5          
004067a9          if (eax_1 != 0)
004067bf              float ecx_2 = *(eax_1 + 4)
004067c8              float ecx_3 = *(eax_1 + 8)
004067cb              float eax_2 = *(eax_1 + 0xc)
004067d6              arg1 = 0f
004067d6              
004067de              if (i s< edx)
004067e6                  void* edi_1 = (i << 5) i+ ebx + 0x2c
004067e6                  
0040684a                  do
004067ea                      int32_t* ecx_6 = *(edi_1 + 8)
004067ea                      
004067ef                      if (ecx_6 != 0)
004067ff                          int32_t edx_2 = *edi_1 * 7
00406824                          long double x87_r7_7 = fconvert.t(eax_2)
00406824                              * fconvert.t(*((edx_2 << 2) + &data_239e0c8)) + fconvert.t(ecx_3)
00406824                              * fconvert.t(*((edx_2 << 2) + &data_239e0c4)) + fconvert.t(ecx_2)
00406824                              * fconvert.t(*((edx_2 << 2) + &data_239e0c0))
00406824                              - fconvert.t(*((edx_2 << 2) + &data_239e0cc))
0040683d                          arg1 = fconvert.s(
0040683d                              sub_410a50(ecx_6) * fconvert.t(fconvert.s(fneg(x87_r7_7)))
0040683d                              + fconvert.t(arg1))
0040683d                      
00406844                      i += 1
00406845                      edi_1 += 0x20
0040684a                  while (i s< *(ebx i+ 0x28))
0040684a              
0040685c              return fconvert.t(arg1) * fconvert.t(0.333333343f)
0040685c          
004067ab          i += 1
004067ac          ecx_1 += 0x20
004067b1      while (i s< edx)
004067b1  
004067be  return fconvert.t(0f)

0040685d                                                                                         90 90 90                               ...

00406860    int32_t sub_406860(int32_t* arg1)

00406860  int32_t* i = arg1
00406864  int32_t result = 0
00406864  
00406868  while (i != 0)
0040686a      i = *i
0040686c      result += 1
0040686c  
00406871  return result

00406872                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00406880    void* sub_406880()

00406884  void* s = sub_4105b0(0x78)
00406894  __builtin_memset(s, c: 0, n: 0x78)
0040689e  sub_4104f0(s + 0x60, s + 0x6c)
004068aa  return s

004068ab                                   90 90 90 90 90                                                             .....

004068b0    void* sub_4068b0()

004068b4  void* s = sub_4105b0(0x5c)
004068c4  __builtin_memset(s, c: 0, n: 0x5c)
004068c4  
004068d1  if (data_42db3c == 1)
004068d4      uint32_t eax_1 = sub_410560(s)
004068e4      data_279c378 += eax_1
004068e4  
004068ee  return s

004068ef                                               90                                                                 .

004068f0    void* sub_4068f0(int32_t arg1)

004068fe  void* s = sub_4105b0((arg1 << 5) + 0x2c)
0040691a  __builtin_memset(s: __builtin_memset(s, c: 0, n: ((arg1 << 5) + 0x2c) u>> 2 << 2), c: 0, 
0040691a      n: ((arg1 << 5) + 0x2c) & 3)
0040691a  
00406923  if (data_42db3c == 1)
0040692c      data_279c37c += 1
00406931      uint32_t eax_2 = sub_410560(s)
0040693f      int32_t ecx_5 = data_279c364 + eax_2
00406946      bool cond:0_1 = ecx_5 s<= data_279c390
00406948      data_279c364 = ecx_5
00406948      
0040694e      if (not(cond:0_1))
00406950          data_279c390 = ecx_5
00406950  
0040695b  return s

0040695c                                                                                      90 90 90 90                              ....

00406960    int32_t sub_406960(void* arg1)

00406966  int32_t i = 0
00406966  
0040696d  if (*(arg1 + 0x28) s> 0)
00406970      void* esi_1 = arg1 + 0x34
00406970      
0040698b      do
00406973          int32_t* eax_1 = *esi_1
00406973          
00406977          if (eax_1 != 0)
0040697a              sub_410740(eax_1)
0040697a          
00406985          i += 1
00406986          esi_1 += 0x20
0040698b      while (i s< *(arg1 + 0x28))
0040698b  
00406995  if (data_42db3c == 1)
0040699f      data_279c37c -= 1
004069a5      uint32_t eax_3 = sub_410560(arg1)
004069aa      int32_t ecx_1 = data_279c364
004069b5      data_279c364 = ecx_1 - eax_3
004069b5      
004069bb      if (ecx_1 - eax_3 s< 0)
004069bd          data_279c364 = 0
004069bd  
004069d2  return sub_41e29e(arg1)

004069d3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

004069e0    int32_t* sub_4069e0(int32_t* arg1)

004069e0  int32_t* result = arg1
004069e0  
004069e6  if (result != 0)
004069f8      int32_t* i
004069f8      
004069f8      do
004069e9          i = *result
004069ec          sub_406960(result)
004069f4          result = i
004069f8      while (i != 0)
004069f8  
004069fb  return result

004069fc                                                                                      90 90 90 90                              ....

00406a00    void* sub_406a00(void* arg1)

00406a07  int32_t eax = *(arg1 + 0x28)
00406a14  void* result = sub_4068f0(eax)
00406a29  int32_t esi_4
00406a29  int32_t edi_1
00406a29  edi_1, esi_4 =
00406a29      __builtin_memcpy(dest: result, src: arg1, n: ((eax << 5) + 0x2c) u>> 2 << 2)
00406a30  __builtin_memcpy(dest: edi_1, src: esi_4, n: ((eax << 5) + 0x2c) & 3)
00406a35  int32_t i = 0
00406a35  
00406a39  if (*(arg1 + 0x28) s> 0)
00406a3d      void* esi_5 = arg1 + 0x34
00406a3d      
00406a65      do
00406a46          int32_t* eax_5 = *esi_5
00406a46          
00406a4a          if (eax_5 != 0)
00406a59              *(result - arg1 + esi_5) = sub_410dd0(eax_5)
00406a59          
00406a5f          i += 1
00406a60          esi_5 += 0x20
00406a65      while (i s< *(arg1 + 0x28))
00406a65  
00406a6d  return result

00406a6e                                            90 90                                                                ..

00406a70    int32_t sub_406a70(float* arg1, float* arg2, float arg3)

00406a70  float* ecx = arg3
00406a74  int32_t edx = ecx[4]
00406a74  
00406a7a  if (edx s< 3)
00406a81      int32_t esi = 0
00406a83      long double x87_r7 = fconvert.t(arg2[edx])
00406a89      long double x87_r6_2 = fconvert.t(ecx[3]) + fconvert.t(0.001)
00406a8f      x87_r6_2 - x87_r7
00406a91      float* eax
00406a91      eax.w = (x87_r6_2 < x87_r7 ? 1 : 0) << 8
00406a91          | (is_unordered.t(x87_r6_2, x87_r7) ? 1 : 0) << 0xa
00406a91          | (x87_r6_2 == x87_r7 ? 1 : 0) << 0xe
00406a91      
00406a96      if ((eax:1.b & 1) != 0)
00406a98          esi = 1
00406a98      
00406aa1      long double x87_r7_1 = fconvert.t(arg1[edx])
00406aa7      long double x87_r6_4 = fconvert.t(ecx[3]) - fconvert.t(0.001)
00406aad      x87_r6_4 - x87_r7_1
00406aaf      float* eax_1
00406aaf      eax_1.w = (x87_r6_4 < x87_r7_1 ? 1 : 0) << 8
00406aaf          | (is_unordered.t(x87_r6_4, x87_r7_1) ? 1 : 0) << 0xa
00406aaf          | (x87_r6_4 == x87_r7_1 ? 1 : 0) << 0xe
00406aaf      
00406ab4      if ((eax_1:1.b & 0x41) != 0)
00406abc          return esi
00406abc      
00406ab6      return esi | 2
00406ab6  
00406abd  float* eax_3 = ecx[5]
00406ac3  long double x87_r7_13
00406ac3  float* edx_2
00406ac3  long double x87_r7_15
00406ac3  
00406ac3  if (eax_3 u> 7)
00406c1b      x87_r7_13 = fconvert.t(0f)
00406c21      arg3 = 0f
00406ac3  else
00406ac9      switch (eax_3)
00406ae6          case nullptr
00406aec              arg3 = fconvert.s(fconvert.t(arg2[1]) * fconvert.t(ecx[1])
00406aec                  + fconvert.t(arg2[2]) * fconvert.t(ecx[2])
00406aec                  + fconvert.t(*arg2) * fconvert.t(*ecx))
00406c17              x87_r7_13 = fconvert.t(arg1[1]) * fconvert.t(ecx[1])
00406c17                  + fconvert.t(arg1[2]) * fconvert.t(ecx[2])
00406c17                  + fconvert.t(*arg1) * fconvert.t(*ecx)
00406b11          case 1
00406b11              arg3 = fconvert.s(fconvert.t(arg2[1]) * fconvert.t(ecx[1])
00406b11                  + fconvert.t(arg2[2]) * fconvert.t(ecx[2])
00406b11                  + fconvert.t(*arg1) * fconvert.t(*ecx))
00406b27              x87_r7_13 = fconvert.t(arg1[1]) * fconvert.t(ecx[1])
00406b27                  + fconvert.t(arg1[2]) * fconvert.t(ecx[2])
00406b27                  + fconvert.t(*arg2) * fconvert.t(*ecx)
00406b2e          case 2
00406b2e              eax_3 = arg1
00406b32              edx_2 = arg2
00406b39              x87_r7_15 = fconvert.t(eax_3[1]) * fconvert.t(ecx[1])
00406b4a              label_406b4a:
00406b4a              arg3 = fconvert.s(x87_r7_15 + fconvert.t(edx_2[2]) * fconvert.t(ecx[2])
00406b4a                  + fconvert.t(*edx_2) * fconvert.t(*ecx))
00406c17              x87_r7_13 = fconvert.t(edx_2[1]) * fconvert.t(ecx[1])
00406c17                  + fconvert.t(eax_3[2]) * fconvert.t(ecx[2])
00406c17                  + fconvert.t(*eax_3) * fconvert.t(*ecx)
00406b56          case 3
00406b72              arg3 = fconvert.s(fconvert.t(arg1[1]) * fconvert.t(ecx[1])
00406b72                  + fconvert.t(arg2[2]) * fconvert.t(ecx[2])
00406b72                  + fconvert.t(*arg1) * fconvert.t(*ecx))
00406b88              x87_r7_13 = fconvert.t(arg2[1]) * fconvert.t(ecx[1])
00406b88                  + fconvert.t(arg1[2]) * fconvert.t(ecx[2])
00406b88                  + fconvert.t(*arg2) * fconvert.t(*ecx)
00406b8f          case 4
00406b72              arg3 = fconvert.s(fconvert.t(arg2[1]) * fconvert.t(ecx[1])
00406b72                  + fconvert.t(arg1[2]) * fconvert.t(ecx[2])
00406b72                  + fconvert.t(*arg2) * fconvert.t(*ecx))
00406b88              x87_r7_13 = fconvert.t(arg1[1]) * fconvert.t(ecx[1])
00406b88                  + fconvert.t(arg2[2]) * fconvert.t(ecx[2])
00406b88                  + fconvert.t(*arg1) * fconvert.t(*ecx)
00406b9f          case 5
00406b9f              eax_3 = arg2
00406ba3              edx_2 = arg1
00406baa              x87_r7_15 = fconvert.t(eax_3[1]) * fconvert.t(ecx[1])
00406bad              goto label_406b4a
00406bcb          case 6
00406bcb              arg3 = fconvert.s(fconvert.t(arg1[1]) * fconvert.t(ecx[1])
00406bcb                  + fconvert.t(arg1[2]) * fconvert.t(ecx[2])
00406bcb                  + fconvert.t(*arg2) * fconvert.t(*ecx))
00406be1              x87_r7_13 = fconvert.t(arg2[1]) * fconvert.t(ecx[1])
00406be1                  + fconvert.t(arg2[2]) * fconvert.t(ecx[2])
00406be1                  + fconvert.t(*arg1) * fconvert.t(*ecx)
00406bfb          case 7
00406c01              arg3 = fconvert.s(fconvert.t(arg1[1]) * fconvert.t(ecx[1])
00406c01                  + fconvert.t(arg1[2]) * fconvert.t(ecx[2])
00406c01                  + fconvert.t(*arg1) * fconvert.t(*ecx))
00406c17              x87_r7_13 = fconvert.t(arg2[1]) * fconvert.t(ecx[1])
00406c17                  + fconvert.t(arg2[2]) * fconvert.t(ecx[2])
00406c17                  + fconvert.t(*arg2) * fconvert.t(*ecx)
00406c2d  long double x87_r6_46 = fconvert.t(arg3) - fconvert.t(ecx[3])
00406c30  int32_t edx_5 = 0
00406c32  long double temp0 = fconvert.t(0.001)
00406c32  x87_r6_46 - temp0
00406c38  eax_3.w = (x87_r6_46 < temp0 ? 1 : 0) << 8
00406c38      | (is_unordered.t(x87_r6_46, temp0) ? 1 : 0) << 0xa
00406c38      | (x87_r6_46 == temp0 ? 1 : 0) << 0xe | 0x3800
00406c38  
00406c3d  if ((eax_3:1.b & 1) == 0)
00406c3f      edx_5 = 1
00406c3f  
00406c44  long double x87_r7_41 = x87_r7_13 - fconvert.t(ecx[3])
00406c47  long double temp1 = fconvert.t(0.001)
00406c47  x87_r7_41 - temp1
00406c4d  eax_3.w = (x87_r7_41 < temp1 ? 1 : 0) << 8
00406c4d      | (is_unordered.t(x87_r7_41, temp1) ? 1 : 0) << 0xa
00406c4d      | (x87_r7_41 == temp1 ? 1 : 0) << 0xe
00406c4d  
00406c52  if ((eax_3:1.b & 1) == 0)
00406c59      return edx_5
00406c59  
00406c54  return edx_5 | 2

00406c5a                                                                                8b ff                                        ..
00406c5c  uint32_t jump_table_406c5c[0x8] = 
00406c5c  {
00406c5c      [0x0] =  0x00406ad0
00406c60      [0x1] =  0x00406af5
00406c64      [0x2] =  0x00406b2e
00406c68      [0x3] =  0x00406b56
00406c6c      [0x4] =  0x00406b8f
00406c70      [0x5] =  0x00406b9f
00406c74      [0x6] =  0x00406baf
00406c78      [0x7] =  0x00406be5
00406c7c  }

00406c7c                                                                                      90 90 90 90                              ....

00406c80    void sub_406c80(void* arg1, float arg2, int32_t* arg3, int32_t* arg4, int32_t* arg5)

00406c8b  float edi = arg2
00406c93  *arg3 = 0
00406ca0  int32_t edx_1 = edi i* 7
00406ca2  *arg4 = 0
00406ca8  int32_t ecx_1 = *((edx_1 << 2) + &data_239e0d0)
00406caf  void* ebx = (edx_1 << 2) + &data_239e0c0
00406cbd  int32_t var_8
00406cbd  void* esi
00406cbd  
00406cbd  if (ecx_1 s>= 3)
00406d4c      esi = arg1
00406d53      label_406d53:
00406d53      int32_t i = 0
00406d53      
00406d57      if (*(esi + 0x28) s> 0)
00406d59          void* ebx_1 = esi + 0x2c
00406d59          
00406d93          do
00406d5c              int32_t esi_1 = *ebx_1
00406d5c              
00406d64              if (esi_1 s>= 0x10000)
00406d6b                  sub_40f970("bad planenum")
00406d6b              
00406d75              if (esi_1 == edi)
00406f16                  return 
00406f16              
00406d82              if (esi_1 == (edi ^ 1))
00406f23                  return 
00406f23              
00406d8c              i += 1
00406d8d              ebx_1 += 0x20
00406d93          while (i s< *(arg1 + 0x28))
00406d93          
00406d99          esi = arg1
00406d99      
00406da4      int32_t eax_6 = sub_406a70(esi + 4, esi + 0x10, ebx)
00406daf      var_8 = eax_6
00406daf      
00406db3      if (eax_6 == 3)
00406db3          goto label_406dbc
00406db3      
00406db3      return 
00406db3  
00406cc6  esi = arg1
00406cca  arg2 = *(ebx + 0xc)
00406cd2  long double x87_r7_2 = fconvert.t(arg2) + fconvert.t(0.001)
00406cd8  long double x87_r6_1 = fconvert.t(*(esi + (ecx_1 << 2) + 4))
00406cde  x87_r7_2 - x87_r6_1
00406ce0  float eax_1
00406ce0  eax_1.w = (x87_r7_2 < x87_r6_1 ? 1 : 0) << 8
00406ce0      | (is_unordered.t(x87_r7_2, x87_r6_1) ? 1 : 0) << 0xa
00406ce0      | (x87_r7_2 == x87_r6_1 ? 1 : 0) << 0xe | 0x3800
00406ce0  
00406ce5  if ((eax_1:1.b & 1) != 0)
00406cf5      return 
00406cf5  
00406cfa  long double x87_r6_3 = fconvert.t(arg2) - fconvert.t(0.001)
00406d00  long double x87_r5_2 = fconvert.t(*(esi + (ecx_1 << 2) + 0x10))
00406d06  x87_r6_3 - x87_r5_2
00406d08  eax_1.w = (x87_r6_3 < x87_r5_2 ? 1 : 0) << 8
00406d08      | (is_unordered.t(x87_r6_3, x87_r5_2) ? 1 : 0) << 0xa
00406d08      | (x87_r6_3 == x87_r5_2 ? 1 : 0) << 0xe | 0x3000
00406d08  
00406d0d  if ((eax_1:1.b & 0x41) == 0)
00406d1f      return 
00406d1f  
00406d20  long double x87_r5_3 = fconvert.t(*(esi + (ecx_1 << 2) + 4))
00406d24  x87_r5_3 - x87_r6_3
00406d26  eax_1.w = (x87_r5_3 < x87_r6_3 ? 1 : 0) << 8
00406d26      | (is_unordered.t(x87_r5_3, x87_r6_3) ? 1 : 0) << 0xa
00406d26      | (x87_r5_3 == x87_r6_3 ? 1 : 0) << 0xe | 0x3000
00406d26  
00406d2d  if ((eax_1:1.b & 1) == 0)
00406d2d      goto label_406d53
00406d2d  
00406d2f  long double x87_r6_4 = fconvert.t(*(esi + (ecx_1 << 2) + 0x10))
00406d33  x87_r6_4 - x87_r6_3
00406d35  eax_1.w = (x87_r6_4 < x87_r6_3 ? 1 : 0) << 8
00406d35      | (is_unordered.t(x87_r6_4, x87_r6_3) ? 1 : 0) << 0xa
00406d35      | (x87_r6_4 == x87_r6_3 ? 1 : 0) << 0xe | 0x3800
00406d35  
00406d3c  if ((eax_1:1.b & 0x41) != 0)
00406d3c      goto label_406d53
00406d3c  
00406d3e  var_8 = 3
00406dbc  label_406dbc:
00406dbc  float var_c_1 = 0f
00406dc6  arg2 = 0f
00406dce  int32_t var_4_1 = 0
00406dce  
00406dd6  if (*(esi + 0x28) s> 0)
00406ddc      void* ebp_1 = esi + 0x48
00406eae      bool cond:5_1
00406eae      
00406eae      do
00406ded          if (*(ebp_1 - 0x18) != 0xffffffff && (*ebp_1 & 2) != 0)
00406df3              int32_t* eax_7 = *(ebp_1 - 0x14)
00406df3              
00406df8              if (eax_7 != 0)
00406dfe                  int32_t i_2 = *eax_7
00406e00                  int32_t edi_1 = 0
00406e02                  int32_t esi_2 = 0
00406e02                  
00406e06                  if (i_2 s> 0)
00406e0c                      void* ecx_5 = &eax_7[2]
00406e6c                      int32_t i_1
00406e6c                      
00406e6c                      do
00406e23                          long double x87_r7_9 = fconvert.t(*(ecx_5 - 4)) * fconvert.t(*ebx)
00406e23                              + fconvert.t(*(ecx_5 + 4)) * fconvert.t(*(ebx + 8))
00406e23                              + fconvert.t(*ecx_5) * fconvert.t(*(ebx + 4))
00406e23                              - fconvert.t(*(ebx + 0xc))
00406e26                          long double temp4_1 = fconvert.t(arg2)
00406e26                          x87_r7_9 - temp4_1
00406e2a                          eax_7.w = (x87_r7_9 < temp4_1 ? 1 : 0) << 8
00406e2a                              | (is_unordered.t(x87_r7_9, temp4_1) ? 1 : 0) << 0xa
00406e2a                              | (x87_r7_9 == temp4_1 ? 1 : 0) << 0xe | 0x3800
00406e2a                          
00406e2f                          if ((eax_7:1.b & 0x41) == 0)
00406e31                              arg2 = fconvert.s(x87_r7_9)
00406e31                          
00406e35                          long double temp5_1 = fconvert.t(var_c_1)
00406e35                          x87_r7_9 - temp5_1
00406e39                          eax_7.w = (x87_r7_9 < temp5_1 ? 1 : 0) << 8
00406e39                              | (is_unordered.t(x87_r7_9, temp5_1) ? 1 : 0) << 0xa
00406e39                              | (x87_r7_9 == temp5_1 ? 1 : 0) << 0xe | 0x3800
00406e39                          
00406e3e                          if ((eax_7:1.b & 1) != 0)
00406e40                              var_c_1 = fconvert.s(x87_r7_9)
00406e40                          
00406e44                          long double temp6_1 = fconvert.t(0.10000000000000001)
00406e44                          x87_r7_9 - temp6_1
00406e4a                          eax_7.w = (x87_r7_9 < temp6_1 ? 1 : 0) << 8
00406e4a                              | (is_unordered.t(x87_r7_9, temp6_1) ? 1 : 0) << 0xa
00406e4a                              | (x87_r7_9 == temp6_1 ? 1 : 0) << 0xe | 0x3800
00406e4a                          
00406e4f                          if ((eax_7:1.b & 0x41) == 0)
00406e51                              esi_2 = 1
00406e51                          
00406e56                          long double temp7_1 = fconvert.t(-0.10000000000000001)
00406e56                          x87_r7_9 - temp7_1
00406e5c                          eax_7.w = (x87_r7_9 < temp7_1 ? 1 : 0) << 8
00406e5c                              | (is_unordered.t(x87_r7_9, temp7_1) ? 1 : 0) << 0xa
00406e5c                              | (x87_r7_9 == temp7_1 ? 1 : 0) << 0xe
00406e5c                          
00406e61                          if ((eax_7:1.b & 1) != 0)
00406e63                              edi_1 = 1
00406e63                          
00406e68                          ecx_5 += 0xc
00406e6b                          i_1 = i_2
00406e6b                          i_2 -= 1
00406e6c                      while (i_1 != 1)
00406e6c                      
00406e7c                      if (esi_2 != 0 && edi_1 != 0 && ((*(ebp_1 - 4)).w:1.b & 2) == 0)
00406e85                          *arg3 += 1
00406e85                          
00406e8d                          if (((*(ebp_1 - 4)).w:1.b & 1) != 0)
00406e93                              *arg4 = 1
00406e93                  
00406e99                  esi = arg1
00406e99          
00406ea5          ebp_1 += 0x20
00406ea8          cond:5_1 = var_4_1 + 1 s< *(esi + 0x28)
00406eaa          var_4_1 += 1
00406eae      while (cond:5_1)
00406eae  
00406eb4  long double x87_r7_10 = fconvert.t(arg2)
00406eb8  long double temp0_1 = fconvert.t(0.0)
00406eb8  x87_r7_10 - temp0_1
00406ebe  int32_t eax_12
00406ebe  eax_12.w = (x87_r7_10 < temp0_1 ? 1 : 0) << 8
00406ebe      | (is_unordered.t(x87_r7_10, temp0_1) ? 1 : 0) << 0xa
00406ebe      | (x87_r7_10 == temp0_1 ? 1 : 0) << 0xe
00406ebe  
00406ec3  if ((eax_12:1.b & 0x41) != 0)
00406ed6      label_406ed6:
00406ed6      long double x87_r7_12 = fconvert.t(var_c_1)
00406eda      long double temp1_1 = fconvert.t(0.0)
00406eda      x87_r7_12 - temp1_1
00406ee0      eax_12.w = (x87_r7_12 < temp1_1 ? 1 : 0) << 8
00406ee0          | (is_unordered.t(x87_r7_12, temp1_1) ? 1 : 0) << 0xa
00406ee0          | (x87_r7_12 == temp1_1 ? 1 : 0) << 0xe
00406ee0      
00406ee5      if ((eax_12:1.b & 1) != 0)
00406ee7          long double x87_r7_13 = fconvert.t(var_c_1)
00406eeb          long double temp3_1 = fconvert.t(-1.0)
00406eeb          x87_r7_13 - temp3_1
00406ef1          eax_12.w = (x87_r7_13 < temp3_1 ? 1 : 0) << 8
00406ef1              | (is_unordered.t(x87_r7_13, temp3_1) ? 1 : 0) << 0xa
00406ef1              | (x87_r7_13 == temp3_1 ? 1 : 0) << 0xe
00406ef1          
00406ef6          if ((eax_12:1.b & 0x41) == 0)
00406efc              *arg5 += 1
00406ec3  else
00406ec5      long double x87_r7_11 = fconvert.t(arg2)
00406ec9      long double temp2_1 = fconvert.t(1.0)
00406ec9      x87_r7_11 - temp2_1
00406ecf      eax_12.w = (x87_r7_11 < temp2_1 ? 1 : 0) << 8
00406ecf          | (is_unordered.t(x87_r7_11, temp2_1) ? 1 : 0) << 0xa
00406ecf          | (x87_r7_11 == temp2_1 ? 1 : 0) << 0xe
00406ecf      
00406ed4      if ((eax_12:1.b & 1) == 0)
00406ed4          goto label_406ed6
00406ed4      
00406efc      *arg5 += 1

00406f24              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00406f30    int32_t sub_406f30(int32_t* arg1)

00406f3b  int32_t ebp = 0
00406f3d  int32_t ebx = 0
00406f3f  int32_t eax = *arg1
00406f3f  
00406f43  if (eax s> 0)
00406f45      void* esi_1 = &arg1[2]
00406f45      
00406fa4      do
00406f4b          int32_t eax_2
00406f4b          
00406f4b          if (ebx != eax - 1)
00406f51              eax_2 = ebx + 1
00406f4b          else
00406f4d              eax_2 = 0
00406f4d          
00406f54          int32_t ecx_1 = eax_2 * 3
00406f6a          float var_c = fconvert.s(fconvert.t(arg1[ecx_1 + 1]) - fconvert.t(*(esi_1 - 4)))
00406f73          float var_8_1 = fconvert.s(fconvert.t(arg1[ecx_1 + 2]) - fconvert.t(*esi_1))
00406f7d          float var_4_1 =
00406f7d              fconvert.s(fconvert.t(arg1[eax_2 * 3 + 3]) - fconvert.t(*(esi_1 + 4)))
00406f81          long double st0_1 = sub_410350(&var_c)
00406f86          long double temp0_1 = fconvert.t(0.20000000000000001)
00406f86          st0_1 - temp0_1
00406f86          
00406f94          if ((((st0_1 < temp0_1 ? 1 : 0) << 8
00406f94                  | (is_unordered.t(st0_1, temp0_1) ? 1 : 0) << 0xa
00406f94                  | (st0_1 == temp0_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0)
00406f96              ebp += 1
00406f96              
00406f9a              if (ebp == 3)
00406fbc                  return 0
00406fbc          
00406f9c          eax = *arg1
00406f9e          ebx += 1
00406f9f          esi_1 += 0xc
00406fa4      while (ebx s< eax)
00406fa4  
00406fb2  return 1

00406fbd                                                                                         90 90 90                               ...

00406fc0    int32_t sub_406fc0(int32_t* arg1)

00406fc7  int32_t ebx = *arg1
00406fc9  int32_t edi = 0
00406fc9  
00406fcd  if (ebx s> 0)
00406fcf      void* esi_1 = &arg1[1]
00406fcf      
00407003      do
00406fd2          int32_t i = 0
00406fd4          void* edx_1 = esi_1
00406fd4          
00406ffb          do
00406fd6              long double x87_r7_1 = fconvert.t(*edx_1)
00406fd8              long double temp0_1 = fconvert.t(-8000f)
00406fd8              x87_r7_1 - temp0_1
00406fde              int32_t* eax
00406fde              eax.w = (x87_r7_1 < temp0_1 ? 1 : 0) << 8
00406fde                  | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
00406fde                  | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe
00406fde              
00406fe3              if ((eax:1.b & 1) != 0)
00407013                  return 1
00407013              
00406fe5              long double x87_r7_2 = fconvert.t(*edx_1)
00406fe7              long double temp1_1 = fconvert.t(8000f)
00406fe7              x87_r7_2 - temp1_1
00406fed              eax.w = (x87_r7_2 < temp1_1 ? 1 : 0) << 8
00406fed                  | (is_unordered.t(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
00406fed                  | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe
00406fed              
00406ff2              if ((eax:1.b & 0x41) == 0)
00407013                  return 1
00407013              
00406ff4              i += 1
00406ff5              edx_1 += 4
00406ffb          while (i s< 3)
00406ffb          
00406ffd          edi += 1
00406ffe          esi_1 += 0xc
00407003      while (edi s< ebx)
00407003  
0040700a  return 0

00407014                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00407020    int32_t* sub_407020(int32_t* arg1, void** arg2)

0040702e  *arg1 = 0xffffffff
00407036  arg1[0xa] = 0
00407039  arg1[0xf] = 0
0040703c  void** i = arg2
0040703c  
0040703e  if (arg2 != 0)
00407076      do
00407043          int32_t ebx_1 = *(i[9] + 8)
00407043          
00407049          if ((ebx_1.b & 1) != 0)
0040704b              int32_t esi_1 = i[0xa]
0040704e              int32_t ecx_2 = 0
0040704e              
00407052              if (esi_1 s> 0)
00407054                  void* edi_1 = &i[0xc]
00407054                  
0040705a                  while (*edi_1 == 0xffffffff)
0040705c                      ecx_2 += 1
0040705d                      edi_1 += 0x20
0040705d                      
00407062                      if (ecx_2 s>= esi_1)
00407062                          break
00407062              
00407068              if (ecx_2 == esi_1)
0040707a                  arg1[0xf] = 1
0040707a                  break
0040707a          
0040706f          arg1[0xf] |= ebx_1
00407072          i = *i
00407076      while (i != 0)
00407076  
00407087  if (data_279c334 != 0)
0040708b      arg1[0x16] = 0
0040708e      arg1[0xf] = 0
00407091      void** i_1 = arg2
00407091      
00407093      if (arg2 != 0)
004070b5          do
0040709b              int32_t esi_4 = arg1[0xf]
004070a3              arg1[0x16] |= *(i_1[9] + 0xc)
004070ae              arg1[0xf] = esi_4 | *(i_1[9] + 8)
004070b1              i_1 = *i_1
004070b5          while (i_1 != 0)
004070b5      
004070b7      int32_t ecx_3 = arg1[0xf]
004070b7      
004070ca      if ((ecx_3.b & 1) != 0 && arg1[0x16] != data_42b164)
004070cf          arg1[0xf] = ecx_3 & 0xfffffffe
004070cf  
004070d3  arg1[0xe] = arg2
004070d9  return arg1

004070da                                                                                90 90 90 90 90 90                            ......

004070e0    void* sub_4070e0(int32_t arg1, void* arg2)

004070e0  void* result = arg2
004070e0  
004070ea  for (int32_t* i = *(result + 4); i != 0; i = i[1])
004070f3      if (*i == arg1)
004070fa          result = sub_40f970("Tried parent")
004070fa  
0040710b  return result

0040710c                                      90 90 90 90                                                              ....

00407110    int32_t sub_407110(void* arg1, void* arg2)

00407128  sub_4074d0(*(arg2 + 0x20), arg1, &arg2, &arg1)
0040712d  void* eax_1 = arg2
00407131  void* ecx_1 = arg1
0040713e  int32_t result
0040713e  
0040713e  if (eax_1 == 0 || ecx_1 == 0)
00407147      result = 0
0040713e  else
00407140      result = 1
00407140  
0040714b  if (eax_1 != 0)
0040714e      sub_406960(eax_1)
00407153      ecx_1 = arg1
00407153  
0040715c  if (ecx_1 != 0)
0040715f      sub_406960(ecx_1)
0040715f  
0040716a  return result

0040716b                                   90 90 90 90 90                                                             .....

00407170    void* sub_407170(void** arg1, void* arg2)

00407177  void* result = nullptr
00407179  int32_t i = 0
0040717b  int32_t var_18 = 0
00407183  void* result_1 = nullptr
00407187  int32_t var_14 = 0xfffe7961
0040718f  int32_t i_2 = 0
0040718f  
004073d0  do
00407193      void** esi_1 = arg1
00407199      void** var_24_1 = esi_1
00407199      
0040719d      if (esi_1 != 0)
004071a5          int32_t ecx_2 = i & 1
004071a8          int32_t var_4_1 = ecx_2
004071a8          
004071b4          while (true)
004071b4              if (ecx_2 == 0)
004071d4                  if ((*(esi_1[9] + 8) & 0x8000000) == 0)
004071dd                      label_4071dd:
004071dd                      int32_t var_10_1 = 0
004071dd                      
004071e7                      if (esi_1[0xa] s> 0)
004071ed                          void* ebx_1 = &esi_1[0x12]
004071f0                          void* var_34_1 = ebx_1
004071f0                          
004071fa                          while (true)
004071fa                              int32_t eax_3
004071fa                              eax_3.w = *ebx_1
004071fa                              
00407235                              if ((eax_3.b & 4) == 0 && *(ebx_1 - 0x14) != 0
00407235                                      && *(ebx_1 - 0x18) != 0xffffffff
00407235                                      && (eax_3.b & 1) == 0
00407235                                      && ((*(ebx_1 - 4)).w:1.b & 2) == 0
00407235                                      && ((eax_3.b & 2) != 0 || i s>= 2))
00407242                                  float edi_1 = *(ebx_1 - 0x1c) & 0xfffffffe
00407247                                  sub_4070e0(edi_1, arg2)
00407247                                  
00407258                                  if (sub_407110(edi_1, arg2) != 0)
0040725e                                      void** j = arg1
00407262                                      int32_t ebp_2 = 0
00407264                                      int32_t var_30_1 = 0
00407268                                      int32_t var_2c_1 = 0
0040726c                                      int32_t var_28_1 = 0
00407270                                      int32_t var_1c = 0
00407270                                      
004072f6                                      do
00407285                                          int32_t var_8
00407285                                          int32_t eax_5 =
00407285                                              sub_406c80(j, edi_1, &var_8, &var_18, &var_1c)
00407285                                          int16_t top = top - 1
00407285                                          unimplemented  {call sub_406c80}
00407290                                          int32_t eax_6 = var_8
0040729b                                          var_28_1 += eax_6
0040729b                                          
004072a4                                          if (eax_6 != 0 && (eax_5.b & 4) != 0)
004072ab                                              sub_40f970("PSIDE_FACING with splits")
004072ab                                          
004072b6                                          j[8] = eax_5
004072b6                                          
004072b9                                          if ((eax_5.b & 4) != 0)
004072be                                              ebp_2 += 1
004072bf                                              int32_t k = 0
004072bf                                              
004072c3                                              if (j[0xa] s> 0)
004072c5                                                  void* eax_8 = &j[0x12]
004072c5                                                  
004072de                                                  do
004072d0                                                      if ((*(eax_8 - 0x1c) & 0xfffffffe)
004072d0                                                              == edi_1)
004072d2                                                          *eax_8 |= 1
004072d2                                                      
004072d8                                                      k += 1
004072d9                                                      eax_8 += 0x20
004072de                                                  while (k s< j[0xa])
004072de                                          
004072e3                                          if ((eax_5.b & 1) != 0)
004072e5                                              var_30_1 += 1
004072e5                                          
004072ec                                          if ((eax_5.b & 2) != 0)
004072ee                                              var_2c_1 += 1
004072ee                                          
004072f2                                          j = *j
004072f6                                      while (j != 0)
004072f6                                      
00407306                                      int32_t eax_11
00407306                                      int32_t edx_5
00407306                                      edx_5:eax_11 = sx.q(var_30_1 - var_2c_1)
00407321                                      int32_t ecx_7 = (ebp_2 - var_28_1) * 5
00407321                                          - ((eax_11 ^ edx_5) - edx_5)
00407321                                      
0040732b                                      if (*(edi_1 i* 0x1c + &data_239e0d0) s< 3)
0040732d                                          ecx_7 += 5
0040732d                                      
00407330                                      int32_t edx_6 = var_1c
00407343                                      int32_t eax_21 =
00407343                                          ecx_7 + ((neg.d(edx_6) << 2) - edx_6) * 0xc8
00407343                                      
0040735b                                      if (var_18 != 0 && ((*(var_34_1 - 4)).w:1.b & 1) == 0)
0040735d                                          eax_21 = 0xff676981
0040735d                                      
00407366                                      if (eax_21 s> var_14)
0040736c                                          var_14 = eax_21
00407373                                          result_1 = var_34_1 - 0x1c
00407377                                          void** j_1 = arg1
00407377                                          
00407385                                          do
0040737e                                              j_1[7] = j_1[8]
00407381                                              j_1 = *j_1
00407385                                          while (j_1 != 0)
00407385                                      
00407387                                      ebx_1 = var_34_1
0040738b                                      esi_1 = var_24_1
0040738b                              
00407397                              ebx_1 += 0x20
0040739a                              bool cond:3_1 = var_10_1 + 1 s< esi_1[0xa]
0040739c                              var_10_1 += 1
004073a0                              var_34_1 = ebx_1
004073a0                              
004073a4                              if (not(cond:3_1))
004073a4                                  break
004073a4                              
004071f6                              i = i_2
004071f6                          
004073aa                          result = result_1
004073ae                          i = i_2
004073b2                          ecx_2 = var_4_1
004071b4              else if ((*(esi_1[9] + 8) & 0x8000000) != 0
004071b4                      && (ecx_2 != 0 || (*(esi_1[9] + 8) & 0x8000000) == 0))
004071c8                  goto label_4071dd
004071c8              
004073b6              void** eax_24 = *esi_1
004073ba              var_24_1 = eax_24
004073ba              
004073be              if (eax_24 == 0)
004073be                  break
004073be              
004071ae              esi_1 = var_24_1
004071ae          
004073c6          if (result != 0)
004073e7              if (i s> 1 && data_42db3c == 1)
004073e9                  data_279c388 += 1
004073e9              
004073f1              if (i s> 0)
004073f7                  *(arg2 + 0x24) = 1
004073f7              
004073f1              break
004073f1      
004073c8      i += 1
004073cc      i_2 = i
004073d0  while (i s< 4)
004073d0  
00407400  for (void** i_1 = arg1; i_1 != 0; i_1 = *i_1)
00407405      int32_t j_2 = 0
00407405      
00407409      if (i_1[0xa] s> 0)
0040740b          void* eax_26 = &i_1[0x12]
0040740b          
0040741c          do
0040740e              *eax_26 &= 0xfffe
00407416              j_2 += 1
00407417              eax_26 += 0x20
0040741c          while (j_2 s< i_1[0xa])
0040741c  
0040742d  return result

0040742e                                            90 90                                                                ..

00407430    void sub_407430(void* arg1, float* arg2)

00407430  int32_t ecx
00407430  int32_t var_4_1 = ecx
00407436  float var_4 = 0f
00407443  int32_t i_2 = *(arg1 + 0x28)
00407443  
00407448  if (i_2 s<= 0)
004074c2      return 
004074c2  
00407451  void* ebx = arg1 + 0x34
00407454  int32_t i_1 = i_2
004074b4  int32_t i
004074b4  
004074b4  do
00407456      int32_t* eax = *ebx
00407456      
0040745a      if (eax != 0)
0040745c          int32_t j_1 = *eax
0040745c          
00407460          if (j_1 s> 0)
00407462              void* ecx_2 = &eax[2]
004074ae              int32_t j
004074ae              
004074ae              do
00407479                  long double x87_r7_5 = fconvert.t(*(ecx_2 - 4)) * fconvert.t(*arg2)
00407479                      + fconvert.t(*(ecx_2 + 4)) * fconvert.t(arg2[2])
00407479                      + fconvert.t(*ecx_2) * fconvert.t(arg2[1]) - fconvert.t(arg2[3])
0040747c                  long double temp1_1 = fconvert.t(var_4)
0040747c                  x87_r7_5 - temp1_1
00407480                  eax.w = (x87_r7_5 < temp1_1 ? 1 : 0) << 8
00407480                      | (is_unordered.t(x87_r7_5, temp1_1) ? 1 : 0) << 0xa
00407480                      | (x87_r7_5 == temp1_1 ? 1 : 0) << 0xe | 0x3800
00407480                  
00407485                  if ((eax:1.b & 0x41) == 0)
00407487                      var_4 = fconvert.s(x87_r7_5)
00407487                  
00407490                  long double x87_r7_6 = fneg(x87_r7_5)
00407492                  long double temp2_1 = fconvert.t(var_4)
00407492                  x87_r7_6 - temp2_1
00407496                  eax.w = (x87_r7_6 < temp2_1 ? 1 : 0) << 8
00407496                      | (is_unordered.t(x87_r7_6, temp2_1) ? 1 : 0) << 0xa
00407496                      | (x87_r7_6 == temp2_1 ? 1 : 0) << 0xe | 0x3800
00407496                  
0040749b                  if ((eax:1.b & 0x41) == 0)
0040749d                      var_4 = fconvert.s(x87_r7_6)
0040749d                  
004074aa                  ecx_2 += 0xc
004074ad                  j = j_1
004074ad                  j_1 -= 1
004074ae              while (j != 1)
004074ae      
004074b0      ebx += 0x20
004074b3      i = i_1
004074b3      i_1 -= 1
004074b4  while (i != 1)

004074c3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

004074d0    int32_t* sub_4074d0(void* arg1, int32_t arg2, void** arg3, int32_t* arg4)

004074dd  void* ebp = arg1
004074e1  *arg4 = 0
004074ec  long double x87_r7 = fconvert.t(0f)
004074f9  *arg3 = 0
00407501  float eax_2 = *(ebp + 0x28)
00407505  float var_18 = 0f
0040750d  void* edi = arg2 * 0x1c + &data_239e0c0
00407516  void* var_14 = edi
0040751a  int32_t* var_20
0040751a  
0040751a  if (eax_2 s> 0)
00407520      void* esi_1 = ebp + 0x34
00407523      float i_7 = eax_2
004075a7      float i
004075a7      
004075a7      do
00407525          int32_t* ecx_1 = *esi_1
00407529          var_20 = ecx_1
00407529          
0040752d          if (ecx_1 != 0)
0040752f              eax_2 = *ecx_1
0040752f              
00407533              if (eax_2 s> 0)
00407535                  void* ecx_2 = &ecx_1[2]
00407538                  float j_2 = eax_2
004075a1                  float j
004075a1                  
004075a1                  do
0040754e                      long double x87_r6_5 = fconvert.t(*(ecx_2 - 4)) * fconvert.t(*edi)
0040754e                          + fconvert.t(*(ecx_2 + 4)) * fconvert.t(*(edi + 8))
0040754e                          + fconvert.t(*ecx_2) * fconvert.t(*(edi + 4))
0040754e                          - fconvert.t(*(edi + 0xc))
00407551                      float var_1c_1 = fconvert.s(x87_r6_5)
00407555                      long double temp3_1 = fconvert.t(0f)
00407555                      x87_r6_5 - temp3_1
0040755b                      eax_2.w = (x87_r6_5 < temp3_1 ? 1 : 0) << 8
0040755b                          | (is_unordered.t(x87_r6_5, temp3_1) ? 1 : 0) << 0xa
0040755b                          | (x87_r6_5 == temp3_1 ? 1 : 0) << 0xe | 0x3800
0040755b                      
00407560                      if ((eax_2:1.b & 0x41) == 0)
00407562                          long double x87_r6_6 = fconvert.t(var_1c_1)
00407566                          x87_r6_6 - x87_r7
00407568                          eax_2.w = (x87_r6_6 < x87_r7 ? 1 : 0) << 8
00407568                              | (is_unordered.t(x87_r6_6, x87_r7) ? 1 : 0) << 0xa
00407568                              | (x87_r6_6 == x87_r7 ? 1 : 0) << 0xe | 0x3800
00407568                          
0040756d                          if ((eax_2:1.b & 0x41) == 0)
00407571                              x87_r7 = fconvert.t(var_1c_1)
00407571                      
00407575                      long double x87_r6_7 = fconvert.t(var_1c_1)
00407579                      long double temp4_1 = fconvert.t(0f)
00407579                      x87_r6_7 - temp4_1
0040757f                      eax_2.w = (x87_r6_7 < temp4_1 ? 1 : 0) << 8
0040757f                          | (is_unordered.t(x87_r6_7, temp4_1) ? 1 : 0) << 0xa
0040757f                          | (x87_r6_7 == temp4_1 ? 1 : 0) << 0xe | 0x3800
0040757f                      
00407584                      if ((eax_2:1.b & 1) != 0)
00407586                          long double x87_r6_8 = fconvert.t(var_1c_1)
0040758a                          long double temp6_1 = fconvert.t(var_18)
0040758a                          x87_r6_8 - temp6_1
0040758e                          eax_2.w = (x87_r6_8 < temp6_1 ? 1 : 0) << 8
0040758e                              | (is_unordered.t(x87_r6_8, temp6_1) ? 1 : 0) << 0xa
0040758e                              | (x87_r6_8 == temp6_1 ? 1 : 0) << 0xe | 0x3800
0040758e                          
00407593                          if ((eax_2:1.b & 1) != 0)
00407599                              var_18 = var_1c_1
00407599                      
0040759d                      ecx_2 += 0xc
004075a0                      j = j_2
004075a0                      j_2 -= 1
004075a1                  while (j != 1)
004075a1          
004075a3          esi_1 += 0x20
004075a6          i = i_7
004075a6          i_7 -= 1
004075a7      while (i != 1)
004075a7  
004075ad  long double temp0 = fconvert.t(0.20000000000000001)
004075ad  x87_r7 - temp0
004075b3  eax_2.w = (x87_r7 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7, temp0) ? 1 : 0) << 0xa
004075b3      | (x87_r7 == temp0 ? 1 : 0) << 0xe
004075b3  
004075b8  if ((eax_2:1.b & 1) != 0)
004075bb      void* eax_3 = sub_406a00(ebp)
004075ca      *arg4 = eax_3
004075d0      return eax_3
004075d0  
004075d1  long double x87_r7_1 = fconvert.t(var_18)
004075d5  long double temp1 = fconvert.t(-0.20000000000000001)
004075d5  x87_r7_1 - temp1
004075db  eax_2.w = (x87_r7_1 < temp1 ? 1 : 0) << 8
004075db      | (is_unordered.t(x87_r7_1, temp1) ? 1 : 0) << 0xa
004075db      | (x87_r7_1 == temp1 ? 1 : 0) << 0xe
004075db  
004075e0  if ((eax_2:1.b & 0x41) == 0)
004075e3      void* eax_4 = sub_406a00(ebp)
004075f2      *arg3 = eax_4
004075f8      return eax_4
004075f8  
004075fe  int32_t* eax_6
004075fe  int80_t st0
004075fe  st0, eax_6 = sub_410b70(edi, *(edi + 0xc))
004075fe  int16_t top = 0xffff
00407603  int32_t ecx_4 = *(ebp + 0x28)
00407609  int32_t i_1 = 0
0040760b  var_20 = eax_6
0040760b  
00407611  if (ecx_4 s> 0)
00407613      void* ebx_1 = ebp + 0x2c
00407613      
00407658      do
00407618          if (eax_6 == 0)
00407618              goto label_407901
00407618          
0040762c          int32_t ecx_6 = (*ebx_1 ^ 1) * 7
00407643          sub_4111c0(&var_20, (ecx_6 << 2) + &data_239e0c0, 
00407643              *((ecx_6 << 2) + &data_239e0cc), 0f)
00407643          top -= 1
00407643          unimplemented  {call sub_4111c0}
0040764e          i_1 += 1
0040764f          ebx_1 += 0x20
00407654          eax_6 = var_20
00407658      while (i_1 s< *(ebp + 0x28))
00407658  
0040765c  int32_t eax_11
0040765c  
0040765c  if (eax_6 != 0)
00407663      eax_11 = sub_406f30(eax_6)
00407663  
0040766d  void* eax_36
0040766d  
0040766d  if (eax_6 == 0 || eax_11 != 0)
00407901      label_407901:
00407901      eax_36 = sub_407430(ebp, edi)
00407901      unimplemented  {call sub_407430}
00407901      
0040790c      if (eax_36 == 1)
0040790f          void* eax_38 = sub_406a00(ebp)
0040791e          *arg3 = eax_38
00407924          return eax_38
00407924      
00407928      if (eax_36 == 2)
0040792b          eax_36 = sub_406a00(ebp)
00407937          *arg4 = eax_36
0040766d  else
00407682      if (sub_406fc0(var_20) != 0)
00407689          sub_410080("WARNING: huge winding\n")
00407689      
00407691      int32_t* edx_4 = var_20
00407695      void* var_10
00407695      void** esi_2 = &var_10
0040769d      int32_t i_8 = 2
004076bb      int32_t i_2
004076bb      
004076bb      do
004076a7          void* eax_15 = sub_4068f0(*(ebp + 0x28) + 1)
004076ac          int32_t ecx_8 = *(ebp + 0x24)
004076af          *esi_2 = eax_15
004076b4          esi_2 = &esi_2[1]
004076b7          i_2 = i_8
004076b7          i_8 -= 1
004076b8          *(eax_15 + 0x24) = ecx_8
004076bb      while (i_2 != 1)
004076c0      int32_t i_6 = 0
004076c0      
004076ca      if (*(ebp + 0x28) s> 0)
004076d0          void* ebp_1 = ebp + 0x2c
0040774f          int32_t i_3
0040774f          
0040774f          do
004076d3              int32_t* eax_17 = *(ebp_1 + 8)
004076d8              var_20 = eax_17
004076d8              
004076dc              if (eax_17 != 0)
004076f0                  void var_8
004076f0                  void var_4
004076f0                  sub_410e60(eax_17, edi, *(edi + 0xc), 0f, &var_8, &var_4)
004076f0                  top -= 1
004076f0                  unimplemented  {call sub_410e60}
004076f0                  
00407738                  for (int32_t j_1 = 0; j_1 s< 8; j_1 += 4)
00407700                      if (*(&var_8 + j_1) != 0)
00407702                          void* ecx_9 = *(&var_10 + j_1)
00407708                          int32_t edx_6 = *(ecx_9 + 0x28)
00407715                          *(ecx_9 + 0x28) = edx_6 + 1
0040771f                          __builtin_memcpy(dest: (edx_6 << 5) + ecx_9 + 0x2c, src: ebp_1, 
0040771f                              n: 0x20)
00407721                          int32_t ecx_10 = *(&var_8 + j_1)
00407725                          *((edx_6 << 5) + ecx_9 + 0x48) &= 0xfffe
0040772b                          edi = var_14
0040772f                          *((edx_6 << 5) + ecx_9 + 0x34) = ecx_10
0040772f              
00407742              i_3 = i_6 + 1
00407743              ebp_1 += 0x20
00407749              i_6 = i_3
0040774f          while (i_3 s< *(arg1 + 0x28))
00407751          ebp = arg1
00407751      
00407753      void** edi_2 = &var_10
00407757      arg1 = 2
00407757      
0040775f      while (true)
0040775f          void* ebx_2 = *edi_2
00407762          sub_406550(ebx_2)
00407762          unimplemented  {call sub_406550}
0040776a          int32_t esi_4 = 0
0040776c          void* ecx_12 = ebx_2 + 0x10
0040776c          
0040776f          while (true)
0040776f              unimplemented  {fld st0, dword [ecx-0xc]}
00407772              long double temp8_1 = fconvert.t(-5000f)
00407772              unimplemented  {fcomp st0, dword [&data_4291ac]} f- temp8_1
00407772              bool c0_7 = unimplemented  {fcomp st0, dword [&data_4291ac]} f< temp8_1
00407772              bool c2_7 =
00407772                  is_unordered.t(unimplemented  {fcomp st0, dword [&data_4291ac]}, temp8_1)
00407772              bool c3_7 = unimplemented  {fcomp st0, dword [&data_4291ac]} f== temp8_1
00407772              unimplemented  {fcomp st0, dword [&data_4291ac]}
00407772              
0040777d              if ((((c0_7 ? 1 : 0) << 8 | (c2_7 ? 1 : 0) << 0xa | (c3_7 ? 1 : 0) << 0xe
0040777d                      | (top & 7) << 0xb):1.b & 1) == 0)
0040777f                  unimplemented  {fld st0, dword [ecx]}
00407781                  long double temp9_1 = fconvert.t(5000f)
00407781                  unimplemented  {fcomp st0, dword [&data_4291a8]} f- temp9_1
00407781                  bool c0_8 = unimplemented  {fcomp st0, dword [&data_4291a8]} f< temp9_1
00407781                  bool c2_8 = is_unordered.t(
00407781                      unimplemented  {fcomp st0, dword [&data_4291a8]}, temp9_1)
00407781                  bool c3_8 = unimplemented  {fcomp st0, dword [&data_4291a8]} f== temp9_1
00407781                  unimplemented  {fcomp st0, dword [&data_4291a8]}
00407781                  
0040778c                  if ((((c0_8 ? 1 : 0) << 8 | (c2_8 ? 1 : 0) << 0xa | (c3_8 ? 1 : 0) << 0xe
0040778c                          | (top & 7) << 0xb):1.b & 0x41) != 0)
0040778e                      esi_4 += 1
0040778f                      ecx_12 += 4
0040778f                      
00407795                      if (esi_4 s>= 3)
00407795                          break
00407795                      
00407795                      continue
00407795              
0040779e              sub_410080("bogus brush after clip")
004077a3              break
004077a3          
004077af          if (*(ebx_2 + 0x28) s< 3 || esi_4 s< 3)
004077b2              sub_406960(ebx_2)
004077ba              *edi_2 = nullptr
004077ba          
004077c4          edi_2 = &edi_2[1]
004077c7          bool cond:5_1 = arg1 != 1
004077c8          arg1 -= 1
004077c8          
004077cc          if (not(cond:5_1))
004077cc              break
004077cc      
004077ce      void* edi_3 = var_10
004077d4      void* esi_5
004077d4      void* var_c
004077d4      
004077d4      if (edi_3 == 0)
0040789d          if (var_c == 0)
004078b3              return sub_410080("split removed brush")
004078b3          
004078b4          esi_5 = var_c
004077d4      else
004077da          esi_5 = var_c
004077da          
004077e0          if (esi_5 != 0)
00407839              for (int32_t i_4 = 0; i_4 s< 2; i_4 += 1)
004077f0                  void* eax_26 = (&var_10)[i_4]
004077f4                  int32_t ecx_13 = *(eax_26 + 0x28)
00407801                  *(eax_26 + 0x28) = ecx_13 + 1
0040780a                  *((ecx_13 << 5) + eax_26 + 0x48) &= 0xfffc
00407813                  *((ecx_13 << 5) + eax_26 + 0x30) = 0xffffffff
00407818                  *((ecx_13 << 5) + eax_26 + 0x2c) = i_4 ^ arg2 ^ 1
00407818                  
0040781a                  if (i_4 != 0)
00407832                      *((ecx_13 << 5) + eax_26 + 0x34) = edx_4
0040781a                  else
00407829                      *((ecx_13 << 5) + eax_26 + 0x34) = sub_410dd0(edx_4)
00407829              
0040783b              void** esi_7 = &var_10
0040783f              int32_t i_9 = 2
00407879              int32_t i_5
00407879              
00407879              do
00407844                  void* edi_4 = *esi_7
00407847                  sub_406780(edi_4)
00407847                  unimplemented  {call sub_406780}
0040784c                  long double temp11_1 = fconvert.t(1.0)
0040784c                  unimplemented  {fcomp st0, qword [&data_429170]} f- temp11_1
0040784c                  bool c0_9 = unimplemented  {fcomp st0, qword [&data_429170]} f< temp11_1
0040784c                  bool c2_9 = is_unordered.t(
0040784c                      unimplemented  {fcomp st0, qword [&data_429170]}, temp11_1)
0040784c                  bool c3_9 = unimplemented  {fcomp st0, qword [&data_429170]} f== temp11_1
0040784c                  unimplemented  {fcomp st0, qword [&data_429170]}
0040784c                  
0040785a                  if ((((c0_9 ? 1 : 0) << 8 | (c2_9 ? 1 : 0) << 0xa | (c3_9 ? 1 : 0) << 0xe
0040785a                          | (top & 7) << 0xb):1.b & 1) != 0)
0040785d                      sub_406960(edi_4)
00407867                      *esi_7 = nullptr
0040786d                      sub_410080("tiny volume after clip")
0040786d                  
00407875                  esi_7 = &esi_7[1]
00407878                  i_5 = i_9
00407878                  i_9 -= 1
00407879              while (i_5 != 1)
00407888              *arg3 = var_10
00407890              *arg4 = var_c
00407896              return var_c
004078bd      eax_36 = sub_410080("split not on both sides")
004078bd      
004078c7      if (edi_3 != 0)
004078ca          sub_406960(edi_3)
004078d0          eax_36 = sub_406a00(ebp)
004078dc          *arg3 = eax_36
004078dc      
004078e0      if (esi_5 != 0)
004078e3          sub_406960(esi_5)
004078e9          void* eax_37 = sub_406a00(ebp)
004078f8          *arg4 = eax_37
004078fe          return eax_37
004078fe  
00407940  return eax_36

00407941     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00407950    int32_t* __convention("regparm") sub_407950(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t* arg4, int32_t* arg5, int32_t* arg6)

00407950  int32_t* result_1 = arg3
00407951  int32_t* result_2
00407951  int32_t* result = result_2
00407956  int32_t* ebp = arg5
0040795c  int32_t* edi = arg6
00407962  *edi = 0
00407968  *ebp = 0
0040796f  void** i = result
0040796f  
00407971  if (result != 0)
00407a32      do
00407978          int32_t ebx_1 = i[7]
00407978          
0040797e          if (ebx_1 != 3)
004079c1              result = sub_406a00(i)
004079c9              result_2 = result
004079c9              
004079d0              if ((ebx_1.b & 4) != 0)
004079d5                  int32_t j = 0
004079d5                  
004079d9                  if (result[0xa] s> 0)
004079db                      int32_t ecx_3 = 0
004079db                      
00407a02                      do
004079eb                          if ((*(ecx_3 + result + 0x2c) & 0xfffffffe) == *arg4)
004079ed                              *(ecx_3 + result + 0x30) = 0xffffffff
004079f5                              result = result_2
004079f5                          
004079fc                          j += 1
004079fd                          ecx_3 += 0x20
00407a02                      while (j s< result[0xa])
00407a02                      
00407a04                      ebp = arg5
00407a08                      edi = arg6
00407a08              
00407a0f              if ((ebx_1.b & 1) != 0)
00407a14                  *result = *ebp
00407a1a                  *ebp = result_2
00407a0f              else if ((ebx_1.b & 2) != 0)
00407a26                  *result = *edi
00407a2c                  *edi = result_2
0040797e          else
00407992              sub_4074d0(i, *arg4, &result_2, &result_1)
00407997              int32_t* result_3 = result_2
00407997              
004079a0              if (result_3 != 0)
004079a5                  *result_3 = *ebp
004079ab                  *ebp = result_2
004079ab              
004079ae              result = result_1
004079ae              
004079b4              if (result != 0)
004079b8                  *result = *edi
00407a2c                  *edi = result_1
00407a2c          
00407a2e          i = *i
00407a32      while (i != 0)
00407a32  
00407a3d  return result

00407a3e                                                                                            90 90                                ..

00407a40    int32_t sub_407a40(void* arg1)

00407a40  sub_414240()
00407a4f  *(arg1 + 0x54) = data_279c36c
00407a58  bool cond:0 = data_279c384 != 0
00407a5a  data_279c36c = arg1
00407a5a  
00407a5f  if (not(cond:0))
00407a61      data_279c384 = arg1
00407a61  
00407a66  data_279c368 += 1
00407a6c  return sub_414290() __tailcall

00407a71                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00407a80    int32_t sub_407a80(void* arg1)

00407a80  sub_414240()
00407a89  *(arg1 + 0x54) = 0
00407a90  void* ecx = data_279c384
00407a90  
00407a98  if (ecx == 0)
00407a9f      data_279c36c = arg1
00407a98  else
00407a9a      *(ecx + 0x54) = arg1
00407a9a  
00407aa4  data_279c384 = arg1
00407aaf  data_279c368 += 1
00407ab4  return sub_414290() __tailcall

00407ab9                                                                             90 90 90 90 90 90 90                           .......

00407ac0    void* sub_407ac0()

00407ac1  sub_414240()
00407ac6  void* result = data_279c36c
00407acf  int32_t eax
00407acf  
00407acf  if (result != 0)
00407ad7      eax = *(result + 0x54)
00407ada      int32_t edx_2 = data_279c368 - 1
00407adb      data_279c36c = eax
00407ae2      data_279c368 = edx_2
00407ae2  
00407ae8  if (result == 0 || eax == 0)
00407aea      data_279c384 = 0
00407aea  
00407af4  sub_414290()
00407afc  return result

00407afd                                                                                         90 90 90                               ...

00407b00    int32_t sub_407b00()

00407b01  sub_414240()
00407b06  int32_t result = data_279c368
00407b0c  sub_414290()
00407b14  return result

00407b15                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00407b20    int32_t sub_407b20()

00407b20  sub_414240()
00407b25  int32_t eax = data_430324
00407b2d  int32_t var_4 = eax
00407b33  data_430324 = eax + 1
00407b38  sub_40fa00("\r%6d")
00407b40  return sub_414290() __tailcall

00407b45                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00407b50    int32_t sub_407b50(int32_t arg1)

00407b50  void** ecx
00407b50  void** var_4 = ecx
00407b50  
00407b5e  for (int32_t* i = sub_407ac0(); i != 0; i = sub_407ac0())
00407b6e      if (sub_407b00() s> 0xa)
00407b75          sub_414330(sub_407b50)
00407b75      
00407b7d      sub_407b20()
00407b87      void** edi_1 = i[0xe]
00407b87      
00407b91      if (data_42db3c == 1)
00407bac          int32_t eax_5 = sub_4107a0() + data_279c364 + data_279c378
00407bac          
00407bb0          if (eax_5 s> data_279c374)
00407bb2              data_279c374 = eax_5
00407bb2          
00407bb7          data_279c380 += 1
00407bb7      
00407bc3      if (data_493f84 != 0)
00407bc5          int32_t* i_1 = i
00407bc7          sub_4064f0(edi_1)
00407bc7      
00407bd5      void* eax_6
00407bd5      
00407bd5      if (data_279bf00 == 0)
00407bd9          eax_6 = sub_407170(edi_1, i)
00407bd9      
00407be3      if (data_279bf00 == 0 && eax_6 != 0)
00407c2f          i[0xa] = eax_6
00407c3a          *i = *eax_6 & 0xfffffffe
00407c3c          void** edi_2 = &i[0xb]
00407c3e          int32_t j_1 = 2
00407c51          int32_t* ecx_4
00407c51          int32_t j
00407c51          
00407c51          do
00407c43              void* eax_10
00407c43              eax_10, ecx_4 = sub_4068b0()
00407c48              *(eax_10 + 4) = i
00407c4b              *edi_2 = eax_10
00407c4d              edi_2 = &edi_2[1]
00407c50              j = j_1
00407c50              j_1 -= 1
00407c51          while (j != 1)
00407c5d          int32_t edx_3 = i[0xc] + 0x38
00407c60          int32_t* eax_12 = i[0xb] + 0x38
00407c63          int32_t var_18_5 = edx_3
00407c67          sub_407950(eax_12, edx_3, ecx_4, edi_1, i, eax_12)
00407c6d          sub_4069e0(edi_1)
00407c78          int32_t eax_13 = *i
00407c7a          int32_t* ecx_6 = i[0xc] + 0x20
00407c7d          void* edx_5 = i[0xb] + 0x20
00407c81          void* ecx_7 = i[8]
00407c89          i[0xe] = 0
00407c8c          sub_4074d0(ecx_7, eax_13, edx_5, ecx_6)
00407c8c          
00407ca2          if (*(i[0xb] + 0x20) == 0 || *(i[0xc] + 0x20) == 0)
00407ca9              sub_40f970("child without volume brush")
00407ca9          
00407cb1          void* eax_15 = i[8]
00407cb1          
00407cb6          if (eax_15 != 0)
00407cb9              sub_406960(eax_15)
00407cc1              i[8] = 0
00407cc1          
00407cc8          data_279c38c(i[0xb])
00407cd2          data_279c38c(i[0xc])
00407be3      else
00407be7          sub_407020(i, edi_1)
00407be7          
00407bf4          if ((i[0xf].b & 1) != 0)
00407bf6              data_279c394 += 1
00407bf6          
00407c02          if (data_279c334 != 0)
00407c08              sub_4069e0(i[0xe])
00407c10              i[0xe] = 0
00407c10          
00407c13          void* eax_9 = i[8]
00407c13          
00407c18          if (eax_9 != 0)
00407c1f              sub_406960(eax_9)
00407c27              i[8] = 0
00407c27  
00407cfe  return sub_414410(arg1)

00407cff                                                                                               90                                 .

00407d00    int32_t sub_407d00(int32_t* arg1)

00407d00  int32_t eax_3 = data_430328
00407d05  data_279c36c = 0
00407d11  data_279c384 = 0
00407d1b  data_279c38c = sub_407a80
00407d1b  
00407d25  if (eax_3 == 0)
00407d27      data_279c38c = sub_407a40
00407d27  
00407d31  sub_4142e0()
00407d3b  int32_t var_4 = data_42db3c
00407d41  sub_410030("%6d threads max\n")
00407d50  char* var_4_1
00407d50  
00407d50  if (data_430328 == 0)
00407d59      var_4_1 = "depth first bsp building\n"
00407d50  else
00407d52      var_4_1 = "breath first bsp building\n"
00407d52  
00407d5e  sub_410030(var_4_1)
00407d66  int32_t var_4_2 = 0
00407d6d  sub_410030("%6d splits")
00407d79  data_279c38c(*arg1)
00407d84  sub_414330(sub_407b50)
00407d8c  sub_414490()
00407d91  return sub_414310() __tailcall

00407d96                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00407da0    void sub_407da0(float arg1, int32_t arg2, float arg3)

00407dac  sub_410030("-------- Brush BSP ---------\n")
00407db4  void* eax = sub_406880()
00407db9  float i_1 = arg1
00407dc3  int32_t var_8 = 0
00407dc7  int32_t var_4 = 0
00407dcb  int32_t var_c = 0
00407dcf  data_279c370 = 0
00407dd5  float i = i_1
00407dd5  
00407dd7  if (i_1 != 0)
00407e7c      do
00407de7          var_c += 1
00407deb          long double st0_1 = sub_406780(i)
00407df0          long double temp0_1 = fconvert.t(data_42c040)
00407df0          st0_1 - temp0_1
00407df0          
00407dfe          if ((((st0_1 < temp0_1 ? 1 : 0) << 8
00407dfe                  | (is_unordered.t(st0_1, temp0_1) ? 1 : 0) << 0xa
00407dfe                  | (st0_1 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
00407e00              int32_t* eax_2 = *(i i+ 0x24)
00407e08              int32_t var_20_2 = eax_2[1]
00407e09              int32_t var_24_1 = *eax_2
00407e0f              sub_410030("WARNING: entity %i, brush %i: mi…")
00407e0f          
00407e17          int32_t j_2 = *(i i+ 0x28)
00407e17          
00407e1c          if (j_2 s> 0)
00407e1e              int16_t* eax_3 = i i+ 0x48
00407e21              int32_t j_1 = j_2
00407e49              int32_t j
00407e49              
00407e49              do
00407e23                  char ecx_1 = (*eax_3).b
00407e23                  
00407e34                  if ((ecx_1 & 4) == 0 && *(eax_3 - 0x14) != 0
00407e34                          && *(eax_3 - 0x18) != 0xffffffff)
00407e39                      if ((ecx_1 & 2) == 0)
00407e41                          var_4 += 1
00407e39                      else
00407e3b                          var_8 += 1
00407e3b                  
00407e45                  eax_3 = &eax_3[0x10]
00407e48                  j = j_1
00407e48                  j_1 -= 1
00407e49              while (j != 1)
00407e49          
00407e59          data_279c370 += j_2
00407e65          sub_410520(i i+ 4, eax + 0x60, eax + 0x6c)
00407e70          sub_410520(i i+ 0x10, eax + 0x60, eax + 0x6c)
00407e75          i = *i
00407e7c      while (i != 0)
00407e7c      
00407e82      i_1 = arg1
00407e82  
00407e8c  int32_t var_20_4 = var_c
00407e92  sub_410030("%6i brushes\n")
00407e9b  int32_t var_28_2 = var_8
00407ea1  sub_410030("%6i visible faces\n")
00407eaa  int32_t var_30_2 = var_4
00407eb0  sub_410030("%6i nonvisible faces\n")
00407ebb  int32_t var_38 = data_279c370
00407ec1  sub_410030("%6i total sides\n")
00407eca  data_279c378 = 0
00407ed0  data_279c37c = var_c
00407ed5  data_279c364 = 0
00407edb  data_279c390 = 0
00407ee1  data_279c380 = 0
00407ee7  data_279c388 = 0
00407eed  void* eax_7 = sub_4068b0()
00407f03  *(eax_7 + 0x20) = sub_4066b0(arg2, arg3)
00407f06  *eax = eax_7
00407f09  data_430324 = 0
00407f13  *(*eax + 0x38) = i_1
00407f16  sub_407d00(eax)
00407f16  
00407f25  if (data_279bf00 == 0)
00407f2d      int32_t var_20_5 = data_430324
00407f33      sub_410030("\r%6d splits\n")
00407f33      
00407f43      if (data_42db3c == 1)
00407f4e          int32_t var_20_6 = data_279c378 s>> 0xa
00407f54          sub_410030("%6i KB of node memory\n")
00407f61          int32_t var_28_3 = data_279c390 s>> 0xa
00407f67          sub_410030("%6i KB of peak brush memory\n")
00407f74          int32_t var_30_3 = sub_4107b0() s>> 0xa
00407f7a          sub_410030("%6i KB of peak winding memory\n")
00407f88          int32_t var_38_1 = data_279c374 s>> 0xa
00407f8e          sub_410030("%6i KB of peak total bsp memory\n")


00407fa0    int80_t sub_407fa0()

00407fac  int32_t ebp = 0
00407fae  int32_t edx = data_279befc * 0xb
00407fb1  void* ebx = (&data_256ee8c)[edx]
00407fc6  void* edi_1 = (&data_256ee90)[edx] + ebx
00407fca  void** eax_1 = sub_409fa0(ebx, edi_1)
00407fd2  int80_t result = sub_41b8e0(eax_1)
00407fd2  
00407fe2  if (sub_41bb50(eax_1) == 0)
0040804f      sub_410030("**** leaked ****\n")
00408055      ebp = 1
0040805a      sub_414550(eax_1)
0040805a      
00408069      if (data_279bee0 != 0)
00408070          sub_410030("--- MAP LEAKED ---\n")
0040807a          sub_41e313(0)
0040807f          return sub_408080() __tailcall
00407fe2  else
00407fe7      sub_41bd90(*eax_1)
00407fe7  
00407ff2  sub_41c280(eax_1, ebx, edi_1)
00407ff8  sub_41c070(eax_1)
00408000  sub_40b040(*eax_1)
00408008  sub_40a9d0(*eax_1)
00408008  
00408017  if (data_279bee4 == 0)
0040801c      sub_41d060(*eax_1)
0040801c  
00408027  sub_41d620(*eax_1)
00408027  
00408031  if (ebp == 0)
00408034      sub_41c620(eax_1)
00408034  
0040803d  sub_41cee0(eax_1)
00408049  return result


00408080    int80_t sub_408080()

0040808e  int32_t edx = data_279befc * 0xb
00408095  void* ebx = (&data_256ee8c)[edx]
004080aa  void* edi_1 = (&data_256ee90)[edx] + ebx
004080dc  int32_t var_18
004080dc  __builtin_memcpy(dest: &var_18, 
004080dc      src: "\x00\x00\x80\x45\x00\x00\x80\x45\x00\x00\x80\x45\x00\x00\x80\xc5\x00\x00\x80\xc5\x00\x00\x80\xc5", 
004080dc      n: 0x18)
004080e4  float var_c
004080e4  void* eax_1 = sub_409a90(ebx, edi_1, &var_c, &var_18)
004080e4  
004080f4  if (data_279bef0 == 0)
004080f7      eax_1 = sub_409d80(eax_1)
004080f7  
0040810a  int32_t* eax_2
0040810a  int80_t st0
0040810a  st0, eax_2 = sub_407da0(eax_1, &var_c, &var_18)
00408112  int80_t result = sub_41b8e0(eax_2)
0040811a  sub_41c280(eax_2, ebx, edi_1)
00408122  sub_40b040(*eax_2)
0040812a  sub_40a9d0(*eax_2)
00408132  sub_41d620(*eax_2)
00408138  sub_41cee0(eax_2)
00408146  return result

00408147                       90 90 90 90 90 90 90 90 90                                                         .........

00408150    int32_t sub_408150()

00408150  sub_41da60()
0040815b  int32_t eax = 0
0040815d  bool cond:0 = data_2584ecc s<= 0
0040815f  data_279befc = 0
0040815f  
00408164  if (not(cond:0))
004081cf      bool cond:1_1
004081cf      
004081cf      do
00408175          if ((&data_256ee90)[eax * 0xb] != 0)
0040817c              int32_t var_4_1 = data_2584e90
00408182              sub_410030("############### model %i #######…")
0040818a              sub_41dac0()
0040818a              unimplemented  {call sub_41dac0}
00408196              int16_t top
00408196              
00408196              if (data_279befc != 0)
0040819f                  sub_408080()
0040819f                  top -= 2
0040819f                  unimplemented  {call sub_408080}
00408196              else
00408198                  sub_407fa0()
00408198                  top -= 2
00408198                  unimplemented  {call sub_407fa0}
004081a4              sub_41dbd0()
004081a4              
004081b0              if (data_279bef8 == 0)
004081b2                  data_42ce60 = 0
004081b2              
004081bc              eax = data_279befc
004081bc          
004081c7          eax += 1
004081c8          cond:1_1 = eax s< data_2584ecc
004081ca          data_279befc = eax
004081cf      while (cond:1_1)
004081cf  
004081d1  return sub_41dab0() __tailcall

004081d6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

004081e0    int80_t sub_4081e0(char* arg1, char* arg2)

004081ee  int32_t ecx
004081ee  double var_808 = fconvert.d(sub_40fae0(ecx))
004081f2  sub_4141f0()
004081ff  sub_40fa20(arg1)
00408204  int32_t edi = 0x430350
00408206  int32_t i = 0xffffffff
00408206  
00408210  while (i != 0)
00408210      bool cond:0_1 = 0 != *edi
00408210      edi += 1
00408210      i -= 1
00408210      
00408210      if (not(cond:0_1))
00408210          break
00408210  
00408212  int32_t ecx_1 = not.d(i)
00408222  int32_t esi_1
00408222  int32_t edi_2
00408222  edi_2, esi_1 = __builtin_memcpy(dest: 0x279bf20, src: edi - ecx_1, n: ecx_1 u>> 2 << 2)
00408229  __builtin_memcpy(dest: edi_2, src: esi_1, n: ecx_1 & 3)
0040822b  sub_40fe10(0x279bf20)
00408230  int32_t var_820 = 0x279bf20
0040823f  void var_800
0040823f  sub_41e430(&var_800, "%s.prt")
00408249  sub_41e406(&var_800)
0040824e  int32_t var_830 = 0x279bf20
0040825d  sub_41e430(&var_800, "%s.lin")
00408267  sub_41e406(&var_800)
0040826d  sub_40fa20(arg1)
00408272  int32_t edi_3 = 0x430350
00408274  int32_t i_1 = 0xffffffff
00408274  
0040827e  while (i_1 != 0)
0040827e      bool cond:1_1 = 0 != *edi_3
0040827e      edi_3 += 1
0040827e      i_1 -= 1
0040827e      
0040827e      if (not(cond:1_1))
0040827e          break
0040827e  
00408280  int32_t ecx_5 = not.d(i_1)
00408295  int32_t esi_3
00408295  int32_t edi_5
00408295  edi_5, esi_3 =
00408295      __builtin_memcpy(dest: &data_279bae0, src: edi_3 - ecx_5, n: ecx_5 u>> 2 << 2)
0040829c  __builtin_memcpy(dest: edi_5, src: esi_3, n: ecx_5 & 3)
0040829e  sub_40fdb0(&data_279bae0, ".map")
004082b0  int80_t result
004082b0  
004082b0  if (data_279c330 == 0)
00408314      sub_40cb70()
0040831e      result = sub_419d00(&data_279bae0)
00408323      sub_41d6a0()
00408328      sub_41d700()
0040832d      sub_408150()
0040833a      sub_40df10(arg2)
004082b0  else
004082b2      sub_40cb70()
004082b7      int32_t __saved_ebx_1 = 0x279bf20
004082c9      void var_400
004082c9      sub_41e430(&var_400, "%s.bsp")
004082da      sub_40dc30(&var_400, nullptr, nullptr)
004082e4      data_2584ecc = 0
004082ee      result = sub_419d00(&data_279bae0)
004082f3      sub_41d6a0()
004082f8      sub_41d700()
004082fd      sub_40e430()
0040830a      sub_40df10(&var_400)
0040830a  
00408347  sub_40fae0(sub_40ce40())
0040835b  sub_410030("%5.0f seconds elapsed\n")
00408366  return result

00408367                       90 90 90 90 90 90 90 90 90                                                         .........

00408370    int80_t sub_408370(char* arg1, void* arg2, void* arg3, int32_t arg4)

0040837e  int32_t ecx
0040837e  double var_408 = fconvert.d(sub_40fae0(ecx))
00408382  sub_4141f0()
0040838f  sub_40fa20(arg1)
00408394  int32_t edi = 0x430350
00408396  int32_t i = 0xffffffff
00408396  
004083a0  while (i != 0)
004083a0      bool cond:0_1 = 0 != *edi
004083a0      edi += 1
004083a0      i -= 1
004083a0      
004083a0      if (not(cond:0_1))
004083a0          break
004083a0  
004083a2  int32_t ecx_1 = not.d(i)
004083b2  int32_t esi_1
004083b2  int32_t edi_2
004083b2  edi_2, esi_1 = __builtin_memcpy(dest: 0x279bf20, src: edi - ecx_1, n: ecx_1 u>> 2 << 2)
004083b9  __builtin_memcpy(dest: edi_2, src: esi_1, n: ecx_1 & 3)
004083bb  sub_40fe10(0x279bf20)
004083c0  int32_t var_420 = 0x279bf20
004083cf  void var_400
004083cf  sub_41e430(&var_400, "%s.prt")
004083d9  sub_41e406(&var_400)
004083de  int32_t var_430 = 0x279bf20
004083ed  sub_41e430(&var_400, "%s.lin")
004083f7  sub_41e406(&var_400)
004083fd  sub_40fa20(arg1)
00408402  int32_t edi_3 = 0x430350
00408404  int32_t i_1 = 0xffffffff
00408404  
0040840e  while (i_1 != 0)
0040840e      bool cond:1_1 = 0 != *edi_3
0040840e      edi_3 += 1
0040840e      i_1 -= 1
0040840e      
0040840e      if (not(cond:1_1))
0040840e          break
0040840e  
00408410  int32_t ecx_5 = not.d(i_1)
00408425  int32_t esi_3
00408425  int32_t edi_5
00408425  edi_5, esi_3 =
00408425      __builtin_memcpy(dest: &data_279bae0, src: edi_3 - ecx_5, n: ecx_5 u>> 2 << 2)
0040842c  __builtin_memcpy(dest: edi_5, src: esi_3, n: ecx_5 & 3)
0040842e  sub_40fdb0(&data_279bae0, ".map")
00408433  sub_40cb70()
00408449  int80_t result = sub_41a440(arg1, arg2, arg3)
00408451  sub_41d6a0()
00408456  sub_41d700()
0040845b  sub_408150()
00408468  sub_40df10(arg4)
00408472  int32_t ecx_11
00408472  long double st0_1
00408472  st0_1, ecx_11 = sub_40fae0(sub_40ce40())
0040847b  int32_t var_41c = ecx_11
0040847c  var_41c.q = fconvert.d(st0_1 - fconvert.t(var_408))
00408484  sub_410030("%5.0f seconds elapsed\n")
00408495  return result

00408496                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

004084a0    char* sub_4084a0(int32_t arg1, int32_t arg2, int32_t* arg3)

004084ac  char* result = nullptr
004084ae  char* j_1 = nullptr
004084ae  
004084b5  if (*arg3 + 1 s< arg1)
00408503      int32_t edx_3
00408503      
00408503      do
004084bd          char* eax_2 = *(arg2 + (*arg3 << 2) + 4)
004084bd          
004084c4          if (*eax_2 == 0x2d)
004084c4              break
004084c4          
004084c7          char* result_1 = sub_412be0(eax_2)
004084c7          
004084d1          if (result_1 != 0)
004084d5              if (j_1 == 0)
004084df                  result = result_1
004084d5              else
004084d7                  *(j_1 + 0x318) = result_1
004084d7              
004084e1              j_1 = result_1
004084e1              
004084eb              for (char* j = *(result_1 + 0x318); j != 0; j = *(j_1 + 0x318))
004084ed                  j_1 = j
004084ed          
004084fb          edx_3 = *arg3 + 1
004084fe          *arg3 = edx_3
00408503      while (edx_3 + 1 s< arg1)
00408503  
0040850b  return result

0040850c                                      90 90 90 90                                                              ....

00408510    int32_t sub_408510(int32_t arg1, char* arg2)

0040851f  char var_90 = data_43032c
0040853a  void s_1
0040853a  int16_t* edi = __builtin_memset(s: &s_1, c: 0, n: 0x8c)
00408549  *edi = 0
0040854b  edi[1].b = 0
0040854c  int32_t var_120 = (*"unknown")[0].d
0040855b  int32_t var_11c = (*"own")[0].d
0040855f  char* var_140 = "bspc.log"
00408564  void s
00408564  __builtin_memset(&s, c: 0, n: 0x88)
00408566  int32_t edi_3 = arg1
0040856d  int32_t var_128 = 0
00408575  data_255eda0 = edi_3
0040857b  data_255eda4 = arg2
00408581  sub_40ff40(var_140)
00408586  char* var_144 = "13:46:31"
0040858b  char* var_148 = "May 20 1999"
00408595  int32_t ecx_1
00408595  char* edx_1
00408595  ecx_1, edx_1 = sub_410030("BSPC version 1.2, %s %s by Mr El…")
004085a2  int32_t eax_1 = 1
004085a6  int32_t var_12c = 1
004085a6  
004085aa  if (edi_3 s<= 1)
00409248      sub_410030("Usage:   bspc [-<switch> [-<swit…")
004085aa  else
004085b0      char* i_7
004085b0      char* i_6 = i_7
00408caa      int16_t top
00408caa      
00408caa      do
004085b4          char* eax_2 = *(arg2 + (eax_1 << 2))
004085b7          char* var_140_1 = "-threads"
004085bc          var_144 = eax_2
004085bd          int32_t eax_3
004085bd          int32_t edx_2
004085bd          eax_3, edx_2 = sub_426fe0(eax_2, edx_1, ecx_1, var_144, var_140_1)
004085bd          
004085c7          if (eax_3 != 0)
004085f5              int32_t eax_6 = var_12c
004085f9              char* var_140_3 = "-glview"
004085fe              char* ecx_3 = *(arg2 + (eax_6 << 2))
00408601              var_144 = ecx_3
00408602              int32_t eax_7
00408602              eax_7, ecx_1, edx_1 = sub_426fe0(eax_6, edx_2, ecx_3, var_144, var_140_3)
00408602              
0040860c              if (eax_7 != 0)
00408619                  int32_t edx_4 = var_12c
0040861d                  char* var_140_4 = "-noverbose"
00408622                  char* eax_8 = *(arg2 + (edx_4 << 2))
00408625                  var_144 = eax_8
00408626                  int32_t eax_9 = sub_426fe0(eax_8, edx_4, ecx_1, var_144, var_140_4)
00408626                  
00408630                  if (eax_9 != 0)
0040864e                      int32_t ecx_4 = var_12c
00408652                      char* var_140_6 = "-draw"
00408657                      char* edx_5 = *(arg2 + (ecx_4 << 2))
0040865a                      var_144 = edx_5
0040865b                      int32_t eax_10
0040865b                      int32_t edx_6
0040865b                      eax_10, edx_6 = sub_426fe0(eax_9, edx_5, ecx_4, var_144, var_140_6)
0040865b                      
00408665                      if (eax_10 != 0)
0040867f                          int32_t eax_11 = var_12c
00408683                          char* var_140_8 = "-noweld"
00408688                          char* ecx_5 = *(arg2 + (eax_11 << 2))
0040868b                          var_144 = ecx_5
0040868c                          int32_t eax_12
0040868c                          int32_t ecx_6
0040868c                          eax_12, ecx_6 =
0040868c                              sub_426fe0(eax_11, edx_6, ecx_5, var_144, var_140_8)
0040868c                          
00408696                          if (eax_12 != 0)
004086b0                              int32_t edx_7 = var_12c
004086b4                              char* var_140_10 = "-nocsg"
004086b9                              char* eax_13 = *(arg2 + (edx_7 << 2))
004086bc                              var_144 = eax_13
004086bd                              int32_t eax_14 =
004086bd                                  sub_426fe0(eax_13, edx_7, ecx_6, var_144, var_140_10)
004086bd                              
004086c7                              if (eax_14 != 0)
004086e1                                  int32_t ecx_7 = var_12c
004086e5                                  char* var_140_12 = "-noshare"
004086ea                                  char* edx_8 = *(arg2 + (ecx_7 << 2))
004086ed                                  var_144 = edx_8
004086ee                                  int32_t eax_15
004086ee                                  int32_t edx_9
004086ee                                  eax_15, edx_9 =
004086ee                                      sub_426fe0(eax_14, edx_8, ecx_7, var_144, var_140_12)
004086ee                                  
004086f8                                  if (eax_15 != 0)
00408712                                      int32_t eax_16 = var_12c
00408716                                      char* var_140_14 = "-notjunc"
0040871b                                      char* ecx_8 = *(arg2 + (eax_16 << 2))
0040871e                                      var_144 = ecx_8
0040871f                                      int32_t eax_17
0040871f                                      int32_t ecx_9
0040871f                                      eax_17, ecx_9 = sub_426fe0(eax_16, edx_9, ecx_8, 
0040871f                                          var_144, var_140_14)
0040871f                                      
00408729                                      if (eax_17 != 0)
00408743                                          int32_t edx_10 = var_12c
00408747                                          char* var_140_16 = "-nowater"
0040874c                                          char* eax_18 = *(arg2 + (edx_10 << 2))
0040874f                                          var_144 = eax_18
00408750                                          int32_t eax_19 = sub_426fe0(eax_18, edx_10, 
00408750                                              ecx_9, var_144, var_140_16)
00408750                                          
0040875a                                          if (eax_19 != 0)
00408774                                              int32_t ecx_10 = var_12c
00408778                                              char* var_140_18 = "-optimize"
0040877d                                              char* edx_11 = *(arg2 + (ecx_10 << 2))
00408780                                              var_144 = edx_11
00408781                                              int32_t eax_20
00408781                                              int32_t edx_12
00408781                                              eax_20, edx_12 = sub_426fe0(eax_19, edx_11, 
00408781                                                  ecx_10, var_144, var_140_18)
00408781                                              
0040878b                                              if (eax_20 != 0)
004087a9                                                  int32_t eax_21 = var_12c
004087ad                                                  char* var_140_20 = "-noprune"
004087b2                                                  char* ecx_11 = *(arg2 + (eax_21 << 2))
004087b5                                                  var_144 = ecx_11
004087b6                                                  int32_t eax_22
004087b6                                                  int32_t ecx_12
004087b6                                                  eax_22, ecx_12 = sub_426fe0(eax_21, 
004087b6                                                      edx_12, ecx_11, var_144, var_140_20)
004087b6                                                  
004087c0                                                  if (eax_22 != 0)
004087da                                                      int32_t edx_13 = var_12c
004087de                                                      char* var_140_22 = "-nomerge"
004087e3                                                      char* eax_23 = *(arg2 + (edx_13 << 2))
004087e6                                                      var_144 = eax_23
004087e7                                                      int32_t eax_24 = sub_426fe0(eax_23, 
004087e7                                                          edx_13, ecx_12, var_144, var_140_22)
004087e7                                                      
004087f1                                                      if (eax_24 != 0)
0040880b                                                          int32_t ecx_13 = var_12c
0040880f                                                          char* var_140_24 = "-nosubdiv"
00408814                                                          char* edx_14 = *(arg2 + (ecx_13 << 2))
00408817                                                          var_144 = edx_14
00408818                                                          int32_t eax_25
00408818                                                          int32_t edx_15
00408818                                                          eax_25, edx_15 = sub_426fe0(eax_24, 
00408818                                                              edx_14, ecx_13, var_144, var_140_24)
00408818                                                          
00408822                                                          if (eax_25 != 0)
0040883c                                                              int32_t eax_26 = var_12c
00408840                                                              char* var_140_26 = "-nodetail"
00408845                                                              char* ecx_14 = *(arg2 + (eax_26 << 2))
00408848                                                              var_144 = ecx_14
00408849                                                              int32_t eax_27
00408849                                                              int32_t ecx_15
00408849                                                              eax_27, ecx_15 = sub_426fe0(eax_26, 
00408849                                                                  edx_15, ecx_14, var_144, var_140_26)
00408849                                                              
00408853                                                              if (eax_27 != 0)
0040886d                                                                  int32_t edx_16 = var_12c
00408871                                                                  char* var_140_28 = "-fulldetail"
00408876                                                                  char* eax_28 = *(arg2 + (edx_16 << 2))
00408879                                                                  var_144 = eax_28
0040887a                                                                  int32_t eax_29 = sub_426fe0(eax_28, 
0040887a                                                                      edx_16, ecx_15, var_144, var_140_28)
0040887a                                                                  
00408884                                                                  if (eax_29 != 0)
0040889e                                                                      int32_t ecx_16 = var_12c
004088a2                                                                      char* var_140_30 = "-onlyents"
004088a7                                                                      char* edx_17 = *(arg2 + (ecx_16 << 2))
004088aa                                                                      var_144 = edx_17
004088ab                                                                      int32_t eax_30
004088ab                                                                      int32_t edx_18
004088ab                                                                      eax_30, edx_18 = sub_426fe0(eax_29, 
004088ab                                                                          edx_17, ecx_16, var_144, var_140_30)
004088ab                                                                      
004088b5                                                                      if (eax_30 != 0)
004088cf                                                                          int32_t eax_31 = var_12c
004088d3                                                                          char* var_140_32 = "-micro"
004088d8                                                                          char* ecx_17 = *(arg2 + (eax_31 << 2))
004088db                                                                          var_144 = ecx_17
004088dc                                                                          int32_t eax_32 = sub_426fe0(eax_31, 
004088dc                                                                              edx_18, ecx_17, var_144, var_140_32)
004088dc                                                                          
004088e6                                                                          if (eax_32 != 0)
00408918                                                                              int32_t ecx_19 = var_12c
0040891c                                                                              char* var_140_34 = "-leaktest"
00408921                                                                              char* edx_20 = *(arg2 + (ecx_19 << 2))
00408924                                                                              var_144 = edx_20
00408925                                                                              int32_t eax_35
00408925                                                                              int32_t edx_21
00408925                                                                              eax_35, edx_21 = sub_426fe0(eax_32, 
00408925                                                                                  edx_20, ecx_19, var_144, var_140_34)
00408925                                                                              
0040892f                                                                              if (eax_35 != 0)
00408949                                                                                  int32_t eax_36 = var_12c
0040894d                                                                                  char* var_140_36 = "-verboseentities"
00408952                                                                                  char* ecx_20 = *(arg2 + (eax_36 << 2))
00408955                                                                                  var_144 = ecx_20
00408956                                                                                  int32_t eax_37
00408956                                                                                  int32_t ecx_21
00408956                                                                                  eax_37, ecx_21 = sub_426fe0(eax_36, 
00408956                                                                                      edx_21, ecx_20, var_144, var_140_36)
00408956                                                                                  
00408960                                                                                  if (eax_37 != 0)
0040897a                                                                                      int32_t edx_22 = var_12c
0040897e                                                                                      char* var_140_38 = "-chop"
00408983                                                                                      char* eax_38 = *(arg2 + (edx_22 << 2))
00408986                                                                                      var_144 = eax_38
00408987                                                                                      int32_t eax_39
00408987                                                                                      int32_t edx_23
00408987                                                                                      eax_39, edx_23 = sub_426fe0(eax_38, 
00408987                                                                                          edx_22, ecx_21, var_144, var_140_38)
00408987                                                                                      
00408991                                                                                      if (eax_39 != 0)
004089c3                                                                                          int32_t eax_41 = var_12c
004089c7                                                                                          char* var_140_40 = "-tmpout"
004089cc                                                                                          char* ecx_24 = *(arg2 + (eax_41 << 2))
004089cf                                                                                          var_144 = ecx_24
004089d0                                                                                          int32_t eax_42 = sub_426fe0(eax_41, 
004089d0                                                                                              edx_23, ecx_24, var_144, var_140_40)
004089d0                                                                                          
004089da                                                                                          if (eax_42 != 0)
00408a04                                                                                              int32_t ecx_25 = var_12c
00408a08                                                                                              char* var_140_42 = "-freetree"
00408a0d                                                                                              char* edx_26 = *(arg2 + (ecx_25 << 2))
00408a10                                                                                              var_144 = edx_26
00408a11                                                                                              int32_t eax_43
00408a11                                                                                              int32_t edx_27
00408a11                                                                                              eax_43, edx_27 = sub_426fe0(eax_42, 
00408a11                                                                                                  edx_26, ecx_25, var_144, var_140_42)
00408a11                                                                                              
00408a1b                                                                                              if (eax_43 != 0)
00408a35                                                                                                  int32_t eax_44 = var_12c
00408a39                                                                                                  char* var_140_44 = "-nobrushmerge"
00408a3e                                                                                                  char* ecx_26 = *(arg2 + (eax_44 << 2))
00408a41                                                                                                  var_144 = ecx_26
00408a42                                                                                                  int32_t eax_45
00408a42                                                                                                  int32_t ecx_27
00408a42                                                                                                  eax_45, ecx_27 = sub_426fe0(eax_44, 
00408a42                                                                                                      edx_27, ecx_26, var_144, var_140_44)
00408a42                                                                                                  
00408a4c                                                                                                  if (eax_45 != 0)
00408a66                                                                                                      int32_t edx_28 = var_12c
00408a6a                                                                                                      char* var_140_46 = "-noliquids"
00408a6f                                                                                                      char* eax_46 = *(arg2 + (edx_28 << 2))
00408a72                                                                                                      var_144 = eax_46
00408a73                                                                                                      int32_t eax_47 = sub_426fe0(eax_46, 
00408a73                                                                                                          edx_28, ecx_27, var_144, var_140_46)
00408a73                                                                                                      
00408a7d                                                                                                      if (eax_47 != 0)
00408a97                                                                                                          int32_t ecx_28 = var_12c
00408a9b                                                                                                          char* var_140_48 = "-output"
00408aa0                                                                                                          char* edx_29 = *(arg2 + (ecx_28 << 2))
00408aa3                                                                                                          var_144 = edx_29
00408aa4                                                                                                          int32_t eax_48 = sub_426fe0(eax_47, 
00408aa4                                                                                                              edx_29, ecx_28, var_144, var_140_48)
00408aa4                                                                                                          
00408aae                                                                                                          if (eax_48 != 0)
00408b25                                                                                                              int32_t ecx_34 = var_12c
00408b29                                                                                                              char* var_140_51 = "-breathfirst"
00408b2e                                                                                                              char* edx_31 = *(arg2 + (ecx_34 << 2))
00408b31                                                                                                              var_144 = edx_31
00408b32                                                                                                              int32_t eax_56
00408b32                                                                                                              int32_t edx_32
00408b32                                                                                                              eax_56, edx_32 = sub_426fe0(eax_48, 
00408b32                                                                                                                  edx_31, ecx_34, var_144, var_140_51)
00408b32                                                                                                              
00408b3c                                                                                                              if (eax_56 != 0)
00408b56                                                                                                                  int32_t eax_57 = var_12c
00408b5a                                                                                                                  char* var_140_53 = "-map2bsp"
00408b5f                                                                                                                  char* ecx_35 = *(arg2 + (eax_57 << 2))
00408b62                                                                                                                  var_144 = ecx_35
00408b63                                                                                                                  int32_t eax_58 = sub_426fe0(eax_57, 
00408b63                                                                                                                      edx_32, ecx_35, var_144, var_140_53)
00408b6d                                                                                                                  int32_t* var_140_54
00408b6d                                                                                                                  
00408b6d                                                                                                                  if (eax_58 == 0)
00408b76                                                                                                                      if (var_12c + 1 s>= edi_3)
00408cb2                                                                                                                          var_12c = 0
00408cba                                                                                                                          break
00408cba                                                                                                                      
00408b7c                                                                                                                      var_128 = 1
00408b84                                                                                                                      label_408b84:
00408b84                                                                                                                      var_140_54 = &var_12c
00408b84                                                                                                                      goto label_408b85
00408b84                                                                                                                  
00408b9a                                                                                                                  int32_t ecx_36 = var_12c
00408b9e                                                                                                                  char* var_140_55 = "-map2aas"
00408ba3                                                                                                                  char* edx_35 = *(arg2 + (ecx_36 << 2))
00408ba6                                                                                                                  var_144 = edx_35
00408ba7                                                                                                                  int32_t eax_59
00408ba7                                                                                                                  int32_t ecx_37
00408ba7                                                                                                                  eax_59, ecx_37 = sub_426fe0(eax_58, 
00408ba7                                                                                                                      edx_35, ecx_36, var_144, var_140_55)
00408ba7                                                                                                                  
00408bb1                                                                                                                  if (eax_59 != 0)
00408bcf                                                                                                                      int32_t edx_36 = var_12c
00408bd3                                                                                                                      char* var_140_56 = "-bsp2map"
00408bd8                                                                                                                      char* eax_62 = *(arg2 + (edx_36 << 2))
00408bdb                                                                                                                      var_144 = eax_62
00408bdc                                                                                                                      int32_t eax_63
00408bdc                                                                                                                      int32_t edx_37
00408bdc                                                                                                                      eax_63, edx_37 = sub_426fe0(eax_62, 
00408bdc                                                                                                                          edx_36, ecx_37, var_144, var_140_56)
00408bdc                                                                                                                      
00408be6                                                                                                                      if (eax_63 == 0)
00408bef                                                                                                                          if (var_12c + 1 s>= edi_3)
00408cb2                                                                                                                              var_12c = 0
00408cba                                                                                                                              break
00408cba                                                                                                                          
00408bf9                                                                                                                          var_128 = 3
00408c01                                                                                                                          var_140_54 = &var_12c
00408c02                                                                                                                          goto label_408b85
00408c02                                                                                                                      
00408c04                                                                                                                      int32_t eax_64 = var_12c
00408c08                                                                                                                      char* var_140_57 = "-bsp2bsp"
00408c0d                                                                                                                      char* ecx_40 = *(arg2 + (eax_64 << 2))
00408c10                                                                                                                      var_144 = ecx_40
00408c11                                                                                                                      int32_t eax_65 = sub_426fe0(eax_64, 
00408c11                                                                                                                          edx_37, ecx_40, var_144, var_140_57)
00408c11                                                                                                                      
00408c1b                                                                                                                      if (eax_65 == 0)
00408c24                                                                                                                          if (var_12c + 1 s< edi_3)
00408c2a                                                                                                                              var_128 = 4
00408c32                                                                                                                              goto label_408b84
00408c32                                                                                                                          
00408cb2                                                                                                                          var_12c = 0
00408cba                                                                                                                          break
00408cba                                                                                                                      
00408c37                                                                                                                      int32_t ecx_41 = var_12c
00408c3b                                                                                                                      char* var_140_58 = "-bsp2aas"
00408c40                                                                                                                      char* edx_40 = *(arg2 + (ecx_41 << 2))
00408c43                                                                                                                      var_144 = edx_40
00408c4c                                                                                                                      bool cond:28_1 = sub_426fe0(eax_65, 
00408c4c                                                                                                                          edx_40, ecx_41, var_144, var_140_58)
00408c4c                                                                                                                          != 0
00408c4e                                                                                                                      int32_t eax_67 = var_12c
00408c4e                                                                                                                      
00408c52                                                                                                                      if (not(cond:28_1))
00408c57                                                                                                                          if (eax_67 + 1 s>= edi_3)
00408cb2                                                                                                                              var_12c = 0
00408cba                                                                                                                              break
00408cba                                                                                                                          
00408c5d                                                                                                                          var_128 = 5
00408c65                                                                                                                          var_140_54 = &var_12c
00408c66                                                                                                                          goto label_408b85
00408c66                                                                                                                      
00408c6d                                                                                                                      if (eax_67 != 1)
00408cbf                                                                                                                          int32_t var_140_60 =
00408cbf                                                                                                                              *(arg2 + (eax_67 << 2))
00408cc0                                                                                                                          var_144 = "unknows parameter %s\n"
00408cc5                                                                                                                          sub_410030(var_144)
00408cca                                                                                                                          break
00408cca                                                                                                                      
00408c6f                                                                                                                      var_12c = 2
00408c80                                                                                                                      i_6 = sub_412be0(*(arg2 + 8))
00408c86                                                                                                                      i_7 = i_6
00408c8a                                                                                                                      var_128 = 1
00408c91                                                                                                                      var_144 = *(arg2 + (var_12c << 2))
00408c97                                                                                                                      ecx_1, edx_1 =
00408c97                                                                                                                          sub_410030("map2bsp: %s\n")
00408bb1                                                                                                                  else
00408bba                                                                                                                      if (var_12c + 1 s>= edi_3)
00408cb2                                                                                                                          var_12c = 0
00408cba                                                                                                                          break
00408cba                                                                                                                      
00408bc4                                                                                                                      var_128 = 2
00408bcc                                                                                                                      var_140_54 = &var_12c
00408b85                                                                                                                      label_408b85:
00408b85                                                                                                                      var_144 = arg2
00408b87                                                                                                                      char* i_8
00408b87                                                                                                                      i_8, ecx_1, edx_1 =
00408b87                                                                                                                          sub_4084a0(edi_3, var_144, var_140_54)
00408b8c                                                                                                                      i_6 = i_8
00408b91                                                                                                                      i_7 = i_6
00408b3c                                                                                                              else
00408b3e                                                                                                                  void* var_140_52 =
00408b3e                                                                                                                      "breathfirst = true\n"
00408b43                                                                                                                  data_430328 = 1
00408b49                                                                                                                  ecx_1, edx_1 = sub_410030(var_140_52)
00408aae                                                                                                          else
00408ab7                                                                                                              if (var_12c + 1 s>= edi_3)
00408cb2                                                                                                                  var_12c = 0
00408cba                                                                                                                  break
00408cba                                                                                                              
00408ac0                                                                                                              char var_140_49 = 4
00408ac2                                                                                                              var_144 = *(arg2 + ((var_12c + 1) << 2))
00408ac2                                                                                                              
00408acd                                                                                                              if (sub_428416(var_144, var_140_49)
00408acd                                                                                                                      != 0)
00408ad7                                                                                                                  int32_t var_140_50 =
00408ad7                                                                                                                      *(arg2 + (var_12c << 2) + 4)
00408ad8                                                                                                                  var_144 = "the folder %s does not exist"
00408add                                                                                                                  sub_40f9c0(var_144)
00408add                                                                                                              
00408ae9                                                                                                              int32_t i = 0xffffffff
00408aec                                                                                                              int32_t eax_54 = var_12c + 1
00408aed                                                                                                              edx_1 = &var_90
00408af4                                                                                                              var_12c = eax_54
00408af8                                                                                                              int32_t edi_4 = *(arg2 + (eax_54 << 2))
00408af8                                                                                                              
00408afd                                                                                                              while (i != 0)
00408afd                                                                                                                  bool cond:27_1 = 0 != *edi_4
00408afd                                                                                                                  edi_4 += 1
00408afd                                                                                                                  i -= 1
00408afd                                                                                                                  
00408afd                                                                                                                  if (not(cond:27_1))
00408afd                                                                                                                      break
00408afd                                                                                                              
00408aff                                                                                                              int32_t ecx_30 = not.d(i)
00408b0c                                                                                                              int32_t esi_2
00408b0c                                                                                                              int32_t edi_6
00408b0c                                                                                                              edi_6, esi_2 = __builtin_memcpy(
00408b0c                                                                                                                  dest: &var_90, src: edi_4 - ecx_30, 
00408b0c                                                                                                                  n: ecx_30 u>> 2 << 2)
00408b13                                                                                                              ecx_1 = __builtin_memcpy(dest: edi_6, 
00408b13                                                                                                                  src: esi_2, n: ecx_30 & 3)
00408b15                                                                                                              i_6 = i_7
00408b19                                                                                                              edi_3 = arg1
00408a7d                                                                                                      else
00408a7f                                                                                                          char* var_140_47 = "noliquids = true\n"
00408a84                                                                                                          data_279bee8 = 1
00408a8a                                                                                                          ecx_1, edx_1 = sub_410030(var_140_47)
00408a4c                                                                                                  else
00408a4e                                                                                                      char* var_140_45 =
00408a4e                                                                                                          "nobrushmerge = true\n"
00408a53                                                                                                      data_279beec = 1
00408a59                                                                                                      ecx_1, edx_1 = sub_410030(var_140_45)
00408a1b                                                                                              else
00408a1d                                                                                                  char* var_140_43 = "freetree = true\n"
00408a22                                                                                                  data_279c320 = 1
00408a28                                                                                                  ecx_1, edx_1 = sub_410030(var_140_43)
004089da                                                                                          else
004089e2                                                                                              eax_42.b = data_42c6c0[4][0]
004089e7                                                                                              char* var_140_41 = "temp output\n"
004089ec                                                                                              data_279c340 = (*"/tmp")[0].d
004089f2                                                                                              data_279c344 = eax_42.b
004089f7                                                                                              ecx_1, edx_1 = sub_410030(var_140_41)
00408991                                                                                      else
00408997                                                                                          int32_t eax_40 = var_12c + 1
00408997                                                                                          
0040899c                                                                                          if (eax_40 s>= edi_3)
00408cb2                                                                                              var_12c = 0
00408cba                                                                                              break
00408cba                                                                                          
004089a2                                                                                          var_12c = eax_40
004089aa                                                                                          char* ecx_23
004089aa                                                                                          long double st0_2
004089aa                                                                                          st0_2, ecx_23 =
004089aa                                                                                              sub_41e482(*(arg2 + (eax_40 << 2)))
004089af                                                                                          data_42ca48 = fconvert.s(st0_2)
004089b5                                                                                          var_144 = ecx_23
004089b6                                                                                          var_144.q = fconvert.d(st0_2)
004089b6                                                                                          top = 0
00408c97                                                                                          ecx_1, edx_1 =
00408c97                                                                                              sub_410030("subdivide_size = %f\n")
00408960                                                                                  else
00408967                                                                                      ecx_1, edx_1 =
00408967                                                                                          sub_410030("verboseentities = true\n")
0040896f                                                                                      data_279bef8 = 1
0040892f                                                                              else
00408936                                                                                  ecx_1, edx_1 =
00408936                                                                                      sub_410030("leaktest = true\n")
0040893e                                                                                  data_279bee0 = 1
004088e6                                                                          else
004088ec                                                                              int32_t eax_33 = var_12c + 1
004088ec                                                                              
004088f1                                                                              if (eax_33 s>= edi_3)
00408cb2                                                                                  var_12c = 0
00408cba                                                                                  break
00408cba                                                                              
004088f7                                                                              var_12c = eax_33
004088ff                                                                              char* ecx_18
004088ff                                                                              long double st0_1
004088ff                                                                              st0_1, ecx_18 =
004088ff                                                                                  sub_41e482(*(arg2 + (eax_33 << 2)))
00408904                                                                              data_42c040 = fconvert.s(st0_1)
0040890a                                                                              var_144 = ecx_18
0040890b                                                                              var_144.q = fconvert.d(st0_1)
0040890b                                                                              top = 0
00408c97                                                                              ecx_1, edx_1 =
00408c97                                                                                  sub_410030("microvolume = %f\n")
004088b5                                                                      else
004088bc                                                                          ecx_1, edx_1 =
004088bc                                                                              sub_410030("onlyents = true\n")
004088c4                                                                          data_279c330 = 1
00408884                                                                  else
0040888b                                                                      ecx_1, edx_1 =
0040888b                                                                          sub_410030("fulldetail = true\n")
00408893                                                                      data_279bacc = 1
00408853                                                              else
0040885a                                                                  ecx_1, edx_1 =
0040885a                                                                      sub_410030("nodetail = true\n")
00408862                                                                  data_279c328 = 1
00408822                                                          else
00408829                                                              ecx_1, edx_1 =
00408829                                                                  sub_410030("nosubdiv = true\n")
00408831                                                              data_279bac4 = 1
004087f1                                                      else
004087f8                                                          ecx_1, edx_1 =
004087f8                                                              sub_410030("nomerge = true\n")
00408800                                                          data_279bef4 = 1
004087c0                                                  else
004087c7                                                      ecx_1, edx_1 =
004087c7                                                          sub_410030("noprune = true\n")
004087cf                                                      data_279bee4 = 1
0040878b                                              else
00408792                                                  ecx_1, edx_1 =
00408792                                                      sub_410030("noopt = false\n")
0040879a                                                  data_42c044 = 0
0040875a                                          else
00408761                                              ecx_1, edx_1 = sub_410030("nowater = true\n")
00408769                                              data_279babc = 1
00408729                                      else
00408730                                          ecx_1, edx_1 = sub_410030("notjunc = true\n")
00408738                                          data_279c32c = 1
004086f8                                  else
004086ff                                      ecx_1, edx_1 = sub_410030("noshare = true\n")
00408707                                      data_279bac8 = 1
004086c7                              else
004086ce                                  ecx_1, edx_1 = sub_410030("nocsg = true\n")
004086d6                                  data_279bef0 = 1
00408696                          else
0040869d                              ecx_1, edx_1 = sub_410030("noweld = true\n")
004086a5                              data_279bac0 = 1
00408665                      else
0040866c                          ecx_1, edx_1 = sub_410030("drawflag = true\n")
00408674                          data_493f84 = 1
00408630                  else
00408637                      ecx_1, edx_1 = sub_410030("verbose = false\n")
0040863f                      data_42ce60 = 0
0040860c              else
0040860e                  data_279c324 = 1
004085c7          else
004085cd              int32_t eax_4 = var_12c + 1
004085cd              
004085d2              if (eax_4 s>= edi_3)
00408cb2                  var_12c = 0
00408cba                  break
00408cba              
004085d8              var_12c = eax_4
004085e0              int32_t eax_5 = sub_41e293(*(arg2 + (eax_4 << 2)))
004085e5              var_144 = eax_5
004085e6              data_42db3c = eax_5
00408c97              ecx_1, edx_1 = sub_410030("threads = %d\n")
00408c97          
00408ca3          eax_1 = var_12c + 1
00408ca6          var_12c = eax_1
00408caa      while (eax_1 s< edi_3)
00408caa      
00408cd9      if (edi_3 s<= 1 || var_12c != edi_3)
00409248          sub_410030("Usage:   bspc [-<switch> [-<swit…")
00408cd9      else if (var_128 - 1 u> 4)
00409248          sub_410030("don't know what to do\n")
00408ce7      else
00408ced          switch (var_128)
00408cf6              case 1
00408cf6                  if (i_6 == 0)
00408cfd                      sub_410030("no files found\n")
00408cfd                  
00408d07                  char* i_1 = i_6
00408d07                  
00408d09                  if (i_6 != 0)
00408ddb                      do
00408d0f                          char* edi_7 = &var_90
00408d16                          int32_t j = 0xffffffff
00408d16                          
00408d1f                          while (j != 0)
00408d1f                              bool cond:7_1 = 0 != *edi_7
00408d1f                              edi_7 = &edi_7[1]
00408d1f                              j -= 1
00408d1f                              
00408d1f                              if (not(cond:7_1))
00408d1f                                  break
00408d1f                          
00408d21                          int32_t ecx_43 = not.d(j)
00408d25                          int32_t var_140_62 = 0x90
00408d33                          int32_t esi_4
00408d33                          int32_t edi_9
00408d33                          edi_9, esi_4 = __builtin_memcpy(dest: &var_120, 
00408d33                              src: edi_7 - ecx_43, n: ecx_43 u>> 2 << 2)
00408d3a                          __builtin_memcpy(dest: edi_9, src: esi_4, n: ecx_43 & 3)
00408d40                          var_144 = &var_120
00408d41                          sub_4144f0(var_144, var_140_62)
00408d46                          int32_t* edi_10 = &var_120
00408d4a                          int32_t j_1 = 0xffffffff
00408d4a                          
00408d55                          while (j_1 != 0)
00408d55                              bool cond:8_1 = 0 != *edi_10
00408d55                              edi_10 += 1
00408d55                              j_1 -= 1
00408d55                              
00408d55                              if (not(cond:8_1))
00408d55                                  break
00408d55                          
00408d60                          sub_40fe50(&i_1[0x208], &var_144 + not.d(j_1) - 1 + 0x24)
00408d65                          char* edi_11 = ".bsp"
00408d6a                          int32_t j_2 = 0xffffffff
00408d6a                          
00408d73                          while (j_2 != 0)
00408d73                              bool cond:9_1 = 0 != *edi_11
00408d73                              edi_11 = &edi_11[1]
00408d73                              j_2 -= 1
00408d73                              
00408d73                              if (not(cond:9_1))
00408d73                                  break
00408d73                          
00408d75                          int32_t ecx_49 = not.d(j_2)
00408d7b                          int32_t* edi_13 = &var_120
00408d7f                          int32_t j_3 = 0xffffffff
00408d7f                          
00408d82                          while (j_3 != 0)
00408d82                              bool cond:10_1 = 0 != *edi_13
00408d82                              edi_13 += 1
00408d82                              j_3 -= 1
00408d82                              
00408d82                              if (not(cond:10_1))
00408d82                                  break
00408d82                          
00408d8a                          int32_t esi_6
00408d8a                          int32_t edi_15
00408d8a                          edi_15, esi_6 = __builtin_memcpy(dest: edi_13 - 1, 
00408d8a                              src: edi_11 - ecx_49, n: ecx_49 u>> 2 << 2)
00408d95                          int32_t* var_150_1 = &var_120
00408d96                          void* var_154_1 = &i_1[0x208]
00408d97                          char* var_158_1 = "map2bsp: %s to %s\n"
00408d9c                          __builtin_memcpy(dest: edi_15, src: esi_6, n: ecx_49 & 3)
00408d9e                          sub_410030(var_158_1)
00408d9e                          
00408daf                          if (*(i_1 + 0x30c) != 4)
00408db1                              void* var_140_63 = &i_1[0x208]
00408db2                              var_144 = "%s is probably not a MAP file\n"
00408db7                              sub_40f9c0(var_144)
00408db7                          
00408dc9                          char* var_140_64 = &var_120
00408dca                          var_144 = &i_1[0x104]
00408dcb                          sub_4081e0(var_144, var_140_64)
00408dcb                          top -= 1
00408dcb                          unimplemented  {call sub_4081e0}
00408dd0                          i_1 = *(i_1 + 0x318)
00408ddb                      while (i_1 != 0)
00408ddb                      
00408de1                      sub_40ffd0()
00408df2                      return 0
00408df5              case 2
00408df5                  if (i_6 == 0)
00408dfc                      sub_410030("no files found\n")
00408dfc                  
00408e06                  char* i_2 = i_6
00408e06                  
00408e08                  if (i_6 != 0)
00408ee9                      do
00408e0e                          char* edi_16 = &var_90
00408e15                          int32_t j_4 = 0xffffffff
00408e15                          
00408e1e                          while (j_4 != 0)
00408e1e                              bool cond:11_1 = 0 != *edi_16
00408e1e                              edi_16 = &edi_16[1]
00408e1e                              j_4 -= 1
00408e1e                              
00408e1e                              if (not(cond:11_1))
00408e1e                                  break
00408e1e                          
00408e20                          int32_t ecx_54 = not.d(j_4)
00408e24                          int32_t var_140_66 = 0x90
00408e32                          int32_t esi_8
00408e32                          int32_t edi_18
00408e32                          edi_18, esi_8 = __builtin_memcpy(dest: &var_120, 
00408e32                              src: edi_16 - ecx_54, n: ecx_54 u>> 2 << 2)
00408e39                          __builtin_memcpy(dest: edi_18, src: esi_8, n: ecx_54 & 3)
00408e3f                          var_144 = &var_120
00408e40                          sub_4144f0(var_144, var_140_66)
00408e45                          int32_t* edi_19 = &var_120
00408e49                          int32_t j_5 = 0xffffffff
00408e49                          
00408e54                          while (j_5 != 0)
00408e54                              bool cond:12_1 = 0 != *edi_19
00408e54                              edi_19 += 1
00408e54                              j_5 -= 1
00408e54                              
00408e54                              if (not(cond:12_1))
00408e54                                  break
00408e54                          
00408e5f                          sub_40fe50(&i_2[0x208], &var_144 + not.d(j_5) - 1 + 0x24)
00408e64                          char* edi_20 = ".aas"
00408e69                          int32_t j_6 = 0xffffffff
00408e69                          
00408e72                          while (j_6 != 0)
00408e72                              bool cond:13_1 = 0 != *edi_20
00408e72                              edi_20 = &edi_20[1]
00408e72                              j_6 -= 1
00408e72                              
00408e72                              if (not(cond:13_1))
00408e72                                  break
00408e72                          
00408e74                          int32_t ecx_60 = not.d(j_6)
00408e7a                          int32_t* edi_22 = &var_120
00408e7e                          int32_t j_7 = 0xffffffff
00408e7e                          
00408e81                          while (j_7 != 0)
00408e81                              bool cond:14_1 = 0 != *edi_22
00408e81                              edi_22 += 1
00408e81                              j_7 -= 1
00408e81                              
00408e81                              if (not(cond:14_1))
00408e81                                  break
00408e81                          
00408e89                          int32_t esi_10
00408e89                          int32_t edi_24
00408e89                          edi_24, esi_10 = __builtin_memcpy(dest: edi_22 - 1, 
00408e89                              src: edi_20 - ecx_60, n: ecx_60 u>> 2 << 2)
00408e94                          int32_t* var_150_2 = &var_120
00408e95                          void* var_154_2 = &i_2[0x208]
00408e96                          char* var_158_2 = "map2aas: %s to %s\n"
00408e9b                          __builtin_memcpy(dest: edi_24, src: esi_10, n: ecx_60 & 3)
00408e9d                          sub_410030(var_158_2)
00408e9d                          
00408eae                          if (*(i_2 + 0x30c) != 4)
00408eb0                              void* var_140_67 = &i_2[0x208]
00408eb1                              var_144 = "%s is probably not a MAP file\n"
00408eb6                              sub_40f9c0(var_144)
00408eb6                          
00408ec4                          data_279c334 = 1
00408ecf                          sub_419d00(&i_2[0x104])
00408ecf                          top -= 1
00408ecf                          unimplemented  {call sub_419d00}
00408ed8                          var_144 = &var_120
00408ed9                          sub_402660(var_144)
00408ede                          i_2 = *(i_2 + 0x318)
00408ee9                      while (i_2 != 0)
00408ee9                      
00408eef                      sub_40ffd0()
00408f00                      return 0
00408f03              case 3
00408f03                  if (i_6 == 0)
00408f0a                      sub_410030("no files found\n")
00408f0a                  
00408f14                  char* i_3 = i_6
00408f14                  
00408f16                  if (i_6 != 0)
00408ffb                      do
00408f1c                          char* edi_25 = &var_90
00408f23                          int32_t j_8 = 0xffffffff
00408f23                          
00408f2c                          while (j_8 != 0)
00408f2c                              bool cond:15_1 = 0 != *edi_25
00408f2c                              edi_25 = &edi_25[1]
00408f2c                              j_8 -= 1
00408f2c                              
00408f2c                              if (not(cond:15_1))
00408f2c                                  break
00408f2c                          
00408f2e                          int32_t ecx_66 = not.d(j_8)
00408f32                          int32_t var_140_70 = 0x90
00408f40                          int32_t esi_12
00408f40                          int32_t edi_27
00408f40                          edi_27, esi_12 = __builtin_memcpy(dest: &var_120, 
00408f40                              src: edi_25 - ecx_66, n: ecx_66 u>> 2 << 2)
00408f47                          __builtin_memcpy(dest: edi_27, src: esi_12, n: ecx_66 & 3)
00408f4d                          var_144 = &var_120
00408f4e                          sub_4144f0(var_144, var_140_70)
00408f53                          int32_t* edi_28 = &var_120
00408f57                          int32_t j_9 = 0xffffffff
00408f57                          
00408f62                          while (j_9 != 0)
00408f62                              bool cond:16_1 = 0 != *edi_28
00408f62                              edi_28 += 1
00408f62                              j_9 -= 1
00408f62                              
00408f62                              if (not(cond:16_1))
00408f62                                  break
00408f62                          
00408f6d                          sub_40fe50(&i_3[0x208], &var_144 + not.d(j_9) - 1 + 0x24)
00408f72                          char* edi_29 = ".map"
00408f77                          int32_t j_10 = 0xffffffff
00408f77                          
00408f80                          while (j_10 != 0)
00408f80                              bool cond:17_1 = 0 != *edi_29
00408f80                              edi_29 = &edi_29[1]
00408f80                              j_10 -= 1
00408f80                              
00408f80                              if (not(cond:17_1))
00408f80                                  break
00408f80                          
00408f82                          int32_t ecx_72 = not.d(j_10)
00408f88                          int32_t* edi_31 = &var_120
00408f8c                          int32_t j_11 = 0xffffffff
00408f8c                          
00408f8f                          while (j_11 != 0)
00408f8f                              bool cond:18_1 = 0 != *edi_31
00408f8f                              edi_31 += 1
00408f8f                              j_11 -= 1
00408f8f                              
00408f8f                              if (not(cond:18_1))
00408f8f                                  break
00408f8f                          
00408f97                          int32_t esi_14
00408f97                          int32_t edi_33
00408f97                          edi_33, esi_14 = __builtin_memcpy(dest: edi_31 - 1, 
00408f97                              src: edi_29 - ecx_72, n: ecx_72 u>> 2 << 2)
00408fa2                          int32_t* var_150_3 = &var_120
00408fa3                          void* var_154_3 = &i_3[0x208]
00408fa4                          char* var_158_3 = "bsp2map: %s to %s\n"
00408fa9                          __builtin_memcpy(dest: edi_33, src: esi_14, n: ecx_72 & 3)
00408fab                          sub_410030(var_158_3)
00408fab                          
00408fbc                          if (*(i_3 + 0x30c) != 2)
00408fbe                              void* var_140_71 = &i_3[0x208]
00408fbf                              var_144 = "%s is probably not a BSP file\n"
00408fc4                              sub_40f9c0(var_144)
00408fc4                          
00408fcc                          void* ecx_77 = *(i_3 + 0x314)
00408fdf                          var_144 = *(i_3 + 0x310)
00408fe1                          sub_416420(&i_3[0x104], var_144, ecx_77)
00408feb                          sub_416200(&var_120)
00408ff0                          i_3 = *(i_3 + 0x318)
00408ffb                      while (i_3 != 0)
00408ffb                      
00409001                      sub_40ffd0()
00409012                      return 0
00409015              case 4
00409015                  if (i_6 == 0)
0040901c                      sub_410030("no files found\n")
0040901c                  
00409026                  char* i_4 = i_6
00409026                  
00409028                  if (i_6 != 0)
00409108                      do
0040902e                          char* edi_34 = &var_90
00409035                          int32_t j_12 = 0xffffffff
00409035                          
0040903e                          while (j_12 != 0)
0040903e                              bool cond:19_1 = 0 != *edi_34
0040903e                              edi_34 = &edi_34[1]
0040903e                              j_12 -= 1
0040903e                              
0040903e                              if (not(cond:19_1))
0040903e                                  break
0040903e                          
00409040                          int32_t ecx_78 = not.d(j_12)
00409044                          int32_t var_140_74 = 0x90
00409052                          int32_t esi_16
00409052                          int32_t edi_36
00409052                          edi_36, esi_16 = __builtin_memcpy(dest: &var_120, 
00409052                              src: edi_34 - ecx_78, n: ecx_78 u>> 2 << 2)
00409059                          __builtin_memcpy(dest: edi_36, src: esi_16, n: ecx_78 & 3)
0040905f                          var_144 = &var_120
00409060                          sub_4144f0(var_144, var_140_74)
00409065                          int32_t* edi_37 = &var_120
00409069                          int32_t j_13 = 0xffffffff
00409069                          
00409074                          while (j_13 != 0)
00409074                              bool cond:20_1 = 0 != *edi_37
00409074                              edi_37 += 1
00409074                              j_13 -= 1
00409074                              
00409074                              if (not(cond:20_1))
00409074                                  break
00409074                          
0040907f                          sub_40fe50(&i_4[0x208], &var_144 + not.d(j_13) - 1 + 0x24)
00409084                          char* edi_38 = ".bsp"
00409089                          int32_t j_14 = 0xffffffff
00409089                          
00409092                          while (j_14 != 0)
00409092                              bool cond:21_1 = 0 != *edi_38
00409092                              edi_38 = &edi_38[1]
00409092                              j_14 -= 1
00409092                              
00409092                              if (not(cond:21_1))
00409092                                  break
00409092                          
00409094                          int32_t ecx_84 = not.d(j_14)
0040909a                          int32_t* edi_40 = &var_120
0040909e                          int32_t j_15 = 0xffffffff
0040909e                          
004090a1                          while (j_15 != 0)
004090a1                              bool cond:22_1 = 0 != *edi_40
004090a1                              edi_40 += 1
004090a1                              j_15 -= 1
004090a1                              
004090a1                              if (not(cond:22_1))
004090a1                                  break
004090a1                          
004090a9                          int32_t esi_18
004090a9                          int32_t edi_42
004090a9                          edi_42, esi_18 = __builtin_memcpy(dest: edi_40 - 1, 
004090a9                              src: edi_38 - ecx_84, n: ecx_84 u>> 2 << 2)
004090b4                          int32_t* var_150_4 = &var_120
004090b5                          void* var_154_4 = &i_4[0x208]
004090b6                          char* var_158_4 = "bsp2bsp: %s to %s\n"
004090bb                          __builtin_memcpy(dest: edi_42, src: esi_18, n: ecx_84 & 3)
004090bd                          sub_410030(var_158_4)
004090bd                          
004090ce                          if (*(i_4 + 0x30c) != 2)
004090d0                              void* var_140_75 = &i_4[0x208]
004090d1                              var_144 = "%s is probably not a BSP file\n"
004090d6                              sub_40f9c0(var_144)
004090d6                          
004090e4                          void* eax_86 = *(i_4 + 0x310)
004090ee                          int32_t* var_140_76 = &var_120
004090ef                          var_144 = *(i_4 + 0x314)
004090f8                          sub_408370(&i_4[0x104], eax_86, var_144, var_140_76)
004090f8                          top -= 1
004090f8                          unimplemented  {call sub_408370}
004090fd                          i_4 = *(i_4 + 0x318)
00409108                      while (i_4 != 0)
00409108                      
0040910e                      sub_40ffd0()
0040911f                      return 0
00409122              case 5
00409122                  if (i_6 == 0)
00409129                      sub_410030("no files found\n")
00409129                  
00409133                  char* i_5 = i_6
00409133                  
00409135                  if (i_6 != 0)
00409224                      do
0040913b                          char* edi_43 = &var_90
00409142                          int32_t j_16 = 0xffffffff
00409142                          
0040914b                          while (j_16 != 0)
0040914b                              bool cond:23_1 = 0 != *edi_43
0040914b                              edi_43 = &edi_43[1]
0040914b                              j_16 -= 1
0040914b                              
0040914b                              if (not(cond:23_1))
0040914b                                  break
0040914b                          
0040914d                          int32_t ecx_90 = not.d(j_16)
00409151                          int32_t var_140_78 = 0x90
0040915f                          int32_t esi_20
0040915f                          int32_t edi_45
0040915f                          edi_45, esi_20 = __builtin_memcpy(dest: &var_120, 
0040915f                              src: edi_43 - ecx_90, n: ecx_90 u>> 2 << 2)
00409166                          __builtin_memcpy(dest: edi_45, src: esi_20, n: ecx_90 & 3)
0040916c                          var_144 = &var_120
0040916d                          sub_4144f0(var_144, var_140_78)
00409172                          int32_t* edi_46 = &var_120
00409176                          int32_t j_17 = 0xffffffff
00409176                          
00409181                          while (j_17 != 0)
00409181                              bool cond:24_1 = 0 != *edi_46
00409181                              edi_46 += 1
00409181                              j_17 -= 1
00409181                              
00409181                              if (not(cond:24_1))
00409181                                  break
00409181                          
0040918c                          sub_40fe50(&i_5[0x208], &var_144 + not.d(j_17) - 1 + 0x24)
00409191                          char* edi_47 = ".aas"
00409196                          int32_t j_18 = 0xffffffff
00409196                          
0040919f                          while (j_18 != 0)
0040919f                              bool cond:25_1 = 0 != *edi_47
0040919f                              edi_47 = &edi_47[1]
0040919f                              j_18 -= 1
0040919f                              
0040919f                              if (not(cond:25_1))
0040919f                                  break
0040919f                          
004091a1                          int32_t ecx_96 = not.d(j_18)
004091a7                          int32_t* edi_49 = &var_120
004091ab                          int32_t j_19 = 0xffffffff
004091ab                          
004091ae                          while (j_19 != 0)
004091ae                              bool cond:26_1 = 0 != *edi_49
004091ae                              edi_49 += 1
004091ae                              j_19 -= 1
004091ae                              
004091ae                              if (not(cond:26_1))
004091ae                                  break
004091ae                          
004091b6                          int32_t esi_22
004091b6                          int32_t edi_51
004091b6                          edi_51, esi_22 = __builtin_memcpy(dest: edi_49 - 1, 
004091b6                              src: edi_47 - ecx_96, n: ecx_96 u>> 2 << 2)
004091c1                          int32_t* var_150_5 = &var_120
004091c2                          void* var_154_5 = &i_5[0x208]
004091c3                          char* var_158_5 = "bsp2aas: %s to %s\n"
004091c8                          __builtin_memcpy(dest: edi_51, src: esi_22, n: ecx_96 & 3)
004091ca                          sub_410030(var_158_5)
004091ca                          
004091db                          if (*(i_5 + 0x30c) != 2)
004091dd                              void* var_140_79 = &i_5[0x208]
004091de                              var_144 = "%s is probably not a BSP file\n"
004091e3                              sub_40f9c0(var_144)
004091e3                          
004091eb                          data_279c334 = 1
004091f5                          void* ecx_101 = *(i_5 + 0x314)
00409208                          var_144 = *(i_5 + 0x310)
0040920a                          sub_416420(&i_5[0x104], var_144, ecx_101)
00409214                          sub_402660(&var_120)
00409219                          i_5 = *(i_5 + 0x318)
00409224                      while (i_5 != 0)
00409224                      
0040922a                      sub_40ffd0()
0040923b                      return 0
0040923b  
00409250  sub_40ffd0()
00409261  return 0

00409262        8b ff                                                                                        ..
00409264  uint32_t jump_table_409264[0x5] = 
00409264  {
00409264      [0x0] =  0x00408cf4
00409268      [0x1] =  0x00408df3
0040926c      [0x2] =  0x00408f01
00409270      [0x3] =  0x00409013
00409274      [0x4] =  0x00409120
00409278  }

00409278                                                                          90 90 90 90 90 90 90 90                          ........

00409280    int32_t* sub_409280(void* arg1)

00409280  int32_t ecx
00409280  int32_t var_4_1 = ecx
00409287  int32_t var_4 = 0
0040928f  int32_t eax = *(arg1 + 0x28)
0040928f  
00409294  if (eax s> 0)
0040929c      void* edi_1 = arg1 + 0x34
0040931f      bool cond:0_1
0040931f      
0040931f      do
0040929f          int32_t i = 0
0040929f          
004092a3          if (eax s> 0)
004092a5              void* esi_1 = arg1 + 0x34
004092a5              
004092fd              do
004092ac                  if (var_4 != i)
004092ae                      int32_t eax_1 = *(edi_1 - 8)
004092cb                      int32_t edx_2 = *(esi_1 - 8) * 7
004092df                      int64_t var_20
004092df                      var_20:4.d = *(eax_1 * 0x1c + &data_239e0cc)
004092e0                      var_20.d = (edx_2 << 2) + &data_239e0c0
004092e0                      
004092f2                      if (sub_412170(*edi_1, *esi_1, eax_1 * 0x1c + &data_239e0c0, var_20, 
004092f2                              *((edx_2 << 2) + &data_239e0cc)) != 0)
00409306                          sub_410030("non convex brush")
0040930b                          break
0040930b                  
004092f7                  i += 1
004092f8                  esi_1 += 0x20
004092fd              while (i s< *(arg1 + 0x28))
004092fd          
00409312          eax = *(arg1 + 0x28)
00409316          edi_1 += 0x20
00409319          cond:0_1 = var_4 + 1 s< eax
0040931b          var_4 += 1
0040931f      while (cond:0_1)
0040931f  
00409328  sub_406550(arg1)
00409330  int32_t i_1 = 0
00409332  void* ecx_8 = arg1 + 0x10
0040937a  int16_t result
0040937a  
0040937a  do
00409335      long double x87_r7_1 = fconvert.t(*(ecx_8 - 0xc))
00409338      long double temp0_1 = fconvert.t(-5000f)
00409338      x87_r7_1 - temp0_1
00409343      long double x87_r7_2
00409343      long double temp1_1
00409343      
00409343      if ((((x87_r7_1 < temp0_1 ? 1 : 0) << 8
00409343              | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
00409343              | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
00409345          x87_r7_2 = fconvert.t(*ecx_8)
00409347          temp1_1 = fconvert.t(5000f)
00409347          x87_r7_2 - temp1_1
00409347      
00409352      char* __saved_ebx_1
00409352      
00409352      if ((((x87_r7_1 < temp0_1 ? 1 : 0) << 8
00409352              | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
00409352              | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) != 0 || ((
00409352              (x87_r7_2 < temp1_1 ? 1 : 0) << 8
00409352              | (is_unordered.t(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
00409352              | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0)
00409387          __saved_ebx_1 = "brush: bounds out of range\n"
00409395          label_409395:
00409395          int32_t __saved_edi = sub_410030(__saved_ebx_1)
00409396          __saved_edi.q = fconvert.d(fconvert.t(*(arg1 + (i_1 << 2) + 0x10)))
0040939d          int32_t i_3 = i_1
004093a1          double var_20_1 = fconvert.d(fconvert.t(*(arg1 + (i_1 << 2) + 4)))
004093a4          int32_t i_2 = i_1
004093b5          return sub_410030("ob->mins[%d] = %f, ob->maxs[%d] …")
004093b5      
00409354      long double x87_r7_3 = fconvert.t(*(ecx_8 - 0xc))
00409357      long double temp2_1 = fconvert.t(5000f)
00409357      x87_r7_3 - temp2_1
00409357      
00409362      if ((((x87_r7_3 < temp2_1 ? 1 : 0) << 8
00409362              | (is_unordered.t(x87_r7_3, temp2_1) ? 1 : 0) << 0xa
00409362              | (x87_r7_3 == temp2_1 ? 1 : 0) << 0xe):1.b & 0x41) != 0)
00409364          long double x87_r7_4 = fconvert.t(*ecx_8)
00409366          long double temp3_1 = fconvert.t(-5000f)
00409366          x87_r7_4 - temp3_1
0040936c          result = (x87_r7_4 < temp3_1 ? 1 : 0) << 8
0040936c              | (is_unordered.t(x87_r7_4, temp3_1) ? 1 : 0) << 0xa
0040936c              | (x87_r7_4 == temp3_1 ? 1 : 0) << 0xe
0040936c      
00409371      if ((((x87_r7_3 < temp2_1 ? 1 : 0) << 8
00409371              | (is_unordered.t(x87_r7_3, temp2_1) ? 1 : 0) << 0xa
00409371              | (x87_r7_3 == temp2_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0 || (result:1.b & 1) != 0)
00409380          __saved_ebx_1 = "brush: no visible sides on brush…"
00409385          goto label_409395
00409385      
00409373      i_1 += 1
00409374      ecx_8 += 4
0040937a  while (i_1 s< 3)
0040937a  
0040937f  return result

004093b6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

004093c0    int32_t sub_4093c0(void* arg1)

004093c0  int32_t ecx
004093c0  int32_t var_4 = ecx
004093c2  void* ebx = arg1
004093c6  int32_t i_1 = 0
004093ce  int32_t i = *(ebx + 0x28)
004093ce  
004093d3  if (i s> 0)
004093dc      void* ebp_1 = ebx + 0x34
004093dc      
0040946d      do
004093e9          int32_t ecx_2 = *(ebp_1 - 8) * 7
004093fb          void* j =
004093fb              sub_410b70((ecx_2 << 2) + &data_239e0c0, *((ecx_2 << 2) + &data_239e0cc))
004093fb          int16_t top = top - 1
004093fb          unimplemented  {call sub_410b70}
00409400          int32_t ecx_3 = *(ebx + 0x28)
00409406          int32_t esi_1 = 0
00409408          arg1 = j
00409408          
0040940e          if (ecx_3 s> 0)
00409410              void* edi_1 = ebx + 0x2c
00409410              
00409415              while (j != 0)
0040941b                  if (i_1 != esi_1)
0040942b                      int32_t ecx_5 = (*edi_1 ^ 1) * 7
00409442                      sub_4111c0(&arg1, (ecx_5 << 2) + &data_239e0c0, 
00409442                          *((ecx_5 << 2) + &data_239e0cc), 0f)
00409442                      top -= 1
00409442                      unimplemented  {call sub_4111c0}
00409447                      j = arg1
00409447                  
00409451                  esi_1 += 1
00409452                  edi_1 += 0x20
00409452                  
00409457                  if (esi_1 s>= *(ebx + 0x28))
00409457                      break
00409457          
00409459          *ebp_1 = j
00409463          i = i_1 + 1
00409464          ebp_1 += 0x20
00409469          i_1 = i
0040946d      while (i s< *(ebx + 0x28))
0040946d  
00409478  return i

00409479                                                                             90 90 90 90 90 90 90                           .......

00409480    void* sub_409480(void* arg1, void* arg2)

00409483  int32_t i = 0
00409486  void* ebx = arg1
0040948b  void* ebp = arg2
00409493  float* esi = ebp + 4
00409496  void* ecx = ebx + 0x10
00409496  
004094d1  do
0040949e      long double x87_r7_2 = fconvert.t(*(ebp - ebx + ecx)) + fconvert.t(2f)
004094a4      long double temp0_1 = fconvert.t(*(ecx - 0xc))
004094a4      x87_r7_2 - temp0_1
004094ac      long double x87_r7_4
004094ac      long double temp1_1
004094ac      
004094ac      if ((((x87_r7_2 < temp0_1 ? 1 : 0) << 8
004094ac              | (is_unordered.t(x87_r7_2, temp0_1) ? 1 : 0) << 0xa
004094ac              | (x87_r7_2 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
004094b4          x87_r7_4 = fconvert.t(*esi) - fconvert.t(2f)
004094ba          temp1_1 = fconvert.t(*ecx)
004094ba          x87_r7_4 - temp1_1
004094ba      
004094c1      if ((((x87_r7_2 < temp0_1 ? 1 : 0) << 8
004094c1              | (is_unordered.t(x87_r7_2, temp0_1) ? 1 : 0) << 0xa
004094c1              | (x87_r7_2 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) != 0 || ((
004094c1              (x87_r7_4 < temp1_1 ? 1 : 0) << 8
004094c1              | (is_unordered.t(x87_r7_4, temp1_1) ? 1 : 0) << 0xa
004094c1              | (x87_r7_4 == temp1_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0)
00409671          label_409671:
00409671          return 0
00409671      
004094c7      i += 1
004094c8      ecx += 4
004094cb      esi = &esi[1]
004094d1  while (i s< 3)
004094d1  
004094da  int32_t var_4_1 = 0
004094de  int32_t i_5 = 0
004094de  
004094e2  if (*(ebx + 0x28) s> 0)
004094e8      void* ebx_1 = ebx + 0x2c
004095ee      int32_t i_1
004095ee      
004095ee      do
004094eb          int32_t edx = *(ebp + 0x28)
004094ee          int32_t ecx_2 = 0
004094ee          
004094f2          if (edx s> 0)
004094f6              void* eax_1 = ebp + 0x2c
004094f6              
00409508              do
00409500                  if (*ebx_1 == (*eax_1 ^ 1))
00409511                      bool cond:1_1 = var_4_1 + 1 s> 1
00409514                      var_4_1 += 1
00409514                      
00409518                      if (cond:1_1)
00409518                          goto label_409671
00409518                      
00409518                      goto label_40951e
00409518                  
00409502                  ecx_2 += 1
00409503                  eax_1 += 0x20
00409508              while (ecx_2 s< edx)
00409508          
0040951e          label_40951e:
0040951e          
00409520          if (ecx_2 s>= edx)
00409526              int32_t j = 0
00409526              
0040952a              if (edx s> 0)
00409534                  int32_t* esi_2 = arg2 + 0x2c
00409534                  
004095cf                  do
0040953b                      int32_t eax_5 = 0
0040953d                      int32_t edx_1 = *(arg1 + 0x28)
0040953d                      
00409542                      if (edx_1 s> 0)
00409549                          void* ecx_4 = arg1 + 0x2c
00409549                          
0040954e                          while (*ecx_4 != (*esi_2 ^ 1))
00409550                              eax_5 += 1
00409551                              ecx_4 += 0x20
00409551                              
00409556                              if (eax_5 s>= edx_1)
00409556                                  break
00409556                      
0040955a                      if (eax_5 s>= edx_1)
0040955c                          int32_t eax_6 = *ebx_1
0040955e                          int32_t ecx_5 = *esi_2
0040955e                          
00409562                          if (eax_6 != ecx_5)
00409595                              int32_t edx_5 = ecx_5 * 7
00409595                              
004095be                              if (sub_412170(*(ebx_1 + 8), esi_2[2], 
004095be                                      eax_6 * 0x1c + &data_239e0c0, 
004095be                                      (edx_5 << 2) + &data_239e0c0, 
004095be                                      *(eax_6 * 0x1c + &data_239e0cc), 
004095be                                      *((edx_5 << 2) + &data_239e0cc)) != 0)
00409671                                  return 0
00409562                          else
00409564                              int32_t ecx_6 = *(ebx_1 + 4)
00409564                              
0040956a                              if (ecx_6 != 0xffffffff)
0040956c                                  int32_t eax_7 = esi_2[1]
0040956c                                  
00409576                                  if (eax_7 != 0xffffffff && ecx_6 != eax_7)
00409671                                      return 0
00409671                      
004095c8                      j += 1
004095c9                      esi_2 = &esi_2[8]
004095cf                  while (j s< *(arg2 + 0x28))
004095cf              
004095d5              ebp = arg2
004095d5          
004095e1          i_1 = i_5 + 1
004095e2          ebx_1 += 0x20
004095e8          i_5 = i_1
004095ee      while (i_1 s< *(arg1 + 0x28))
004095f4      ebx = arg1
004095f4  
004095ff  void* result = sub_4068f0(*(ebx + 0x28) + *(ebp + 0x28))
00409604  void* ebx_2 = arg1
0040960a  int32_t i_2 = 0
0040960f  int32_t eax_12 = *(ebx_2 + 0x24)
00409612  *(result + 0x28) = 0
00409615  *(result + 0x24) = eax_12
0040961d  void* edi_7
0040961d  
0040961d  if (*(ebx_2 + 0x28) s<= 0)
00409672      edi_7 = arg2
0040961d  else
0040961f      void* ecx_10 = ebx_2 + 0x2c
0040961f      
00409664      do
00409622          edi_7 = arg2
00409626          int32_t j_1 = 0
00409626          
0040962d          if (*(edi_7 + 0x28) s> 0)
0040962f              void* eax_15 = edi_7 + 0x30
0040962f              
00409657              do
00409637                  if (*ecx_10 == *(eax_15 - 4))
0040963d                      if (*(ecx_10 + 4) == 0xffffffff)
00409641                          *(ecx_10 + 4) = *eax_15
00409641                      
00409647                      if (*eax_15 == 0xffffffff)
0040964c                          *eax_15 = *(ecx_10 + 4)
0040964c                  
00409651                  j_1 += 1
00409652                  eax_15 += 0x20
00409657              while (j_1 s< *(edi_7 + 0x28))
00409657          
00409659          ebx_2 = arg1
0040965d          i_2 += 1
0040965e          ecx_10 += 0x20
00409664      while (i_2 s< *(ebx_2 + 0x28))
00409664  
00409679  int32_t i_6 = 0
00409679  
00409683  if (*(ebx_2 + 0x28) s> 0)
00409689      void* ebx_7 = ebx_2 + 0x2c
00409712      int32_t i_3
00409712      
00409712      do
0040968c          int32_t edx_12 = *(edi_7 + 0x28)
0040968f          int32_t ecx_11 = 0
0040968f          
00409693          if (edx_12 s> 0)
00409697              void* eax_18 = edi_7 + 0x2c
00409697              
004096a1              while (*ebx_7 != (*eax_18 ^ 1))
004096a3                  ecx_11 += 1
004096a4                  eax_18 += 0x20
004096a4                  
004096a9                  if (ecx_11 s>= edx_12)
004096a9                      break
004096a9              
004096ab              edi_7 = arg2
004096ab          
004096b1          if (ecx_11 s>= edx_12)
004096b3              int32_t ecx_12 = *(result + 0x28)
004096b6              int32_t esi_4 = 0
004096b6              
004096ba              if (ecx_12 s> 0)
004096be                  void* eax_19 = result + 0x2c
004096be                  
004096cb                  do
004096c3                      if (*eax_19 == *ebx_7)
004096d4                          sub_410030("brush duplicate plane\n")
004096d9                          break
004096d9                      
004096c5                      esi_4 += 1
004096c6                      eax_19 += 0x20
004096cb                  while (esi_4 s< ecx_12)
004096cb              
004096dc              int32_t eax_20 = *(result + 0x28)
004096dc              
004096e1              if (esi_4 s>= eax_20)
004096f4                  *(result + 0x28) = eax_20 + 1
004096f7                  __builtin_memcpy(dest: (eax_20 << 5) + result + 0x2c, src: ebx_7, n: 0x20)
004096f9                  edi_7 = arg2
004096f9          
00409705          i_3 = i_6 + 1
00409706          ebx_7 += 0x20
0040970c          i_6 = i_3
00409712      while (i_3 s< *(arg1 + 0x28))
00409712  
0040971b  int32_t i_7 = 0
0040971b  
00409725  if (*(edi_7 + 0x28) s> 0)
0040972b      void* ebx_8 = edi_7 + 0x2c
004097b6      int32_t i_4
004097b6      
004097b6      do
00409732          int32_t edx_15 = 0
00409734          int32_t edi_11 = *(arg1 + 0x28)
00409734          
00409739          if (edi_11 s> 0)
0040973b              int32_t esi_6 = *ebx_8
0040973f              void* ecx_17 = arg1 + 0x2c
0040973f              
00409755              do
00409742                  int32_t eax_25 = *ecx_17
00409742                  
00409746                  if (esi_6 == eax_25)
00409746                      break
00409746                  
0040974d                  if (esi_6 == (eax_25 ^ 1))
0040974d                      break
0040974d                  
0040974f                  edx_15 += 1
00409750                  ecx_17 += 0x20
00409755              while (edx_15 s< edi_11)
00409755          
00409759          if (edx_15 s>= edi_11)
0040975b              int32_t ecx_18 = *(result + 0x28)
0040975e              int32_t esi_7 = 0
0040975e              
00409762              if (ecx_18 s> 0)
00409766                  void* eax_27 = result + 0x2c
00409766                  
00409773                  do
0040976b                      if (*eax_27 == *ebx_8)
0040977c                          sub_410030("brush duplicate plane\n")
00409781                          break
00409781                      
0040976d                      esi_7 += 1
0040976e                      eax_27 += 0x20
00409773                  while (esi_7 s< ecx_18)
00409773              
00409784              int32_t eax_28 = *(result + 0x28)
00409784              
00409789              if (esi_7 s>= eax_28)
0040979c                  *(result + 0x28) = eax_28 + 1
0040979f                  __builtin_memcpy(dest: (eax_28 << 5) + result + 0x2c, src: ebx_8, n: 0x20)
0040979f          
004097a9          i_4 = i_7 + 1
004097aa          ebx_8 += 0x20
004097b0          i_7 = i_4
004097b6      while (i_4 s< *(arg2 + 0x28))
004097b6  
004097bd  sub_4093c0(result)
004097c3  sub_406550(result)
004097c9  sub_409280(result)
004097da  return result

004097db                                                                                   90 90 90 90 90                             .....

004097e0    int32_t* sub_4097e0(void* arg1, int32_t arg2, void** arg3, int32_t* arg4)

004097fc  return sub_4074d0(arg1, arg2, arg3, arg4)

004097fd                                                                                         90 90 90                               ...

00409800    void* sub_409800(void* arg1, void** arg2)

00409805  void** ebp = arg2
0040980a  void* esi = arg1
00409812  int32_t i = 0
00409816  void** var_8 = nullptr
00409816  
0040981a  if (ebp[0xa] s> 0)
0040981c      void* ebx_1 = &ebp[0xb]
0040981c      
0040986d      do
00409821          if (esi == 0)
00409821              goto label_40988d
00409821          
00409831          void* var_4
00409831          sub_4097e0(esi, *ebx_1, &arg2, &var_4)
00409831          
0040983f          if (esi != arg1)
00409842              sub_406960(esi)
00409842          
0040984a          void** eax_2 = arg2
0040984a          
00409850          if (eax_2 != 0)
00409856              *eax_2 = var_8
0040985c              var_8 = arg2
0040985c          
00409863          esi = var_4
00409867          i += 1
00409868          ebx_1 += 0x20
0040986d      while (i s< ebp[0xa])
0040986d  
00409871  if (esi != 0)
00409874      sub_406960(esi)
00409887      return var_8
00409887  
0040988d  label_40988d:
0040988d  sub_4069e0(var_8)
004098a0  return arg1

004098a1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

004098b0    int32_t sub_4098b0(void* arg1, void* arg2)

004098b2  void* ebp = arg2
004098b8  void* edi = arg1
004098be  int32_t i = 0
004098c0  float* esi = ebp + 4
004098c3  float* ecx = edi + 0x10
004098c3  
004098ea  do
004098c8      long double x87_r7_1 = fconvert.t(ecx[-3])
004098cb      long double temp0_1 = fconvert.t(*(ebp - edi + ecx))
004098cb      x87_r7_1 - temp0_1
004098d3      long double x87_r7_2
004098d3      long double temp1_1
004098d3      
004098d3      if ((((x87_r7_1 < temp0_1 ? 1 : 0) << 8
004098d3              | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
004098d3              | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
004098d5          x87_r7_2 = fconvert.t(*ecx)
004098d7          temp1_1 = fconvert.t(*esi)
004098d7          x87_r7_2 - temp1_1
004098d7      
004098de      if ((((x87_r7_1 < temp0_1 ? 1 : 0) << 8
004098de              | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
004098de              | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) == 0 || ((
004098de              (x87_r7_2 < temp1_1 ? 1 : 0) << 8
004098de              | (is_unordered.t(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
004098de              | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe):1.b & 0x41) != 0)
0040993b          return 1
0040993b      
004098e0      i += 1
004098e1      ecx = &ecx[1]
004098e4      esi = &esi[1]
004098ea  while (i s< 3)
004098ea  
004098ec  void* eax_1 = *(edi + 0x28)
004098ef  int32_t ebx_2 = 0
004098f3  arg1 = eax_1
004098f3  
004098f7  if (eax_1 s> 0)
004098f9      int32_t esi_1 = *(ebp + 0x28)
004098fc      void* edi_1 = edi + 0x2c
004098fc      
00409929      do
004098ff          int32_t ecx_1 = 0
004098ff          
00409903          if (esi_1 s> 0)
00409907              void* eax_2 = ebp + 0x2c
00409907              
00409919              do
00409911                  if (*edi_1 == (*eax_2 ^ 1))
0040993b                      return 1
0040993b                  
00409913                  ecx_1 += 1
00409914                  eax_2 += 0x20
00409919              while (ecx_1 s< esi_1)
00409919              
0040991b              ebp = arg2
0040991f              eax_1 = arg1
0040991f          
00409923          ebx_2 += 1
00409924          edi_1 += 0x20
00409929      while (ebx_2 s< eax_1)
00409929  
00409931  return 0

0040993c                                                                                      90 90 90 90                              ....

00409940    void* sub_409940(void* arg1, void* arg2, void* arg3)

00409943  void* eax = arg3
0040995e  float* edx_1 = arg2 - eax
00409960  void* ecx = 0x10 - eax
00409967  void* edi = &data_279bab0 - eax
00409969  void* ebp = 4 - eax
0040996f  void* result = arg1
00409973  void* var_c = nullptr
0040997b  float* esi = eax
0040997d  void* var_8 = ecx
00409981  void* ebx = &data_279baa0 - eax
00409981  
0040998b  while (true)
0040998b      long double x87_r7_1 = fconvert.t(*(ecx + esi + result))
0040998e      long double temp0_1 = fconvert.t(*esi)
0040998e      x87_r7_1 - temp0_1
00409990      eax.w = (x87_r7_1 < temp0_1 ? 1 : 0) << 8
00409990          | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
00409990          | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe
00409990      
00409995      if ((eax:1.b & 0x41) == 0)
004099a6          sub_4074d0(result, *(edi + esi), &arg2, &arg3)
004099ab          void* eax_2 = arg2
004099ab          
004099b4          if (eax_2 != 0)
004099b7              sub_406960(eax_2)
004099b7          
004099bf          result = arg3
004099bf      
004099c5      if ((eax:1.b & 0x41) == 0 && result == 0)
00409a81          return 0
00409a81      
004099d2      long double x87_r7_2 = fconvert.t(*(esi + ebp + result))
004099d5      long double temp1_1 = fconvert.t(*(edx_1 + esi))
004099d5      x87_r7_2 - temp1_1
004099d8      float* eax_3
004099d8      eax_3.w = (x87_r7_2 < temp1_1 ? 1 : 0) << 8
004099d8          | (is_unordered.t(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
004099d8          | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe
004099d8      
004099dd      if ((eax_3:1.b & 1) != 0)
004099ee          sub_4074d0(result, *(ebx + esi), &arg2, &arg3)
004099f3          void* eax_4 = arg3
004099f3          
004099fc          if (eax_4 != 0)
004099ff              sub_406960(eax_4)
004099ff          
00409a07          result = arg2
00409a07          
00409a0d          if (result == 0)
00409a81              return 0
00409a81      
00409a13      esi = &esi[1]
00409a17      bool cond:0_1 = var_c + 1 s< 2
00409a1a      var_c += 1
00409a1a      
00409a1e      if (not(cond:0_1))
00409a1e          break
00409a1e      
00409985      ecx = var_8
00409985  
00409a27  int32_t i = 0
00409a27  
00409a2b  if (*(result + 0x28) s> 0)
00409a2d      void* eax_7 = result + 0x48
00409a2d      
00409a6c      do
00409a3c          int32_t ecx_5 = *(eax_7 - 0x1c) & 0xfffffffe
00409a3c          
00409a59          if (ecx_5 == data_279bab0 || ecx_5 == data_279bab4 || ecx_5 == data_279baa0
00409a59                  || ecx_5 == data_279baa4)
00409a5b              *(eax_7 - 0x18) = 0xffffffff
00409a5e              *eax_7 &= 0xfffd
00409a5e          
00409a66          i += 1
00409a67          eax_7 += 0x20
00409a6c      while (i s< *(result + 0x28))
00409a6c  
00409a77  return result

00409a82        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00409a90    void* sub_409a90(void* arg1, void* arg2, float* arg3, void* arg4)

00409a96  int32_t* esi = arg4
00409aad  float var_c
00409aad  void* ebx = &var_c - esi
00409aaf  void* ebp = &data_279bab0 - esi
00409ab1  float* edi_1 = arg3 - esi
00409ab3  void* eax = &data_279baa0 - esi
00409ab5  int32_t var_18 = 2
00409b22  bool cond:0_1
00409b22  
00409b22  do
00409ac1      int32_t eax_1 = *esi
00409ac9      int32_t var_4_1 = 0
00409ad1      int32_t var_30_1 = eax_1
00409ad2      int32_t var_8_1 = 0
00409ada      var_c = 0f
00409ae3      *(ebx + esi) = 0x3f800000
00409aea      int32_t var_1c_1 = eax_1
00409af3      *(esi + ebp) = sub_414ae0(&var_c)
00409b05      float var_38_1 = fconvert.s(fconvert.t(*(edi_1 + esi)))
00409b13      *(eax + esi) = sub_414ae0(&var_c)
00409b1a      esi = &esi[1]
00409b1d      cond:0_1 = var_18 != 1
00409b1e      var_18 -= 1
00409b22  while (cond:0_1)
00409b30  void* result = nullptr
00409b34  void* var_18_1 = nullptr
00409b34  
00409b38  if (arg1 s>= arg2)
00409cac      return 0
00409cac  
00409b43  void* var_14_1 = arg2 - arg1
00409b4a  void* esi_1 = arg1 * 0x34 + &data_4b6030
00409b51  arg2 = esi_1
00409c91  bool cond:2_1
00409c91  
00409c91  do
00409b55      int32_t i_5 = *(esi_1 - 4)
00409b55      
00409b61      if (i_5 != 0)
00409b67          void* edx_4 = nullptr
00409b6b          arg1 = nullptr
00409b6f          void* eax_7
00409b6f          
00409b6f          if (i_5 s> 0)
00409b73              int32_t i_3 = i_5
00409b75              eax_7 = *esi_1 + 8
00409b88              int32_t i
00409b88              
00409b88              do
00409b81                  if ((*(eax_7 + 0x14) & 2) != 0 && *eax_7 != 0)
00409b83                      edx_4 += 1
00409b83                  
00409b84                  eax_7 += 0x20
00409b87                  i = i_3
00409b87                  i_3 -= 1
00409b88              while (i != 1)
00409b8a              arg1 = edx_4
00409b8a          
00409b8e          float* edx_5 = arg3
00409b96          int32_t i_1 = 0
00409b98          void* ecx_4 = esi_1 - 0x10
00409b9b          void* ebp_2 = arg4 - edx_5
00409b9b          
00409bbf          do
00409b9d              long double x87_r7_2 = fconvert.t(*(ecx_4 - 0xc))
00409ba0              long double temp2_1 = fconvert.t(*(edx_5 + ebp_2))
00409ba0              x87_r7_2 - temp2_1
00409ba3              eax_7.w = (x87_r7_2 < temp2_1 ? 1 : 0) << 8
00409ba3                  | (is_unordered.t(x87_r7_2, temp2_1) ? 1 : 0) << 0xa
00409ba3                  | (x87_r7_2 == temp2_1 ? 1 : 0) << 0xe
00409ba3              
00409ba8              if ((eax_7:1.b & 1) == 0)
00409ba8                  break
00409ba8              
00409baa              long double x87_r7_3 = fconvert.t(*ecx_4)
00409bac              long double temp3_1 = fconvert.t(*edx_5)
00409bac              x87_r7_3 - temp3_1
00409bae              eax_7.w = (x87_r7_3 < temp3_1 ? 1 : 0) << 8
00409bae                  | (is_unordered.t(x87_r7_3, temp3_1) ? 1 : 0) << 0xa
00409bae                  | (x87_r7_3 == temp3_1 ? 1 : 0) << 0xe
00409bae              
00409bb3              if ((eax_7:1.b & 0x41) != 0)
00409bb3                  break
00409bb3              
00409bb5              i_1 += 1
00409bb6              ecx_4 += 4
00409bb9              edx_5 = &edx_5[1]
00409bbf          while (i_1 s< 3)
00409bbf          
00409bc4          if (i_1 == 3)
00409bce              void* eax_10 = sub_4068f0(*(esi_1 - 4))
00409bdc              *(eax_10 + 0x24) = esi_1 - 0x30
00409be2              *(eax_10 + 0x28) = *(esi_1 - 4)
00409bed              int32_t ecx_7 = i_5 << 5
00409bf5              int32_t esi_3
00409bf5              int32_t edi_3
00409bf5              edi_3, esi_3 =
00409bf5                  __builtin_memcpy(dest: eax_10 + 0x2c, src: *esi_1, n: ecx_7 u>> 2 << 2)
00409bfe              __builtin_memcpy(dest: edi_3, src: esi_3, n: ecx_7 & 3)
00409bfe              
00409c00              if (i_5 s> 0)
00409c02                  void* esi_4 = eax_10 + 0x34
00409c05                  int32_t i_4 = i_5
00409c28                  int32_t i_2
00409c28                  
00409c28                  do
00409c07                      int32_t* eax_12 = *esi_4
00409c07                      
00409c0b                      if (eax_12 != 0)
00409c16                          *esi_4 = sub_410dd0(eax_12)
00409c16                      
00409c1e                      if (((*(esi_4 + 0x10)).w:1.b & 1) != 0)
00409c20                          *(esi_4 + 0x14) |= 2
00409c20                      
00409c24                      esi_4 += 0x20
00409c27                      i_2 = i_4
00409c27                      i_4 -= 1
00409c28                  while (i_2 != 1)
00409c28              
00409c2d              *(eax_10 + 4) = *(esi_1 - 0x1c)
00409c33              *(eax_10 + 8) = *(esi_1 - 0x18)
00409c39              *(eax_10 + 0xc) = *(esi_1 - 0x14)
00409c3f              *(eax_10 + 0x10) = *(esi_1 - 0x10)
00409c49              *(eax_10 + 0x14) = *(esi_1 - 0xc)
00409c56              *(eax_10 + 0x18) = *(esi_1 - 8)
00409c59              void* result_1 = sub_409940(eax_10, arg3, arg4)
00409c59              
00409c63              if (result_1 != 0)
00409c6f                  var_18_1 += arg1
00409c77                  *result_1 = result
00409c79                  result = result_1
00409c79      
00409c85      esi_1 = arg2 + 0x34
00409c88      cond:2_1 = var_14_1 != 1
00409c89      arg2 = esi_1
00409c8d      var_14_1 -= 1
00409c91  while (cond:2_1)
00409ca2  return result

00409cad                                         90 90 90                                                               ...

00409cb0    int32_t* sub_409cb0(int32_t* arg1, int32_t* arg2)

00409cb0  int32_t* ecx = arg1
00409cb4  int32_t* result = arg2
00409cb4  
00409cba  if (ecx != 0)
00409ccc      int32_t* i
00409ccc      
00409ccc      do
00409cbc          i = *ecx
00409cbe          *ecx = 0
00409cc4          *result = ecx
00409cc6          result = ecx
00409cca          ecx = i
00409ccc      while (i != 0)
00409ccc  
00409cce  return result

00409ccf                                               90                                                                 .

00409cd0    int32_t* sub_409cd0(int32_t* arg1, int32_t arg2)

00409cd0  int32_t* eax = arg1
00409cd5  int32_t* result = nullptr
00409cd5  
00409cd9  if (eax == 0)
00409d05      return 0
00409d05  
00409cfa  int32_t* i
00409cfa  
00409cfa  do
00409ce1      i = *eax
00409ce1      
00409ce5      if (eax != arg2)
00409cf2          *eax = result
00409cf4          result = eax
00409ce5      else
00409ce8          sub_406960(eax)
00409ce8      
00409cf8      eax = i
00409cfa  while (i != 0)
00409d01  return result

00409d06                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00409d10    int32_t sub_409d10(void* arg1, void* arg2)

00409d22  if (data_279c334 != 0)
00409d24      void* eax = *(arg1 + 0x24)
00409d27      void* ecx_1 = *(arg2 + 0x24)
00409d27      
00409d32      if (*(eax + 0xc) != *(ecx_1 + 0xc))
00409d39          return 0
00409d39      
00409d49      if ((0x20000000 & *(eax + 8)) != 0 && (*(ecx_1 + 8) & 0x20000000) == 0)
00409d50          return 0
00409d50  
00409d54  int32_t eax_4 = *(*(arg1 + 0x24) + 8)
00409d54  
00409d68  if ((eax_4 & 0x8000000) != 0 && (*(*(arg2 + 0x24) + 8) & 0x8000000) == 0)
00409d6f      return 0
00409d6f  
00409d79  return sx.d(eax_4.b) & 1

00409d7a                                                                                90 90 90 90 90 90                            ......

00409d80    int32_t* sub_409d80(int32_t* arg1)

00409d8c  sub_410030("-------- Brush CSG ---------\n")
00409d91  int32_t* i = arg1
00409d9b  int32_t var_30 = sub_406860(i)
00409da1  sub_410030("%6d original brushes\n")
00409da8  int32_t var_38 = 0
00409dae  int32_t var_10 = 0
00409db2  sub_40fa00("%6d output brushes")
00409dbc  arg1 = nullptr
00409dc0  int32_t* i_2
00409dc0  
00409dc0  for (; i != 0; i = i_2)
00409dc6      int32_t* j = *i
00409dc8      int32_t* var_14_1 = i
00409dc8      
00409dce      for (; j != 0; j = *j)
00409dd0          var_14_1 = j
00409dd0      
00409ddc      int32_t* i_4
00409ddc      int32_t* i_3
00409ddc      
00409ddc      while (true)
00409ddc          if (i == 0)
00409f72              if (data_279bf00 == 0)
00409f78                  int32_t var_28_17 = var_10
00409f7e                  sub_410030("\r%6d output brushes\n")
00409f7e              
00409f91              return arg1
00409f91          
00409de7          i_3 = *i
00409deb          i_4 = i_3
00409deb          
00409def          if (data_279bf00 == 0)
00409e01              if (i_3 != 0)
00409e01                  break
00409e01              
00409ed9              label_409ed9:
00409ed9              *i = arg1
00409edb              int32_t var_28_10 = var_10 + 1
00409ee1              arg1 = i
00409ee5              var_10 += 1
00409ee9              sub_40fa00("\r%6d")
00409ef1              i = i_3
00409def          else
00409df1              int32_t* eax_2 = arg1
00409df5              arg1 = i
00409df9              *i = eax_2
00409dfb              i = i_3
00409dfb      
00409e09      while (true)
00409e13          if (sub_4098b0(i, i_3) == 0)
00409e20              int32_t* ebp_1 = nullptr
00409e22              void* ebx_1 = nullptr
00409e24              int32_t var_c_1 = 0xf423f
00409e24              
00409e36              if (sub_409d10(i_3, i) == 0)
00409e5f                  label_409e5f:
00409e69                  int32_t eax_9
00409e69                  
00409e69                  if (sub_409d10(i, i_3) == 0)
00409e8e                      eax_9 = 0xf423f
00409e92                      label_409e92:
00409e92                      
00409e98                      if (ebp_1 != 0 || ebx_1 != 0)
00409ea6                          if (var_c_1 s<= 1 || eax_9 s<= 1)
00409f18                              int32_t* i_1
00409f18                              
00409f18                              if (var_c_1 s>= eax_9)
00409f37                                  if (ebp_1 != 0)
00409f3a                                      sub_4069e0(ebp_1)
00409f3a                                  
00409f48                                  sub_409cb0(ebx_1, var_14_1)
00409f4d                                  i_1 = i_3
00409f18                              else
00409f1c                                  if (ebx_1 != 0)
00409f1f                                      sub_4069e0(ebx_1)
00409f1f                                  
00409f2d                                  sub_409cb0(ebp_1, var_14_1)
00409f32                                  i_1 = i
00409f32                              
00409f4f                              i_2 = sub_409cd0(i, i_1)
00409f54                              break
00409f54                          
00409eaa                          if (ebx_1 != 0)
00409ead                              sub_4069e0(ebx_1)
00409ead                          
00409eb7                          if (ebp_1 != 0)
00409eba                              sub_4069e0(ebp_1)
00409e69                  else
00409e72                      ebx_1 = sub_409800(i_3, i)
00409e72                      
00409e79                      if (ebx_1 != i_3)
00409e7d                          if (ebx_1 != 0)
00409e84                              eax_9 = sub_406860(ebx_1)
00409e7d                              goto label_409e92
00409e7d                          
00409f05                          sub_4069e0(ebp_1)
00409f0c                          i_2 = sub_409cd0(i, i_3)
00409f14                          break
00409e36              else
00409e3f                  ebp_1 = sub_409800(i, i_3)
00409e3f                  
00409e46                  if (ebp_1 != i)
00409e4a                      if (ebp_1 != 0)
00409e59                          var_c_1 = sub_406860(ebp_1)
00409e4a                          goto label_409e5f
00409e4a                      
00409efa                      i_2 = sub_409cd0(i, i)
00409f02                      break
00409f02          
00409ec2          i_3 = *i_3
00409ec2          
00409ec6          if (i_3 == 0)
00409ecc              i_3 = i_4
00409ecc              goto label_409ed9
00409ecc  
00409f6a  return 0

00409f92                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00409fa0    void** sub_409fa0(void* arg1, void* arg2)

00409faf  float var_c = fconvert.s(fconvert.t(data_255e0f0) - fconvert.t(8f))
00409fbf  float var_8 = fconvert.s(fconvert.t(data_255e0f4) - fconvert.t(8f))
00409fcf  float var_4 = fconvert.s(fconvert.t(data_255e0f8) - fconvert.t(8f))
00409fdf  float var_18 = fconvert.s(fconvert.t(data_255e0d0) + fconvert.t(8f))
00409fef  float var_14 = fconvert.s(fconvert.t(data_255e0d4) + fconvert.t(8f))
00409fff  float var_10 = fconvert.s(fconvert.t(data_255e0d8) + fconvert.t(8f))
0040a003  sub_4064c0()
0040a008  tytiNil::()
0040a021  float eax_1 = sub_409a90(arg1, arg2, &var_c, &var_18)
0040a021  
0040a02b  if (eax_1 == 0)
0040a02e      void* eax_2 = sub_4068b0()
0040a035      *eax_2 = 0xffffffff
0040a03b      *(eax_2 + 0x3c) = 1
0040a042      void** eax_3 = sub_406880()
0040a047      *eax_3 = eax_2
0040a04d      eax_3[0x18] = var_c
0040a054      eax_3[0x19] = var_8
0040a05b      eax_3[0x1a] = var_4
0040a062      eax_3[0x1b] = var_18
0040a069      eax_3[0x1c] = var_14
0040a070      eax_3[0x1d] = var_10
0040a077      return eax_3
0040a077  
0040a080  if (data_279bef0 == 0)
0040a083      eax_1 = sub_409d80(eax_1)
0040a083  
0040a093  if (data_279bf00 == 0)
0040a0af      int32_t eax_5
0040a0af      int80_t st0
0040a0af      st0, eax_5 = sub_407da0(eax_1, &var_c, &var_18)
0040a0ba      return eax_5
0040a0ba  
0040a096  sub_4069e0(eax_1)
0040a0a3  return 0

0040a0bb                                                                                   90 90 90 90 90                             .....

0040a0c0    int32_t sub_40a0c0(float* arg1)

0040a0ce  int32_t eax
0040a0ce  int16_t x87control
0040a0ce  int16_t x87control_1
0040a0ce  eax, x87control_1 = __ftol(x87control, fconvert.t(*arg1) + fconvert.t(0.5))
0040a0e4  int32_t esi_2 = (eax + 0x1000) s>> 7
0040a0f4  int32_t edi_3 =
0040a0f4      (__ftol(x87control_1, fconvert.t(arg1[1]) + fconvert.t(0.5)) + 0x1000) s>> 7
0040a0f4  
0040a107  if (esi_2 s< 0 || esi_2 s>= 0x40 || edi_3 s< 0 || edi_3 s>= 0x40)
0040a10e      sub_40f970("HashVec: point outside valid ran…")
0040a10e  
0040a11f  return (edi_3 << 6) + esi_2


0040a120    int32_t sub_40a120(float arg1)

0040a12c  int32_t* esi = arg1
0040a135  data_275ba68 += 1
0040a13b  float var_c
0040a13b  void* edi = &var_c - esi
0040a13d  int32_t i_2 = 3
0040a181  int32_t i
0040a181  
0040a181  do
0040a142      float eax_1 = *esi
0040a157      long double x87_r7_3 = fabs(fconvert.t(eax_1) - sub_4103c0(eax_1))
0040a159      long double temp0_1 = fconvert.t(0.01)
0040a159      x87_r7_3 - temp0_1
0040a159      
0040a164      if ((((x87_r7_3 < temp0_1 ? 1 : 0) << 8
0040a164              | (is_unordered.t(x87_r7_3, temp0_1) ? 1 : 0) << 0xa
0040a164              | (x87_r7_3 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
0040a17a          *(edi + esi) = *esi
0040a164      else
0040a170          *(edi + esi) = fconvert.s(sub_4103c0(eax_1))
0040a170      
0040a17d      esi = &esi[1]
0040a180      i = i_2
0040a180      i_2 -= 1
0040a181  while (i != 1)
0040a188  int32_t eax_4 = sub_40a0c0(&var_c)
0040a18d  int32_t edi_1 = data_2584ed4
0040a193  int32_t esi_1 = eax_4
0040a1a1  float var_8
0040a1a1  float var_4
0040a1a1  
0040a1a1  for (int32_t i_1 = *((esi_1 << 2) + &data_2757a60); i_1 != 0; 
0040a1a1          i_1 = *((i_1 << 2) + &data_275ba80))
0040a1a3      int32_t edx_2 = i_1 * 3
0040a1ad      void* edx_3 = edi_1 + (edx_2 << 2)
0040a1b0      long double x87_r7_7 = fabs(fconvert.t(*(edi_1 + (edx_2 << 2))) - fconvert.t(var_c))
0040a1b2      long double temp2_1 = fconvert.t(0.5)
0040a1b2      x87_r7_7 - temp2_1
0040a1b8      eax_4.w = (x87_r7_7 < temp2_1 ? 1 : 0) << 8
0040a1b8          | (is_unordered.t(x87_r7_7, temp2_1) ? 1 : 0) << 0xa
0040a1b8          | (x87_r7_7 == temp2_1 ? 1 : 0) << 0xe
0040a1b8      
0040a1bd      if ((eax_4:1.b & 1) != 0)
0040a1c6          long double x87_r7_10 = fabs(fconvert.t(*(edx_3 + 4)) - fconvert.t(var_8))
0040a1c8          long double temp3_1 = fconvert.t(0.5)
0040a1c8          x87_r7_10 - temp3_1
0040a1ce          eax_4.w = (x87_r7_10 < temp3_1 ? 1 : 0) << 8
0040a1ce              | (is_unordered.t(x87_r7_10, temp3_1) ? 1 : 0) << 0xa
0040a1ce              | (x87_r7_10 == temp3_1 ? 1 : 0) << 0xe
0040a1ce          
0040a1d3          if ((eax_4:1.b & 1) != 0)
0040a1dc              long double x87_r7_13 = fabs(fconvert.t(*(edx_3 + 8)) - fconvert.t(var_4))
0040a1de              long double temp4_1 = fconvert.t(0.5)
0040a1de              x87_r7_13 - temp4_1
0040a1e4              eax_4.w = (x87_r7_13 < temp4_1 ? 1 : 0) << 8
0040a1e4                  | (is_unordered.t(x87_r7_13, temp4_1) ? 1 : 0) << 0xa
0040a1e4                  | (x87_r7_13 == temp4_1 ? 1 : 0) << 0xe
0040a1e4              
0040a1e9              if ((eax_4:1.b & 1) != 0)
0040a291                  return i_1
0040a291  
0040a1fa  int32_t eax_5 = data_2584ee8
0040a1fa  
0040a204  if (eax_5 == 0x10000)
0040a20b      sub_40f970("numvertexes == MAX_MAP_VERTS")
0040a210      edi_1 = data_2584ed4
0040a216      eax_5 = data_2584ee8
0040a216  
0040a225  *(edi_1 + eax_5 * 0xc) = fconvert.s(fconvert.t(var_c))
0040a23b  *(data_2584ed4 + data_2584ee8 * 0xc + 4) = fconvert.s(fconvert.t(var_8))
0040a251  *(data_2584ed4 + data_2584ee8 * 0xc + 8) = fconvert.s(fconvert.t(var_4))
0040a255  int32_t eax_10 = data_2584ee8
0040a25a  int32_t edx_5 = *((esi_1 << 2) + &data_2757a60)
0040a261  *((esi_1 << 2) + &data_2757a60) = eax_10
0040a269  *((eax_10 << 2) + &data_275ba80) = edx_5
0040a276  int32_t edx_7 = data_265d218 + 1
0040a278  data_2584ee8 = eax_10 + 1
0040a27d  data_265d218 = edx_7
0040a288  return eax_10

0040a292                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

0040a2a0    void sub_40a2a0(uint32_t arg1, int32_t* arg2, int32_t arg3)

0040a2a0  int32_t ecx
0040a2a0  int32_t var_4 = ecx
0040a2a4  int32_t edi = data_265d214
0040a2ad  int32_t ebp
0040a2ad  int32_t* esi
0040a2ad  
0040a2ad  if (edi s<= 0x14)
0040a38a      ebp = arg3
0040a38e      esi = arg2
0040a2ad  else
0040a2bd      uint32_t edx_2 = (edi - 3) u/ 0x12
0040a2c2      ebp = arg3
0040a2c8      esi = arg2
0040a2cd      uint32_t ebx_1 = arg1
0040a2d1      arg1 = edx_2
0040a356      bool cond:1_1
0040a356      
0040a356      do
0040a2e9          data_275ba6c += 1
0040a2ef          void* eax_6 = sub_40aae0(esi)
0040a2f4          esi[2] = eax_6
0040a2fa          *eax_6 = *(ebx_1 + 0x34)
0040a2ff          *(ebx_1 + 0x34) = eax_6
0040a302          *(eax_6 + 0x2c) = 0x14
0040a309          int32_t i = 0
0040a30b          void* edi_3 = eax_6 + 0x34
0040a30b          
0040a329          do
0040a311              edi_3 += 4
0040a314              int32_t eax_8
0040a314              int32_t edx_4
0040a314              edx_4:eax_8 = sx.q(i + ebp)
0040a31b              i += 1
0040a326              *(edi_3 - 4) = *((mods.dp.d(edx_4:eax_8, data_265d214) << 2) + &data_2757260)
0040a329          while (i s< 0x14)
0040a329          
0040a32c          void* eax_10 = sub_40aae0(esi)
0040a331          esi[3] = eax_10
0040a337          esi = eax_10
0040a33d          *esi = *(ebx_1 + 0x34)
0040a33f          *(ebx_1 + 0x34) = esi
0040a34f          cond:1_1 = arg1 != 1
0040a350          arg1 -= 1
0040a354          ebp = mods.dp.d(sx.q(ebp + 0x13), data_265d214)
0040a356      while (cond:1_1)
0040a358      edi += ((neg.d(edx_2) << 3) - edx_2) << 1
0040a358  
0040a35d  int32_t ecx_4 = 0
0040a35f  esi[0xb] = edi
0040a35f  
0040a364  if (edi s> 0)
0040a366      void* esi_1 = &esi[0xd]
0040a366      
0040a383      do
0040a36c          esi_1 += 4
0040a36f          int32_t eax_15
0040a36f          int32_t edx_8
0040a36f          edx_8:eax_15 = sx.q(ecx_4 + ebp)
0040a370          data_265d214
0040a376          ecx_4 += 1
0040a380          *(esi_1 - 4) = *((mods.dp.d(edx_8:eax_15, data_265d214) << 2) + &data_2757260)
0040a383      while (ecx_4 s< edi)

0040a394                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

0040a3a0    int32_t* sub_40a3a0(uint32_t arg1, int32_t* arg2)

0040a3a0  int32_t* result = arg2
0040a3a0  
0040a3bf  if (result[1] != 0 || result[2] != 0 || result[3] != 0)
0040a4ac      return result
0040a4ac  
0040a3c7  int32_t* ebp_1 = result[0xa]
0040a3ca  int32_t i = 0
0040a3ca  
0040a3d0  if (*ebp_1 s> 0)
0040a3d6      int32_t eax = data_2584ee8
0040a3dd      void* edi_1 = &data_2757260
0040a3e2      void* esi_1 = &ebp_1[1]
0040a3e2      
0040a485      do
0040a3ed          if (data_279bac0 == 0)
0040a46f              *edi_1 = sub_40a120(esi_1)
0040a471              eax = data_2584ee8
0040a3ed          else
0040a3f4              if (eax == 0x10000)
0040a3fb                  sub_40f970("MAX_MAP_VERTS")
0040a400                  eax = data_2584ee8
0040a400              
0040a408              int32_t edx_1 = data_2584ed4
0040a40e              *edi_1 = eax
0040a415              *(edx_1 + eax * 0xc) = *esi_1
0040a429              *(data_2584ed4 + data_2584ee8 * 0xc + 4) = *(esi_1 + 4)
0040a43e              *(data_2584ed4 + data_2584ee8 * 0xc + 8) = *(esi_1 + 8)
0040a453              eax = data_2584ee8 + 1
0040a454              int32_t edx_5 = data_265d218 + 1
0040a455              int32_t ecx_8 = data_275ba68 + 1
0040a456              data_2584ee8 = eax
0040a45b              data_265d218 = edx_5
0040a461              data_275ba68 = ecx_8
0040a461          
0040a47c          i += 1
0040a47d          esi_1 += 0xc
0040a480          edi_1 += 4
0040a485      while (i s< *ebp_1)
0040a485      
0040a48b      result = arg2
0040a48b  
0040a49c  data_265d214 = *ebp_1
0040a4a2  return sub_40a2a0(arg1, result, 0)

0040a4ad                                         90 90 90                                                               ...

0040a4b0    void sub_40a4b0(int32_t* arg1)

0040a4b8  if (*arg1 != 0xffffffff)
0040a4c0      for (int32_t* i = arg1[0xd]; i != 0; i = *i)
0040a4c4          sub_40a3a0(arg1, i)
0040a4c4      
0040a4d2      void* esi_1 = &arg1[0xb]
0040a4d5      int32_t i_2 = 2
0040a4e9      int32_t i_1
0040a4e9      
0040a4e9      do
0040a4dd          sub_40a4b0(*esi_1)
0040a4e5          esi_1 += 4
0040a4e8          i_1 = i_2
0040a4e8          i_2 -= 1
0040a4e9      while (i_1 != 1)

0040a4ee                                            90 90                                                                ..

0040a4f0    int32_t sub_40a4f0(float* arg1, int32_t arg2)

0040a500  int32_t eax
0040a500  int16_t x87control
0040a500  int16_t x87control_1
0040a500  eax, x87control_1 = __ftol(x87control, fconvert.t(*arg1) + fconvert.t(0.5))
0040a516  int32_t result_1 = (eax + 0x1000) s>> 7
0040a519  int32_t eax_1
0040a519  int16_t x87control_2
0040a519  eax_1, x87control_2 = __ftol(x87control_1, fconvert.t(arg1[1]) + fconvert.t(0.5))
0040a51e  float* edi_1 = arg2
0040a532  int32_t ebx_2 = (eax_1 + 0x1000) s>> 7
0040a535  int32_t eax_2
0040a535  int16_t x87control_3
0040a535  eax_2, x87control_3 = __ftol(x87control_2, fconvert.t(*edi_1) + fconvert.t(0.5))
0040a54b  arg1 = (eax_2 + 0x1000) s>> 7
0040a560  int32_t ebp_2 =
0040a560      (__ftol(x87control_3, fconvert.t(edi_1[1]) + fconvert.t(0.5)) + 0x1000) s>> 7
0040a560  
0040a565  if (result_1 s> arg1)
0040a567      int32_t result_2 = result_1
0040a569      result_1 = arg1
0040a56b      arg1 = result_2
0040a56b  
0040a571  if (ebx_2 s> ebp_2)
0040a573      int32_t eax_6 = ebx_2
0040a575      ebx_2 = ebp_2
0040a577      ebp_2 = eax_6
0040a577  
0040a57d  int32_t edi_2 = 0
0040a57f  int32_t result = result_1
0040a583  data_275ba60 = 0
0040a589  arg2 = result
0040a589  
0040a58d  if (result_1 s<= arg1)
0040a5db      do
0040a591          if (ebx_2 s<= ebp_2)
0040a59e              int32_t i_1 = ebp_2 - ebx_2 + 1
0040a59f              void* eax_7 = (((ebx_2 << 6) + result) << 2) + &data_2757a60
0040a5ca              int32_t i
0040a5ca              
0040a5ca              do
0040a5a6                  int32_t j = *eax_7
0040a5a6                  
0040a5aa                  if (j != 0)
0040a5ac                      void* edx_1 = (edi_2 << 2) + &data_261d200
0040a5ac                      
0040a5c2                      do
0040a5b3                          *edx_1 = j
0040a5b5                          j = *((j << 2) + &data_275ba80)
0040a5bc                          edi_2 += 1
0040a5bd                          edx_1 += 4
0040a5c2                      while (j != 0)
0040a5c2                  
0040a5c4                  eax_7 += 0x100
0040a5c9                  i = i_1
0040a5c9                  i_1 -= 1
0040a5ca              while (i != 1)
0040a5cc              result = arg2
0040a5cc          
0040a5d4          result += 1
0040a5d7          arg2 = result
0040a5db      while (result s<= arg1)
0040a5db      
0040a5dd      data_275ba60 = edi_2
0040a5dd  
0040a5e7  return result

0040a5e8                          90 90 90 90 90 90 90 90                                                          ........

0040a5f0    void sub_40a5f0(float arg1, float arg2, int32_t arg3, int32_t arg4, int32_t arg5)

0040a604  if (arg3 == arg4)
0040a606      data_265d20c += 1
0040a612      return 
0040a612  
0040a613  int32_t i = arg5
0040a613  
0040a61d  if (i s< data_275ba60)
0040a623      void* ebx_1 = (i << 2) + &data_261d200
0040a623      
0040a72a      do
0040a62a          int32_t esi_1 = *ebx_1
0040a62a          
0040a63a          if (esi_1 != arg3 && esi_1 != arg4)
0040a640              int32_t edx_1 = data_2584ed4
0040a646              int32_t ecx_1 = esi_1 * 3
0040a649              void* eax_3 = edx_1 + (ecx_1 << 2)
0040a64c              float ecx_2 = *(edx_1 + (ecx_1 << 2))
0040a64f              float edx_2 = *(eax_3 + 4)
0040a667              float var_24_1 = *(eax_3 + 8)
0040a69b              float var_30_1 = fconvert.s(fconvert.t(data_265d228)
0040a69b                  * (fconvert.t(var_24_1) - fconvert.t(data_265d208))
0040a69b                  + fconvert.t(data_265d224)
0040a69b                  * (fconvert.t(edx_2) - fconvert.t(data_265d204)) + fconvert.t(data_265d220)
0040a69b                  * (fconvert.t(ecx_2) - fconvert.t(data_265d200)))
0040a6a5              long double x87_r7_4 = fconvert.t(var_30_1)
0040a6a9              long double temp0_1 = fconvert.t(arg1)
0040a6a9              x87_r7_4 - temp0_1
0040a6ac              float eax_4
0040a6ac              eax_4.w = (x87_r7_4 < temp0_1 ? 1 : 0) << 8
0040a6ac                  | (is_unordered.t(x87_r7_4, temp0_1) ? 1 : 0) << 0xa
0040a6ac                  | (x87_r7_4 == temp0_1 ? 1 : 0) << 0xe
0040a6ac              
0040a6b1              if ((eax_4:1.b & 0x41) == 0)
0040a6b3                  long double x87_r7_5 = fconvert.t(var_30_1)
0040a6b7                  long double temp1_1 = fconvert.t(arg2)
0040a6b7                  x87_r7_5 - temp1_1
0040a6ba                  eax_4.w = (x87_r7_5 < temp1_1 ? 1 : 0) << 8
0040a6ba                      | (is_unordered.t(x87_r7_5, temp1_1) ? 1 : 0) << 0xa
0040a6ba                      | (x87_r7_5 == temp1_1 ? 1 : 0) << 0xe
0040a6ba                  
0040a6bf                  if ((eax_4:1.b & 1) != 0)
0040a6da                      float var_20
0040a6da                      sub_4103e0(&data_265d200, fconvert.d(fconvert.t(var_30_1)), 
0040a6da                          &data_265d220, &var_20)
0040a6ec                      float var_14 = fconvert.s(fconvert.t(ecx_2) - fconvert.t(var_20))
0040a6f8                      float var_1c
0040a6f8                      float var_10_1 = fconvert.s(fconvert.t(edx_2) - fconvert.t(var_1c))
0040a704                      float var_18
0040a704                      float var_c_1 = fconvert.s(fconvert.t(var_24_1) - fconvert.t(var_18))
0040a70d                      long double x87_r7_14 = fabs(sub_410350(&var_14))
0040a70f                      long double temp2_1 = fconvert.t(0.5)
0040a70f                      x87_r7_14 - temp2_1
0040a70f                      
0040a71d                      if ((((x87_r7_14 < temp2_1 ? 1 : 0) << 8
0040a71d                              | (is_unordered.t(x87_r7_14, temp2_1) ? 1 : 0) << 0xa
0040a71d                              | (x87_r7_14 == temp2_1 ? 1 : 0) << 0xe):1.b & 0x41) != 0)
0040a774                          data_2757240 += 1
0040a77f                          double var_50_1
0040a77f                          var_50_1:4.d = arg3
0040a780                          var_50_1.d = var_30_1
0040a782                          sub_40a5f0(arg1, var_50_1, esi_1, i + 1)
0040a78f                          var_50_1:4.d = esi_1
0040a790                          var_50_1.d = arg2
0040a792                          sub_40a5f0(var_30_1, var_50_1, arg4, i + 1)
0040a7a0                          return 
0040a7a0          
0040a724          i += 1
0040a725          ebx_1 += 4
0040a72a      while (i s< data_275ba60)
0040a72a  
0040a73a  if (data_265d214 s>= 0x200)
0040a741      sub_40f970("MAX_SUPERVERTS")
0040a741  
0040a749  int32_t eax_7 = data_265d214
0040a751  *((eax_7 << 2) + &data_2757260) = arg3
0040a759  data_265d214 = eax_7 + 1

0040a7a1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040a7b0    int32_t __stdcall sub_40a7b0(uint32_t arg1, int32_t* arg2)

0040a7b5  sub_41e520(0x1014)
0040a7bb  int32_t* ebx = arg2
0040a7c4  int32_t eax = ebx[1]
0040a7c7  int32_t esi = 0
0040a7c7  
0040a7de  if (eax != 0 || ebx[2] != 0 || ebx[3] != 0)
0040a98e      return eax
0040a98e  
0040a7e4  data_265d214 = 0
0040a7ea  int32_t ecx_1 = ebx[0xb]
0040a7ea  
0040a7ef  if (ecx_1 s> 0)
0040a7f8      __return_addr = &ebx[0xd]
0040a80e      int32_t arg_14[0x200]
0040a80e      int32_t arg_814[0x200]
0040a80e      int32_t eax_10
0040a80e      
0040a80e      while (true)
0040a80e          int32_t edi_1 = *__return_addr
0040a813          int32_t ecx_2 = data_2584ed4
0040a81c          int32_t* eax_5 = ecx_2 + edi_1 * 0xc
0040a81f          int32_t ebx_1 = ebx[mods.dp.d(sx.q(esi + 1), ecx_1) + 0xd]
0040a825          data_265d200 = *eax_5
0040a82e          data_265d204 = eax_5[1]
0040a837          int32_t edx_6 = ebx_1 * 3
0040a83a          data_265d208 = eax_5[2]
0040a83f          void* eax_7 = ecx_2 + (edx_6 << 2)
0040a845          int32_t arg_4 = *(ecx_2 + (edx_6 << 2))
0040a850          int32_t arg_8 = *(eax_7 + 4)
0040a85d          int32_t arg_c = *(eax_7 + 8)
0040a861          sub_40a4f0(&data_265d200, &arg_4)
0040a866          unimplemented  {fld st0, dword [esp+0x1c]}
0040a86a          unimplemented  {fsub st0, dword [&data_265d200]}
0040a87a          data_265d220 = fconvert.s(unimplemented  {fstp dword [&data_265d220], st0})
0040a87a          unimplemented  {fstp dword [&data_265d220], st0}
0040a880          unimplemented  {fld st0, dword [esp+0x28]}
0040a884          unimplemented  {fsub st0, dword [&data_265d204]}
0040a88a          data_265d224 = fconvert.s(unimplemented  {fstp dword [&data_265d224], st0})
0040a88a          unimplemented  {fstp dword [&data_265d224], st0}
0040a890          unimplemented  {fld st0, dword [esp+0x2c]}
0040a894          unimplemented  {fsub st0, dword [&data_265d208]}
0040a89a          data_265d228 = fconvert.s(unimplemented  {fstp dword [&data_265d228], st0})
0040a89a          unimplemented  {fstp dword [&data_265d228], st0}
0040a8a0          sub_410460(&data_265d220, &data_265d220)
0040a8a0          unimplemented  {call sub_410460}
0040a8a5          float arg_10 = fconvert.s(unimplemented  {fstp dword [esp+0x30], st0})
0040a8a5          unimplemented  {fstp dword [esp+0x30], st0}
0040a8ba          arg_814[esi] = data_265d214
0040a8c1          sub_40a5f0(0f, arg_10, edi_1, ebx_1, 0)
0040a8c1          int16_t top = top - 1
0040a8c1          unimplemented  {call sub_40a5f0}
0040a8c6          eax_10 = data_265d214
0040a8e7          arg_14[esi] = eax_10 - arg_814[esi]
0040a8eb          ecx_1 = arg2[0xb]
0040a8ee          esi += 1
0040a8f0          __return_addr += 4
0040a8f0          
0040a8f6          if (esi s>= ecx_1)
0040a8f6              break
0040a8f6          
0040a7fe          ebx = arg2
0040a7fe      
0040a8ff      if (eax_10 s>= 3)
0040a927          int32_t esi_1 = 0
0040a929          int32_t ecx_6 = arg2[0xb]
0040a929          
0040a92e          if (ecx_6 s> 0)
0040a930              int32_t edi_4 = ecx_6 - 1
0040a933              int32_t (* ebx_3)[0x200] = &arg_14
0040a933              
0040a94f              do
0040a93a                  if (*ebx_3 == 1 && arg_14[mods.dp.d(sx.q(edi_4), ecx_6)] == 1)
0040a946                      break
0040a946                  
0040a948                  esi_1 += 1
0040a949                  ebx_3 = &(*ebx_3)[1]
0040a94c                  edi_4 += 1
0040a94f              while (esi_1 s< ecx_6)
0040a94f          
0040a953          int32_t esi_2
0040a953          
0040a953          if (esi_1 != ecx_6)
0040a96b              esi_2 = arg_814[esi_1]
0040a953          else
0040a955              arg2[0xc] = 1
0040a962              esi_2 = 0
0040a964              data_2757244 += 1
0040a964          
0040a97c          return sub_40a2a0(arg1, arg2, esi_2)
0040a97c      
0040a901      ebx = arg2
0040a901  
0040a903  ebx[0xb] = 0
0040a910  int32_t eax_12 = data_279ba84 + 1
0040a913  data_279ba84 = eax_12
0040a91f  return eax_12

0040a98f                                               90                                                                 .

0040a990    void sub_40a990(int32_t* arg1)

0040a998  if (*arg1 != 0xffffffff)
0040a9a0      for (int32_t* i = arg1[0xd]; i != 0; i = *i)
0040a9a4          sub_40a7b0(arg1, i)
0040a9a4      
0040a9b2      void* esi_1 = &arg1[0xb]
0040a9b5      int32_t i_2 = 2
0040a9c9      int32_t i_1
0040a9c9      
0040a9c9      do
0040a9bd          sub_40a990(*esi_1)
0040a9c5          esi_1 += 4
0040a9c8          i_1 = i_2
0040a9c8          i_2 -= 1
0040a9c9      while (i_1 != 1)

0040a9ce                                            90 90                                                                ..

0040a9d0    int32_t sub_40a9d0(int32_t* arg1)

0040a9d7  sub_40fa00("---- snap verts ----\n")
0040a9ea  __builtin_memset(s: &data_2757a60, c: 0, n: 0x4000)
0040a9f0  data_275ba68 = 0
0040a9f7  data_265d218 = 0
0040a9fd  data_275ba6c = 0
0040aa03  sub_40a4b0(arg1)
0040aa13  int32_t var_14 = data_275ba68
0040aa14  int32_t var_18 = data_265d218
0040aa1a  sub_40fa00("%i unique from %i\n")
0040aa24  sub_40fa00("---- tjunc ----\n")
0040aa31  bool cond:0 = data_279c32c != 0
0040aa33  data_279ba80 = 0
0040aa39  data_265d20c = 0
0040aa3f  data_279ba84 = 0
0040aa45  data_2757240 = 0
0040aa45  
0040aa4b  if (not(cond:0))
0040aa4e      sub_40a990(arg1)
0040aa4e  
0040aa5c  int32_t var_c_2 = data_265d20c
0040aa62  sub_40fa00("%5i edges degenerated\n")
0040aa6c  int32_t var_14_1 = data_279ba84
0040aa72  sub_40fa00("%5i faces degenerated\n")
0040aa7d  int32_t var_1c = data_2757240
0040aa83  sub_40fa00("%5i edges added by tjunctions\n")
0040aa8e  int32_t var_24 = data_275ba6c
0040aa94  sub_40fa00("%5i faces added by tjunctions\n")
0040aa9e  int32_t var_2c = data_2757244
0040aaae  return sub_40fa00("%5i bad start verts\n")

0040aaaf                                               90                                                                 .

0040aab0    void* sub_40aab0()

0040aab6  void* s = sub_4105b0(0x84)
0040aac6  __builtin_memset(s, c: 0, n: 0x84)
0040aad1  data_275ba64 += 1
0040aad9  return s

0040aada                                                                                90 90 90 90 90 90                            ......

0040aae0    void* sub_40aae0(int32_t arg1)

0040aae2  void* result = sub_40aab0()
0040aaf2  __builtin_memcpy(dest: result, src: arg1, n: 0x84)
0040aaf7  *(result + 4) = 0
0040aafa  *(result + 0xc) = 0
0040aafd  *(result + 8) = 0
0040ab00  *(result + 0x28) = 0
0040ab04  return result

0040ab05                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040ab10    int32_t sub_40ab10(void* arg1)

0040ab15  int32_t* eax = *(arg1 + 0x28)
0040ab15  
0040ab1a  if (eax != 0)
0040ab1d      sub_410740(eax)
0040ab1d  
0040ab26  sub_41e29e(arg1)
0040ab33  int32_t result = data_275ba64 - 1
0040ab34  data_275ba64 = result
0040ab3a  return result

0040ab3b                                                                                   90 90 90 90 90                             .....

0040ab40    int32_t sub_40ab40(int16_t arg1, int16_t arg2, void* arg3)

0040ab46  int32_t eax = data_279bac8
0040ab4e  int32_t esi = data_2584e98
0040ab5a  data_279ba80 += 1
0040ab62  int16_t* ecx
0040ab62  
0040ab62  if (eax == 0)
0040ab64      int32_t eax_1 = data_42ca44
0040ab64      
0040ab6b      if (eax_1 s< esi)
0040ab73          void* edx_1 = (eax_1 << 3) + &data_265d244
0040ab7a          ecx = data_2584ea8 + (eax_1 << 2)
0040ab7a          
0040abb3          do
0040ab83              int32_t ebx_1
0040ab83              ebx_1.w = ecx[1]
0040ab83              
0040ab89              if (arg1.d == ebx_1)
0040ab91                  int32_t ebx_2
0040ab91                  ebx_2.w = *ecx
0040ab91                  
0040aba8                  if (arg2.d == ebx_2 && *(*(edx_1 - 4) + 0x20) == *(arg3 + 0x20)
0040aba8                          && *edx_1 == 0)
0040ac03                      *((eax_1 << 3) + &data_265d244) = arg3
0040ac10                      return neg.d(eax_1)
0040ac10              
0040abaa              eax_1 += 1
0040abab              ecx = &ecx[2]
0040abae              edx_1 += 8
0040abb3          while (eax_1 s< esi)
0040abb3  
0040abbb  if (esi s>= 0x1f400)
0040abc2      sub_40f970("numedges == MAX_MAP_EDGES")
0040abc7      esi = data_2584e98
0040abc7  
0040abd6  ecx.w = arg1
0040abdb  int16_t* eax_2 = data_2584ea8 + (esi << 2)
0040abde  int32_t edx_2
0040abde  edx_2.w = arg2
0040abe4  data_2584e98 = esi + 1
0040abea  *eax_2 = ecx.w
0040abed  eax_2[1] = edx_2.w
0040abf1  int32_t eax_3 = data_2584e98
0040abf6  *((eax_3 << 3) + &data_265d238) = arg3
0040ac02  return eax_3 - 1

0040ac11                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

0040ac20    void* sub_40ac20(void* arg1, void* arg2, float* arg3)

0040ac27  int32_t* ecx = *(arg1 + 0x28)
0040ac27  
0040ac2c  if (ecx != 0)
0040ac32      int32_t* eax_1 = *(arg2 + 0x28)
0040ac32      
0040ac55      if (eax_1 != 0 && *(arg1 + 0x14) == *(arg2 + 0x14) && *(arg1 + 0x1c) == *(arg2 + 0x1c)
0040ac55              && *(arg1 + 0x20) == *(arg2 + 0x20))
0040ac5e          int32_t* eax_2 = sub_411460(ecx, eax_1, arg3)
0040ac5e          
0040ac6a          if (eax_2 != 0)
0040ac73              data_279ba90 += 1
0040ac78              void* result = sub_40aae0(arg1)
0040ac80              *(result + 0x28) = eax_2
0040ac83              *(arg1 + 4) = result
0040ac86              *(arg2 + 4) = result
0040ac8c              return result
0040ac8c  
0040ac92  return 0

0040ac93                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0040aca0    void sub_40aca0(void* arg1)

0040acab  for (void** i = *(arg1 + 0x34); i != 0; i = *i)
0040acc1      if (i[1] == 0 && i[2] == 0 && i[3] == 0)
0040acc8          for (void** j = *(arg1 + 0x34); j != i; j = *j)
0040acdd              if (j[1] == 0 && j[2] == 0 && j[3] == 0)
0040acf5                  void* eax = sub_40ac20(i, j, i[7] * 0x1c + &data_239e0c0)
0040acf5                  
0040acff                  if (eax != 0)
0040ad09                      void** k_1 = *(arg1 + 0x34)
0040ad09                      
0040ad10                      for (void* k = *k_1; k != 0; k = *k_1)
0040ad12                          k_1 = k
0040ad12                      
0040ad1a                      *eax = 0
0040ad20                      *k_1 = eax
0040ad20                      break

0040ad2c                                      90 90 90 90                                                              ....

0040ad30    int32_t sub_40ad30(void* arg1, float arg2)

0040ad36  float esi = arg2
0040ad3b  int32_t eax = *(esi i+ 4)
0040ad3b  
0040ad40  if (eax == 0)
0040ad4c      int32_t edx_1 = *(esi i+ 0x14) * 0x13
0040ad4f      eax.b = *((edx_1 << 2) + &data_2585020)
0040ad4f      
0040ad5f      if ((eax.b & 0xc) == 0)
0040ad65          int32_t* ebx_1 = *(esi i+ 0x28)
0040ad68          int32_t edi_1 = 0
0040ad6c          int32_t var_14
0040ad6c          float var_10
0040ad6c          
0040ad6c          while (true)
0040ad6c              arg2 = 999999f
0040ad77              void* eax_3 = (edi_1 << 4) + (edx_1 << 2) + &data_2585000
0040ad79              long double x87_r7_1 = fconvert.t(-999999f)
0040ad81              float var_c = *eax_3
0040ad85              float edx_2 = *(eax_3 + 4)
0040ad8c              float eax_4 = *(eax_3 + 8)
0040ad93              int32_t i_2 = *ebx_1
0040ad93              
0040ad97              if (i_2 s> 0)
0040ad99                  void* ecx_3 = &ebx_1[2]
0040ad9c                  int32_t i_1 = i_2
0040addc                  int32_t i
0040addc                  
0040addc                  do
0040adb4                      long double x87_r6_4 = fconvert.t(eax_4) * fconvert.t(*(ecx_3 + 4))
0040adb4                          + fconvert.t(var_c) * fconvert.t(*(ecx_3 - 4))
0040adb4                          + fconvert.t(edx_2) * fconvert.t(*ecx_3)
0040adb6                      long double temp1_1 = fconvert.t(arg2)
0040adb6                      x87_r6_4 - temp1_1
0040adba                      var_10 = fconvert.s(x87_r6_4)
0040adba                      bool c1_1 = unimplemented  {fst dword [esp+0x14], st0}
0040adbe                      i_2.w = (x87_r6_4 < temp1_1 ? 1 : 0) << 8 | (c1_1 ? 1 : 0) << 9
0040adbe                          | (is_unordered.t(x87_r6_4, temp1_1) ? 1 : 0) << 0xa
0040adbe                          | (x87_r6_4 == temp1_1 ? 1 : 0) << 0xe | 0x3000
0040adbe                      
0040adc3                      if ((i_2:1.b & 1) != 0)
0040adc5                          arg2 = fconvert.s(x87_r6_4)
0040adc5                      
0040adc9                      x87_r6_4 - x87_r7_1
0040adcb                      i_2.w = (x87_r6_4 < x87_r7_1 ? 1 : 0) << 8
0040adcb                          | (is_unordered.t(x87_r6_4, x87_r7_1) ? 1 : 0) << 0xa
0040adcb                          | (x87_r6_4 == x87_r7_1 ? 1 : 0) << 0xe | 0x3800
0040adcb                      
0040add0                      if ((i_2:1.b & 0x41) == 0)
0040add4                          x87_r7_1 = fconvert.t(var_10)
0040add4                      
0040add8                      ecx_3 += 0xc
0040addb                      i = i_1
0040addb                      i_1 -= 1
0040addc                  while (i != 1)
0040addc              
0040adde              long double x87_r7_2 = x87_r7_1 - fconvert.t(arg2)
0040ade5              long double temp0_1 = fconvert.t(data_42ca48)
0040ade5              x87_r7_2 - temp0_1
0040adeb              i_2.w = (x87_r7_2 < temp0_1 ? 1 : 0) << 8
0040adeb                  | (is_unordered.t(x87_r7_2, temp0_1) ? 1 : 0) << 0xa
0040adeb                  | (x87_r7_2 == temp0_1 ? 1 : 0) << 0xe
0040adeb              
0040aded              if (edi_1 != 2)
0040adf9                  if ((i_2:1.b & 0x41) == 0)
0040ae1e                      label_40ae1e:
0040ae1e                      data_279ba8c += 1
0040ae24                      long double st0_1 = sub_410460(&var_c, &var_c)
0040ae4f                      int32_t* var_34_1 = &var_14
0040ae59                      sub_410e60(ebx_1, &var_c, 
0040ae59                          fconvert.s((fconvert.t(data_42ca48) + fconvert.t(arg2)
0040ae59                              - fconvert.t(16f)) / st0_1), 
0040ae59                          0.100000001f, &var_14, &var_10)
0040ae67                      break
0040aded              else if ((i_2:1.b & 0x41) == 0)
0040adf2                  goto label_40ae1e
0040adf2              
0040adfb              edi_1 += 1
0040adfb              
0040adff              if (edi_1 s>= 2)
0040ae0c                  return i_2
0040ae0c          
0040ae6f          if (var_14 == 0 || var_10 == 0)
0040ae76              sub_40f970("SubdivideFace: didn't split the …")
0040ae76          
0040ae7f          void* eax_7 = sub_40aae0(esi)
0040ae84          int32_t ecx_4 = var_14
0040ae8c          *(esi i+ 8) = eax_7
0040ae8f          *(eax_7 + 0x28) = ecx_4
0040ae99          **(esi i+ 8) = *(arg1 + 0x34)
0040ae9e          *(arg1 + 0x34) = *(esi i+ 8)
0040aea1          void* eax_9 = sub_40aae0(esi)
0040aea6          float edx_4 = var_10
0040aeaa          *(esi i+ 0xc) = eax_9
0040aead          *(eax_9 + 0x28) = edx_4
0040aeb6          **(esi i+ 0xc) = *(arg1 + 0x34)
0040aebb          *(arg1 + 0x34) = *(esi i+ 0xc)
0040aec3          sub_40ad30(arg1, *(esi i+ 8))
0040aecd          return sub_40ad30(arg1, *(esi i+ 0xc))
0040aecd  
0040aedc  return eax

0040aedd                                                                                         90 90 90                               ...

0040aee0    void sub_40aee0(void* arg1)

0040aeeb  for (float i = *(arg1 + 0x34); i != 0; i = *i)
0040aeef      sub_40ad30(arg1, i)


0040af00    void* sub_40af00(void* arg1, int32_t arg2)

0040af07  int32_t* ebx = *(arg1 + 0x38)
0040af07  
0040af0c  if (ebx == 0)
0040af13      return 0
0040af13  
0040af14  void* result = sub_40aab0()
0040af1e  *(result + 0x14) = ebx[1]
0040af2a  int32_t ecx_2 = (*ebx & 0xfffffffe) | arg2
0040af2c  *(result + 0x10) = arg1
0040af2f  *(result + 0x1c) = ecx_2
0040af36  int32_t eax_2 = *(*(arg1 + (arg2 << 2) + 0x20) + 0x3c)
0040af36  
0040af3b  if ((eax_2.b & 2) != 0)
0040af41      int32_t ecx_3
0040af41      ecx_3.b = arg2 == 0
0040af41      
0040af59      if (sub_41af50(*(*(arg1 + (ecx_3 << 2) + 0x20) + 0x3c) ^ eax_2) == 2)
0040af60          return 0
0040af60  
0040af61  int32_t* edx_2 = *(arg1 + 0x30)
0040af61  
0040af67  if (arg2 == 0)
0040af88      *(result + 0x28) = sub_410dd0(edx_2)
0040af96      *(result + 0x20) = *(*(arg1 + 0x20) + 0x3c)
0040af9c      return result
0040af9c  
0040af6e  *(result + 0x28) = sub_410e00(edx_2)
0040af7c  *(result + 0x20) = *(*(arg1 + 0x24) + 0x3c)
0040af82  return result

0040af9d                                                                                         90 90 90                               ...

0040afa0    void sub_40afa0(int32_t* arg1)

0040afa9  if (*arg1 != 0xffffffff)
0040afaf      sub_40afa0(arg1[0xb])
0040afb8      sub_40afa0(arg1[0xc])
0040afb8      
0040afc7      if (data_279bef4 == 0)
0040afca          sub_40aca0(arg1)
0040afca      
0040afd9      if (data_279bac4 == 0)
0040afdc          sub_40aee0(arg1)
0040afa9  else if ((arg1[0xf].b & 1) == 0)
0040aff2      int32_t edx_1
0040aff2      
0040aff2      for (void* i = arg1[0x14]; i != 0; i = *(i + (edx_1 << 2) + 0x28))
0040affc          edx_1.b = *(i + 0x24) == arg1
0040b003          void* eax = sub_40af00(i, edx_1)
0040b00b          *(i + (edx_1 << 2) + 0x3c) = eax
0040b00b          
0040b011          if (eax != 0)
0040b019              data_265d210 += 1
0040b028              **(i + (edx_1 << 2) + 0x3c) = *(*(i + 0x1c) + 0x34)
0040b031              *(*(i + 0x1c) + 0x34) = *(i + (edx_1 << 2) + 0x3c)


0040b040    int32_t sub_40b040(int32_t* arg1)

0040b045  sub_40fa00("--- MakeFaces ---\n")
0040b04c  data_279ba90 = 0
0040b051  data_279ba8c = 0
0040b056  data_265d210 = 0
0040b060  sub_40afa0(arg1)
0040b06b  int32_t var_c = data_265d210
0040b071  sub_40fa00("%5i makefaces\n")
0040b07c  int32_t var_14 = data_279ba90
0040b082  sub_40fa00("%5i merged\n")
0040b08c  int32_t var_1c = data_279ba8c
0040b09a  return sub_40fa00("%5i subdivided\n")

0040b09b                                                                                   90 90 90 90 90                             .....

0040b0a0    int32_t* sub_40b0a0()

0040b0a8  data_261d0ec = 0
0040b0b8  data_261d0b4 = sub_4105b0(0x6400)
0040b0bd  data_430334 = 0x6400
0040b0c7  data_261d090 = 0
0040b0cd  void* eax_1 = sub_4105b0(0x200000)
0040b0dd  int32_t ecx_1 = data_430334 + 0x200000
0040b0e3  data_261d1f4 = eax_1
0040b0e8  data_430334 = ecx_1
0040b0ee  data_261d09c = 0
0040b0f4  void* eax_2 = sub_4105b0(0x200000)
0040b104  int32_t ecx_3 = data_430334 + 0x200000
0040b10a  data_261d0a0 = eax_2
0040b10f  data_430334 = ecx_3
0040b115  data_261d0c8 = 0
0040b11b  void* eax_3 = sub_4105b0(0x200000)
0040b12b  int32_t ecx_5 = data_430334 + 0x200000
0040b131  data_261d0b0 = eax_3
0040b136  data_430334 = ecx_5
0040b13c  data_261d118 = 0
0040b142  void* eax_4 = sub_4105b0(0x20000)
0040b152  int32_t ecx_7 = data_430334 + 0x20000
0040b158  data_261d094 = eax_4
0040b15d  data_430334 = ecx_7
0040b163  data_261d0a8 = 0
0040b169  void* eax_5 = sub_4105b0(0x38000)
0040b179  int32_t ecx_9 = data_430334 + 0x38000
0040b17f  data_261d10c = eax_5
0040b184  data_430334 = ecx_9
0040b18a  data_261d0d4 = 0
0040b190  void* eax_6 = sub_4105b0(0x9ffec)
0040b1a0  int32_t ecx_11 = data_430334 + 0x9ffec
0040b1a6  data_261d1fc = eax_6
0040b1ab  data_430334 = ecx_11
0040b1b1  data_261d120 = 0
0040b1b7  void* eax_7 = sub_4105b0(0xbfff4)
0040b1c7  int32_t ecx_13 = data_430334 + 0xbfff4
0040b1cd  data_261d11c = eax_7
0040b1d2  data_430334 = ecx_13
0040b1d8  data_261d0d8 = 0
0040b1de  void* eax_8 = sub_4105b0(0xbffe8)
0040b1ee  int32_t ecx_15 = data_430334 + 0xbffe8
0040b1f4  data_261d100 = eax_8
0040b1f9  data_430334 = ecx_15
0040b1ff  data_261d1ec = 0
0040b205  void* eax_9 = sub_4105b0(0x50000)
0040b215  int32_t ecx_17 = data_430334 + 0x50000
0040b21b  data_261d1f8 = eax_9
0040b220  data_430334 = ecx_17
0040b226  data_261d0c0 = 0
0040b22c  void* eax_10 = sub_4105b0(0x13ffec)
0040b23c  int32_t ecx_19 = data_430334 + 0x13ffec
0040b242  data_261d0f8 = eax_10
0040b247  data_430334 = ecx_19
0040b24d  data_261d0ac = 0
0040b258  data_261d1e0 = sub_4105b0(0x3fff8)
0040b268  int32_t ecx_21 = data_430334 + 0x3fff8
0040b26e  data_261d0bc = 0
0040b274  data_430334 = ecx_21
0040b27a  void* eax_12 = sub_4105b0(0xfa000)
0040b28a  int32_t ecx_23 = data_430334 + 0x3e800
0040b290  data_261d0f4 = eax_12
0040b295  data_430334 = ecx_23
0040b29b  data_261d1f0 = 0
0040b2a1  void* eax_13 = sub_4105b0(0x1fffe)
0040b2b1  int32_t ecx_25 = data_430334 + 0x1fffe
0040b2b7  data_261d0e0 = eax_13
0040b2bc  data_430334 = ecx_25
0040b2c2  data_261d0b8 = 0
0040b2c8  void* eax_14 = sub_4105b0(0x1f4000)
0040b2d8  int32_t edx_1 = data_430334 + 0x1f4000
0040b2de  data_261d0e4 = eax_14
0040b2e3  data_430334 = edx_1
0040b2e9  sub_410030("allocated ")
0040b2f7  sub_4105f0(data_430334)
0040b30a  return sub_410030(" of BSP memory\n")

0040b30b                                   90 90 90 90 90                                                             .....

0040b310    int32_t* sub_40b310()

0040b310  void* eax_5 = data_261d0b4
0040b319  data_261d0ec = 0
0040b31f  sub_4105e0(eax_5)
0040b324  void* ecx = data_261d1f4
0040b32a  data_261d0b4 = 0
0040b331  data_261d090 = 0
0040b337  sub_4105e0(ecx)
0040b33c  void* edx = data_261d0a0
0040b342  data_261d1f4 = 0
0040b349  data_261d09c = 0
0040b34f  sub_4105e0(edx)
0040b354  void* eax = data_261d0b0
0040b359  data_261d0a0 = 0
0040b360  data_261d0c8 = 0
0040b366  sub_4105e0(eax)
0040b36b  void* ecx_1 = data_261d094
0040b371  data_261d0b0 = 0
0040b378  data_261d118 = 0
0040b37e  sub_4105e0(ecx_1)
0040b383  void* edx_1 = data_261d10c
0040b389  data_261d094 = 0
0040b390  data_261d0a8 = 0
0040b396  sub_4105e0(edx_1)
0040b39b  void* eax_1 = data_261d1fc
0040b3a0  data_261d10c = 0
0040b3a7  data_261d0d4 = 0
0040b3ad  sub_4105e0(eax_1)
0040b3b2  void* ecx_2 = data_261d11c
0040b3b8  data_261d1fc = 0
0040b3bf  data_261d120 = 0
0040b3c5  sub_4105e0(ecx_2)
0040b3ca  void* edx_2 = data_261d100
0040b3d0  data_261d11c = 0
0040b3d7  data_261d0d8 = 0
0040b3dd  sub_4105e0(edx_2)
0040b3e2  void* eax_2 = data_261d1f8
0040b3e7  data_261d100 = 0
0040b3ee  data_261d1ec = 0
0040b3f4  sub_4105e0(eax_2)
0040b3f9  void* ecx_3 = data_261d0f8
0040b3ff  data_261d1f8 = 0
0040b406  data_261d0c0 = 0
0040b40c  sub_4105e0(ecx_3)
0040b411  void* edx_3 = data_261d1e0
0040b417  data_261d0f8 = 0
0040b41e  data_261d0ac = 0
0040b424  sub_4105e0(edx_3)
0040b429  void* eax_3 = data_261d0f4
0040b42e  data_261d1e0 = 0
0040b435  data_261d0bc = 0
0040b43b  sub_4105e0(eax_3)
0040b440  void* ecx_4 = data_261d0e0
0040b446  data_261d0f4 = 0
0040b44d  data_261d1f0 = 0
0040b453  sub_4105e0(ecx_4)
0040b458  void* edx_4 = data_261d0e4
0040b45e  data_261d0e0 = 0
0040b465  data_261d0b8 = 0
0040b46b  sub_4105e0(edx_4)
0040b475  data_261d0e4 = 0
0040b47b  sub_410030("freed ")
0040b489  sub_4105f0(data_430334)
0040b493  int32_t* result = sub_410030(" of BSP memory\n")
0040b49b  data_430334 = 0
0040b4a2  return result

0040b4a3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0040b4b0    int32_t sub_40b4b0(char* arg1, int32_t arg2)

0040b4b4  int32_t result = 0
0040b4b4  
0040b4bb  if (arg2 != 0)
0040b4bd      int32_t i_1 = arg2
0040b4c0      char* ecx_1 = arg1
0040b4cf      int32_t i
0040b4cf      
0040b4cf      do
0040b4cb          result = result << 4 ^ sx.d(*ecx_1)
0040b4cd          ecx_1 = &ecx_1[1]
0040b4ce          i = i_1
0040b4ce          i_1 -= 1
0040b4cf      while (i != 1)
0040b4cf  
0040b4d2  return result

0040b4d3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0040b4e0    int32_t sub_40b4e0(int32_t arg1)

0040b4e0  int32_t ecx
0040b4e0  int32_t var_4_1 = ecx
0040b4e8  int32_t ebp = 0
0040b4ee  int32_t var_4 = 0
0040b4ee  
0040b4f2  if (data_261d0ec s> 0)
0040b589      bool cond:1_1
0040b589      
0040b589      do
0040b4fd          int32_t i_12 = 4
0040b502          void* esi_1 = data_261d0b4 + ebp
0040b505          int32_t* edi_1 = esi_1 + 0x24
0040b519          int32_t i
0040b519          
0040b519          do
0040b510              *edi_1 = sub_40ff30(*edi_1)
0040b515              edi_1 = &edi_1[1]
0040b518              i = i_12
0040b518              i_12 -= 1
0040b519          while (i != 1)
0040b524          *(esi_1 + 0x34) = sub_40ff30(*(esi_1 + 0x34))
0040b52b          int32_t eax_5 = sub_40ff30(*(esi_1 + 0x38))
0040b530          int32_t ecx_2 = *(esi_1 + 0x3c)
0040b533          *(esi_1 + 0x38) = eax_5
0040b53f          *(esi_1 + 0x3c) = sub_40ff30(ecx_2)
0040b542          void* esi_2 = esi_1 + 0x18
0040b545          int32_t i_13 = 3
0040b573          int32_t i_1
0040b573          
0040b573          do
0040b553              *(esi_2 - 0x18) = fconvert.s(sub_40ff20(*(esi_2 - 0x18)))
0040b55f              *(esi_2 - 0xc) = fconvert.s(sub_40ff20(*(esi_2 - 0xc)))
0040b56a              *esi_2 = fconvert.s(sub_40ff20(*esi_2))
0040b56f              esi_2 += 4
0040b572              i_1 = i_13
0040b572              i_13 -= 1
0040b573          while (i_1 != 1)
0040b580          ebp += 0x40
0040b583          cond:1_1 = var_4 + 1 s< data_261d0ec
0040b585          var_4 += 1
0040b589      while (cond:1_1)
0040b589  
0040b594  int32_t i_2 = 0
0040b594  
0040b598  if (data_261d120 s> 0)
0040b59a      int32_t* esi_3 = nullptr
0040b59a      
0040b5ca      do
0040b59c          int32_t j_9 = 3
0040b5c0          int32_t j
0040b5c0          
0040b5c0          do
0040b5b9              *(esi_3 + data_261d11c) = fconvert.s(sub_40ff20(*(esi_3 + data_261d11c)))
0040b5bc              esi_3 = &esi_3[1]
0040b5bf              j = j_9
0040b5bf              j_9 -= 1
0040b5c0          while (j != 1)
0040b5c7          i_2 += 1
0040b5ca      while (i_2 s< data_261d120)
0040b5ca  
0040b5d1  int32_t i_3 = 0
0040b5d1  
0040b5d5  if (data_261d0d4 s> 0)
0040b5d7      int32_t edi_2 = 0
0040b5d7      
0040b643      do
0040b5d9          int32_t esi_4 = edi_2
0040b5db          int32_t j_5 = 3
0040b5ff          int32_t j_1
0040b5ff          
0040b5ff          do
0040b5f8              *(data_261d1fc + esi_4) = fconvert.s(sub_40ff20(*(data_261d1fc + esi_4)))
0040b5fb              esi_4 += 4
0040b5fe              j_1 = j_5
0040b5fe              j_5 -= 1
0040b5ff          while (j_1 != 1)
0040b617          *(edi_2 + data_261d1fc + 0xc) =
0040b617              fconvert.s(sub_40ff20(*(edi_2 + data_261d1fc + 0xc)))
0040b634          i_3 += 1
0040b635          *(edi_2 + data_261d1fc + 0x10) = sub_40ff30(*(edi_2 + data_261d1fc + 0x10))
0040b63e          edi_2 += 0x14
0040b643      while (i_3 s< data_261d0d4)
0040b643  
0040b64a  int32_t i_4 = 0
0040b64a  
0040b64e  if (data_261d1ec s> 0)
0040b650      int32_t* edi_3 = nullptr
0040b650      
0040b6bc      do
0040b652          int32_t* esi_5 = edi_3
0040b654          int32_t j_6 = 8
0040b678          int32_t j_2
0040b678          
0040b678          do
0040b671              *(esi_5 + data_261d1f8) = fconvert.s(sub_40ff20(*(esi_5 + data_261d1f8)))
0040b674              esi_5 = &esi_5[1]
0040b677              j_2 = j_6
0040b677              j_6 -= 1
0040b678          while (j_2 != 1)
0040b690          *(edi_3 + data_261d1f8 + 0x20) = sub_40ff30(*(edi_3 + data_261d1f8 + 0x20))
0040b6ad          i_4 += 1
0040b6ae          *(edi_3 + data_261d1f8 + 0x24) = sub_40ff30(*(edi_3 + data_261d1f8 + 0x24))
0040b6b7          edi_3 = &edi_3[0xa]
0040b6bc      while (i_4 s< data_261d1ec)
0040b6bc  
0040b6c3  int32_t i_5 = 0
0040b6c3  
0040b6c7  if (data_261d0c0 s> 0)
0040b6cd      int16_t* esi_6 = nullptr
0040b6cd      
0040b77f      do
0040b6d5          int32_t eax_26
0040b6d5          eax_26.w = *(esi_6 + data_261d0f8 + 0xa)
0040b6e6          *(esi_6 + data_261d0f8 + 0xa) = sub_40ff10(eax_26.w)
0040b701          *(esi_6 + data_261d0f8) = sub_40ff10(*(esi_6 + data_261d0f8))
0040b71c          *(esi_6 + data_261d0f8 + 2) = sub_40ff10(*(esi_6 + data_261d0f8 + 2))
0040b737          *(esi_6 + data_261d0f8 + 0x10) = sub_40ff30(*(esi_6 + data_261d0f8 + 0x10))
0040b751          *(esi_6 + data_261d0f8 + 4) = sub_40ff30(*(esi_6 + data_261d0f8 + 4))
0040b75b          int32_t eax_33
0040b75b          eax_33.w = *(esi_6 + data_261d0f8 + 8)
0040b76f          i_5 += 1
0040b770          *(esi_6 + data_261d0f8 + 8) = sub_40ff10(eax_33.w)
0040b77a          esi_6 = &esi_6[0xa]
0040b77f      while (i_5 s< data_261d0c0)
0040b77f  
0040b78a  int32_t i_6 = 0
0040b78a  
0040b78e  if (data_261d0d8 s> 0)
0040b794      int32_t* esi_7 = nullptr
0040b794      
0040b876      do
0040b7ae          void* edi_4 = esi_7 + 0xe
0040b7b1          int32_t j_7 = 3
0040b7b6          *(esi_7 + data_261d100) = sub_40ff30(*(esi_7 + data_261d100))
0040b7f6          int32_t eax_37
0040b7f6          int32_t j_3
0040b7f6          
0040b7f6          do
0040b7bf              eax_37.w = *(edi_4 + data_261d100 - 6)
0040b7d0              *(edi_4 + data_261d100 - 6) = sub_40ff10(eax_37.w)
0040b7ee              *(edi_4 + data_261d100) = sub_40ff10(*(edi_4 + data_261d100)).w
0040b7f2              edi_4 += 2
0040b7f5              j_3 = j_7
0040b7f5              j_7 -= 1
0040b7f6          while (j_3 != 1)
0040b7fe          eax_37.w = *(esi_7 + data_261d100 + 4)
0040b80f          *(esi_7 + data_261d100 + 4) = sub_40ff10(eax_37.w)
0040b82b          *(esi_7 + data_261d100 + 6) = sub_40ff10(*(esi_7 + data_261d100 + 6))
0040b847          *(esi_7 + data_261d100 + 0x14) = sub_40ff10(*(esi_7 + data_261d100 + 0x14))
0040b866          i_6 += 1
0040b867          *(esi_7 + data_261d100 + 0x16) = sub_40ff10(*(esi_7 + data_261d100 + 0x16))
0040b871          esi_7 = &esi_7[6]
0040b876      while (i_6 s< data_261d0d8)
0040b876  
0040b881  int32_t i_7 = 0
0040b881  
0040b885  if (data_261d0a8 s> 0)
0040b88b      int32_t* edi_5 = nullptr
0040b88b      
0040b94f      do
0040b8a5          void* esi_8 = edi_5 + 0xe
0040b8a8          int32_t j_8 = 3
0040b8ad          *(edi_5 + data_261d10c) = sub_40ff30(*(edi_5 + data_261d10c))
0040b8ed          int32_t eax_46
0040b8ed          int32_t j_4
0040b8ed          
0040b8ed          do
0040b8b6              eax_46.w = *(esi_8 + data_261d10c - 6)
0040b8c7              *(esi_8 + data_261d10c - 6) = sub_40ff10(eax_46.w)
0040b8e5              *(esi_8 + data_261d10c) = sub_40ff10(*(esi_8 + data_261d10c)).w
0040b8e9              esi_8 += 2
0040b8ec              j_4 = j_8
0040b8ec              j_8 -= 1
0040b8ed          while (j_4 != 1)
0040b8f5          eax_46.w = *(edi_5 + data_261d10c + 0x14)
0040b906          *(edi_5 + data_261d10c + 0x14) = sub_40ff10(eax_46.w)
0040b922          *(edi_5 + data_261d10c + 0x16) = sub_40ff10(*(edi_5 + data_261d10c + 0x16))
0040b940          i_7 += 1
0040b941          *(edi_5 + data_261d10c + 4) = sub_40ff30(*(edi_5 + data_261d10c + 4))
0040b94a          edi_5 = &edi_5[7]
0040b94f      while (i_7 s< data_261d0a8)
0040b94f  
0040b95a  int32_t i_8 = 0
0040b95a  
0040b95e  if (data_261d0ac s> 0)
0040b9bb      do
0040b975          *(data_261d1e0 + (i_8 << 3)) = sub_40ff30(*(data_261d1e0 + (i_8 << 3)))
0040b97e          int32_t eax_55
0040b97e          eax_55.w = *(data_261d1e0 + (i_8 << 3) + 4)
0040b98f          *(data_261d1e0 + (i_8 << 3) + 4) = sub_40ff10(eax_55.w)
0040b9ae          *(data_261d1e0 + (i_8 << 3) + 6) = sub_40ff10(*(data_261d1e0 + (i_8 << 3) + 6))
0040b9b8          i_8 += 1
0040b9bb      while (i_8 s< data_261d0ac)
0040b9bb  
0040b9c4  if (data_261d0c8 != 0)
0040b9ca      int32_t* esi_9 = data_261d0b0
0040b9d2      int32_t i_14
0040b9d2      
0040b9d2      if (arg1 == 0)
0040b9e3          i_14 = sub_40ff30(*esi_9)
0040b9d2      else
0040b9d4          i_14 = *esi_9
0040b9d4      
0040b9f0      *esi_9 = sub_40ff30(*esi_9)
0040b9f0      
0040b9f4      if (i_14 s> 0)
0040b9f6          void* esi_10 = &esi_9[1]
0040ba0a          int32_t i_9
0040ba0a          
0040ba0a          do
0040ba01              *esi_10 = sub_40ff30(*esi_10)
0040ba06              esi_10 += 4
0040ba09              i_9 = i_14
0040ba09              i_14 -= 1
0040ba0a          while (i_9 != 1)
0040ba0a  
0040ba11  int32_t i_10 = 0
0040ba11  
0040ba15  if (data_261d1f0 s> 0)
0040ba3c      do
0040ba1d          int32_t eax_65
0040ba1d          eax_65.w = *(data_261d0e0 + (i_10 << 1))
0040ba30          *(data_261d0e0 + (i_10 << 1)) = sub_40ff10(eax_65.w)
0040ba39          i_10 += 1
0040ba3c      while (i_10 s< data_261d1f0)
0040ba3c  
0040ba43  int32_t i_11 = 0
0040ba43  
0040ba47  if (data_261d0b8 s> 0)
0040ba6c      do
0040ba61          *(data_261d0e4 + (i_11 << 2)) = sub_40ff30(*(data_261d0e4 + (i_11 << 2)))
0040ba69          i_11 += 1
0040ba6c      while (i_11 s< data_261d0b8)
0040ba6c  
0040ba6e  int32_t result = data_261d0bc
0040ba73  int32_t esi_11 = 0
0040ba73  
0040ba77  if (result s> 0)
0040baba      do
0040ba7f          result.w = *(data_261d0f4 + (esi_11 << 2))
0040ba8f          *(data_261d0f4 + (esi_11 << 2)) = sub_40ff10(result.w)
0040baad          *(data_261d0f4 + (esi_11 << 2) + 2) =
0040baad              sub_40ff10(*(data_261d0f4 + (esi_11 << 2) + 2))
0040bab2          result = data_261d0bc
0040bab7          esi_11 += 1
0040baba      while (esi_11 s< result)
0040baba  
0040bac1  return result

0040bac2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0040bad0    int32_t sub_40bad0(int32_t arg1, int32_t arg2, int32_t arg3)

0040bad7  int32_t esi = data_261d0f0
0040bae2  int32_t ebx = *(esi + (arg1 << 3) + 8)
0040bae6  int32_t edi = *(esi + (arg1 << 3) + 4)
0040bae6  
0040baf1  if (mods.dp.d(sx.q(ebx), arg3) != 0)
0040baf8      sub_40f970("HL_LoadBSPFile: odd lump size")
0040bafd      esi = data_261d0f0
0040bafd  
0040bb13  int32_t esi_2
0040bb13  int32_t edi_2
0040bb13  edi_2, esi_2 = __builtin_memcpy(dest: arg2, src: esi + edi, n: ebx u>> 2 << 2)
0040bb1a  __builtin_memcpy(dest: edi_2, src: esi_2, n: ebx & 3)
0040bb23  return divs.dp.d(sx.q(ebx), arg3)

0040bb24              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040bb30    int32_t sub_40bb30(int32_t arg1, void* arg2, void* arg3)

0040bb46  sub_40fcf0(arg1, &data_261d0f0, arg2, arg3)
0040bb46  
0040bb72  for (int32_t* i = nullptr; i s< 0x7c; )
0040bb5a      int32_t eax_1 = sub_40ff30(*(i + data_261d0f0))
0040bb65      i = &i[1]
0040bb6e      *(i + data_261d0f0 - 4) = eax_1
0040bb6e  
0040bb7a  int32_t eax_2 = *data_261d0f0
0040bb7a  
0040bb7f  if (eax_2 != 0x1e)
0040bb81      int32_t var_c_2 = 0x1e
0040bb83      int32_t var_10_1 = eax_2
0040bb84      int32_t var_14_1 = arg1
0040bb8a      sub_40f970("%s is version %i, not %i")
0040bb8a  
0040bb9c  int32_t eax_4 = sub_40bad0(0xe, data_261d0b4, 0x40)
0040bba1  int32_t ecx_2 = data_261d11c
0040bbac  data_261d0ec = eax_4
0040bbb1  int32_t eax_5 = sub_40bad0(3, ecx_2, 0xc)
0040bbb6  int32_t edx_3 = data_261d1fc
0040bbc1  data_261d120 = eax_5
0040bbcb  data_261d0d4 = sub_40bad0(1, edx_3, 0x14)
0040bbda  int32_t eax_8 = sub_40bad0(0xa, data_261d10c, 0x1c)
0040bbdf  int32_t ecx_3 = data_261d100
0040bbea  data_261d0a8 = eax_8
0040bbef  int32_t eax_9 = sub_40bad0(5, ecx_3, 0x18)
0040bbf4  int32_t edx_4 = data_261d1f8
0040bbff  data_261d0d8 = eax_9
0040bc0c  data_261d1ec = sub_40bad0(6, edx_4, 0x28)
0040bc1b  int32_t eax_12 = sub_40bad0(9, data_261d1e0, 8)
0040bc20  int32_t ecx_4 = data_261d0f8
0040bc2b  data_261d0ac = eax_12
0040bc30  int32_t eax_13 = sub_40bad0(7, ecx_4, 0x14)
0040bc35  int32_t edx_5 = data_261d0e0
0040bc40  data_261d0c0 = eax_13
0040bc4a  data_261d1f0 = sub_40bad0(0xb, edx_5, 2)
0040bc59  int32_t eax_16 = sub_40bad0(0xd, data_261d0e4, 4)
0040bc5e  int32_t ecx_5 = data_261d0f4
0040bc69  data_261d0b8 = eax_16
0040bc6e  int32_t eax_17 = sub_40bad0(0xc, ecx_5, 4)
0040bc73  int32_t edx_6 = data_261d0b0
0040bc7e  data_261d0bc = eax_17
0040bc8b  data_261d0c8 = sub_40bad0(2, edx_6, 1)
0040bc9f  data_261d090 = sub_40bad0(4, data_261d1f4, 1)
0040bcaf  int32_t eax_21 = sub_40bad0(8, data_261d0a0, 1)
0040bcb4  int32_t edx_7 = data_261d094
0040bcbf  data_261d09c = eax_21
0040bcc9  data_261d118 = sub_40bad0(0, edx_7, 1)
0040bcd4  sub_41e29e(data_261d0f0)
0040bcdb  sub_40b4e0(0)
0040bcf1  int32_t eax_24 = sub_40b4b0(data_261d0b4, data_261d0ec << 6)
0040bcf6  char* ecx_9 = data_261d11c
0040bcfc  data_261d0a4 = eax_24
0040bd13  data_261d0c4 = sub_40b4b0(ecx_9, data_261d120 * 0xc)
0040bd2f  data_261d1e8 = sub_40b4b0(data_261d1fc, data_261d0d4 * 0x14)
0040bd50  int32_t eax_33 = sub_40b4b0(data_261d10c, data_261d0a8 * 0x1c)
0040bd55  char* ecx_13 = data_261d100
0040bd5b  data_261d0dc = eax_33
0040bd72  data_261d110 = sub_40b4b0(ecx_13, data_261d0d8 * 0x18)
0040bd89  int32_t eax_40 = sub_40b4b0(data_261d1f8, data_261d1ec * 0x28)
0040bd8e  int32_t ecx_14 = data_261d0ac
0040bd94  data_261d108 = eax_40
0040bda7  int32_t eax_42 = sub_40b4b0(data_261d1e0, ecx_14 << 3)
0040bdac  char* edx_15 = data_261d0f8
0040bdb2  data_261d0fc = eax_42
0040bdc9  data_261d08c = sub_40b4b0(edx_15, data_261d0c0 * 0x14)
0040bdde  int32_t eax_46 = sub_40b4b0(data_261d0e0, data_261d1f0 * 2)
0040bde3  char* edx_17 = data_261d0e4
0040bde9  data_261d104 = eax_46
0040bdfc  int32_t eax_48 = sub_40b4b0(edx_17, data_261d0b8 << 2)
0040be01  char* edx_18 = data_261d0f4
0040be07  data_261d0cc = eax_48
0040be1a  int32_t eax_50 = sub_40b4b0(edx_18, data_261d0bc << 2)
0040be1f  char* ecx_20 = data_261d0b0
0040be28  data_261d088 = eax_50
0040be34  int32_t eax_52 = sub_40b4b0(ecx_20, data_261d0bc)
0040be39  int32_t edx_19 = data_261d090
0040be3f  data_261d1e4 = eax_52
0040be4b  int32_t eax_54 = sub_40b4b0(data_261d1f4, edx_19)
0040be50  int32_t ecx_21 = data_261d09c
0040be56  char* edx_20 = data_261d0a0
0040be5e  data_261d0d0 = eax_54
0040be63  int32_t eax_55 = sub_40b4b0(edx_20, ecx_21)
0040be68  char* ecx_22 = data_261d094
0040be6e  data_261d0e8 = eax_55
0040be7a  int32_t result = sub_40b4b0(ecx_22, data_261d118)
0040be82  data_261d114 = result
0040be89  return result

0040be8a                                90 90 90 90 90 90                                                            ......

0040be90    int32_t sub_40be90()

0040be90  void* eax_3 = data_261d118
0040be95  int32_t ecx = data_261d094
0040bea3  data_2584ecc = 0
0040bead  void* eax = sub_414130(ecx, eax_3, "*Half-Life bsp file")
0040beb7  sub_414010(eax, 0xc)
0040beb7  
0040bec7  if (sub_40e2a0(eax) != 0)
0040bed4      int32_t i
0040bed4      
0040bed4      do
0040beca          i = sub_40e2a0(eax)
0040bed4      while (i != 0)
0040bed4  
0040bee0  return sub_4105e0(eax)

0040bee1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040bef0    int32_t* sub_40bef0()

0040bef8  data_261d028 = 0
0040bf08  data_261d034 = sub_4105b0(0x4000)
0040bf0d  data_43033c = 0x4000
0040bf17  data_261d074 = 0
0040bf1d  void* eax_1 = sub_4105b0(0x100000)
0040bf2d  int32_t ecx_1 = data_43033c + 0x100000
0040bf33  data_261d00c = eax_1
0040bf38  data_43033c = ecx_1
0040bf3e  data_261d03c = 0
0040bf44  void* eax_2 = sub_4105b0(0x100000)
0040bf54  int32_t ecx_3 = data_43033c + 0x100000
0040bf5a  data_261d038 = eax_2
0040bf5f  data_43033c = ecx_3
0040bf65  data_261d040 = 0
0040bf6b  void* eax_3 = sub_4105b0(0x200000)
0040bf7b  int32_t ecx_5 = data_43033c + 0x200000
0040bf81  data_261d048 = eax_3
0040bf86  data_43033c = ecx_5
0040bf8c  data_261d058 = 0
0040bf92  void* eax_4 = sub_4105b0(0x10000)
0040bfa2  int32_t ecx_7 = data_43033c + 0x10000
0040bfa8  data_261d07c = eax_4
0040bfad  data_43033c = ecx_7
0040bfb3  data_261d06c = 0
0040bfb9  void* eax_5 = sub_4105b0(0xdffe4)
0040bfc9  int32_t ecx_9 = data_43033c + 0xdffe4
0040bfcf  data_261d070 = eax_5
0040bfd4  data_43033c = ecx_9
0040bfda  data_261d020 = 0
0040bfe0  void* eax_6 = sub_4105b0(0x28000)
0040bff0  int32_t ecx_11 = data_43033c + 0x28000
0040bff6  data_261d01c = eax_6
0040bffb  data_43033c = ecx_11
0040c001  data_261d084 = 0
0040c007  void* eax_7 = sub_4105b0(0xbfff4)
0040c017  int32_t ecx_13 = data_43033c + 0xbfff4
0040c01d  data_261d044 = eax_7
0040c022  data_43033c = ecx_13
0040c028  data_261d04c = 0
0040c02e  void* eax_8 = sub_4105b0(0xbffe8)
0040c03e  int32_t ecx_15 = data_43033c + 0xbffe8
0040c044  data_261d030 = eax_8
0040c049  data_43033c = ecx_15
0040c04f  data_261d080 = 0
0040c055  void* eax_9 = sub_4105b0(0x28000)
0040c065  int32_t ecx_17 = data_43033c + 0x28000
0040c06b  data_261d078 = eax_9
0040c070  data_43033c = ecx_17
0040c076  data_261d054 = 0
0040c07c  void* eax_10 = sub_4105b0(0x13ffec)
0040c08c  int32_t ecx_19 = data_43033c + 0x13ffec
0040c092  data_261d018 = eax_10
0040c097  data_43033c = ecx_19
0040c09d  data_261d02c = 0
0040c0a8  data_261d064 = sub_4105b0(0x3fff8)
0040c0b8  int32_t ecx_21 = data_43033c + 0x3fff8
0040c0be  data_261d050 = 0
0040c0c4  data_43033c = ecx_21
0040c0ca  void* eax_12 = sub_4105b0(0xfa000)
0040c0da  int32_t ecx_23 = data_43033c + 0x3e800
0040c0e0  data_261d014 = eax_12
0040c0e5  data_43033c = ecx_23
0040c0eb  data_261d068 = 0
0040c0f1  void* eax_13 = sub_4105b0(0x1fffe)
0040c101  int32_t ecx_25 = data_43033c + 0x1fffe
0040c107  data_261d05c = eax_13
0040c10c  data_43033c = ecx_25
0040c112  data_261d024 = 0
0040c118  void* eax_14 = sub_4105b0(0x1f4000)
0040c128  int32_t edx_1 = data_43033c + 0x1f4000
0040c12e  data_261d060 = eax_14
0040c133  data_43033c = edx_1
0040c139  sub_410030("allocated ")
0040c147  sub_4105f0(data_43033c)
0040c15a  return sub_410030(" of BSP memory\n")

0040c15b                                                                                   90 90 90 90 90                             .....

0040c160    int32_t* sub_40c160()

0040c160  void* eax_5 = data_261d034
0040c169  data_261d028 = 0
0040c16f  sub_4105e0(eax_5)
0040c174  void* ecx = data_261d00c
0040c17a  data_261d034 = 0
0040c181  data_261d074 = 0
0040c187  sub_4105e0(ecx)
0040c18c  void* edx = data_261d038
0040c192  data_261d00c = 0
0040c199  data_261d03c = 0
0040c19f  sub_4105e0(edx)
0040c1a4  void* eax = data_261d048
0040c1a9  data_261d038 = 0
0040c1b0  data_261d040 = 0
0040c1b6  sub_4105e0(eax)
0040c1bb  void* ecx_1 = data_261d07c
0040c1c1  data_261d048 = 0
0040c1c8  data_261d058 = 0
0040c1ce  sub_4105e0(ecx_1)
0040c1d3  void* edx_1 = data_261d070
0040c1d9  data_261d07c = 0
0040c1e0  data_261d06c = 0
0040c1e6  sub_4105e0(edx_1)
0040c1eb  void* eax_1 = data_261d01c
0040c1f0  data_261d070 = 0
0040c1f7  data_261d020 = 0
0040c1fd  sub_4105e0(eax_1)
0040c202  void* ecx_2 = data_261d044
0040c208  data_261d01c = 0
0040c20f  data_261d084 = 0
0040c215  sub_4105e0(ecx_2)
0040c21a  void* edx_2 = data_261d030
0040c220  data_261d044 = 0
0040c227  data_261d04c = 0
0040c22d  sub_4105e0(edx_2)
0040c232  void* eax_2 = data_261d078
0040c237  data_261d030 = 0
0040c23e  data_261d080 = 0
0040c244  sub_4105e0(eax_2)
0040c249  void* ecx_3 = data_261d018
0040c24f  data_261d078 = 0
0040c256  data_261d054 = 0
0040c25c  sub_4105e0(ecx_3)
0040c261  void* edx_3 = data_261d064
0040c267  data_261d018 = 0
0040c26e  data_261d02c = 0
0040c274  sub_4105e0(edx_3)
0040c279  void* eax_3 = data_261d014
0040c27e  data_261d064 = 0
0040c285  data_261d050 = 0
0040c28b  sub_4105e0(eax_3)
0040c290  void* ecx_4 = data_261d05c
0040c296  data_261d014 = 0
0040c29d  data_261d068 = 0
0040c2a3  sub_4105e0(ecx_4)
0040c2a8  void* edx_4 = data_261d060
0040c2ae  data_261d05c = 0
0040c2b5  data_261d024 = 0
0040c2bb  sub_4105e0(edx_4)
0040c2c5  data_261d060 = 0
0040c2cb  sub_410030("freed ")
0040c2d9  sub_4105f0(data_43033c)
0040c2e3  int32_t* result = sub_410030(" of BSP memory\n")
0040c2eb  data_43033c = 0
0040c2f2  return result

0040c2f3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0040c300    int32_t sub_40c300(int32_t arg1)

0040c300  int32_t ecx
0040c300  int32_t var_4_1 = ecx
0040c308  int32_t ebp = 0
0040c30e  int32_t var_4 = 0
0040c30e  
0040c312  if (data_261d028 s> 0)
0040c3a9      bool cond:1_1
0040c3a9      
0040c3a9      do
0040c31d          int32_t i_12 = 4
0040c322          void* esi_1 = data_261d034 + ebp
0040c325          int32_t* edi_1 = esi_1 + 0x24
0040c339          int32_t i
0040c339          
0040c339          do
0040c330              *edi_1 = sub_40ff30(*edi_1)
0040c335              edi_1 = &edi_1[1]
0040c338              i = i_12
0040c338              i_12 -= 1
0040c339          while (i != 1)
0040c344          *(esi_1 + 0x34) = sub_40ff30(*(esi_1 + 0x34))
0040c34b          int32_t eax_5 = sub_40ff30(*(esi_1 + 0x38))
0040c350          int32_t ecx_2 = *(esi_1 + 0x3c)
0040c353          *(esi_1 + 0x38) = eax_5
0040c35f          *(esi_1 + 0x3c) = sub_40ff30(ecx_2)
0040c362          void* esi_2 = esi_1 + 0x18
0040c365          int32_t i_13 = 3
0040c393          int32_t i_1
0040c393          
0040c393          do
0040c373              *(esi_2 - 0x18) = fconvert.s(sub_40ff20(*(esi_2 - 0x18)))
0040c37f              *(esi_2 - 0xc) = fconvert.s(sub_40ff20(*(esi_2 - 0xc)))
0040c38a              *esi_2 = fconvert.s(sub_40ff20(*esi_2))
0040c38f              esi_2 += 4
0040c392              i_1 = i_13
0040c392              i_13 -= 1
0040c393          while (i_1 != 1)
0040c3a0          ebp += 0x40
0040c3a3          cond:1_1 = var_4 + 1 s< data_261d028
0040c3a5          var_4 += 1
0040c3a9      while (cond:1_1)
0040c3a9  
0040c3b4  int32_t i_2 = 0
0040c3b4  
0040c3b8  if (data_261d084 s> 0)
0040c3ba      int32_t* esi_3 = nullptr
0040c3ba      
0040c3ea      do
0040c3bc          int32_t j_9 = 3
0040c3e0          int32_t j
0040c3e0          
0040c3e0          do
0040c3d9              *(esi_3 + data_261d044) = fconvert.s(sub_40ff20(*(esi_3 + data_261d044)))
0040c3dc              esi_3 = &esi_3[1]
0040c3df              j = j_9
0040c3df              j_9 -= 1
0040c3e0          while (j != 1)
0040c3e7          i_2 += 1
0040c3ea      while (i_2 s< data_261d084)
0040c3ea  
0040c3f1  int32_t i_3 = 0
0040c3f1  
0040c3f5  if (data_261d020 s> 0)
0040c3f7      int32_t edi_2 = 0
0040c3f7      
0040c463      do
0040c3f9          int32_t esi_4 = edi_2
0040c3fb          int32_t j_5 = 3
0040c41f          int32_t j_1
0040c41f          
0040c41f          do
0040c418              *(data_261d01c + esi_4) = fconvert.s(sub_40ff20(*(data_261d01c + esi_4)))
0040c41b              esi_4 += 4
0040c41e              j_1 = j_5
0040c41e              j_5 -= 1
0040c41f          while (j_1 != 1)
0040c437          *(edi_2 + data_261d01c + 0xc) =
0040c437              fconvert.s(sub_40ff20(*(edi_2 + data_261d01c + 0xc)))
0040c454          i_3 += 1
0040c455          *(edi_2 + data_261d01c + 0x10) = sub_40ff30(*(edi_2 + data_261d01c + 0x10))
0040c45e          edi_2 += 0x14
0040c463      while (i_3 s< data_261d020)
0040c463  
0040c46a  int32_t i_4 = 0
0040c46a  
0040c46e  if (data_261d080 s> 0)
0040c470      int32_t* edi_3 = nullptr
0040c470      
0040c4dc      do
0040c472          int32_t* esi_5 = edi_3
0040c474          int32_t j_6 = 8
0040c498          int32_t j_2
0040c498          
0040c498          do
0040c491              *(esi_5 + data_261d078) = fconvert.s(sub_40ff20(*(esi_5 + data_261d078)))
0040c494              esi_5 = &esi_5[1]
0040c497              j_2 = j_6
0040c497              j_6 -= 1
0040c498          while (j_2 != 1)
0040c4b0          *(edi_3 + data_261d078 + 0x20) = sub_40ff30(*(edi_3 + data_261d078 + 0x20))
0040c4cd          i_4 += 1
0040c4ce          *(edi_3 + data_261d078 + 0x24) = sub_40ff30(*(edi_3 + data_261d078 + 0x24))
0040c4d7          edi_3 = &edi_3[0xa]
0040c4dc      while (i_4 s< data_261d080)
0040c4dc  
0040c4e3  int32_t i_5 = 0
0040c4e3  
0040c4e7  if (data_261d054 s> 0)
0040c4ed      int16_t* esi_6 = nullptr
0040c4ed      
0040c59f      do
0040c4f5          int32_t eax_26
0040c4f5          eax_26.w = *(esi_6 + data_261d018 + 0xa)
0040c506          *(esi_6 + data_261d018 + 0xa) = sub_40ff10(eax_26.w)
0040c521          *(esi_6 + data_261d018) = sub_40ff10(*(esi_6 + data_261d018))
0040c53c          *(esi_6 + data_261d018 + 2) = sub_40ff10(*(esi_6 + data_261d018 + 2))
0040c557          *(esi_6 + data_261d018 + 0x10) = sub_40ff30(*(esi_6 + data_261d018 + 0x10))
0040c571          *(esi_6 + data_261d018 + 4) = sub_40ff30(*(esi_6 + data_261d018 + 4))
0040c57b          int32_t eax_33
0040c57b          eax_33.w = *(esi_6 + data_261d018 + 8)
0040c58f          i_5 += 1
0040c590          *(esi_6 + data_261d018 + 8) = sub_40ff10(eax_33.w)
0040c59a          esi_6 = &esi_6[0xa]
0040c59f      while (i_5 s< data_261d054)
0040c59f  
0040c5aa  int32_t i_6 = 0
0040c5aa  
0040c5ae  if (data_261d04c s> 0)
0040c5b4      int32_t* esi_7 = nullptr
0040c5b4      
0040c696      do
0040c5ce          void* edi_4 = esi_7 + 0xe
0040c5d1          int32_t j_7 = 3
0040c5d6          *(esi_7 + data_261d030) = sub_40ff30(*(esi_7 + data_261d030))
0040c616          int32_t eax_37
0040c616          int32_t j_3
0040c616          
0040c616          do
0040c5df              eax_37.w = *(edi_4 + data_261d030 - 6)
0040c5f0              *(edi_4 + data_261d030 - 6) = sub_40ff10(eax_37.w)
0040c60e              *(edi_4 + data_261d030) = sub_40ff10(*(edi_4 + data_261d030)).w
0040c612              edi_4 += 2
0040c615              j_3 = j_7
0040c615              j_7 -= 1
0040c616          while (j_3 != 1)
0040c61e          eax_37.w = *(esi_7 + data_261d030 + 4)
0040c62f          *(esi_7 + data_261d030 + 4) = sub_40ff10(eax_37.w)
0040c64b          *(esi_7 + data_261d030 + 6) = sub_40ff10(*(esi_7 + data_261d030 + 6))
0040c667          *(esi_7 + data_261d030 + 0x14) = sub_40ff10(*(esi_7 + data_261d030 + 0x14))
0040c686          i_6 += 1
0040c687          *(esi_7 + data_261d030 + 0x16) = sub_40ff10(*(esi_7 + data_261d030 + 0x16))
0040c691          esi_7 = &esi_7[6]
0040c696      while (i_6 s< data_261d04c)
0040c696  
0040c6a1  int32_t i_7 = 0
0040c6a1  
0040c6a5  if (data_261d06c s> 0)
0040c6ab      int32_t* edi_5 = nullptr
0040c6ab      
0040c76f      do
0040c6c5          void* esi_8 = edi_5 + 0xe
0040c6c8          int32_t j_8 = 3
0040c6cd          *(edi_5 + data_261d070) = sub_40ff30(*(edi_5 + data_261d070))
0040c70d          int32_t eax_46
0040c70d          int32_t j_4
0040c70d          
0040c70d          do
0040c6d6              eax_46.w = *(esi_8 + data_261d070 - 6)
0040c6e7              *(esi_8 + data_261d070 - 6) = sub_40ff10(eax_46.w)
0040c705              *(esi_8 + data_261d070) = sub_40ff10(*(esi_8 + data_261d070)).w
0040c709              esi_8 += 2
0040c70c              j_4 = j_8
0040c70c              j_8 -= 1
0040c70d          while (j_4 != 1)
0040c715          eax_46.w = *(edi_5 + data_261d070 + 0x14)
0040c726          *(edi_5 + data_261d070 + 0x14) = sub_40ff10(eax_46.w)
0040c742          *(edi_5 + data_261d070 + 0x16) = sub_40ff10(*(edi_5 + data_261d070 + 0x16))
0040c760          i_7 += 1
0040c761          *(edi_5 + data_261d070 + 4) = sub_40ff30(*(edi_5 + data_261d070 + 4))
0040c76a          edi_5 = &edi_5[7]
0040c76f      while (i_7 s< data_261d06c)
0040c76f  
0040c77a  int32_t i_8 = 0
0040c77a  
0040c77e  if (data_261d02c s> 0)
0040c7db      do
0040c795          *(data_261d064 + (i_8 << 3)) = sub_40ff30(*(data_261d064 + (i_8 << 3)))
0040c79e          int32_t eax_55
0040c79e          eax_55.w = *(data_261d064 + (i_8 << 3) + 4)
0040c7af          *(data_261d064 + (i_8 << 3) + 4) = sub_40ff10(eax_55.w)
0040c7ce          *(data_261d064 + (i_8 << 3) + 6) = sub_40ff10(*(data_261d064 + (i_8 << 3) + 6))
0040c7d8          i_8 += 1
0040c7db      while (i_8 s< data_261d02c)
0040c7db  
0040c7e4  if (data_261d040 != 0)
0040c7ea      int32_t* esi_9 = data_261d048
0040c7f2      int32_t i_14
0040c7f2      
0040c7f2      if (arg1 == 0)
0040c803          i_14 = sub_40ff30(*esi_9)
0040c7f2      else
0040c7f4          i_14 = *esi_9
0040c7f4      
0040c810      *esi_9 = sub_40ff30(*esi_9)
0040c810      
0040c814      if (i_14 s> 0)
0040c816          void* esi_10 = &esi_9[1]
0040c82a          int32_t i_9
0040c82a          
0040c82a          do
0040c821              *esi_10 = sub_40ff30(*esi_10)
0040c826              esi_10 += 4
0040c829              i_9 = i_14
0040c829              i_14 -= 1
0040c82a          while (i_9 != 1)
0040c82a  
0040c831  int32_t i_10 = 0
0040c831  
0040c835  if (data_261d068 s> 0)
0040c85c      do
0040c83d          int32_t eax_65
0040c83d          eax_65.w = *(data_261d05c + (i_10 << 1))
0040c850          *(data_261d05c + (i_10 << 1)) = sub_40ff10(eax_65.w)
0040c859          i_10 += 1
0040c85c      while (i_10 s< data_261d068)
0040c85c  
0040c863  int32_t i_11 = 0
0040c863  
0040c867  if (data_261d024 s> 0)
0040c88c      do
0040c881          *(data_261d060 + (i_11 << 2)) = sub_40ff30(*(data_261d060 + (i_11 << 2)))
0040c889          i_11 += 1
0040c88c      while (i_11 s< data_261d024)
0040c88c  
0040c88e  int32_t result = data_261d050
0040c893  int32_t esi_11 = 0
0040c893  
0040c897  if (result s> 0)
0040c8da      do
0040c89f          result.w = *(data_261d014 + (esi_11 << 2))
0040c8af          *(data_261d014 + (esi_11 << 2)) = sub_40ff10(result.w)
0040c8cd          *(data_261d014 + (esi_11 << 2) + 2) =
0040c8cd              sub_40ff10(*(data_261d014 + (esi_11 << 2) + 2))
0040c8d2          result = data_261d050
0040c8d7          esi_11 += 1
0040c8da      while (esi_11 s< result)
0040c8da  
0040c8e1  return result

0040c8e2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0040c8f0    int32_t sub_40c8f0(int32_t arg1, int32_t arg2, int32_t arg3)

0040c8f7  int32_t esi = data_261d010
0040c902  int32_t ebx = *(esi + (arg1 << 3) + 8)
0040c906  int32_t edi = *(esi + (arg1 << 3) + 4)
0040c906  
0040c911  if (mods.dp.d(sx.q(ebx), arg3) != 0)
0040c918      sub_40f970("Q1_LoadBSPFile: odd lump size")
0040c91d      esi = data_261d010
0040c91d  
0040c933  int32_t esi_2
0040c933  int32_t edi_2
0040c933  edi_2, esi_2 = __builtin_memcpy(dest: arg2, src: esi + edi, n: ebx u>> 2 << 2)
0040c93a  __builtin_memcpy(dest: edi_2, src: esi_2, n: ebx & 3)
0040c943  return divs.dp.d(sx.q(ebx), arg3)

0040c944              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040c950    int32_t sub_40c950(int32_t arg1, void* arg2, void* arg3)

0040c966  sub_40fcf0(arg1, &data_261d010, arg2, arg3)
0040c98f  int32_t i
0040c98f  
0040c98f  for (i = 0; i s< 0x1f; i += 1)
0040c988      *(data_261d010 + (i << 2)) = sub_40ff30(*(data_261d010 + (i << 2)))
0040c988  
0040c99a  if (*data_261d010 != 0x1d)
0040c99c      int32_t var_c_2 = 0x1d
0040c99e      int32_t i_1 = i
0040c99f      int32_t var_14_1 = arg1
0040c9a5      sub_40f970("%s is version %i, not %i")
0040c9a5  
0040c9b7  int32_t eax_3 = sub_40c8f0(0xe, data_261d034, 0x40)
0040c9bc  int32_t ecx_2 = data_261d044
0040c9c7  data_261d028 = eax_3
0040c9cc  int32_t eax_4 = sub_40c8f0(3, ecx_2, 0xc)
0040c9d1  int32_t edx_3 = data_261d01c
0040c9dc  data_261d084 = eax_4
0040c9e6  data_261d020 = sub_40c8f0(1, edx_3, 0x14)
0040c9f5  int32_t eax_7 = sub_40c8f0(0xa, data_261d070, 0x1c)
0040c9fa  int32_t ecx_3 = data_261d030
0040ca05  data_261d06c = eax_7
0040ca0a  int32_t eax_8 = sub_40c8f0(5, ecx_3, 0x18)
0040ca0f  int32_t edx_4 = data_261d078
0040ca1a  data_261d04c = eax_8
0040ca27  data_261d080 = sub_40c8f0(6, edx_4, 0x28)
0040ca36  int32_t eax_11 = sub_40c8f0(9, data_261d064, 8)
0040ca3b  int32_t ecx_4 = data_261d018
0040ca46  data_261d02c = eax_11
0040ca4b  int32_t eax_12 = sub_40c8f0(7, ecx_4, 0x14)
0040ca50  int32_t edx_5 = data_261d05c
0040ca5b  data_261d054 = eax_12
0040ca65  data_261d068 = sub_40c8f0(0xb, edx_5, 2)
0040ca74  int32_t eax_15 = sub_40c8f0(0xd, data_261d060, 4)
0040ca79  int32_t ecx_5 = data_261d014
0040ca84  data_261d024 = eax_15
0040ca89  int32_t eax_16 = sub_40c8f0(0xc, ecx_5, 4)
0040ca8e  int32_t edx_6 = data_261d048
0040ca99  data_261d050 = eax_16
0040caa6  data_261d040 = sub_40c8f0(2, edx_6, 1)
0040caba  data_261d074 = sub_40c8f0(4, data_261d00c, 1)
0040caca  int32_t eax_20 = sub_40c8f0(8, data_261d038, 1)
0040cacf  int32_t edx_7 = data_261d07c
0040cada  data_261d03c = eax_20
0040cae4  data_261d058 = sub_40c8f0(0, edx_7, 1)
0040caef  sub_41e29e(data_261d010)
0040cb00  return sub_40c300(0)

0040cb01     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040cb10    int32_t sub_40cb10()

0040cb10  void* eax_3 = data_261d058
0040cb15  int32_t ecx = data_261d07c
0040cb23  data_2584ecc = 0
0040cb2d  void* eax = sub_414130(ecx, eax_3, "*Quake1 bsp file")
0040cb37  sub_414010(eax, 0xc)
0040cb37  
0040cb47  if (sub_40e2a0(eax) != 0)
0040cb54      int32_t i
0040cb54      
0040cb54      do
0040cb4a          i = sub_40e2a0(eax)
0040cb54      while (i != 0)
0040cb54  
0040cb60  return sub_4105e0(eax)

0040cb61     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040cb70    int32_t* sub_40cb70()

0040cb78  data_2584e90 = 0
0040cb7e  void* eax = sub_410570(0xc000)
0040cb8e  int32_t ecx_1 = data_430344 + 0xc000
0040cb94  data_2584ec0 = eax
0040cb99  data_430344 = ecx_1
0040cb9f  data_2584ec4 = 0
0040cba5  void* eax_1 = sub_410570(0x280000)
0040cbb5  int32_t ecx_3 = data_430344 + 0x280000
0040cbbb  data_255ee44 = eax_1
0040cbc0  data_261d004 = eax_1
0040cbc5  data_430344 = ecx_3
0040cbcb  data_2584edc = 0
0040cbd1  void* eax_2 = sub_410570(0x320000)
0040cbe1  int32_t ecx_5 = data_430344 + 0x320000
0040cbe7  data_256ee64 = eax_2
0040cbec  data_430344 = ecx_5
0040cbf2  data_2584eec = 0
0040cbf8  void* eax_3 = sub_410570(0x40000)
0040cc08  int32_t ecx_7 = data_430344 + 0x40000
0040cc0e  data_256ee60 = eax_3
0040cc13  data_430344 = ecx_7
0040cc19  data_2584e88 = 0
0040cc1f  void* eax_4 = sub_410570(0x1c0000)
0040cc2f  int32_t ecx_9 = data_430344 + 0x1c0000
0040cc35  data_2584e94 = eax_4
0040cc3a  data_430344 = ecx_9
0040cc40  data_2584ef4 = 0
0040cc46  void* eax_5 = sub_410570(0x140000)
0040cc56  int32_t ecx_11 = data_430344 + 0x140000
0040cc5c  data_261d008 = eax_5
0040cc61  data_430344 = ecx_11
0040cc67  data_2584ee8 = 0
0040cc6d  void* eax_6 = sub_410570(0xc0000)
0040cc7d  int32_t ecx_13 = data_430344 + 0xc0000
0040cc83  data_2584ed4 = eax_6
0040cc88  data_430344 = ecx_13
0040cc8e  data_2584eb8 = 0
0040cc94  void* eax_7 = sub_410570(0x1c0000)
0040cca4  int32_t ecx_15 = data_430344 + 0x1c0000
0040ccaa  data_2584ebc = eax_7
0040ccaf  data_430344 = ecx_15
0040ccb5  data_2584e9c = 0
0040ccbb  void* eax_8 = sub_410570(0x140000)
0040cccb  int32_t ecx_17 = data_430344 + 0x140000
0040ccd1  data_2584eac = eax_8
0040ccd6  data_430344 = ecx_17
0040ccdc  data_2584e98 = 0
0040cce2  void* eax_9 = sub_410570(0x7d000)
0040ccf2  int32_t ecx_19 = data_430344 + 0x7d000
0040ccf8  data_2584ea8 = eax_9
0040ccfd  data_430344 = ecx_19
0040cd03  data_2584e84 = 0
0040cd09  void* eax_10 = sub_410570(0x20000)
0040cd0e  int32_t ecx_20 = data_430344
0040cd14  data_2584eb4 = eax_10
0040cd1f  data_2584ee4 = 0
0040cd25  data_430344 = ecx_20 + 0x20000
0040cd30  void* eax_11 = sub_410570(0x20000)
0040cd40  int32_t ecx_23 = data_430344 + 0x20000
0040cd46  data_255ee4c = eax_11
0040cd4b  data_430344 = ecx_23
0040cd51  data_2584ed0 = 0
0040cd57  void* eax_12 = sub_410570(0xfa000)
0040cd67  int32_t ecx_25 = data_430344 + 0xfa000
0040cd6d  data_2584ed8 = eax_12
0040cd72  data_430344 = ecx_25
0040cd78  data_2584ec8 = 0
0040cd7e  void* eax_13 = sub_410570(0x18000)
0040cd8e  int32_t ecx_27 = data_430344 + 0x18000
0040cd94  data_261d000 = eax_13
0040cd99  data_430344 = ecx_27
0040cd9f  data_255ee48 = 0
0040cda5  void* eax_14 = sub_410570(0x40000)
0040cdb5  int32_t ecx_29 = data_430344 + 0x40000
0040cdbb  data_2584ee0 = eax_14
0040cdc0  data_430344 = ecx_29
0040cdc6  data_2584e80 = 0
0040cdcc  void* eax_15 = sub_410570(0x800)
0040cdda  int32_t ecx_31 = data_430344 + 0x800
0040cde0  data_2584e8c = eax_15
0040cdea  data_430344 = ecx_31
0040cdf0  data_2584ea0 = 0
0040cdf6  void* eax_16 = sub_410570(0x2000)
0040ce06  int32_t edx_1 = data_430344 + 0x2000
0040ce0c  data_2584ea4 = eax_16
0040ce11  data_430344 = edx_1
0040ce17  sub_410030("allocated ")
0040ce22  sub_4105f0(data_430344)
0040ce35  return sub_410030(" of BSP memory\n")

0040ce36                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040ce40    int32_t* sub_40ce40()

0040ce40  void* eax_5 = data_2584ec0
0040ce49  data_2584e90 = 0
0040ce4f  sub_4105e0(eax_5)
0040ce54  void* ecx = data_255ee44
0040ce5a  data_2584ec0 = 0
0040ce61  data_2584ec4 = 0
0040ce67  sub_4105e0(ecx)
0040ce6c  void* edx = data_256ee64
0040ce72  data_255ee44 = 0
0040ce79  data_261d004 = 0
0040ce7f  data_2584edc = 0
0040ce85  sub_4105e0(edx)
0040ce8a  void* eax = data_256ee60
0040ce8f  data_256ee64 = 0
0040ce96  data_2584eec = 0
0040ce9c  sub_4105e0(eax)
0040cea1  void* ecx_1 = data_2584e94
0040cea7  data_256ee60 = 0
0040ceae  data_2584e88 = 0
0040ceb4  sub_4105e0(ecx_1)
0040ceb9  void* edx_1 = data_261d008
0040cebf  data_2584e94 = 0
0040cec6  data_2584ef4 = 0
0040cecc  sub_4105e0(edx_1)
0040ced1  void* eax_1 = data_2584ed4
0040ced6  data_261d008 = 0
0040cedd  data_2584ee8 = 0
0040cee3  sub_4105e0(eax_1)
0040cee8  void* ecx_2 = data_2584ebc
0040ceee  data_2584ed4 = 0
0040cef5  data_2584eb8 = 0
0040cefb  sub_4105e0(ecx_2)
0040cf00  void* edx_2 = data_2584eac
0040cf06  data_2584ebc = 0
0040cf0d  data_2584e9c = 0
0040cf13  sub_4105e0(edx_2)
0040cf18  void* eax_2 = data_2584ea8
0040cf1d  data_2584eac = 0
0040cf24  data_2584e98 = 0
0040cf2a  sub_4105e0(eax_2)
0040cf2f  void* ecx_3 = data_2584eb4
0040cf35  data_2584ea8 = 0
0040cf3c  data_2584e84 = 0
0040cf42  sub_4105e0(ecx_3)
0040cf47  void* edx_3 = data_255ee4c
0040cf4d  data_2584eb4 = 0
0040cf54  data_2584ee4 = 0
0040cf5a  sub_4105e0(edx_3)
0040cf5f  void* eax_3 = data_2584ed8
0040cf64  data_255ee4c = 0
0040cf6b  data_2584ed0 = 0
0040cf71  sub_4105e0(eax_3)
0040cf76  void* ecx_4 = data_261d000
0040cf7c  data_2584ed8 = 0
0040cf83  data_2584ec8 = 0
0040cf89  sub_4105e0(ecx_4)
0040cf8e  void* edx_4 = data_2584ee0
0040cf94  data_261d000 = 0
0040cf9b  data_255ee48 = 0
0040cfa1  sub_4105e0(edx_4)
0040cfa6  void* eax_4 = data_2584e8c
0040cfab  data_2584ee0 = 0
0040cfb1  data_2584e80 = 0
0040cfb8  sub_4105e0(eax_4)
0040cfbd  void* ecx_5 = data_2584ea4
0040cfc6  data_2584e8c = 0
0040cfcc  data_2584ea0 = 0
0040cfd3  sub_4105e0(ecx_5)
0040cfdd  data_2584ea4 = 0
0040cfe3  sub_410030("freed ")
0040cfef  sub_4105f0(data_430344)
0040cff9  int32_t* result = sub_410030(" of BSP memory\n")
0040d001  data_430344 = 0
0040d008  return result

0040d009                             90 90 90 90 90 90 90                                                           .......

0040d010    int32_t* sub_40d010(int16_t* arg1, int32_t* arg2)

0040d01c  int32_t* eax_1 = sub_410dd0(arg2)
0040d030  int32_t ecx
0040d030  ecx.w = *arg1
0040d034  bool cond:0 = arg1[1] == 0
0040d03d  arg2 = eax_1
0040d04c  float var_14
0040d04c  __builtin_memcpy(dest: &var_14, src: data_261d008 + ecx * 0x14, n: 0x14)
0040d04e  int16_t top
0040d04e  
0040d04e  if (not(cond:0))
0040d056      var_14 = fconvert.s(fneg(fconvert.t(var_14)))
0040d060      float var_10
0040d060      float var_10_1 = fconvert.s(fneg(fconvert.t(var_10)))
0040d06a      float var_c
0040d06a      float var_c_1 = fconvert.s(fneg(fconvert.t(var_c)))
0040d074      float var_8
0040d074      float var_8_1 = fconvert.s(fneg(fconvert.t(var_8)))
0040d074      top = 0
0040d074  
0040d078  int32_t i = 0
0040d078  
0040d07e  if (arg1[4] s> 0)
0040d162      do
0040d086          if (eax_1 == 0)
0040d086              goto label_40d18f
0040d086          
0040d099          *(data_2584ed8 + ((*(arg1 + 4) + i) << 2))
0040d0d0          unimplemented  {fld st0, dword [esi]}
0040d0e3          unimplemented  {fsub st0, dword [eax+edx*4]}
0040d0ee          float var_20 = fconvert.s(unimplemented  {fstp dword [esp+0x24], st0})
0040d0ee          unimplemented  {fstp dword [esp+0x24], st0}
0040d0f2          unimplemented  {fld st0, dword [esi+0x4]}
0040d0f5          unimplemented  {fsub st0, dword [eax+0x4]}
0040d0f8          float var_1c_1 = fconvert.s(unimplemented  {fstp dword [esp+0x28], st0})
0040d0f8          unimplemented  {fstp dword [esp+0x28], st0}
0040d0fc          unimplemented  {fld st0, dword [esi+0x8]}
0040d0ff          unimplemented  {fsub st0, dword [eax+0x8]}
0040d107          float var_18_1 = fconvert.s(unimplemented  {fstp dword [esp+0x30], st0})
0040d107          unimplemented  {fstp dword [esp+0x30], st0}
0040d10b          float var_2c
0040d10b          sub_410420(&var_20, &var_14, &var_2c)
0040d11a          int32_t ecx_3 = sub_410460(&var_2c, &var_2c)
0040d11a          unimplemented  {call sub_410460}
0040d11f          unimplemented  {fstp st0, st0}
0040d11f          unimplemented  {fstp st0, st0}
0040d121          unimplemented  {fld st0, dword [esp+0x24]}
0040d125          unimplemented  {fmul st0, dword [esi]}
0040d127          unimplemented  {fld st0, dword [esp+0x28]}
0040d12b          unimplemented  {fmul st0, dword [esi+0x4]}
0040d135          unimplemented  {faddp st1, st0}
0040d135          unimplemented  {faddp st1, st0}
0040d137          unimplemented  {fld st0, dword [esp+0x18]}
0040d13b          unimplemented  {fmul st0, dword [esi+0x8]}
0040d143          int32_t var_44_2 = ecx_3
0040d148          unimplemented  {faddp st1, st0}
0040d148          unimplemented  {faddp st1, st0}
0040d14a          float var_44_3 = fconvert.s(unimplemented  {fstp dword [esp], st0})
0040d14a          unimplemented  {fstp dword [esp], st0}
0040d14f          sub_4111c0(&arg2, &var_2c, var_44_3, 0.899999976f)
0040d14f          top -= 1
0040d14f          unimplemented  {call sub_4111c0}
0040d158          eax_1 = arg2
0040d15f          i += 1
0040d162      while (i s< sx.d(arg1[4]))
0040d162  
0040d16a  if (eax_1 == 0)
0040d18f      label_40d18f:
0040d18f      unimplemented  {fld st0, dword [&data_429148]}
0040d19c      return eax_1
0040d19c  
0040d16d  sub_410a50(eax_1)
0040d16d  unimplemented  {call sub_410a50}
0040d176  arg1 = fconvert.s(unimplemented  {fstp dword [esp+0x44], st0})
0040d176  unimplemented  {fstp dword [esp+0x44], st0}
0040d17b  int32_t eax_7 = sub_410740(arg2)
0040d180  unimplemented  {fld st0, dword [esp+0x48]}
0040d18e  return eax_7

0040d19d                                                                                         90 90 90                               ...

0040d1a0    int32_t __convention("regparm") sub_40d1a0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t* arg4, int16_t* arg5)

0040d1a0  int32_t i_1 = arg3
0040d1a9  int32_t eax
0040d1a9  eax.w = *arg5
0040d1ae  int32_t edx = eax * 5
0040d1b1  int32_t eax_1 = data_261d008
0040d1bf  int32_t i_2
0040d1bf  int80_t st0
0040d1bf  st0, i_2 = sub_410b70(eax_1 + (edx << 2), *(eax_1 + (edx << 2) + 0xc))
0040d1bf  int16_t top = 0xffff
0040d1c8  int32_t i = i_2
0040d1cd  int32_t ebx = 0
0040d1cf  int32_t eax_2 = arg4[1]
0040d1d2  i_1 = i
0040d1d2  
0040d1d8  if (eax_2 s> 0)
0040d1de      int32_t edi_1 = data_261d008
0040d1de      
0040d1e6      while (i != 0)
0040d1fa          int32_t ecx_2
0040d1fa          ecx_2.w = *(data_2584ee0 + ((*arg4 + ebx) << 2))
0040d1fa          
0040d204          if (ecx_2.w != *arg5)
0040d20f              unimplemented  {fld st0, dword [edi+edx*4+0x8]}
0040d213              unimplemented  {fmul st0, dword [esi+0x8]}
0040d216              unimplemented  {fld st0, dword [edi+edx*4+0x4]}
0040d21d              unimplemented  {fmul st0, dword [esi+0x4]}
0040d220              unimplemented  {faddp st1, st0}
0040d220              unimplemented  {faddp st1, st0}
0040d222              unimplemented  {fld st0, dword [edx]}
0040d224              unimplemented  {fmul st0, dword [esi]}
0040d226              unimplemented  {faddp st1, st0}
0040d226              unimplemented  {faddp st1, st0}
0040d228              long double temp0_1 = fconvert.t(0.999)
0040d228              unimplemented  {fcomp st0, qword [&data_429200]} f- temp0_1
0040d228              bool c0_1 = unimplemented  {fcomp st0, qword [&data_429200]} f< temp0_1
0040d228              bool c2_1 =
0040d228                  is_unordered.t(unimplemented  {fcomp st0, qword [&data_429200]}, temp0_1)
0040d228              bool c3_1 = unimplemented  {fcomp st0, qword [&data_429200]} f== temp0_1
0040d228              unimplemented  {fcomp st0, qword [&data_429200]}
0040d22e              int16_t* eax_6
0040d22e              eax_6.w = (c0_1 ? 1 : 0) << 8 | (c2_1 ? 1 : 0) << 0xa | (c3_1 ? 1 : 0) << 0xe
0040d22e                  | (top & 7) << 0xb
0040d22e              
0040d233              if ((eax_6:1.b & 0x41) != 0)
0040d24a                  label_40d24a:
0040d256                  int32_t eax_7 = ((ecx_2 & 0xffff) ^ 1) * 5
0040d263                  sub_4111c0(&i_1, edi_1 + (eax_7 << 2), *(edi_1 + (eax_7 << 2) + 0xc), 
0040d263                      -0.100000001f)
0040d263                  top -= 1
0040d263                  unimplemented  {call sub_4111c0}
0040d268                  edi_1 = data_261d008
0040d233              else
0040d235                  unimplemented  {fld st0, dword [esi+0xc]}
0040d238                  unimplemented  {fsub st0, dword [edx+0xc]}
0040d23b                  unimplemented  {fabs }
0040d23d                  long double temp1_1 = fconvert.t(0.01)
0040d23d                  unimplemented  {fcomp st0, qword [&data_4291c0]} f- temp1_1
0040d23d                  bool c0_2 = unimplemented  {fcomp st0, qword [&data_4291c0]} f< temp1_1
0040d23d                  bool c2_2 = is_unordered.t(
0040d23d                      unimplemented  {fcomp st0, qword [&data_4291c0]}, temp1_1)
0040d23d                  bool c3_2 = unimplemented  {fcomp st0, qword [&data_4291c0]} f== temp1_1
0040d23d                  unimplemented  {fcomp st0, qword [&data_4291c0]}
0040d243                  eax_6.w = (c0_2 ? 1 : 0) << 8 | (c2_2 ? 1 : 0) << 0xa
0040d243                      | (c3_2 ? 1 : 0) << 0xe | (top & 7) << 0xb
0040d243                  
0040d248                  if ((eax_6:1.b & 1) == 0)
0040d248                      goto label_40d24a
0040d248              
0040d271              i = i_1
0040d271          
0040d278          ebx += 1
0040d278          
0040d27b          if (ebx s>= arg4[1])
0040d27b              break
0040d27b  
0040d288  return i

0040d289                             90 90 90 90 90 90 90                                                           .......

0040d290    int32_t sub_40d290(int32_t* arg1)

0040d296  int32_t edx = 0
0040d298  int32_t esi = arg1[1]
0040d298  
0040d29d  if (esi s> 0)
0040d2a7      int16_t* ecx_2 = data_2584ee0 + (*arg1 << 2) + 2
0040d2a7      
0040d2ce      do
0040d2ab          int32_t eax
0040d2ab          eax.w = *ecx_2
0040d2ab          
0040d2b1          if (eax.w s> 0 && ((*(sx.d(eax.w) * 0x4c + &data_2585020)).w:1.b & 3) != 0)
0040d2dc              return 1
0040d2dc          
0040d2c8          edx += 1
0040d2c9          ecx_2 = &ecx_2[2]
0040d2ce      while (edx s< esi)
0040d2ce  
0040d2d4  return 0

0040d2dd                                                                                         90 90 90                               ...

0040d2e0    int32_t sub_40d2e0()

0040d2f0  __builtin_memset(s: 0x255ee60, c: 0, n: 0x10000)
0040d2f2  int32_t i = data_2584ec8
0040d2f7  void* edi = nullptr
0040d2fb  int32_t i_1 = 0
0040d2fb  
0040d2ff  if (i s> 0)
0040d308      void* var_4_1 = nullptr
0040d308      
0040d485      do
0040d311          int32_t* edi_1 = edi + data_261d000
0040d311          
0040d31e          if (sub_40d290(edi_1) == 0)
0040d324              int32_t eax_2 = edi_1[1]
0040d327              int32_t ebp_1 = 0
0040d32b              int32_t var_14_1 = 0
0040d32b              
0040d32f              if (eax_2 s> 0)
0040d463                  do
0040d337                      int32_t edx_1 = data_2584ee0
0040d33d                      int32_t ecx_2 = *edi_1 + ebp_1
0040d33f                      int16_t* ebx_1 = edx_1 + (ecx_2 << 2)
0040d349                      int32_t* esi_1 = sub_40d1a0(eax_2, edx_1, ecx_2, edi_1, ebx_1)
0040d349                      
0040d354                      if (esi_1 != 0)
0040d371                          if (sub_406f30(esi_1) != 0)
0040d447                              sub_410740(esi_1)
0040d451                              *(*edi_1 + ebp_1 + 0x255ee60) = 1
0040d371                          else
0040d377                              int32_t eax_6 = sub_411870(esi_1)
0040d377                              
0040d394                              if (eax_6 == 1 || eax_6 == 2 || eax_6 == 3)
0040d447                                  sub_410740(esi_1)
0040d451                                  *(*edi_1 + ebp_1 + 0x255ee60) = 1
0040d394                              else
0040d39b                                  sub_410a50(esi_1)
0040d39b                                  unimplemented  {call sub_410a50}
0040d3a0                                  long double temp0_1 = fconvert.t(20f)
0040d3a0                                  unimplemented  {fcomp st0, dword [&data_429208]}
0040d3a0                                      f- temp0_1
0040d3a0                                  bool c0_1 =
0040d3a0                                      unimplemented  {fcomp st0, dword [&data_429208]}
0040d3a0                                      f< temp0_1
0040d3a0                                  bool c2_1 = is_unordered.t(
0040d3a0                                      unimplemented  {fcomp st0, dword [&data_429208]}, 
0040d3a0                                      temp0_1)
0040d3a0                                  bool c3_1 =
0040d3a0                                      unimplemented  {fcomp st0, dword [&data_429208]}
0040d3a0                                      f== temp0_1
0040d3a0                                  unimplemented  {fcomp st0, dword [&data_429208]}
0040d3ae                                  int16_t top
0040d3ae                                  
0040d3ae                                  if ((((c0_1 ? 1 : 0) << 8 | (c2_1 ? 1 : 0) << 0xa
0040d3ae                                          | (c3_1 ? 1 : 0) << 0xe | (top & 7) << 0xb):1.b & 1)
0040d3ae                                          != 0)
0040d3b2                                      *(*edi_1 + ebp_1 + 0x255ee60) = 1
0040d3b2                                  
0040d3bf                                  int32_t var_c_1 = 0
0040d3bf                                  
0040d3c9                                  if (data_2584e9c s> 0)
0040d3cb                                      int32_t ebp_2 = 0
0040d419                                      bool cond:6_1
0040d419                                      
0040d419                                      do
0040d3cd                                          int16_t* eax_9 = data_2584eac
0040d3d4                                          int32_t ecx_3
0040d3d4                                          ecx_3.w = *ebx_1
0040d3d9                                          int32_t edx_3
0040d3d9                                          edx_3.w = *(eax_9 + ebp_2)
0040d3dd                                          void* esi_2 = eax_9 + ebp_2
0040d3dd                                          
0040d3e8                                          if (((ecx_3 ^ edx_3) & 0xfffffffe) == 0)
0040d3f0                                              sub_40d010(esi_2, esi_1)
0040d3f5                                              long double temp1_1 = fconvert.t(0f)
0040d3f5                                              unimplemented  {fcomp st0, dword [
0040d3f5                                                  &data_429148]} f- temp1_1
0040d3f5                                              bool c0_2 = unimplemented  {fcomp st0, dword [
0040d3f5                                                  &data_429148]} f< temp1_1
0040d3f5                                              bool c2_2 = is_unordered.t(
0040d3f5                                                  unimplemented  {fcomp st0, dword [
0040d3f5                                                      &data_429148]}, 
0040d3f5                                                  temp1_1)
0040d3f5                                              bool c3_2 = unimplemented  {fcomp st0, dword [
0040d3f5                                                  &data_429148]} f== temp1_1
0040d3f5                                              unimplemented  {fcomp st0, dword [
0040d3f5                                                  &data_429148]}
0040d3f5                                              top += 1
0040d3f5                                              
0040d403                                              if ((((c0_2 ? 1 : 0) << 8
0040d403                                                      | (c2_2 ? 1 : 0) << 0xa
0040d403                                                      | (c3_2 ? 1 : 0) << 0xe
0040d403                                                      | (top & 7) << 0xb):1.b & 0x40) == 0)
0040d425                                                  ebx_1[1] = *(esi_2 + 0xa)
0040d42b                                                  *(*edi_1 + var_14_1 + 0x255ee60) = 1
0040d42b                                                  break
0040d42b                                          
0040d410                                          ebp_2 += 0x14
0040d413                                          cond:6_1 = var_c_1 + 1 s< data_2584e9c
0040d415                                          var_c_1 += 1
0040d419                                      while (cond:6_1)
0040d437                                      ebp_1 = var_14_1
0040d437                                  
0040d43c                                  sub_410740(esi_1)
0040d354                      else
0040d358                          *(*edi_1 + ebp_1 + 0x255ee60) = 1
0040d358                      
0040d459                      eax_2 = edi_1[1]
0040d45c                      ebp_1 += 1
0040d45f                      var_14_1 = ebp_1
0040d463                  while (ebp_1 s< eax_2)
0040d463          
0040d477          i = i_1 + 1
0040d478          edi = var_4_1 + 0xc
0040d47d          i_1 = i
0040d481          var_4_1 = edi
0040d485      while (i s< data_2584ec8)
0040d485  
0040d492  return i

0040d493                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0040d4a0    int32_t sub_40d4a0(int32_t arg1)

0040d4a7  int32_t i = 0
0040d4a7  
0040d4ad  if (data_2584e90 s> 0)
0040d4af      void* ebx_1 = nullptr
0040d4af      
0040d51f      do
0040d4b1          int32_t eax = data_2584ec0
0040d4ba          void* esi_1 = ebx_1 + eax
0040d4be          int32_t eax_1 = sub_40ff30(*(ebx_1 + eax + 0x28))
0040d4c3          int32_t edx_1 = *(esi_1 + 0x2c)
0040d4c6          *(esi_1 + 0x28) = eax_1
0040d4cf          *(esi_1 + 0x2c) = sub_40ff30(edx_1)
0040d4de          *(esi_1 + 0x24) = sub_40ff30(*(esi_1 + 0x24))
0040d4e1          void* esi_2 = esi_1 + 0x18
0040d4e4          int32_t j_10 = 3
0040d512          int32_t j
0040d512          
0040d512          do
0040d4f2              *(esi_2 - 0x18) = fconvert.s(sub_40ff20(*(esi_2 - 0x18)))
0040d4fe              *(esi_2 - 0xc) = fconvert.s(sub_40ff20(*(esi_2 - 0xc)))
0040d509              *esi_2 = fconvert.s(sub_40ff20(*esi_2))
0040d50e              esi_2 += 4
0040d511              j = j_10
0040d511              j_10 -= 1
0040d512          while (j != 1)
0040d519          i += 1
0040d51a          ebx_1 += 0x30
0040d51f      while (i s< data_2584e90)
0040d51f  
0040d526  int32_t i_1 = 0
0040d526  
0040d52a  if (data_2584ee8 s> 0)
0040d52c      int32_t* esi_3 = nullptr
0040d52c      
0040d55b      do
0040d52e          int32_t j_11 = 3
0040d551          int32_t j_1
0040d551          
0040d551          do
0040d54a              *(esi_3 + data_2584ed4) = fconvert.s(sub_40ff20(*(esi_3 i+ data_2584ed4)))
0040d54d              esi_3 = &esi_3[1]
0040d550              j_1 = j_11
0040d550              j_11 -= 1
0040d551          while (j_1 != 1)
0040d558          i_1 += 1
0040d55b      while (i_1 s< data_2584ee8)
0040d55b  
0040d562  int32_t i_2 = 0
0040d562  
0040d566  if (data_2584ef4 s> 0)
0040d568      int32_t* edi_1 = nullptr
0040d568      
0040d5d2      do
0040d56a          int32_t* esi_4 = edi_1
0040d56c          int32_t j_6 = 3
0040d58f          int32_t j_2
0040d58f          
0040d58f          do
0040d588              *(esi_4 + data_261d008) = fconvert.s(sub_40ff20(*(esi_4 + data_261d008)))
0040d58b              esi_4 = &esi_4[1]
0040d58e              j_2 = j_6
0040d58e              j_6 -= 1
0040d58f          while (j_2 != 1)
0040d5a6          *(edi_1 + data_261d008 + 0xc) =
0040d5a6              fconvert.s(sub_40ff20(*(edi_1 + data_261d008 + 0xc)))
0040d5c3          i_2 += 1
0040d5c4          *(edi_1 i+ data_261d008 + 0x10) = sub_40ff30(*(edi_1 + data_261d008 + 0x10))
0040d5cd          edi_1 = &edi_1[5]
0040d5d2      while (i_2 s< data_2584ef4)
0040d5d2  
0040d5d9  int32_t i_3 = 0
0040d5d9  
0040d5dd  if (data_2584ef0 s> 0)
0040d5df      void* esi_5 = &data_2585020
0040d5df      
0040d62f      do
0040d5e4          void* edi_2 = esi_5 - 0x20
0040d5e7          int32_t j_7 = 8
0040d5fd          int32_t j_3
0040d5fd          
0040d5fd          do
0040d5f4              *edi_2 = fconvert.s(sub_40ff20(*edi_2))
0040d5f9              edi_2 += 4
0040d5fc              j_3 = j_7
0040d5fc              j_7 -= 1
0040d5fd          while (j_3 != 1)
0040d607          *esi_5 = sub_40ff30(*esi_5)
0040d612          *(esi_5 + 4) = sub_40ff30(*(esi_5 + 4))
0040d621          *(esi_5 + 0x28) = sub_40ff30(*(esi_5 + 0x28))
0040d629          i_3 += 1
0040d62a          esi_5 += 0x4c
0040d62f      while (i_3 s< data_2584ef0)
0040d62f  
0040d636  int32_t i_4 = 0
0040d63a  float ecx
0040d63a  
0040d63a  if (data_2584e9c s> 0)
0040d640      int16_t* esi_6 = nullptr
0040d640      
0040d6ec      do
0040d647          ecx.w = *(esi_6 + data_2584eac + 0xa)
0040d658          *(esi_6 + data_2584eac + 0xa) = sub_40ff10(ecx.w)
0040d662          ecx.w = *(esi_6 + data_2584eac)
0040d672          *(esi_6 + data_2584eac) = sub_40ff10(ecx.w)
0040d67b          ecx.w = *(esi_6 + data_2584eac + 2)
0040d68c          *(esi_6 + data_2584eac + 2) = sub_40ff10(ecx.w)
0040d6a6          *(esi_6 + data_2584eac + 0x10) = sub_40ff30(*(esi_6 + data_2584eac + 0x10))
0040d6bf          *(esi_6 + data_2584eac + 4) = sub_40ff30(*(esi_6 + data_2584eac + 4))
0040d6c8          ecx.w = *(esi_6 + data_2584eac + 8)
0040d6dc          i_4 += 1
0040d6dd          *(esi_6 + data_2584eac + 8) = sub_40ff10(ecx.w)
0040d6e7          esi_6 = &esi_6[0xa]
0040d6ec      while (i_4 s< data_2584e9c)
0040d6ec  
0040d6f7  int32_t i_5 = 0
0040d6f7  
0040d6fb  if (data_2584eb8 s> 0)
0040d701      int32_t* esi_7 = nullptr
0040d701      
0040d7d8      do
0040d71a          void* edi_3 = esi_7 + 0x12
0040d71d          int32_t j_8 = 3
0040d722          *(esi_7 + data_2584ebc) = sub_40ff30(*(esi_7 + data_2584ebc))
0040d760          int32_t j_4
0040d760          
0040d760          do
0040d72a              int32_t ecx_6
0040d72a              ecx_6.w = *(edi_3 + data_2584ebc - 6)
0040d73b              *(edi_3 + data_2584ebc - 6) = sub_40ff10(ecx_6.w)
0040d745              ecx_6.w = *(edi_3 + data_2584ebc)
0040d758              *(edi_3 + data_2584ebc) = sub_40ff10(ecx_6.w)
0040d75c              edi_3 += 2
0040d75f              j_4 = j_8
0040d75f              j_8 -= 1
0040d760          while (j_4 != 1)
0040d777          *(esi_7 + data_2584ebc + 4) = sub_40ff30(*(esi_7 + data_2584ebc + 4))
0040d790          *(esi_7 + data_2584ebc + 8) = sub_40ff30(*(esi_7 + data_2584ebc + 8))
0040d799          ecx.w = *(esi_7 + data_2584ebc + 0x18)
0040d7aa          *(esi_7 + data_2584ebc + 0x18) = sub_40ff10(ecx.w)
0040d7b4          ecx.w = *(esi_7 + data_2584ebc + 0x1a)
0040d7c8          i_5 += 1
0040d7c9          *(esi_7 + data_2584ebc + 0x1a) = sub_40ff10(ecx.w)
0040d7d3          esi_7 = &esi_7[7]
0040d7d8      while (i_5 s< data_2584eb8)
0040d7d8  
0040d7e3  int32_t i_6 = 0
0040d7e3  
0040d7e7  if (data_2584e88 s> 0)
0040d7ed      void* esi_8 = nullptr
0040d7ed      
0040d8fe      do
0040d803          *(esi_8 + data_2584e94) = sub_40ff30(*(esi_8 + data_2584e94))
0040d80b          ecx.w = *(esi_8 + data_2584e94 + 4)
0040d81c          *(esi_8 + data_2584e94 + 4) = sub_40ff10(ecx.w)
0040d826          ecx.w = *(esi_8 + data_2584e94 + 6)
0040d83a          int16_t* edi_4 = esi_8 + 0xe
0040d83d          int32_t j_9 = 3
0040d842          *(esi_8 + data_2584e94 + 6) = sub_40ff10(ecx.w)
0040d882          int32_t j_5
0040d882          
0040d882          do
0040d84c              ecx.w = *(edi_4 + data_2584e94 - 6)
0040d85d              *(edi_4 + data_2584e94 - 6) = sub_40ff10(ecx.w)
0040d867              ecx.w = *(edi_4 + data_2584e94)
0040d87a              *(edi_4 + data_2584e94) = sub_40ff10(ecx.w)
0040d87e              edi_4 = &edi_4[1]
0040d881              j_5 = j_9
0040d881              j_9 -= 1
0040d882          while (j_5 != 1)
0040d889          ecx.w = *(esi_8 + data_2584e94 + 0x14)
0040d89a          *(esi_8 + data_2584e94 + 0x14) = sub_40ff10(ecx.w)
0040d8a4          ecx.w = *(esi_8 + data_2584e94 + 0x16)
0040d8b5          *(esi_8 + data_2584e94 + 0x16) = sub_40ff10(ecx.w)
0040d8bf          ecx.w = *(esi_8 + data_2584e94 + 0x18)
0040d8d0          *(esi_8 + data_2584e94 + 0x18) = sub_40ff10(ecx.w)
0040d8da          ecx.w = *(esi_8 + data_2584e94 + 0x1a)
0040d8ee          i_6 += 1
0040d8ef          *(esi_8 + data_2584e94 + 0x1a) = sub_40ff10(ecx.w)
0040d8f9          esi_8 += 0x1c
0040d8fe      while (i_6 s< data_2584e88)
0040d8fe  
0040d909  int32_t i_7 = 0
0040d909  
0040d90d  if (data_2584e84 s> 0)
0040d933      do
0040d914          ecx.w = *(data_2584eb4 + (i_7 << 1))
0040d927          *(data_2584eb4 + (i_7 << 1)) = sub_40ff10(ecx.w)
0040d930          i_7 += 1
0040d933      while (i_7 s< data_2584e84)
0040d933  
0040d93a  int32_t i_8 = 0
0040d93a  
0040d93e  if (data_2584ee4 s> 0)
0040d964      do
0040d945          ecx.w = *(data_255ee4c + (i_8 << 1))
0040d958          *(data_255ee4c + (i_8 << 1)) = sub_40ff10(ecx.w)
0040d961          i_8 += 1
0040d964      while (i_8 s< data_2584ee4)
0040d964  
0040d96b  int32_t i_9 = 0
0040d96b  
0040d96f  if (data_2584ed0 s> 0)
0040d993      do
0040d988          *(data_2584ed8 + (i_9 << 2)) = sub_40ff30(*(data_2584ed8 + (i_9 << 2)))
0040d990          i_9 += 1
0040d993      while (i_9 s< data_2584ed0)
0040d993  
0040d99a  int32_t i_10 = 0
0040d99a  
0040d99e  if (data_2584e98 s> 0)
0040d9df      do
0040d9a5          ecx.w = *(data_2584ea8 + (i_10 << 2))
0040d9b5          *(data_2584ea8 + (i_10 << 2)) = sub_40ff10(ecx.w)
0040d9be          ecx.w = *(data_2584ea8 + (i_10 << 2) + 2)
0040d9d2          *(data_2584ea8 + (i_10 << 2) + 2) = sub_40ff10(ecx.w)
0040d9dc          i_10 += 1
0040d9df      while (i_10 s< data_2584e98)
0040d9df  
0040d9e6  int32_t i_11 = 0
0040d9e6  
0040d9ea  if (data_2584ec8 s> 0)
0040d9ec      int32_t* esi_9 = nullptr
0040d9ec      
0040da45      do
0040da02          *(esi_9 + data_261d000) = sub_40ff30(*(esi_9 + data_261d000))
0040da1a          *(esi_9 + data_261d000 + 4) = sub_40ff30(*(esi_9 + data_261d000 + 4))
0040da36          i_11 += 1
0040da37          *(esi_9 + data_261d000 + 8) = sub_40ff30(*(esi_9 + data_261d000 + 8))
0040da40          esi_9 = &esi_9[3]
0040da45      while (i_11 s< data_2584ec8)
0040da45  
0040da4c  int32_t i_12 = 0
0040da4c  
0040da50  if (data_2584e80 s> 0)
0040da8d      do
0040da66          *(data_2584e8c + (i_12 << 3)) = sub_40ff30(*(data_2584e8c + (i_12 << 3)))
0040da81          *(data_2584e8c + (i_12 << 3) + 4) = sub_40ff30(*(data_2584e8c + (i_12 << 3) + 4))
0040da8a          i_12 += 1
0040da8d      while (i_12 s< data_2584e80)
0040da8d  
0040da94  int32_t i_13 = 0
0040da94  
0040da98  if (data_2584ea0 s> 0)
0040dad5      do
0040daae          *(data_2584ea4 + (i_13 << 3)) = sub_40ff30(*(data_2584ea4 + (i_13 << 3)))
0040dac9          *(data_2584ea4 + (i_13 << 3) + 4) = sub_40ff30(*(data_2584ea4 + (i_13 << 3) + 4))
0040dad2          i_13 += 1
0040dad5      while (i_13 s< data_2584ea0)
0040dad5  
0040dadc  int32_t i_14 = 0
0040dadc  
0040dae0  if (data_255ee48 s> 0)
0040db21      do
0040dae7          ecx.w = *(data_2584ee0 + (i_14 << 2))
0040daf7          *(data_2584ee0 + (i_14 << 2)) = sub_40ff10(ecx.w)
0040db00          ecx.w = *(data_2584ee0 + (i_14 << 2) + 2)
0040db14          *(data_2584ee0 + (i_14 << 2) + 2) = sub_40ff10(ecx.w)
0040db1e          i_14 += 1
0040db21      while (i_14 s< data_255ee48)
0040db21  
0040db29  int32_t edi_5
0040db29  
0040db29  if (arg1 == 0)
0040db45      edi_5 = sub_40ff30(*data_261d004)
0040db29  else
0040db30      edi_5 = *data_261d004
0040db30  
0040db4f  int32_t result = sub_40ff30(*data_261d004)
0040db5d  int32_t esi_10 = 0
0040db61  *data_261d004 = result
0040db61  
0040db63  if (edi_5 s> 0)
0040db9d      do
0040db7a          *(data_261d004 + (esi_10 << 3) + 4) =
0040db7a              sub_40ff30(*(data_261d004 + (esi_10 << 3) + 4))
0040db88          result = sub_40ff30(*(data_261d004 + (esi_10 << 3) + 8))
0040db96          *(data_261d004 + (esi_10 << 3) + 8) = result
0040db9a          esi_10 += 1
0040db9d      while (esi_10 s< edi_5)
0040db9d  
0040dba3  return result

0040dba4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040dbb0    int32_t sub_40dbb0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)

0040dbb0  int32_t eax_9 = data_2584eb0
0040dbc1  int32_t esi = *(eax_9 + (arg1 << 3) + 0xc)
0040dbc5  int32_t ebp = *(eax_9 + (arg1 << 3) + 8)
0040dbc5  
0040dbd0  if (mods.dp.d(sx.q(esi), arg3) != 0)
0040dbd7      sub_40f970("LoadBSPFile: odd lump size")
0040dbd7  
0040dbe2  int32_t result = divs.dp.d(sx.q(esi), arg3)
0040dbe2  
0040dbec  if (result s> arg4)
0040dbee      int32_t var_14_1 = arg4
0040dbef      int32_t result_1 = result
0040dbf0      int32_t var_1c_1 = arg1
0040dbf6      sub_40f970("Q2_LoadBSPFile: exceeded max siz…")
0040dbf6  
0040dc11  int32_t esi_2
0040dc11  int32_t edi_2
0040dc11  edi_2, esi_2 = __builtin_memcpy(dest: arg2, src: data_2584eb0 + ebp, n: esi u>> 2 << 2)
0040dc1a  __builtin_memcpy(dest: edi_2, src: esi_2, n: esi & 3)
0040dc20  return result

0040dc21     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040dc30    int32_t sub_40dc30(int32_t arg1, void* arg2, void* arg3)

0040dc46  sub_40fcf0(arg1, &data_2584eb0, arg2, arg3)
0040dc46  
0040dc75  for (int32_t* i = nullptr; i s< 0xa0; )
0040dc5a      int32_t eax_1 = sub_40ff30(*(i + data_2584eb0))
0040dc65      i = &i[1]
0040dc71      *(i + data_2584eb0 - 4) = eax_1
0040dc71  
0040dc83  if (*data_2584eb0 != 0x50534249)
0040dc85      int32_t var_c_2 = arg1
0040dc8b      sub_40f970("%s is not a IBSP file")
0040dc8b  
0040dc98  int32_t eax_3 = *(data_2584eb0 + 4)
0040dc98  
0040dc9e  if (eax_3 != 0x26)
0040dca0      int32_t var_c_3 = 0x26
0040dca2      int32_t var_10_1 = eax_3
0040dca3      int32_t var_14_1 = arg1
0040dca9      sub_40f970("%s is version %i, not %i")
0040dca9  
0040dcc1  int32_t eax_4 = sub_40dbb0(0xd, data_2584ec0, 0x30, 0x400)
0040dcc6  int32_t edx_3 = data_2584ed4
0040dcd6  data_2584e90 = eax_4
0040dce0  data_2584ee8 = sub_40dbb0(2, edx_3, 0xc, 0x10000)
0040dcf4  int32_t eax_7 = sub_40dbb0(1, data_261d008, 0x14, 0x10000)
0040dcf9  int32_t ecx_3 = data_2584e94
0040dd09  data_2584ef4 = eax_7
0040dd0e  int32_t eax_8 = sub_40dbb0(8, ecx_3, 0x1c, 0x10000)
0040dd13  int32_t edx_4 = data_2584ebc
0040dd1c  data_2584e88 = eax_8
0040dd3e  data_2584eb8 = sub_40dbb0(4, edx_4, 0x1c, 0x10000)
0040dd48  data_2584ef0 = sub_40dbb0(5, &data_2585000, 0x4c, 0x2000)
0040dd5c  int32_t eax_12 = sub_40dbb0(6, data_2584eac, 0x14, 0x10000)
0040dd61  int32_t ecx_4 = data_2584eb4
0040dd71  data_2584e9c = eax_12
0040dd76  int32_t eax_13 = sub_40dbb0(9, ecx_4, 2, 0x10000)
0040dd7b  int32_t edx_5 = data_255ee4c
0040dd84  data_2584e84 = eax_13
0040dd98  data_2584ee4 = sub_40dbb0(0xa, edx_5, 2, 0x10000)
0040ddac  int32_t eax_16 = sub_40dbb0(0xc, data_2584ed8, 4, 0x3e800)
0040ddb1  int32_t ecx_5 = data_2584ea8
0040ddc1  data_2584ed0 = eax_16
0040ddc6  int32_t eax_17 = sub_40dbb0(0xb, ecx_5, 4, 0x1f400)
0040ddcb  int32_t edx_6 = data_261d000
0040ddd6  data_2584e98 = eax_17
0040dde8  data_2584ec8 = sub_40dbb0(0xe, edx_6, 0xc, 0x2000)
0040ddfc  int32_t eax_20 = sub_40dbb0(0xf, data_2584ee0, 4, 0x10000)
0040de01  int32_t ecx_6 = data_2584e8c
0040de11  data_255ee48 = eax_20
0040de16  int32_t eax_21 = sub_40dbb0(0x11, ecx_6, 8, 0x100)
0040de1b  int32_t edx_7 = data_2584ea4
0040de2b  data_2584e80 = eax_21
0040de35  data_2584ea0 = sub_40dbb0(0x12, edx_7, 8, 0x400)
0040de49  int32_t eax_24 = sub_40dbb0(3, data_255ee44, 1, 0x280000)
0040de4e  int32_t ecx_7 = data_256ee64
0040de57  data_2584ec4 = eax_24
0040de66  int32_t eax_25 = sub_40dbb0(7, ecx_7, 1, 0x320000)
0040de6b  int32_t edx_8 = data_256ee60
0040de7b  data_2584edc = eax_25
0040de93  data_2584eec = sub_40dbb0(0, edx_8, 1, 0x40000)
0040de98  sub_40dbb0(0x10, &data_2584f00, 1, 0x100)
0040dea3  sub_41e29e(data_2584eb0)
0040deaa  sub_40d4a0(0)
0040deb9  return sub_40d2e0()

0040deba                                                                                90 90 90 90 90 90                            ......

0040dec0    uint32_t sub_40dec0(int32_t arg1, char* arg2, int32_t arg3)

0040ded3  int32_t* esi = data_2584eb0 + (arg1 << 3) + 8
0040dee6  *esi = sub_40ff30(sub_41e085(data_261d098))
0040def1  esi[1] = sub_40ff30(arg3)
0040df0e  return sub_40fcc0(data_261d098, arg2, (arg3 + 3) & 0xfffffffc)

0040df0f                                               90                                                                 .

0040df10    int32_t sub_40df10(int32_t arg1)

0040df1d  data_2584eb0 = 0x261d140
0040df25  __builtin_memset(s: 0x261d140, c: 0, n: 0xa0)
0040df27  sub_40d4a0(1)
0040df3e  *data_2584eb0 = sub_40ff30(0x50534249)
0040df4b  *(data_2584eb0 + 4) = sub_40ff30(0x26)
0040df53  int32_t* eax_3 = sub_40fc10(arg1)
0040df58  char* ecx_1 = data_2584eb0
0040df65  data_261d098 = eax_3
0040df6a  sub_40fcc0(eax_3, ecx_1, 0xa0)
0040df83  sub_40dec0(1, data_261d008, data_2584ef4 * 0x14)
0040dfa3  sub_40dec0(8, data_2584e94, data_2584e88 * 0x1c)
0040dfbd  sub_40dec0(2, data_2584ed4, data_2584ee8 * 0xc)
0040dfdf  sub_40dec0(4, data_2584ebc, data_2584eb8 * 0x1c)
0040dffa  sub_40dec0(5, &data_2585000, data_2584ef0 * 0x4c)
0040e014  sub_40dec0(6, data_2584eac, data_2584e9c * 0x14)
0040e02d  sub_40dec0(0xe, data_261d000, data_2584ec8 * 0xc)
0040e048  sub_40dec0(0xf, data_2584ee0, data_255ee48 << 2)
0040e05f  sub_40dec0(9, data_2584eb4, data_2584e84 * 2)
0040e079  sub_40dec0(0xa, data_255ee4c, data_2584ee4 * 2)
0040e094  sub_40dec0(0xc, data_2584ed8, data_2584ed0 << 2)
0040e0af  sub_40dec0(0xb, data_2584ea8, data_2584e98 << 2)
0040e0c9  sub_40dec0(0xd, data_2584ec0, data_2584e90 * 0x30)
0040e0e4  sub_40dec0(0x11, data_2584e8c, data_2584e80 << 3)
0040e0ff  sub_40dec0(0x12, data_2584ea4, data_2584ea0 << 3)
0040e116  sub_40dec0(7, data_256ee64, data_2584edc)
0040e12a  sub_40dec0(3, data_255ee44, data_2584ec4)
0040e13f  sub_40dec0(0, data_256ee60, data_2584eec)
0040e150  sub_40dec0(0x10, &data_2584f00, 0x100)
0040e15f  sub_41de4f(data_261d098, nullptr, FILE_BEGIN)
0040e177  sub_40fcc0(data_261d098, data_2584eb0, 0xa0)
0040e18e  return sub_41ddd2(data_261d098)

0040e18f                                               90                                                                 .

0040e190    char* sub_40e190(int32_t arg1)

0040e195  int32_t edi = arg1
0040e197  int32_t i = 0xffffffff
0040e197  
0040e19c  while (i != 0)
0040e19c      bool cond:0_1 = 0 != *edi
0040e19c      edi += 1
0040e19c      i -= 1
0040e19c      
0040e19c      if (not(cond:0_1))
0040e19c          break
0040e19c  
0040e1a2  char* result = not.d(i) - 1 + arg1 - 1
0040e1a2  
0040e1a8  if (result u>= arg1)
0040e1ad      while (*result s<= 0x20)
0040e1af          *result = 0
0040e1b2          result -= 1
0040e1b2          
0040e1b5          if (result u< arg1)
0040e1b5              break
0040e1b5  
0040e1b7  return result

0040e1b8                                                                          90 90 90 90 90 90 90 90                          ........

0040e1c0    void* sub_40e1c0(void* arg1)

0040e1cb  void* result = sub_4105b0(0xc)
0040e1e1  *result = 0
0040e1e5  *(result + 4) = 0
0040e1e8  *(result + 8) = 0
0040e1eb  char var_430[0x430]
0040e1eb  sub_413ee0(arg1, &var_430)
0040e1f5  sub_413fa0(&var_430)
0040e1fa  char (* edi)[0x430] = &var_430
0040e1fe  int32_t i = 0xffffffff
0040e1fe  
0040e206  while (i != 0)
0040e206      bool cond:0_1 = 0 != *edi
0040e206      edi = &(*edi)[1]
0040e206      i -= 1
0040e206      
0040e206      if (not(cond:0_1))
0040e206          break
0040e206  
0040e20e  if (not.d(i) - 1 u>= 0x1f)
0040e214      char (* var_440_1)[0x430] = &var_430
0040e21a      sub_40f970("ParseEpair: token %s too long")
0040e21a  
0040e22c  *(result + 4) = sub_40faa0(&var_430)
0040e235  sub_413ee0(arg1, &var_430)
0040e23f  sub_413fa0(&var_430)
0040e244  char (* edi_1)[0x430] = &var_430
0040e248  int32_t i_1 = 0xffffffff
0040e248  
0040e250  while (i_1 != 0)
0040e250      bool cond:1_1 = 0 != *edi_1
0040e250      edi_1 = &(*edi_1)[1]
0040e250      i_1 -= 1
0040e250      
0040e250      if (not(cond:1_1))
0040e250          break
0040e250  
0040e25b  if (not.d(i_1) - 1 u>= 0x3ff)
0040e261      char (* var_440_3)[0x430] = &var_430
0040e267      sub_40f970("ParseEpair: token %s too long")
0040e267  
0040e274  void* eax_1 = sub_40faa0(&var_430)
0040e279  int32_t ecx_5 = *(result + 4)
0040e27c  *(result + 8) = eax_1
0040e280  sub_40e190(ecx_5)
0040e289  sub_40e190(*(result + 8))
0040e29c  return result

0040e29d                                                                                         90 90 90                               ...

0040e2a0    int32_t sub_40e2a0(void* arg1)

0040e2b4  char var_430[0x430]
0040e2b4  int32_t result = sub_413970(arg1, &var_430)
0040e2b4  
0040e2be  if (result == 0)
0040e2c7      return result
0040e2c7  
0040e2c8  int32_t ebx
0040e2c8  int32_t var_438_1 = ebx
0040e2cb  void* esi = &data_42cdc4
0040e2d0  char (* eax)[0x430] = &var_430
0040e2d4  int32_t eax_2
0040e2d4  
0040e2d4  while (true)
0040e2d4      char edx_1 = *eax
0040e2d6      ebx.b = *esi
0040e2da      bool c_1 = edx_1 u< ebx.b
0040e2da      
0040e2dc      if (edx_1 == ebx.b)
0040e2e0          if (edx_1 == 0)
0040e2f8              eax_2 = 0
0040e2fa              break
0040e2fa          
0040e2e2          edx_1 = (*eax)[1]
0040e2e5          ebx.b = *(esi + 1)
0040e2ea          c_1 = edx_1 u< ebx.b
0040e2ea          
0040e2ec          if (edx_1 == ebx.b)
0040e2ee              eax = &(*eax)[2]
0040e2f1              esi += 2
0040e2f1              
0040e2f6              if (edx_1 != 0)
0040e2f6                  continue
0040e2f6              
0040e2f8              eax_2 = 0
0040e2fa              break
0040e2fa      
0040e2fc      bool c_2 = unimplemented  {sbb eax, eax}
0040e2fe      eax_2 = sbb.d(sbb.d(eax, eax, c_1), 0xffffffff, c_2)
0040e2fe      break
0040e2fe  
0040e303  if (eax_2 != 0)
0040e30a      sub_40f970("ParseEntity: { not found")
0040e30a  
0040e312  int32_t eax_3 = data_2584ecc
0040e312  
0040e31c  if (eax_3 == 0x800)
0040e323      sub_40f970("num_entities == MAX_MAP_ENTITIES")
0040e328      eax_3 = data_2584ecc
0040e328  
0040e337  data_2584ecc = eax_3 + 1
0040e337  
0040e349  while (true)
0040e353      if (sub_413970(arg1, &var_430) == 0)
0040e35a          sub_40f970("ParseEntity: EOF without closing…")
0040e35a      
0040e362      void* esi_1 = &data_42cd58
0040e367      char (* eax_6)[0x430] = &var_430
0040e36b      int32_t eax_8
0040e36b      
0040e36b      while (true)
0040e36b          char edx_3 = *eax_6
0040e36d          ebx.b = *esi_1
0040e371          bool c_3 = edx_3 u< ebx.b
0040e371          
0040e373          if (edx_3 == ebx.b)
0040e377              if (edx_3 == 0)
0040e38f                  eax_8 = 0
0040e391                  break
0040e391              
0040e379              edx_3 = (*eax_6)[1]
0040e37c              ebx.b = *(esi_1 + 1)
0040e381              c_3 = edx_3 u< ebx.b
0040e381              
0040e383              if (edx_3 == ebx.b)
0040e385                  eax_6 = &(*eax_6)[2]
0040e388                  esi_1 += 2
0040e388                  
0040e38d                  if (edx_3 != 0)
0040e38d                      continue
0040e38d                  
0040e38f                  eax_8 = 0
0040e391                  break
0040e391          
0040e393          bool c_4 = unimplemented  {sbb eax, eax}
0040e395          eax_8 = sbb.d(sbb.d(eax_6, eax_6, c_3), 0xffffffff, c_4)
0040e395          break
0040e395      
0040e39a      if (eax_8 == 0)
0040e39a          break
0040e39a      
0040e39d      sub_413f90(arg1)
0040e3a3      void* eax_9 = sub_40e1c0(arg1)
0040e3ae      *eax_9 = *(eax_3 * 0x2c + &data_256ee94)
0040e3b0      *(eax_3 * 0x2c + &data_256ee94) = eax_9
0040e3b0  
0040e3c4  return 1

0040e3c5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040e3d0    int32_t sub_40e3d0()

0040e3d0  void* eax_3 = data_2584eec
0040e3d5  int32_t ecx = data_256ee60
0040e3e3  data_2584ecc = 0
0040e3ed  void* eax = sub_414130(ecx, eax_3, "*Quake2 bsp file")
0040e3f7  sub_414010(eax, 0xc)
0040e3f7  
0040e407  if (sub_40e2a0(eax) != 0)
0040e414      int32_t i
0040e414      
0040e414      do
0040e40a          i = sub_40e2a0(eax)
0040e414      while (i != 0)
0040e414  
0040e420  return sub_4105e0(eax)

0040e421     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040e430    int32_t sub_40e430()

0040e435  sub_41e520(0x100c)
0040e43a  char* edx = data_256ee60
0040e441  char* arg_8 = edx
0040e445  char* ebp = edx
0040e447  *edx = 0
0040e44a  int32_t i = data_2584ecc
0040e451  int32_t i_1 = 0
0040e451  
0040e459  if (i s> 0)
0040e462      __return_addr = &data_256ee94
0040e462      
0040e5e5      do
0040e471          if (*__return_addr != 0)
0040e477              void* edi_1 = &data_42c9dc
0040e47c              int32_t j = 0xffffffff
0040e47c              
0040e481              while (j != 0)
0040e481                  bool cond:2_1 = 0 != *edi_1
0040e481                  edi_1 += 1
0040e481                  j -= 1
0040e481                  
0040e481                  if (not(cond:2_1))
0040e481                      break
0040e481              
0040e483              int32_t ecx_1 = not.d(j)
0040e48b              char* edi_3 = ebp
0040e48d              int32_t j_1 = 0xffffffff
0040e48d              
0040e490              while (j_1 != 0)
0040e490                  bool cond:3_1 = 0 != *edi_3
0040e490                  edi_3 = &edi_3[1]
0040e490                  j_1 -= 1
0040e490                  
0040e490                  if (not(cond:3_1))
0040e490                      break
0040e490              
0040e498              int32_t esi_2
0040e498              int32_t edi_5
0040e498              edi_5, esi_2 =
0040e498                  __builtin_memcpy(dest: edi_3 - 1, src: edi_1 - ecx_1, n: ecx_1 u>> 2 << 2)
0040e49c              void* ebp_1 = &ebp[2]
0040e4a2              __builtin_memcpy(dest: edi_5, src: esi_2, n: ecx_1 & 3)
0040e4a8              void** j_2 = *__return_addr
0040e4a8              
0040e4ac              if (j_2 != 0)
0040e577                  do
0040e4b2                      int32_t edi_6 = j_2[1]
0040e4b5                      int32_t k = 0xffffffff
0040e4b5                      
0040e4c1                      while (k != 0)
0040e4c1                          bool cond:7_1 = 0 != *edi_6
0040e4c1                          edi_6 += 1
0040e4c1                          k -= 1
0040e4c1                          
0040e4c1                          if (not(cond:7_1))
0040e4c1                              break
0040e4c1                      
0040e4c3                      int32_t ecx_7 = not.d(k)
0040e4d0                      void arg_40c
0040e4d0                      int32_t esi_4
0040e4d0                      int32_t edi_8
0040e4d0                      edi_8, esi_4 = __builtin_memcpy(dest: &arg_40c, src: edi_6 - ecx_7, 
0040e4d0                          n: ecx_7 u>> 2 << 2)
0040e4d7                      __builtin_memcpy(dest: edi_8, src: esi_4, n: ecx_7 & 3)
0040e4e1                      sub_40e190(&arg_40c)
0040e4e6                      int32_t edi_9 = j_2[2]
0040e4e9                      int32_t k_1 = 0xffffffff
0040e4e9                      
0040e4f2                      while (k_1 != 0)
0040e4f2                          bool cond:8_1 = 0 != *edi_9
0040e4f2                          edi_9 += 1
0040e4f2                          k_1 -= 1
0040e4f2                          
0040e4f2                          if (not(cond:8_1))
0040e4f2                              break
0040e4f2                      
0040e4f4                      int32_t ecx_11 = not.d(k_1)
0040e501                      void arg_c
0040e501                      int32_t esi_6
0040e501                      int32_t edi_11
0040e501                      edi_11, esi_6 = __builtin_memcpy(dest: &arg_c, src: edi_9 - ecx_11, 
0040e501                          n: ecx_11 u>> 2 << 2)
0040e508                      __builtin_memcpy(dest: edi_11, src: esi_6, n: ecx_11 & 3)
0040e50f                      sub_40e190(&arg_c)
0040e51f                      void* var_1c_1 = &arg_c
0040e520                      void* var_20_1 = &arg_40c
0040e52e                      void arg_80c
0040e52e                      sub_41e430(&arg_80c, ""%s" "%s"\n")
0040e533                      void* edi_12 = &arg_80c
0040e53a                      int32_t k_2 = 0xffffffff
0040e53a                      
0040e542                      while (k_2 != 0)
0040e542                          bool cond:9_1 = 0 != *edi_12
0040e542                          edi_12 += 1
0040e542                          k_2 -= 1
0040e542                          
0040e542                          if (not(cond:9_1))
0040e542                              break
0040e542                      
0040e544                      int32_t ecx_15 = not.d(k_2)
0040e54c                      void* edi_14 = ebp_1
0040e54e                      int32_t k_3 = 0xffffffff
0040e54e                      
0040e551                      while (k_3 != 0)
0040e551                          bool cond:10_1 = 0 != *edi_14
0040e551                          edi_14 += 1
0040e551                          k_3 -= 1
0040e551                          
0040e551                          if (not(cond:10_1))
0040e551                              break
0040e551                      
0040e559                      int32_t esi_8
0040e559                      int32_t edi_16
0040e559                      edi_16, esi_8 = __builtin_memcpy(dest: edi_14 - 1, 
0040e559                          src: edi_12 - ecx_15, n: ecx_15 u>> 2 << 2)
0040e560                      __builtin_memcpy(dest: edi_16, src: esi_8, n: ecx_15 & 3)
0040e562                      void* edi_17 = &arg_80c
0040e569                      int32_t k_4 = 0xffffffff
0040e569                      
0040e56c                      while (k_4 != 0)
0040e56c                          bool cond:11_1 = 0 != *edi_17
0040e56c                          edi_17 += 1
0040e56c                          k_4 -= 1
0040e56c                          
0040e56c                          if (not(cond:11_1))
0040e56c                              break
0040e56c                      
0040e56e                      j_2 = *j_2
0040e573                      ebp_1 += not.d(k_4) - 1
0040e577                  while (j_2 != 0)
0040e577                  
0040e57d                  edx = arg_8
0040e57d              
0040e581              void* edi_18 = &data_42c9d8
0040e586              int32_t j_3 = 0xffffffff
0040e586              
0040e58b              while (j_3 != 0)
0040e58b                  bool cond:4_1 = 0 != *edi_18
0040e58b                  edi_18 += 1
0040e58b                  j_3 -= 1
0040e58b                  
0040e58b                  if (not(cond:4_1))
0040e58b                      break
0040e58b              
0040e58d              int32_t ecx_22 = not.d(j_3)
0040e595              void* edi_20 = ebp_1
0040e597              int32_t j_4 = 0xffffffff
0040e597              
0040e59a              while (j_4 != 0)
0040e59a                  bool cond:5_1 = 0 != *edi_20
0040e59a                  edi_20 += 1
0040e59a                  j_4 -= 1
0040e59a                  
0040e59a                  if (not(cond:5_1))
0040e59a                      break
0040e59a              
0040e5a2              int32_t esi_10
0040e5a2              int32_t edi_22
0040e5a2              edi_22, esi_10 = __builtin_memcpy(dest: edi_20 - 1, src: edi_18 - ecx_22, 
0040e5a2                  n: ecx_22 u>> 2 << 2)
0040e5a6              ebp = ebp_1 + 2
0040e5b4              __builtin_memcpy(dest: edi_22, src: esi_10, n: ecx_22 & 3)
0040e5b4              
0040e5b6              if (ebp u> &edx[0x40000])
0040e5bd                  sub_40f970("Entity text too long")
0040e5c2                  edx = arg_8
0040e5c2          
0040e5d7          i = i_1 + 1
0040e5dd          i_1 = i
0040e5e1          __return_addr += 0x2c
0040e5e5      while (i s< data_2584ecc)
0040e5e5  
0040e5f1  data_2584eec = ebp - edx + 1
0040e5fe  return i

0040e5ff                                                                                               90                                 .

0040e600    void* sub_40e600(void* arg1, char* arg2, int32_t arg3)

0040e60c  void** edi = *(arg1 + 0x14)
0040e60c  
0040e611  if (edi != 0)
0040e613      while (true)
0040e613          char* eax_1 = edi[1]
0040e616          char* esi_1 = arg2
0040e618          int32_t eax_3
0040e618          
0040e618          while (true)
0040e618              char edx = *eax_1
0040e61c              char temp0_1 = *esi_1
0040e61c              bool c_1 = edx u< temp0_1
0040e61c              
0040e61e              if (edx == temp0_1)
0040e622                  if (edx == 0)
0040e638                      eax_3 = 0
0040e63a                      break
0040e63a                  
0040e624                  edx = eax_1[1]
0040e629                  char temp3_1 = esi_1[1]
0040e629                  c_1 = edx u< temp3_1
0040e629                  
0040e62c                  if (edx == temp3_1)
0040e62e                      eax_1 = &eax_1[2]
0040e631                      esi_1 = &esi_1[2]
0040e631                      
0040e636                      if (edx != 0)
0040e636                          continue
0040e636                      
0040e638                      eax_3 = 0
0040e63a                      break
0040e63a              
0040e63c              bool c_2 = unimplemented  {sbb eax, eax}
0040e63e              eax_3 = sbb.d(sbb.d(eax_1, eax_1, c_1), 0xffffffff, c_2)
0040e63e              break
0040e63e          
0040e643          if (eax_3 == 0)
0040e67e              sub_41e29e(edi[2])
0040e688              void* eax_9 = sub_40faa0(arg3)
0040e690              edi[2] = eax_9
0040e697              return eax_9
0040e697          
0040e645          edi = *edi
0040e645          
0040e649          if (edi == 0)
0040e649              break
0040e649  
0040e64d  int32_t* eax_4 = sub_4105b0(0xc)
0040e658  *eax_4 = *(arg1 + 0x14)
0040e65a  *(arg1 + 0x14) = eax_4
0040e662  eax_4[1] = sub_40faa0(arg2)
0040e66a  void* eax_7 = sub_40faa0(arg3)
0040e672  eax_4[2] = eax_7
0040e679  return eax_7

0040e698                                                                          90 90 90 90 90 90 90 90                          ........

0040e6a0    int32_t sub_40e6a0(void* arg1, char* arg2)

0040e6a4  int32_t ebx
0040e6a4  int32_t var_4 = ebx
0040e6a8  void** edi = *(arg1 + 0x14)
0040e6a8  
0040e6ad  if (edi != 0)
0040e6b3      while (true)
0040e6b3          char* eax = edi[1]
0040e6b6          char* esi_1 = arg2
0040e6b8          int32_t eax_2
0040e6b8          
0040e6b8          while (true)
0040e6b8              char edx = *eax
0040e6ba              ebx.b = *esi_1
0040e6be              bool c_1 = edx u< ebx.b
0040e6be              
0040e6c0              if (edx == ebx.b)
0040e6c4                  if (edx == 0)
0040e6dc                      eax_2 = 0
0040e6de                      break
0040e6de                  
0040e6c6                  edx = eax[1]
0040e6c9                  ebx.b = esi_1[1]
0040e6ce                  c_1 = edx u< ebx.b
0040e6ce                  
0040e6d0                  if (edx == ebx.b)
0040e6d2                      eax = &eax[2]
0040e6d5                      esi_1 = &esi_1[2]
0040e6d5                      
0040e6da                      if (edx != 0)
0040e6da                          continue
0040e6da                      
0040e6dc                      eax_2 = 0
0040e6de                      break
0040e6de              
0040e6e0              bool c_2 = unimplemented  {sbb eax, eax}
0040e6e2              eax_2 = sbb.d(sbb.d(eax, eax, c_1), 0xffffffff, c_2)
0040e6e2              break
0040e6e2          
0040e6e7          if (eax_2 == 0)
0040e700              return edi[2]
0040e700          
0040e6e9          edi = *edi
0040e6e9          
0040e6ed          if (edi == 0)
0040e6ed              break
0040e6ed  
0040e6f8  return &data_43032c

0040e701     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040e710    int80_t sub_40e710(void* arg1, char* arg2)

0040e728  return sub_41e482(sub_40e6a0(arg1, arg2))

0040e729                             90 90 90 90 90 90 90                                                           .......

0040e730    float* sub_40e730(void* arg1, char* arg2, float* arg3)

0040e741  char* eax_1 = sub_40e6a0(arg1, arg2)
0040e74e  int32_t var_10
0040e74e  int32_t* var_2c = &var_10
0040e753  int32_t var_18
0040e753  int32_t* var_30 = &var_18
0040e754  int32_t s
0040e754  int32_t* var_34 = &s
0040e77b  __builtin_memset(&s, c: 0, n: 0x18)
0040e78b  sub_41e54f(eax_1, "%lf %lf %lf")
0040e79a  *arg3 = fconvert.s(fconvert.t(s.q))
0040e7a0  arg3[1] = fconvert.s(fconvert.t(var_18.q))
0040e7a7  arg3[2] = fconvert.s(fconvert.t(var_10.q))
0040e7ad  return arg3

0040e7ae                                            90 90                                                                ..

0040e7b0    int32_t* sub_40e7b0()

0040e7b8  data_255ee10 = 0
0040e7be  void* eax = sub_410570(0xc000)
0040e7ce  int32_t ecx_1 = data_43034c + 0xc000
0040e7d4  data_255ee34 = eax
0040e7d9  data_43034c = ecx_1
0040e7df  data_255edc8 = 0
0040e7e5  void* eax_1 = sub_410570(0x280000)
0040e7f5  int32_t ecx_3 = data_43034c + 0x280000
0040e7fb  data_255ee20 = eax_1
0040e800  data_255edd0 = eax_1
0040e805  data_43034c = ecx_3
0040e80b  data_255ee40 = 0
0040e811  void* eax_2 = sub_410570(0x300000)
0040e821  int32_t ecx_5 = data_43034c + 0x300000
0040e827  data_255edec = eax_2
0040e82c  data_43034c = ecx_5
0040e832  data_255ee24 = 0
0040e838  void* eax_3 = sub_410570(0x40000)
0040e848  int32_t ecx_7 = data_43034c + 0x40000
0040e84e  data_255ee30 = eax_3
0040e853  data_43034c = ecx_7
0040e859  data_255edd8 = 0
0040e85f  void* eax_4 = sub_410570(0x1c0000)
0040e86f  int32_t ecx_9 = data_43034c + 0x1c0000
0040e875  data_255ee08 = eax_4
0040e87a  data_43034c = ecx_9
0040e880  data_255ee3c = 0
0040e886  void* eax_5 = sub_410570(0x140000)
0040e896  int32_t ecx_11 = data_43034c + 0x140000
0040e89c  data_255edac = eax_5
0040e8a1  data_43034c = ecx_11
0040e8a7  data_255edb4 = 0
0040e8ad  void* eax_6 = sub_410570(0xc0000)
0040e8bd  int32_t ecx_13 = data_43034c + 0xc0000
0040e8c3  data_255ede4 = eax_6
0040e8c8  data_43034c = ecx_13
0040e8ce  data_255edfc = 0
0040e8d4  void* eax_7 = sub_410570(0x1c0000)
0040e8e4  int32_t ecx_15 = data_43034c + 0x1c0000
0040e8ea  data_255ee2c = eax_7
0040e8ef  data_43034c = ecx_15
0040e8f5  data_255ee1c = 0
0040e8fb  void* eax_8 = sub_410570(0x168000)
0040e90b  int32_t ecx_17 = data_43034c + 0x168000
0040e911  data_255edb0 = eax_8
0040e916  data_43034c = ecx_17
0040e91c  data_255edf4 = 0
0040e922  void* eax_9 = sub_410570(0x240000)
0040e932  int32_t ecx_19 = data_43034c + 0x240000
0040e938  data_255ede0 = eax_9
0040e93d  data_43034c = ecx_19
0040e943  data_255edf0 = 0
0040e949  void* eax_10 = sub_410570(0x7d000)
0040e94e  int32_t ecx_20 = data_43034c
0040e954  data_255eddc = eax_10
0040e95f  data_255ee00 = 0
0040e965  data_43034c = ecx_20 + 0x7d000
0040e970  void* eax_11 = sub_410570(0x20000)
0040e980  int32_t ecx_23 = data_43034c + 0x20000
0040e986  data_255edc4 = eax_11
0040e98b  data_43034c = ecx_23
0040e991  data_255edbc = 0
0040e997  void* eax_12 = sub_410570(0x20000)
0040e9a7  int32_t ecx_25 = data_43034c + 0x20000
0040e9ad  data_255ee28 = eax_12
0040e9b2  data_43034c = ecx_25
0040e9b8  data_255edc0 = 0
0040e9be  void* eax_13 = sub_410570(0xfa000)
0040e9ce  int32_t ecx_27 = data_43034c + 0xfa000
0040e9d4  data_255ee14 = eax_13
0040e9d9  data_43034c = ecx_27
0040e9df  data_255edd4 = 0
0040e9e5  void* eax_14 = sub_410570(0x18000)
0040e9f5  int32_t ecx_29 = data_43034c + 0x18000
0040e9fb  data_255ee0c = eax_14
0040ea00  data_43034c = ecx_29
0040ea06  data_255edb8 = 0
0040ea0c  void* eax_15 = sub_410570(0x80000)
0040ea1a  int32_t ecx_31 = data_43034c + 0x80000
0040ea20  data_255ee38 = eax_15
0040ea2a  data_43034c = ecx_31
0040ea30  data_255ede8 = 0
0040ea36  void* eax_16 = sub_410570(0x800)
0040ea46  int32_t ecx_33 = data_43034c + 0x800
0040ea4c  data_255edf8 = eax_16
0040ea51  data_43034c = ecx_33
0040ea57  data_255edcc = 0
0040ea5d  void* eax_17 = sub_410570(0x2000)
0040ea6d  int32_t ecx_35 = data_43034c + 0x2000
0040ea73  data_255eda8 = eax_17
0040ea78  data_43034c = ecx_35
0040ea7e  data_255ee18 = 0
0040ea84  void* eax_18 = sub_410570(0x78000)
0040ea94  int32_t edx_1 = data_43034c + 0x78000
0040ea9a  data_255ee04 = eax_18
0040ea9f  data_43034c = edx_1
0040eaa5  sub_410030("allocated ")
0040eab0  sub_4105f0(data_43034c)
0040eac3  return sub_410030(" of BSP memory\n")

0040eac4              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040ead0    int32_t* sub_40ead0()

0040ead0  void* eax_6 = data_255ee34
0040ead9  data_255ee10 = 0
0040eadf  sub_4105e0(eax_6)
0040eae4  void* ecx = data_255ee20
0040eaea  data_255ee34 = 0
0040eaf1  data_255edc8 = 0
0040eaf7  sub_4105e0(ecx)
0040eafc  void* edx = data_255edec
0040eb02  data_255ee20 = 0
0040eb09  data_255edd0 = 0
0040eb0f  data_255ee40 = 0
0040eb15  sub_4105e0(edx)
0040eb1a  void* eax = data_255ee30
0040eb1f  data_255edec = 0
0040eb26  data_255ee24 = 0
0040eb2c  sub_4105e0(eax)
0040eb31  void* ecx_1 = data_255ee08
0040eb37  data_255ee30 = 0
0040eb3e  data_255edd8 = 0
0040eb44  sub_4105e0(ecx_1)
0040eb49  void* edx_1 = data_255edac
0040eb4f  data_255ee08 = 0
0040eb56  data_255ee3c = 0
0040eb5c  sub_4105e0(edx_1)
0040eb61  void* eax_1 = data_255ede4
0040eb66  data_255edac = 0
0040eb6d  data_255edb4 = 0
0040eb73  sub_4105e0(eax_1)
0040eb78  void* ecx_2 = data_255ee2c
0040eb7e  data_255ede4 = 0
0040eb85  data_255edfc = 0
0040eb8b  sub_4105e0(ecx_2)
0040eb90  void* edx_2 = data_255edb0
0040eb96  data_255ee2c = 0
0040eb9d  data_255ee1c = 0
0040eba3  sub_4105e0(edx_2)
0040eba8  void* eax_2 = data_255ede0
0040ebad  data_255edb0 = 0
0040ebb4  data_255edf4 = 0
0040ebba  sub_4105e0(eax_2)
0040ebbf  void* ecx_3 = data_255eddc
0040ebc5  data_255ede0 = 0
0040ebcc  data_255edf0 = 0
0040ebd2  sub_4105e0(ecx_3)
0040ebd7  void* edx_3 = data_255edc4
0040ebdd  data_255eddc = 0
0040ebe4  data_255ee00 = 0
0040ebea  sub_4105e0(edx_3)
0040ebef  void* eax_3 = data_255ee28
0040ebf4  data_255edc4 = 0
0040ebfb  data_255edbc = 0
0040ec01  sub_4105e0(eax_3)
0040ec06  void* ecx_4 = data_255ee14
0040ec0c  data_255ee28 = 0
0040ec13  data_255edc0 = 0
0040ec19  sub_4105e0(ecx_4)
0040ec1e  void* edx_4 = data_255ee0c
0040ec24  data_255ee14 = 0
0040ec2b  data_255edd4 = 0
0040ec31  sub_4105e0(edx_4)
0040ec36  void* eax_4 = data_255ee38
0040ec3b  data_255ee0c = 0
0040ec41  data_255edb8 = 0
0040ec48  sub_4105e0(eax_4)
0040ec4d  void* ecx_5 = data_255edf8
0040ec56  data_255ee38 = 0
0040ec5c  data_255ede8 = 0
0040ec63  sub_4105e0(ecx_5)
0040ec68  void* edx_5 = data_255eda8
0040ec6e  data_255edf8 = 0
0040ec75  data_255edcc = 0
0040ec7b  sub_4105e0(edx_5)
0040ec80  void* eax_5 = data_255ee04
0040ec85  data_255eda8 = 0
0040ec8c  data_255ee18 = 0
0040ec92  sub_4105e0(eax_5)
0040ec9c  data_255ee04 = 0
0040eca2  sub_410030("freed ")
0040ecae  sub_4105f0(data_43034c)
0040ecb8  int32_t* result = sub_410030(" of BSP memory\n")
0040ecc0  data_43034c = 0
0040ecc7  return result

0040ecc8                          90 90 90 90 90 90 90 90                                                          ........

0040ecd0    int32_t sub_40ecd0(int32_t arg1)

0040ecd7  int32_t i = 0
0040ecd7  
0040ecdd  if (data_255ee10 s> 0)
0040ecdf      void* ebx_1 = nullptr
0040ecdf      
0040ed4f      do
0040ece1          int32_t eax = data_255ee34
0040ecea          void* esi_1 = ebx_1 + eax
0040ecee          int32_t eax_1 = sub_40ff30(*(ebx_1 + eax + 0x28))
0040ecf3          int32_t edx_1 = *(esi_1 + 0x2c)
0040ecf6          *(esi_1 + 0x28) = eax_1
0040ecff          *(esi_1 + 0x2c) = sub_40ff30(edx_1)
0040ed0e          *(esi_1 + 0x24) = sub_40ff30(*(esi_1 + 0x24))
0040ed11          void* esi_2 = esi_1 + 0x18
0040ed14          int32_t j_12 = 3
0040ed42          int32_t j
0040ed42          
0040ed42          do
0040ed22              *(esi_2 - 0x18) = fconvert.s(sub_40ff20(*(esi_2 - 0x18)))
0040ed2e              *(esi_2 - 0xc) = fconvert.s(sub_40ff20(*(esi_2 - 0xc)))
0040ed39              *esi_2 = fconvert.s(sub_40ff20(*esi_2))
0040ed3e              esi_2 += 4
0040ed41              j = j_12
0040ed41              j_12 -= 1
0040ed42          while (j != 1)
0040ed49          i += 1
0040ed4a          ebx_1 += 0x30
0040ed4f      while (i s< data_255ee10)
0040ed4f  
0040ed56  int32_t i_1 = 0
0040ed56  
0040ed5a  if (data_255edb4 s> 0)
0040ed5c      int32_t* esi_3 = nullptr
0040ed5c      
0040ed8b      do
0040ed5e          int32_t j_13 = 3
0040ed81          int32_t j_1
0040ed81          
0040ed81          do
0040ed7a              *(esi_3 + data_255ede4) = fconvert.s(sub_40ff20(*(esi_3 + data_255ede4)))
0040ed7d              esi_3 = &esi_3[1]
0040ed80              j_1 = j_13
0040ed80              j_13 -= 1
0040ed81          while (j_1 != 1)
0040ed88          i_1 += 1
0040ed8b      while (i_1 s< data_255edb4)
0040ed8b  
0040ed92  int32_t i_2 = 0
0040ed92  
0040ed96  if (data_255ee3c s> 0)
0040ed98      int32_t* edi_1 = nullptr
0040ed98      
0040ee02      do
0040ed9a          int32_t* esi_4 = edi_1
0040ed9c          int32_t j_7 = 3
0040edbf          int32_t j_2
0040edbf          
0040edbf          do
0040edb8              *(esi_4 + data_255edac) = fconvert.s(sub_40ff20(*(esi_4 + data_255edac)))
0040edbb              esi_4 = &esi_4[1]
0040edbe              j_2 = j_7
0040edbe              j_7 -= 1
0040edbf          while (j_2 != 1)
0040edd6          *(edi_1 + data_255edac + 0xc) =
0040edd6              fconvert.s(sub_40ff20(*(edi_1 + data_255edac + 0xc)))
0040edf3          i_2 += 1
0040edf4          *(edi_1 + data_255edac + 0x10) = sub_40ff30(*(edi_1 + data_255edac + 0x10))
0040edfd          edi_1 = &edi_1[5]
0040ee02      while (i_2 s< data_255ee3c)
0040ee02  
0040ee09  int32_t i_3 = 0
0040ee09  
0040ee0d  if (data_255ee1c s> 0)
0040ee13      int32_t* esi_5 = nullptr
0040ee13      
0040ef44      do
0040ee15          int32_t* edi_2 = esi_5
0040ee17          int32_t j_8 = 8
0040ee3b          int32_t j_3
0040ee3b          
0040ee3b          do
0040ee34              *(edi_2 + data_255edb0) = fconvert.s(sub_40ff20(*(edi_2 + data_255edb0)))
0040ee37              edi_2 = &edi_2[1]
0040ee3a              j_3 = j_8
0040ee3a              j_8 -= 1
0040ee3b          while (j_3 != 1)
0040ee53          *(esi_5 + data_255edb0 + 0x68) =
0040ee53              fconvert.s(sub_40ff20(*(esi_5 + data_255edb0 + 0x68)))
0040ee6d          *(esi_5 + data_255edb0 + 0x6c) = sub_40ff30(*(esi_5 + data_255edb0 + 0x6c))
0040ee87          *(esi_5 + data_255edb0 + 0x74) =
0040ee87              fconvert.s(sub_40ff20(*(esi_5 + data_255edb0 + 0x74)))
0040eea1          *(esi_5 + data_255edb0 + 0x78) =
0040eea1              fconvert.s(sub_40ff20(*(esi_5 + data_255edb0 + 0x78)))
0040eebb          *(esi_5 + data_255edb0 + 0x7c) =
0040eebb              fconvert.s(sub_40ff20(*(esi_5 + data_255edb0 + 0x7c)))
0040eed8          *(esi_5 + data_255edb0 + 0x80) =
0040eed8              fconvert.s(sub_40ff20(*(esi_5 + data_255edb0 + 0x80)))
0040eef8          *(esi_5 + data_255edb0 + 0x84) =
0040eef8              fconvert.s(sub_40ff20(*(esi_5 + data_255edb0 + 0x84)))
0040ef15          *(esi_5 + data_255edb0 + 0x20) = sub_40ff30(*(esi_5 + data_255edb0 + 0x20))
0040ef32          i_3 += 1
0040ef33          *(esi_5 + data_255edb0 + 0x64) = sub_40ff30(*(esi_5 + data_255edb0 + 0x64))
0040ef3c          esi_5 = &esi_5[0x2d]
0040ef44      while (i_3 s< data_255ee1c)
0040ef44  
0040ef4f  int32_t i_4 = 0
0040ef4f  
0040ef53  if (data_255ee18 s> 0)
0040ef59      int32_t* esi_6 = nullptr
0040ef59      
0040eff8      do
0040ef5b          int32_t* edi_3 = &esi_6[1]
0040ef5e          int32_t j_9 = 3
0040ef82          int32_t j_4
0040ef82          
0040ef82          do
0040ef7b              *(edi_3 + data_255ee04) = fconvert.s(sub_40ff20(*(edi_3 + data_255ee04)))
0040ef7e              edi_3 = &edi_3[1]
0040ef81              j_4 = j_9
0040ef81              j_9 -= 1
0040ef82          while (j_4 != 1)
0040ef99          *(esi_6 + data_255ee04) = sub_40ff30(*(esi_6 + data_255ee04))
0040efb2          *(esi_6 + data_255ee04 + 0x10) =
0040efb2              fconvert.s(sub_40ff20(*(esi_6 + data_255ee04 + 0x10)))
0040efcc          *(esi_6 + data_255ee04 + 0x14) =
0040efcc              fconvert.s(sub_40ff20(*(esi_6 + data_255ee04 + 0x14)))
0040efe9          i_4 += 1
0040efea          *(esi_6 + data_255ee04 + 0x18) =
0040efea              fconvert.s(sub_40ff20(*(esi_6 + data_255ee04 + 0x18)))
0040eff3          esi_6 = &esi_6[0xf]
0040eff8      while (i_4 s< data_255ee18)
0040eff8  
0040f003  int32_t i_5 = 0
0040f003  
0040f007  if (data_255edf4 s> 0)
0040f00d      int16_t* esi_7 = nullptr
0040f00d      
0040f0d9      do
0040f015          int32_t eax_38
0040f015          eax_38.w = *(esi_7 + data_255ede0 + 0xa)
0040f026          *(esi_7 + data_255ede0 + 0xa) = sub_40ff10(eax_38.w)
0040f041          *(esi_7 + data_255ede0 + 0x20) = sub_40ff30(*(esi_7 + data_255ede0 + 0x20))
0040f04b          int32_t eax_41
0040f04b          eax_41.w = *(esi_7 + data_255ede0)
0040f05b          *(esi_7 + data_255ede0) = sub_40ff10(eax_41.w)
0040f076          *(esi_7 + data_255ede0 + 2) = sub_40ff10(*(esi_7 + data_255ede0 + 2))
0040f091          *(esi_7 + data_255ede0 + 0x1c) = sub_40ff30(*(esi_7 + data_255ede0 + 0x1c))
0040f0ab          *(esi_7 + data_255ede0 + 4) = sub_40ff30(*(esi_7 + data_255ede0 + 4))
0040f0b5          int32_t eax_47
0040f0b5          eax_47.w = *(esi_7 + data_255ede0 + 8)
0040f0c9          i_5 += 1
0040f0ca          *(esi_7 + data_255ede0 + 8) = sub_40ff10(eax_47.w)
0040f0d4          esi_7 = &esi_7[0x12]
0040f0d9      while (i_5 s< data_255edf4)
0040f0d9  
0040f0e4  int32_t i_6 = 0
0040f0e4  
0040f0e8  if (data_255edfc s> 0)
0040f0ee      int32_t* esi_8 = nullptr
0040f0ee      
0040f1cc      do
0040f108          void* edi_4 = esi_8 + 0x12
0040f10b          int32_t j_10 = 3
0040f110          *(esi_8 + data_255ee2c) = sub_40ff30(*(esi_8 + data_255ee2c))
0040f150          int32_t j_5
0040f150          
0040f150          do
0040f119              int32_t eax_51
0040f119              eax_51.w = *(edi_4 + data_255ee2c - 6)
0040f12a              *(edi_4 + data_255ee2c - 6) = sub_40ff10(eax_51.w)
0040f148              *(edi_4 + data_255ee2c) = sub_40ff10(*(edi_4 + data_255ee2c)).w
0040f14c              edi_4 += 2
0040f14f              j_5 = j_10
0040f14f              j_10 -= 1
0040f150          while (j_5 != 1)
0040f168          *(esi_8 + data_255ee2c + 4) = sub_40ff30(*(esi_8 + data_255ee2c + 4))
0040f182          *(esi_8 + data_255ee2c + 8) = sub_40ff30(*(esi_8 + data_255ee2c + 8))
0040f18c          int32_t eax_56
0040f18c          eax_56.w = *(esi_8 + data_255ee2c + 0x18)
0040f19d          *(esi_8 + data_255ee2c + 0x18) = sub_40ff10(eax_56.w)
0040f1bc          i_6 += 1
0040f1bd          *(esi_8 + data_255ee2c + 0x1a) = sub_40ff10(*(esi_8 + data_255ee2c + 0x1a))
0040f1c7          esi_8 = &esi_8[7]
0040f1cc      while (i_6 s< data_255edfc)
0040f1cc  
0040f1d7  int32_t i_7 = 0
0040f1d7  
0040f1db  if (data_255edd8 s> 0)
0040f1e1      int32_t* esi_9 = nullptr
0040f1e1      
0040f2fb      do
0040f1f8          *(esi_9 + data_255ee08) = sub_40ff30(*(esi_9 + data_255ee08))
0040f201          int32_t eax_62
0040f201          eax_62.w = *(esi_9 + data_255ee08 + 4)
0040f212          *(esi_9 + data_255ee08 + 4) = sub_40ff10(eax_62.w)
0040f231          void* edi_5 = esi_9 + 0xe
0040f234          int32_t j_11 = 3
0040f239          *(esi_9 + data_255ee08 + 6) = sub_40ff10(*(esi_9 + data_255ee08 + 6))
0040f27b          int32_t j_6
0040f27b          
0040f27b          do
0040f255              *(edi_5 + data_255ee08 - 6) = sub_40ff10(*(edi_5 + data_255ee08 - 6))
0040f273              *(edi_5 + data_255ee08) = sub_40ff10(*(edi_5 + data_255ee08))
0040f277              edi_5 += 2
0040f27a              j_6 = j_11
0040f27a              j_11 -= 1
0040f27b          while (j_6 != 1)
0040f294          *(esi_9 + data_255ee08 + 0x14) = sub_40ff10(*(esi_9 + data_255ee08 + 0x14))
0040f2b0          *(esi_9 + data_255ee08 + 0x16) = sub_40ff10(*(esi_9 + data_255ee08 + 0x16))
0040f2cc          *(esi_9 + data_255ee08 + 0x18) = sub_40ff10(*(esi_9 + data_255ee08 + 0x18))
0040f2eb          i_7 += 1
0040f2ec          *(esi_9 + data_255ee08 + 0x1a) = sub_40ff10(*(esi_9 + data_255ee08 + 0x1a))
0040f2f6          esi_9 = &esi_9[7]
0040f2fb      while (i_7 s< data_255edd8)
0040f2fb  
0040f306  int32_t i_8 = 0
0040f306  
0040f30a  if (data_255ee00 s> 0)
0040f331      do
0040f312          int32_t eax_71
0040f312          eax_71.w = *(data_255edc4 + (i_8 << 1))
0040f325          *(data_255edc4 + (i_8 << 1)) = sub_40ff10(eax_71.w)
0040f32e          i_8 += 1
0040f331      while (i_8 s< data_255ee00)
0040f331  
0040f338  int32_t i_9 = 0
0040f338  
0040f33c  if (data_255edbc s> 0)
0040f363      do
0040f344          int32_t eax_73
0040f344          eax_73.w = *(data_255ee28 + (i_9 << 1))
0040f357          *(data_255ee28 + (i_9 << 1)) = sub_40ff10(eax_73.w)
0040f360          i_9 += 1
0040f363      while (i_9 s< data_255edbc)
0040f363  
0040f36a  int32_t i_10 = 0
0040f36a  
0040f36e  if (data_255edc0 s> 0)
0040f393      do
0040f388          *(data_255ee14 + (i_10 << 2)) = sub_40ff30(*(data_255ee14 + (i_10 << 2)))
0040f390          i_10 += 1
0040f393      while (i_10 s< data_255edc0)
0040f393  
0040f39a  int32_t i_11 = 0
0040f39a  
0040f39e  if (data_255edf0 s> 0)
0040f3e1      do
0040f3a6          int32_t eax_79
0040f3a6          eax_79.w = *(data_255eddc + (i_11 << 2))
0040f3b6          *(data_255eddc + (i_11 << 2)) = sub_40ff10(eax_79.w)
0040f3d4          *(data_255eddc + (i_11 << 2) + 2) = sub_40ff10(*(data_255eddc + (i_11 << 2) + 2))
0040f3de          i_11 += 1
0040f3e1      while (i_11 s< data_255edf0)
0040f3e1  
0040f3e8  int32_t i_12 = 0
0040f3e8  
0040f3ec  if (data_255edd4 s> 0)
0040f3ee      int32_t* esi_10 = nullptr
0040f3ee      
0040f44a      do
0040f405          *(esi_10 + data_255ee0c) = sub_40ff30(*(esi_10 + data_255ee0c))
0040f41e          *(esi_10 + data_255ee0c + 4) = sub_40ff30(*(esi_10 + data_255ee0c + 4))
0040f43b          i_12 += 1
0040f43c          *(esi_10 + data_255ee0c + 8) = sub_40ff30(*(esi_10 + data_255ee0c + 8))
0040f445          esi_10 = &esi_10[3]
0040f44a      while (i_12 s< data_255edd4)
0040f44a  
0040f451  int32_t i_13 = 0
0040f451  
0040f455  if (data_255ede8 s> 0)
0040f494      do
0040f46c          *(data_255edf8 + (i_13 << 3)) = sub_40ff30(*(data_255edf8 + (i_13 << 3)))
0040f488          *(data_255edf8 + (i_13 << 3) + 4) = sub_40ff30(*(data_255edf8 + (i_13 << 3) + 4))
0040f491          i_13 += 1
0040f494      while (i_13 s< data_255ede8)
0040f494  
0040f49b  int32_t i_14 = 0
0040f49b  
0040f49f  if (data_255edcc s> 0)
0040f4de      do
0040f4b6          *(data_255eda8 + (i_14 << 3)) = sub_40ff30(*(data_255eda8 + (i_14 << 3)))
0040f4d2          *(data_255eda8 + (i_14 << 3) + 4) = sub_40ff30(*(data_255eda8 + (i_14 << 3) + 4))
0040f4db          i_14 += 1
0040f4de      while (i_14 s< data_255edcc)
0040f4de  
0040f4e5  int32_t i_15 = 0
0040f4e5  
0040f4e9  if (data_255edb8 s> 0)
0040f546      do
0040f4f1          int32_t eax_102
0040f4f1          eax_102.w = *(data_255ee38 + (i_15 << 3))
0040f501          *(data_255ee38 + (i_15 << 3)) = sub_40ff10(eax_102.w)
0040f51c          *(data_255ee38 + (i_15 << 3) + 2) = sub_40ff10(*(data_255ee38 + (i_15 << 3) + 2))
0040f53a          *(data_255ee38 + (i_15 << 3) + 4) = sub_40ff30(*(data_255ee38 + (i_15 << 3) + 4))
0040f543          i_15 += 1
0040f546      while (i_15 s< data_255edb8)
0040f546  
0040f54e  int32_t edi_6
0040f54e  
0040f54e  if (arg1 == 0)
0040f56a      edi_6 = sub_40ff30(*data_255edd0)
0040f54e  else
0040f556      edi_6 = *data_255edd0
0040f556  
0040f575  int32_t result = sub_40ff30(*data_255edd0)
0040f583  int32_t esi_11 = 0
0040f587  *data_255edd0 = result
0040f587  
0040f589  if (edi_6 s> 0)
0040f5c5      do
0040f5a1          *(data_255edd0 + (esi_11 << 3) + 4) =
0040f5a1              sub_40ff30(*(data_255edd0 + (esi_11 << 3) + 4))
0040f5b0          result = sub_40ff30(*(data_255edd0 + (esi_11 << 3) + 8))
0040f5be          *(data_255edd0 + (esi_11 << 3) + 8) = result
0040f5c2          esi_11 += 1
0040f5c5      while (esi_11 s< edi_6)
0040f5c5  
0040f5cb  return result

0040f5cc                                      90 90 90 90                                                              ....

0040f5d0    int32_t sub_40f5d0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)

0040f5d0  int32_t eax_9 = data_2584eb0
0040f5e1  int32_t esi = *(eax_9 + (arg1 << 3) + 0xc)
0040f5e5  int32_t ebp = *(eax_9 + (arg1 << 3) + 8)
0040f5e5  
0040f5f0  if (mods.dp.d(sx.q(esi), arg3) != 0)
0040f5f7      sub_40f970("Sin_LoadBSPFile: odd lump size")
0040f5f7  
0040f602  int32_t result = divs.dp.d(sx.q(esi), arg3)
0040f602  
0040f60c  if (result s> arg4)
0040f60e      int32_t var_14_1 = arg4
0040f60f      int32_t result_1 = result
0040f610      int32_t var_1c_1 = arg1
0040f616      sub_40f970("Sin_LoadBSPFile: exceeded max si…")
0040f616  
0040f631  int32_t esi_2
0040f631  int32_t edi_2
0040f631  edi_2, esi_2 = __builtin_memcpy(dest: arg2, src: data_2584eb0 + ebp, n: esi u>> 2 << 2)
0040f63a  __builtin_memcpy(dest: edi_2, src: esi_2, n: esi & 3)
0040f640  return result

0040f641     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040f650    int32_t sub_40f650(int32_t arg1, void* arg2, void* arg3)

0040f666  sub_40fcf0(arg1, &data_2584eb0, arg2, arg3)
0040f666  
0040f695  for (int32_t* i = nullptr; i s< 0xa0; )
0040f67a      int32_t eax_1 = sub_40ff30(*(i + data_2584eb0))
0040f685      i = &i[1]
0040f691      *(i + data_2584eb0 - 4) = eax_1
0040f691  
0040f69d  int32_t eax_2 = *data_2584eb0
0040f69d  
0040f6ab  if (eax_2 != 0x50534249 && eax_2 != 0x50534252)
0040f6ad      int32_t var_c_2 = arg1
0040f6b3      sub_40f970("%s is not a IBSP file")
0040f6b3  
0040f6c0  int32_t eax_4 = *(data_2584eb0 + 4)
0040f6c0  
0040f6cb  if (eax_4 != 0x29 && eax_4 != 1)
0040f6cd      int32_t var_c_3 = 0x26
0040f6cf      int32_t var_10_1 = eax_4
0040f6d0      int32_t var_14_1 = arg1
0040f6d6      sub_40f970("%s is version %i, not %i")
0040f6d6  
0040f6ee  int32_t eax_5 = sub_40f5d0(0xd, data_255ee34, 0x30, 0x400)
0040f6f3  int32_t edx_3 = data_255ede4
0040f703  data_255ee10 = eax_5
0040f70d  data_255edb4 = sub_40f5d0(2, edx_3, 0xc, 0x10000)
0040f721  int32_t eax_8 = sub_40f5d0(1, data_255edac, 0x14, 0x10000)
0040f726  int32_t ecx_3 = data_255ee08
0040f736  data_255ee3c = eax_8
0040f73b  int32_t eax_9 = sub_40f5d0(8, ecx_3, 0x1c, 0x10000)
0040f740  int32_t edx_4 = data_255ee2c
0040f749  data_255edd8 = eax_9
0040f75d  data_255edfc = sub_40f5d0(4, edx_4, 0x1c, 0x10000)
0040f774  int32_t eax_12 = sub_40f5d0(5, data_255edb0, 0xb4, 0x2000)
0040f779  int32_t ecx_4 = data_255ede0
0040f789  data_255ee1c = eax_12
0040f78e  int32_t eax_13 = sub_40f5d0(6, ecx_4, 0x24, 0x10000)
0040f793  int32_t edx_5 = data_255edc4
0040f7a3  data_255edf4 = eax_13
0040f7b0  data_255ee00 = sub_40f5d0(9, edx_5, 2, 0x10000)
0040f7c4  int32_t eax_16 = sub_40f5d0(0xa, data_255ee28, 2, 0x10000)
0040f7c9  int32_t ecx_5 = data_255ee14
0040f7d9  data_255edbc = eax_16
0040f7de  int32_t eax_17 = sub_40f5d0(0xc, ecx_5, 4, 0x3e800)
0040f7e3  int32_t edx_6 = data_255eddc
0040f7f3  data_255edc0 = eax_17
0040f802  data_255edf0 = sub_40f5d0(0xb, edx_6, 4, 0x1f400)
0040f811  int32_t eax_20 = sub_40f5d0(0xe, data_255ee0c, 0xc, 0x2000)
0040f816  int32_t ecx_6 = data_255ee38
0040f81f  data_255edd4 = eax_20
0040f82e  int32_t eax_21 = sub_40f5d0(0xf, ecx_6, 8, 0x10000)
0040f833  int32_t edx_7 = data_255edf8
0040f843  data_255edb8 = eax_21
0040f84d  data_255ede8 = sub_40f5d0(0x11, edx_7, 8, 0x100)
0040f861  int32_t eax_24 = sub_40f5d0(0x12, data_255eda8, 8, 0x400)
0040f866  int32_t ecx_7 = data_255ee04
0040f876  data_255edcc = eax_24
0040f87b  int32_t eax_25 = sub_40f5d0(0x13, ecx_7, 0x3c, 0x2000)
0040f880  int32_t edx_8 = data_255ee20
0040f889  data_255ee18 = eax_25
0040f89d  data_255edc8 = sub_40f5d0(3, edx_8, 1, 0x280000)
0040f8b1  int32_t eax_28 = sub_40f5d0(7, data_255edec, 1, 0x300000)
0040f8b6  int32_t ecx_8 = data_255ee30
0040f8c6  data_255ee40 = eax_28
0040f8de  data_255ee24 = sub_40f5d0(0, ecx_8, 1, 0x40000)
0040f8e3  sub_40f5d0(0x10, &data_2584f00, 1, 0x100)
0040f8f2  sub_41e29e(data_2584eb0)
0040f903  return sub_40ecd0(0)

0040f904              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0040f910    int32_t sub_40f910()

0040f910  void* eax_3 = data_255ee24
0040f915  int32_t ecx = data_255ee30
0040f923  data_2584ecc = 0
0040f92d  void* eax = sub_414130(ecx, eax_3, "*sin bsp file")
0040f937  sub_414010(eax, 0xc)
0040f937  
0040f947  if (sub_40e2a0(eax) != 0)
0040f954      int32_t i
0040f954      
0040f954      do
0040f94a          i = sub_40e2a0(eax)
0040f954      while (i != 0)
0040f954  
0040f960  return sub_4105e0(eax)

0040f961     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0040f970    int32_t sub_40f970(void* arg1)

0040f988  void var_400
0040f988  void arg_8
0040f988  sub_41e690(&var_400, arg1, &arg_8)
0040f991  void* var_410 = &var_400
0040f997  sub_41dc50("ERROR: %s\n")
0040f9a1  sub_410080(&var_400)
0040f9a9  sub_40ffd0()
0040f9b0  sub_41e313(1)
0040f9bf  return sub_40f9c0(var_400) __tailcall


0040f9c0    int32_t* sub_40f9c0(void* arg1)

0040f9d8  void var_400
0040f9d8  void arg_8
0040f9d8  sub_41e690(&var_400, arg1, &arg_8)
0040f9e1  void* var_410 = &var_400
0040f9e7  sub_41dc50("WARNING: %s\n")
0040f9fc  return sub_410080(&var_400)

0040f9fd                                                                                         90 90 90                               ...

0040fa00    int32_t sub_40fa00(void* arg1)

0040fa00  int32_t result = data_42ce60
0040fa00  
0040fa07  if (result == 0)
0040fa1b      return result
0040fa1b  
0040fa13  void arg_8
0040fa13  return sub_41e6e1(arg1, &arg_8)

0040fa1c                                                                                      90 90 90 90                              ....

0040fa20    int32_t sub_40fa20(char* arg1)

0040fa22  char* edi = arg1
0040fa26  char eax = *edi
0040fa26  
0040fa34  if (eax == 0x2f || eax == 0x5c || edi[1] == 0x3a)
0040fa73      int32_t i = 0xffffffff
0040fa73      
0040fa78      while (i != 0)
0040fa78          bool cond:0_1 = 0 != *edi
0040fa78          edi = &edi[1]
0040fa78          i -= 1
0040fa78          
0040fa78          if (not(cond:0_1))
0040fa78              break
0040fa78      
0040fa7a      int32_t ecx_5 = not.d(i)
0040fa8a      int32_t esi_3
0040fa8a      int32_t edi_6
0040fa8a      edi_6, esi_3 =
0040fa8a          __builtin_memcpy(dest: &data_430350, src: edi - ecx_5, n: ecx_5 u>> 2 << 2)
0040fa96      __builtin_memcpy(dest: edi_6, src: esi_3, n: ecx_5 & 3)
0040fa9a      return &data_430350
0040fa9a  
0040fa3b  sub_40fb00(&data_430350)
0040fa40  int32_t i_1 = 0xffffffff
0040fa40  
0040fa48  while (i_1 != 0)
0040fa48      bool cond:1_1 = 0 != *edi
0040fa48      edi = &edi[1]
0040fa48      i_1 -= 1
0040fa48      
0040fa48      if (not(cond:1_1))
0040fa48          break
0040fa48  
0040fa4a  int32_t ecx = not.d(i_1)
0040fa52  void* edi_2 = &data_430350
0040fa57  int32_t i_2 = 0xffffffff
0040fa57  
0040fa5a  while (i_2 != 0)
0040fa5a      bool cond:2_1 = 0 != *edi_2
0040fa5a      edi_2 += 1
0040fa5a      i_2 -= 1
0040fa5a      
0040fa5a      if (not(cond:2_1))
0040fa5a          break
0040fa5a  
0040fa62  int32_t esi_1
0040fa62  int32_t edi_4
0040fa62  edi_4, esi_1 = __builtin_memcpy(dest: edi_2 - 1, src: edi - ecx, n: ecx u>> 2 << 2)
0040fa6e  __builtin_memcpy(dest: edi_4, src: esi_1, n: ecx & 3)
0040fa72  return &data_430350

0040fa9b                                                                                   90 90 90 90 90                             .....

0040faa0    void* sub_40faa0(int32_t arg1)

0040faa6  int32_t edi = arg1
0040faa8  int32_t i = 0xffffffff
0040faa8  
0040faad  while (i != 0)
0040faad      bool cond:0_1 = 0 != *edi
0040faad      edi += 1
0040faad      i -= 1
0040faad      
0040faad      if (not(cond:0_1))
0040faad          break
0040faad  
0040fab2  void* result = sub_4105b0(not.d(i))
0040fab9  int32_t edi_1 = arg1
0040fabb  int32_t i_1 = 0xffffffff
0040fabb  
0040fac3  while (i_1 != 0)
0040fac3      bool cond:1_1 = 0 != *edi_1
0040fac3      edi_1 += 1
0040fac3      i_1 -= 1
0040fac3      
0040fac3      if (not(cond:1_1))
0040fac3          break
0040fac3  
0040fac5  int32_t ecx_1 = not.d(i_1)
0040fad2  int32_t esi_2
0040fad2  int32_t edi_4
0040fad2  edi_4, esi_2 = __builtin_memcpy(dest: result, src: edi_1 - ecx_1, n: ecx_1 u>> 2 << 2)
0040fadb  __builtin_memcpy(dest: edi_4, src: esi_2, n: ecx_1 & 3)
0040fadf  return result


0040fae0    long double __fastcall sub_40fae0(int32_t arg1)

0040fae0  int32_t var_4 = arg1
0040fae6  sub_41e81e(&var_4)
0040faf2  return float.t(var_4)

0040faf3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0040fb00    int32_t sub_40fb00(void* arg1)

0040fb0d  sub_4270d7(arg1, 0x100)
0040fb12  void* edi = &data_42d088
0040fb17  int32_t i = 0xffffffff
0040fb17  
0040fb1f  while (i != 0)
0040fb1f      bool cond:0_1 = 0 != *edi
0040fb1f      edi += 1
0040fb1f      i -= 1
0040fb1f      
0040fb1f      if (not(cond:0_1))
0040fb1f          break
0040fb1f  
0040fb21  int32_t ecx = not.d(i)
0040fb29  void* edi_2 = arg1
0040fb2b  int32_t i_1 = 0xffffffff
0040fb2b  
0040fb2e  while (i_1 != 0)
0040fb2e      bool cond:1_1 = 0 != *edi_2
0040fb2e      edi_2 += 1
0040fb2e      i_1 -= 1
0040fb2e      
0040fb2e      if (not(cond:1_1))
0040fb2e          break
0040fb2e  
0040fb36  int32_t esi_1
0040fb36  int32_t edi_4
0040fb36  edi_4, esi_1 = __builtin_memcpy(dest: edi_2 - 1, src: edi - ecx, n: ecx u>> 2 << 2)
0040fb3d  __builtin_memcpy(dest: edi_4, src: esi_1, n: ecx & 3)
0040fb42  return 0

0040fb43           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0040fb50    int32_t sub_40fb50(char* arg1, char* arg2, int32_t arg3)

0040fb5a  int32_t eax = sx.d(*arg1)
0040fb5d  int32_t ecx = sx.d(*arg2)
0040fb65  void* edx = &arg1[1]
0040fb66  void* esi_1 = &arg2[1]
0040fb69  int32_t i_1 = arg3 - 1
0040fb69  
0040fb6c  if (arg3 != 0)
0040fba1      int32_t i
0040fba1      
0040fba1      do
0040fb70          if (eax != ecx)
0040fb7a              if (eax s>= 0x61 && eax s<= 0x7a)
0040fb7c                  eax -= 0x20
0040fb7c              
0040fb87              if (ecx s>= 0x61 && ecx s<= 0x7a)
0040fb89                  ecx -= 0x20
0040fb89              
0040fb8e              if (eax != ecx)
0040fbaf                  return 0xffffffff
0040fbaf          
0040fb92          if (eax == 0)
0040fb92              break
0040fb92          
0040fb94          eax = sx.d(*edx)
0040fb97          ecx = sx.d(*esi_1)
0040fb9a          edx += 1
0040fb9b          esi_1 += 1
0040fb9c          i = i_1
0040fb9e          i_1 -= 1
0040fba1      while (i != 0)
0040fba1  
0040fba8  return 0


0040fbb0    int32_t sub_40fbb0(char* arg1, char* arg2)

0040fbc7  return sub_40fb50(arg1, arg2, 0x1869f)

0040fbc8                          90 90 90 90 90 90 90 90                                                          ........

0040fbd0    void* sub_40fbd0(int32_t* arg1)

0040fbd8  void* eax = sub_41e085(arg1)
0040fbe4  sub_41de4f(arg1, nullptr, FILE_END)
0040fbea  void* result = sub_41e085(arg1)
0040fbf5  sub_41de4f(arg1, eax, FILE_BEGIN)
0040fc02  return result

0040fc03           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0040fc10    int32_t* sub_40fc10(int32_t arg1)

0040fc1c  int32_t* result = sub_41df39(arg1, "wb")
0040fc1c  
0040fc28  if (result == 0)
0040fc37      void* var_10_1 = sub_41e8fa(*sub_41e9bd())
0040fc38      int32_t var_14_1 = arg1
0040fc3e      sub_40f970("Error opening %s: %s")
0040fc3e  
0040fc4a  return result

0040fc4b                                   90 90 90 90 90                                                             .....

0040fc50    int32_t* sub_40fc50(int32_t arg1)

0040fc5c  int32_t* result = sub_41df39(arg1, "rb")
0040fc5c  
0040fc68  if (result == 0)
0040fc77      void* var_10_1 = sub_41e8fa(*sub_41e9bd())
0040fc78      int32_t var_14_1 = arg1
0040fc7e      sub_40f970("Error opening %s: %s")
0040fc7e  
0040fc8a  return result

0040fc8b                                   90 90 90 90 90                                                             .....

0040fc90    uint32_t sub_40fc90(int32_t* arg1, void* arg2, uint32_t arg3)

0040fca2  uint32_t result = sub_41dcbb(arg2, 1, arg3, arg1)
0040fca2  
0040fcad  if (result != arg3)
0040fcb4      result = sub_40f970("File read failure")
0040fcb4  
0040fcba  return result

0040fcbb                                                                                   90 90 90 90 90                             .....

0040fcc0    uint32_t sub_40fcc0(int32_t* arg1, char* arg2, uint32_t arg3)

0040fcd2  uint32_t result = sub_41df4c(arg2, 1, arg3, arg1)
0040fcd2  
0040fcdd  if (result != arg3)
0040fce4      result = sub_40f970("File write failure")
0040fce4  
0040fcea  return result

0040fceb                                   90 90 90 90 90                                                             .....

0040fcf0    void* sub_40fcf0(int32_t arg1, char** arg2, void* arg3, void* arg4)

0040fcf8  int32_t* eax = sub_40fc50(arg1)
0040fd07  sub_41de4f(eax, arg3, FILE_BEGIN)
0040fd0c  void* result = arg4
0040fd0c  
0040fd15  if (result == 0)
0040fd20      result = sub_40fbd0(eax)
0040fd20  
0040fd2b  char* edi = sub_4105b0(result + 1)
0040fd30  *(edi + result) = 0
0040fd34  sub_40fc90(eax, edi, result)
0040fd3a  sub_41ddd2(eax)
0040fd46  *arg2 = edi
0040fd4d  return result

0040fd4e                                            90 90                                                                ..

0040fd50    void* sub_40fd50(int32_t arg1, int32_t* arg2)

0040fd60  *arg2 = 0
0040fd67  int32_t* eax = sub_41df39(arg1, "rb")
0040fd67  
0040fd73  if (eax == 0)
0040fd7a      return 0xffffffff
0040fd7a  
0040fd7e  void* result = sub_40fbd0(eax)
0040fd89  void* eax_2 = sub_4105b0(result + 1)
0040fd93  *(eax_2 + result) = 0
0040fd97  sub_40fc90(eax, eax_2, result)
0040fd9d  sub_41ddd2(eax)
0040fda7  *arg2 = eax_2
0040fdae  return result

0040fdaf                                               90                                                                 .

0040fdb0    void* sub_40fdb0(int32_t arg1, int32_t arg2)

0040fdb5  int32_t edi = arg1
0040fdb7  int32_t i = 0xffffffff
0040fdb7  
0040fdbc  while (i != 0)
0040fdbc      bool cond:0_1 = 0 != *edi
0040fdbc      edi += 1
0040fdbc      i -= 1
0040fdbc      
0040fdbc      if (not(cond:0_1))
0040fdbc          break
0040fdbc  
0040fdc1  void* result = not.d(i) - 1 + arg1 - 1
0040fdc5  int32_t ecx_1
0040fdc5  ecx_1.b = *(not.d(i) - 1 + arg1 - 1)
0040fdc5  
0040fdcc  if (ecx_1.b != 0x2f)
0040fdd0      while (result != arg1)
0040fdd5          if (ecx_1.b == 0x2e)
0040fe0e              return result
0040fe0e          
0040fdd7          ecx_1.b = *(result - 1)
0040fdda          result -= 1
0040fdda          
0040fdde          if (ecx_1.b == 0x2f)
0040fdde              break
0040fdde  
0040fde0  int32_t edi_1 = arg2
0040fde4  int32_t i_1 = 0xffffffff
0040fde4  
0040fdea  while (i_1 != 0)
0040fdea      bool cond:1_1 = 0 != *edi_1
0040fdea      edi_1 += 1
0040fdea      i_1 -= 1
0040fdea      
0040fdea      if (not(cond:1_1))
0040fdea          break
0040fdea  
0040fdec  int32_t ecx_2 = not.d(i_1)
0040fdf5  int32_t edi_3 = arg1
0040fdf7  int32_t i_2 = 0xffffffff
0040fdf7  
0040fdfa  while (i_2 != 0)
0040fdfa      bool cond:2_1 = 0 != *edi_3
0040fdfa      edi_3 += 1
0040fdfa      i_2 -= 1
0040fdfa      
0040fdfa      if (not(cond:2_1))
0040fdfa          break
0040fdfa  
0040fe02  int32_t esi_2
0040fe02  int32_t edi_5
0040fe02  edi_5, esi_2 = __builtin_memcpy(dest: edi_3 - 1, src: edi_1 - ecx_2, n: ecx_2 u>> 2 << 2)
0040fe09  __builtin_memcpy(dest: edi_5, src: esi_2, n: ecx_2 & 3)
0040fe0e  return nullptr

0040fe0f                                               90                                                                 .

0040fe10    int32_t sub_40fe10(int32_t arg1)

0040fe15  int32_t edi = arg1
0040fe17  int32_t i = 0xffffffff
0040fe1a  char i_1 = 0
0040fe1a  
0040fe1c  while (i != 0)
0040fe1c      bool cond:0_1 = 0 != *edi
0040fe1c      edi += 1
0040fe1c      i -= 1
0040fe1c      
0040fe1c      if (not(cond:0_1))
0040fe1c          break
0040fe1c  
0040fe20  char* ecx_1 = not.d(i) - 2
0040fe24  bool cond:1 = ecx_1 == 0
0040fe24  
0040fe26  if (ecx_1 s> 0)
0040fe28      i_1 = ecx_1[arg1]
0040fe28      
0040fe2d      while (i_1 != 0x2e)
0040fe2f          i_1 = ecx_1[arg1 - 1]
0040fe33          ecx_1 -= 1
0040fe33          
0040fe36          if (i_1 == 0x2f)
0040fe44              return i_1
0040fe44          
0040fe3a          if (ecx_1 s<= 0)
0040fe3a              break
0040fe3a      
0040fe3c      cond:1 = ecx_1 == 0
0040fe3c  
0040fe3e  if (not(cond:1))
0040fe40      ecx_1[arg1] = 0
0040fe40  
0040fe44  return i_1

0040fe45                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040fe50    char* sub_40fe50(int32_t arg1, char* arg2)

0040fe55  int32_t edi = arg1
0040fe57  int32_t i = 0xffffffff
0040fe57  
0040fe5c  while (i != 0)
0040fe5c      bool cond:0_1 = 0 != *edi
0040fe5c      edi += 1
0040fe5c      i -= 1
0040fe5c      
0040fe5c      if (not(cond:0_1))
0040fe5c          break
0040fe5c  
0040fe68  void* i_1
0040fe68  int32_t ecx_1
0040fe68  
0040fe68  for (i_1 = not.d(i) - 1 + arg1 - 1; i_1 != arg1; i_1 -= 1)
0040fe6a      ecx_1.b = *(i_1 - 1)
0040fe6a      
0040fe70      if (ecx_1.b == 0x5c)
0040fe70          break
0040fe70      
0040fe75      if (ecx_1.b == 0x2f)
0040fe75          break
0040fe75  
0040fe7c  ecx_1.b = *i_1
0040fe7c  
0040fe80  if (ecx_1.b == 0)
0040fe9e      *arg2 = 0
0040fea1      return arg2
0040fea1  
0040fe82  char* edx = arg2
0040fe82  
0040fe89  while (ecx_1.b != 0x2e)
0040fe8b      *edx = ecx_1.b
0040fe8d      ecx_1.b = *(i_1 + 1)
0040fe90      edx = &edx[1]
0040fe91      i_1 += 1
0040fe91      
0040fe94      if (ecx_1.b == 0)
0040fe94          break
0040fe94  
0040fe96  *edx = 0
0040fe99  return i_1

0040fea2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0040feb0    char* sub_40feb0(int32_t arg1, char* arg2)

0040feb5  int32_t edi = arg1
0040feb7  int32_t i = 0xffffffff
0040feb7  
0040febc  while (i != 0)
0040febc      bool cond:0_1 = 0 != *edi
0040febc      edi += 1
0040febc      i -= 1
0040febc      
0040febc      if (not(cond:0_1))
0040febc          break
0040febc  
0040fec1  void* edi_1 = not.d(i) - 1 + arg1 - 1
0040fec1  
0040fec7  if (edi_1 != arg1)
0040fece      while (*(edi_1 - 1) != 0x2e)
0040fed0          edi_1 -= 1
0040fed0          
0040fed3          if (edi_1 == arg1)
0040feda              *arg2 = 0
0040fedd              return arg2
0040fedd      
0040fee0      if (edi_1 != arg1)
0040feeb          int32_t i_1 = 0xffffffff
0040feeb          
0040fef0          while (i_1 != 0)
0040fef0              bool cond:1_1 = 0 != *edi_1
0040fef0              edi_1 += 1
0040fef0              i_1 -= 1
0040fef0              
0040fef0              if (not(cond:1_1))
0040fef0                  break
0040fef0          
0040fef2          int32_t ecx_2 = not.d(i_1)
0040ff02          int32_t esi_1
0040ff02          int32_t edi_4
0040ff02          edi_4, esi_1 =
0040ff02              __builtin_memcpy(dest: arg2, src: edi_1 - ecx_2, n: ecx_2 u>> 2 << 2)
0040ff09          __builtin_memcpy(dest: edi_4, src: esi_1, n: ecx_2 & 3)
0040ff0d          return 0
0040ff0d  
0040fee7  *arg2 = 0
0040feea  return arg2

0040ff0e                                            90 90                                                                ..

0040ff10    int32_t sub_40ff10(int16_t arg1) __pure

0040ff10  int32_t result
0040ff10  result.w = arg1
0040ff15  return result

0040ff16                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0040ff20    long double sub_40ff20(float arg1) __pure

0040ff24  return fconvert.t(arg1)

0040ff25                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0040ff30    int32_t sub_40ff30(int32_t arg1) __pure

0040ff34  return arg1

0040ff35                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0040ff40    int32_t sub_40ff40(char* arg1)

0040ff47  if (arg1 != 0)
0040ff4a      char* edi_1 = arg1
0040ff4c      int32_t i = 0xffffffff
0040ff4c      
0040ff51      while (i != 0)
0040ff51          bool cond:0_1 = 0 != *edi_1
0040ff51          edi_1 = &edi_1[1]
0040ff51          i -= 1
0040ff51          
0040ff51          if (not(cond:0_1))
0040ff51              break
0040ff51      
0040ff57      if (not.d(i) != 1)
0040ff60          if (data_255e980 != 0)
0040ff62              void* __saved_edi = &data_255e580
0040ff75              return sub_41dc50("log file %s is already opened\n")
0040ff75          
0040ff7c          int32_t* eax_2 = sub_41df39(arg1, "wb")
0040ff84          data_255e980 = eax_2
0040ff84          
0040ff8b          if (eax_2 == 0)
0040ff8d              char* __saved_edi_1 = arg1
0040ff9c              return sub_41dc50("can't open the log file %s\n")
0040ff9c          
0040ffa8          sub_41e720(&data_255e580, arg1, 0x400)
0040ffad          void* var_14 = &data_255e580
0040ffc0          return sub_41dc50("Opened log %s\n")
0040ffc0  
0040ffcf  return sub_41dc50("openlog <filename>\n")


0040ffd0    int32_t sub_40ffd0()

0040ffd0  int32_t* eax_4 = data_255e980
0040ffd0  
0040ffd7  if (eax_4 == 0)
0040ffe6      return sub_41dc50("no log file to close\n")
0040ffe6  
0040fff2  if (sub_41ddd2(eax_4) != 0)
0040fff4      void* var_4_1 = &data_255e580
00410006      return sub_41dc50("can't close log file %s\n")
00410006  
00410007  void* var_4_2 = &data_255e580
00410011  data_255e980 = 0
00410023  return sub_41dc50("Closed log %s\n")

00410024              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00410030    int32_t* sub_410030(void* arg1)

00410037  void arg_8
00410037  
00410037  if (data_42ce60 != 0)
00410043      sub_41e6e1(arg1, &arg_8)
00410043  
0041004b  int32_t* result = data_255e980
0041004b  
00410052  if (result == 0)
00410073      return result
00410073  
0041005f  sub_41edaa(result, arg1, &arg_8)
0041006b  return sub_41ec44(data_255e980)

00410074                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00410080    int32_t* sub_410080(void* arg1)

00410080  int32_t* result = data_255e980
00410080  
00410087  if (result == 0)
004100b8      return result
004100b8  
00410094  void arg_8
00410094  sub_41edaa(result, arg1, &arg_8)
004100a4  sub_41e4d9(data_255e980, &data_42d174)
004100b0  return sub_41ec44(data_255e980)

004100b9                                                                             90 90 90 90 90 90 90                           .......

004100c0    float* sub_4100c0(float* arg1, float* arg2, float* arg3)

004100e0  *arg3 = fconvert.s(fconvert.t(*arg1) * fconvert.t(*arg2)
004100e0      + fconvert.t(arg1[1]) * fconvert.t(arg2[3])
004100e0      + fconvert.t(arg2[6]) * fconvert.t(arg1[2]))
004100f7  arg3[1] = fconvert.s(fconvert.t(arg1[1]) * fconvert.t(arg2[4])
004100f7      + fconvert.t(arg2[7]) * fconvert.t(arg1[2])
004100f7      + fconvert.t(arg2[1]) * fconvert.t(*arg1))
0041010f  arg3[2] = fconvert.s(fconvert.t(arg1[1]) * fconvert.t(arg2[5])
0041010f      + fconvert.t(arg2[8]) * fconvert.t(arg1[2])
0041010f      + fconvert.t(arg2[2]) * fconvert.t(*arg1))
00410127  arg3[3] = fconvert.s(fconvert.t(arg1[4]) * fconvert.t(arg2[3])
00410127      + fconvert.t(arg1[3]) * fconvert.t(*arg2)
00410127      + fconvert.t(arg1[5]) * fconvert.t(arg2[6]))
00410140  arg3[4] = fconvert.s(fconvert.t(arg1[5]) * fconvert.t(arg2[7])
00410140      + fconvert.t(arg1[4]) * fconvert.t(arg2[4])
00410140      + fconvert.t(arg1[3]) * fconvert.t(arg2[1]))
00410159  arg3[5] = fconvert.s(fconvert.t(arg1[5]) * fconvert.t(arg2[8])
00410159      + fconvert.t(arg1[4]) * fconvert.t(arg2[5])
00410159      + fconvert.t(arg1[3]) * fconvert.t(arg2[2]))
00410171  arg3[6] = fconvert.s(fconvert.t(arg1[6]) * fconvert.t(*arg2)
00410171      + fconvert.t(arg2[6]) * fconvert.t(arg1[8])
00410171      + fconvert.t(arg1[7]) * fconvert.t(arg2[3]))
0041018a  arg3[7] = fconvert.s(fconvert.t(arg2[7]) * fconvert.t(arg1[8])
0041018a      + fconvert.t(arg2[4]) * fconvert.t(arg1[7])
0041018a      + fconvert.t(arg2[1]) * fconvert.t(arg1[6]))
004101a3  arg3[8] = fconvert.s(fconvert.t(arg2[8]) * fconvert.t(arg1[8])
004101a3      + fconvert.t(arg2[5]) * fconvert.t(arg1[7])
004101a3      + fconvert.t(arg2[2]) * fconvert.t(arg1[6]))
004101a6  return arg1

004101a7                       90 90 90 90 90 90 90 90 90                                                         .........

004101b0    float* sub_4101b0(float* arg1, float* arg2)

004101b8  long double x87_r7 = fconvert.t(*arg1)
004101ba  long double x87_r6 = fconvert.t(arg1[1])
004101bd  long double x87_r5 = fconvert.t(arg1[2])
004101d2  *arg1 = fconvert.s(x87_r5 * fconvert.t(arg2[2]) + x87_r6 * fconvert.t(arg2[1])
004101d2      + x87_r7 * fconvert.t(*arg2))
004101e7  arg1[1] = fconvert.s(x87_r5 * fconvert.t(arg2[5]) + x87_r6 * fconvert.t(arg2[4])
004101e7      + x87_r7 * fconvert.t(arg2[3]))
004101fb  arg1[2] = fconvert.s(x87_r5 * fconvert.t(arg2[8]) + x87_r6 * fconvert.t(arg2[7])
004101fb      + x87_r7 * fconvert.t(arg2[6]))
004101fe  return arg2

004101ff                                                                                               90                                 .

00410200    float* sub_410200(float arg1, float* arg2)

00410204  float* esi = arg1
0041020c  int32_t var_64 = 0
00410217  long double x87_r7_1 = fconvert.t(esi[1]) * fconvert.t(0.017453292519943295)
0041021e  int32_t var_58 = 0
00410226  int32_t var_54 = 0
0041022e  int32_t var_50 = 0
00410238  long double st0
00410238  bool c2
00410238  st0, c2 = __fsin(x87_r7_1)
0041023a  int32_t var_4c = 0x3f800000
00410242  int32_t var_44 = 0
0041024a  int32_t var_3c = 0
00410252  int32_t var_38 = 0x3f800000
0041025a  int32_t var_34 = 0
00410262  int32_t var_2c = 0
0041026a  arg1 = fconvert.s(st0)
00410272  long double st0_1
00410272  bool c2_1
00410272  st0_1, c2_1 = __fcos(x87_r7_1)
00410274  float var_68 = arg1
0041027d  float var_6c = fconvert.s(st0_1)
00410287  float var_60 = fconvert.s(fneg(fconvert.t(arg1)))
0041028b  float var_5c = fconvert.s(st0_1)
00410291  long double x87_r7_4 = fconvert.t(*esi) * fconvert.t(0.017453292519943295)
0041029b  long double st0_2
0041029b  bool c2_2
0041029b  st0_2, c2_2 = __fsin(x87_r7_4)
004102a1  long double st0_3
004102a1  bool c2_3
004102a1  st0_3, c2_3 = __fcos(fconvert.t(fconvert.s(x87_r7_4)))
004102a7  float var_48 = fconvert.s(st0_3)
004102b3  float var_40 = fconvert.s(fneg(st0_2))
004102b7  float var_28 = fconvert.s(st0_3)
004102bf  float var_30 = fconvert.s(st0_2)
004102c4  float var_24[0x9]
004102c4  sub_4100c0(&var_48, &var_6c, &var_24)
004102cc  long double x87_r7_7 = fconvert.t(esi[2]) * fconvert.t(0.017453292519943295)
004102e1  long double st0_4
004102e1  bool c2_4
004102e1  st0_4, c2_4 = __fsin(x87_r7_7)
004102e3  var_6c = 1f
004102eb  int32_t var_68_1 = 0
004102f3  int32_t var_64_1 = 0
004102fb  int32_t var_60_1 = 0
00410303  int32_t var_54_1 = 0
0041030b  arg1 = fconvert.s(st0_4)
00410319  long double st0_5
00410319  bool c2_5
00410319  st0_5, c2_5 = __fcos(x87_r7_7)
0041031b  float var_58_1 = arg1
00410324  float var_5c_1 = fconvert.s(st0_5)
00410331  float var_50_1 = fconvert.s(fneg(fconvert.t(arg1)))
00410335  float var_4c_1 = fconvert.s(st0_5)
00410345  return sub_4100c0(&var_6c, &var_24, arg2)

00410346                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00410350    long double sub_410350(float* arg1)

00410356  float* eax = arg1
0041035a  int32_t i_1 = 3
0041036d  long double x87_r6_1
0041036d  int32_t i
0041036d  
0041036d  do
0041035f      x87_r6_1 = fconvert.t(*eax)
00410365      eax = &eax[1]
00410368      i = i_1
00410368      i_1 -= 1
0041036d  while (i != 1)
00410371  return sqrt(x87_r6_1)

00410372                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00410380    int32_t sub_410380(int32_t arg1, float* arg2)

00410380  float* ecx = arg2
00410389  int32_t i = 0
0041038b  float* esi_1 = arg1 - ecx
0041038b  
004103a8  do
00410392      long double x87_r7_3 = fabs(fconvert.t(*(esi_1 + ecx)) - fconvert.t(*ecx))
00410394      long double temp0_1 = fconvert.t(0.001)
00410394      x87_r7_3 - temp0_1
00410394      
0041039f      if ((((x87_r7_3 < temp0_1 ? 1 : 0) << 8
0041039f              | (is_unordered.t(x87_r7_3, temp0_1) ? 1 : 0) << 0xa
0041039f              | (x87_r7_3 == temp0_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0)
004103b4          return 0
004103b4      
004103a1      i += 1
004103a2      ecx = &ecx[1]
004103a8  while (i s< 3)
004103a8  
004103b0  return 1

004103b5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

004103c0    int80_t sub_4103c0(float arg1)

004103d8  return sub_41ede5(fconvert.d(fconvert.t(arg1) + fconvert.t(0.5)))

004103d9                                                                             90 90 90 90 90 90 90                           .......

004103e0    float* sub_4103e0(float* arg1, double arg2, float* arg3, float* arg4)

004103f4  *arg4 = fconvert.s(fconvert.t(*arg3) * fconvert.t(arg2) + fconvert.t(*arg1))
00410400  arg4[1] = fconvert.s(fconvert.t(arg3[1]) * fconvert.t(arg2) + fconvert.t(arg1[1]))
0041040d  arg4[2] = fconvert.s(fconvert.t(arg3[2]) * fconvert.t(arg2) + fconvert.t(arg1[2]))
00410410  return arg3

00410411                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00410420    float* sub_410420(float* arg1, float* arg2, float* arg3)

0041043a  *arg3 = fconvert.s(fconvert.t(arg2[2]) * fconvert.t(arg1[1])
0041043a      - fconvert.t(arg1[2]) * fconvert.t(arg2[1]))
00410448  arg3[1] = fconvert.s(fconvert.t(arg1[2]) * fconvert.t(*arg2)
00410448      - fconvert.t(*arg1) * fconvert.t(arg2[2]))
00410457  arg3[2] = fconvert.s(fconvert.t(*arg1) * fconvert.t(arg2[1])
00410457      - fconvert.t(*arg2) * fconvert.t(arg1[1]))
0041045a  return arg1

0041045b                                                                                   90 90 90 90 90                             .....

00410460    long double sub_410460(float* arg1, int32_t* arg2)

00410464  arg1[2]
00410467  arg1[1]
0041046a  long double result = fconvert.t(*arg1)
00410484  long double temp0 = fconvert.t(0f)
00410484  result - temp0
00410484  
0041048f  if ((((result < temp0 ? 1 : 0) << 8 | (is_unordered.t(result, temp0) ? 1 : 0) << 0xa
0041048f          | (result == temp0 ? 1 : 0) << 0xe | 0x3800):1.b & 0x40) != 0)
0041049f      arg2[2] = 0
004104a2      arg2[1] = 0
004104a5      *arg2 = 0
004104a7      return fconvert.t(0f)
004104a7  
004104aa  long double x87_r6_3 = fconvert.t(1.0) / result
004104b8  *arg2 = fconvert.s(x87_r6_3 * fconvert.t(*arg1))
004104bf  arg2[1] = fconvert.s(x87_r6_3 * fconvert.t(arg1[1]))
004104c5  arg2[2] = fconvert.s(x87_r6_3 * fconvert.t(arg1[2]))
004104c8  return result

004104c9                             90 90 90 90 90 90 90                                                           .......

004104d0    float* sub_4104d0(float* arg1)

004104d8  *arg1 = fconvert.s(fneg(fconvert.t(*arg1)))
004104df  arg1[1] = fconvert.s(fneg(fconvert.t(arg1[1])))
004104e7  arg1[2] = fconvert.s(fneg(fconvert.t(arg1[2])))
004104ea  return arg1

004104eb                                   90 90 90 90 90                                                             .....

004104f0    int32_t* sub_4104f0(int32_t* arg1, int32_t* arg2)

004104f9  arg1[2] = 0x47c34f80
004104fc  arg1[1] = 0x47c34f80
004104ff  *arg1 = 0x47c34f80
0041050a  arg2[2] = 0xc7c34f80
0041050d  arg2[1] = 0xc7c34f80
00410510  *arg2 = 0xc7c34f80
00410512  return arg2

00410513                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00410520    void sub_410520(int32_t arg1, float* arg2, int32_t arg3)

00410520  float* ecx = arg2
0041052e  float* esi_1 = arg1 - ecx
00410530  float* edx_1 = arg3 - ecx
00410532  int32_t i_1 = 3
0041055a  int32_t i
0041055a  
0041055a  do
00410537      long double x87_r7_1 = fconvert.t(*(esi_1 + ecx))
0041053a      long double temp0_1 = fconvert.t(*ecx)
0041053a      x87_r7_1 - temp0_1
0041053a      
00410541      if ((((x87_r7_1 < temp0_1 ? 1 : 0) << 8
00410541              | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
00410541              | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe | 0x3800):1.b & 1) != 0)
00410543          *ecx = fconvert.s(x87_r7_1)
00410543      
00410545      long double temp1_1 = fconvert.t(*(edx_1 + ecx))
00410545      x87_r7_1 - temp1_1
00410545      
0041054d      if ((((x87_r7_1 < temp1_1 ? 1 : 0) << 8
0041054d              | (is_unordered.t(x87_r7_1, temp1_1) ? 1 : 0) << 0xa
0041054d              | (x87_r7_1 == temp1_1 ? 1 : 0) << 0xe | 0x3800):1.b & 0x41) == 0)
0041054f          *(edx_1 + ecx) = fconvert.s(x87_r7_1)
0041054f      
00410556      ecx = &ecx[1]
00410559      i = i_1
00410559      i_1 -= 1
0041055a  while (i != 1)

0041055f                                                                                               90                                 .

00410560    uint32_t sub_410560(void* arg1)

0041056d  return sub_41eeb4(arg1)

0041056e                                            90 90                                                                ..

00410570    void* sub_410570(int32_t* arg1)

00410577  void* s = sub_41e583(arg1)
00410577  
00410583  if (s == 0)
0041058a      sub_40f970("out of memory")
0041058a  
004105a4  __builtin_memset(s: __builtin_memset(s, c: 0, n: arg1 u>> 2 << 2), c: 0, n: arg1 & 3)
004105aa  return s

004105ab                                   90 90 90 90 90                                                             .....

004105b0    void* sub_4105b0(int32_t* arg1)

004105b6  void* result = sub_41e583(arg1)
004105b6  
004105c2  if (result == 0)
004105c9      sub_40f970("out of memory")
004105c9  
004105d4  return result

004105d5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

004105e0    int32_t sub_4105e0(void* arg1)

004105eb  return sub_41e29e(arg1)

004105ec                                      90 90 90 90                                                              ....

004105f0    int32_t* sub_4105f0(int32_t arg1)

004105fc  uint32_t ecx_1 = arg1 u>> 0x14
004105ff  int32_t esi_2 = arg1 u>> 0xa & 0x3ff
00410605  int32_t* result = arg1 & 0x3ff
0041060b  int32_t* result_1 = result
0041060b  
0041060f  if (ecx_1 == 0)
0041060f      goto label_410630
0041060f  
00410611  uint32_t var_c_1 = ecx_1
00410617  result = sub_410030("%ld MB")
00410617  
00410621  if (esi_2 == 0)
00410621      goto label_410653
00410621  
00410628  result = sub_410030(" and ")
00410630  label_410630:
00410630  
00410632  if (esi_2 == 0)
00410632      goto label_410653
00410632  
00410634  int32_t var_c_2 = esi_2
0041063a  result = sub_410030("%ld KB")
0041063a  
00410644  if (result_1 != 0)
0041064b      result = sub_410030(" and ")
00410653      label_410653:
00410653      
00410655      if (result_1 != 0)
00410657          int32_t* result_2 = result_1
0041065d          return sub_410030("%ld bytes")
0041065d  
00410667  return result

00410668                          90 90 90 90 90 90 90 90                                                          ........

00410670    int32_t tytiNil::()

00410672  data_255e140 = 0
00410677  data_255e560 = 0
0041067c  data_255e144 = 0
00410681  data_255e13c = 0
00410686  data_255e148 = 0
0041068b  data_255e564 = 0
00410690  char result = data_43032c
00410695  data_255e160 = result
0041069a  return result

0041069b                                                                                   90 90 90 90 90                             .....

004106a0    void* sub_4106a0(int32_t arg1)

004106b2  void* s = sub_4105b0(arg1 * 0xc + 4)
004106ce  __builtin_memset(s: __builtin_memset(s, c: 0, n: (arg1 * 0xc + 4) u>> 2 << 2), c: 0, 
004106ce      n: (arg1 * 0xc + 4) & 3)
004106ce  
004106d7  if (data_42db3c == 1)
004106de      int32_t edi_3 = data_255e13c
004106e4      int32_t ecx_4 = data_255e560
004106eb      data_255e144 += 1
004106f7      int32_t eax_4 = data_255e140 + 1
004106fa      data_255e13c = edi_3 + arg1
00410700      data_255e140 = eax_4
00410700      
00410705      if (eax_4 s> ecx_4)
00410707          data_255e560 = eax_4
00410707      
0041070d      uint32_t eax_5 = sub_410560(s)
0041071b      int32_t ecx_6 = data_255e148 + eax_5
00410722      bool cond:1_1 = ecx_6 s<= data_255e564
00410724      data_255e148 = ecx_6
00410724      
0041072a      if (not(cond:1_1))
0041072c          data_255e564 = ecx_6
0041072c  
00410737  return s

00410738                                                                          90 90 90 90 90 90 90 90                          ........

00410740    int32_t sub_410740(int32_t* arg1)

0041074b  if (*arg1 == 0xdeaddead)
00410752      sub_40f970("FreeWinding: freed a freed windi…")
00410752  
00410761  if (data_42db3c == 1)
0041076b      data_255e140 -= 1
00410771      uint32_t eax_1 = sub_410560(arg1)
00410781      data_255e148 -= eax_1
00410781  
00410788  *arg1 = 0xdeaddead
00410797  return sub_41e29e(arg1)

00410798                                                                          90 90 90 90 90 90 90 90                          ........

004107a0    int32_t sub_4107a0()

004107a5  return data_255e148

004107a6                    90 90 90 90 90 90 90 90 90 90                                                        ..........

004107b0    int32_t sub_4107b0()

004107b5  return data_255e564

004107b6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

004107c0    void sub_4107c0(int32_t* arg1)

004107d1  int32_t eax = 0
004107d3  int32_t ebp = 0
004107d5  int32_t var_324 = 0
004107d9  int32_t ebx = *arg1
004107d9  
004107dd  if (ebx s> 0)
004107e7      void* esi_1 = &arg1[2]
004107ea      void var_2fc
004107ea      void* var_320_1 = &var_2fc
004107ea      
004108e2      do
004107f6          int32_t temp1_1 = mods.dp.d(sx.q(ebp + 1), ebx)
004107ff          int32_t temp1_2 = mods.dp.d(sx.q(ebx + ebp - 1), ebx)
00410801          int32_t eax_5 = temp1_1 * 3
00410812          float var_31c = fconvert.s(fconvert.t(arg1[eax_5 + 1]) - fconvert.t(*(esi_1 - 4)))
0041081b          float var_318_1 = fconvert.s(fconvert.t(arg1[eax_5 + 2]) - fconvert.t(*esi_1))
00410825          float var_314_1 =
00410825              fconvert.s(fconvert.t(arg1[temp1_1 * 3 + 3]) - fconvert.t(*(esi_1 + 4)))
0041082c          int32_t eax_7 = temp1_2 * 3
0041083f          float var_310 = fconvert.s(fconvert.t(*(esi_1 - 4)) - fconvert.t(arg1[eax_7 + 1]))
0041084d          float var_30c_1 = fconvert.s(fconvert.t(*esi_1) - fconvert.t(arg1[eax_7 + 2]))
00410857          float var_308_1 =
00410857              fconvert.s(fconvert.t(*(esi_1 + 4)) - fconvert.t(arg1[temp1_2 * 3 + 3]))
0041085b          sub_410460(&var_31c, &var_31c)
0041086c          sub_410460(&var_310, &var_310)
00410890          long double x87_r7_18 = fconvert.t(var_308_1) * fconvert.t(var_314_1)
00410890              + fconvert.t(var_30c_1) * fconvert.t(var_318_1)
00410890              + fconvert.t(var_310) * fconvert.t(var_31c)
00410892          long double temp2_1 = fconvert.t(0.999)
00410892          x87_r7_18 - temp2_1
00410892          
0041089d          if ((((x87_r7_18 < temp2_1 ? 1 : 0) << 8
0041089d                  | (is_unordered.t(x87_r7_18, temp2_1) ? 1 : 0) << 0xa
0041089d                  | (x87_r7_18 == temp2_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
004108a4              if (var_324 s>= 0x40)
004108ab                  sub_40f970("RemoveColinearPoints: MAX_POINTS…")
004108ab              
004108ba              int32_t edx_5 = *esi_1
004108bc              *(var_320_1 - 4) = *(esi_1 - 4)
004108bf              int32_t ecx_5 = *(esi_1 + 4)
004108c2              *var_320_1 = edx_5
004108c8              *(var_320_1 + 4) = ecx_5
004108cf              var_324 += 1
004108d3              var_320_1 += 0xc
004108d3          
004108d7          ebp += 1
004108db          ebx = *arg1
004108dd          esi_1 += 0xc
004108e2      while (ebp s< ebx)
004108e2      
004108e8      eax = var_324
004108e8  
004108ec  int32_t ecx_6 = *arg1
004108ec  
004108f0  if (eax != ecx_6)
004108f9      if (data_42db3c == 1)
00410905          data_255e568 += ecx_6 - eax
00410905      
0041090e      *arg1 = eax
00410910      int32_t ecx_9 = eax * 0xc
0041091f      void var_300
0041091f      int32_t esi_2
0041091f      int32_t edi_2
0041091f      edi_2, esi_2 = __builtin_memcpy(dest: &arg1[1], src: &var_300, n: ecx_9 u>> 2 << 2)
00410926      __builtin_memcpy(dest: edi_2, src: esi_2, n: ecx_9 & 3)

00410933                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

00410940    int32_t sub_410940(int32_t* arg1, float* arg2, float* arg3)

0041094b  int32_t i = *arg1
0041094f  float var_18
0041094f  float var_c
0041094f  
0041094f  if (i s> 0)
00410955      int32_t ecx_1 = 1
0041095a      void* esi_1 = &arg1[2]
0041095a      
004109fa      do
00410963          int32_t temp1_1 = mods.dp.d(sx.q(ecx_1), i)
00410965          int32_t eax_3 = temp1_1 * 3
00410976          var_18 = fconvert.s(fconvert.t(arg1[eax_3 + 1]) - fconvert.t(*(esi_1 - 4)))
00410981          float var_14_1 = fconvert.s(fconvert.t(arg1[eax_3 + 2]) - fconvert.t(*esi_1))
0041098c          int32_t temp1_2 = mods.dp.d(sx.q(ecx_1 + 1), i)
0041098e          float var_10_1 =
0041098e              fconvert.s(fconvert.t(arg1[temp1_1 * 3 + 3]) - fconvert.t(*(esi_1 + 4)))
00410992          int32_t eax_7 = temp1_2 * 3
004109a8          var_c = fconvert.s(fconvert.t(arg1[eax_7 + 1]) - fconvert.t(*(esi_1 - 4)))
004109b1          float var_8_1 = fconvert.s(fconvert.t(arg1[eax_7 + 2]) - fconvert.t(*esi_1))
004109bb          float var_4_1 =
004109bb              fconvert.s(fconvert.t(arg1[temp1_2 * 3 + 3]) - fconvert.t(*(esi_1 + 4)))
004109bf          long double st0_1 = sub_410350(&var_18)
004109c4          long double temp2_1 = fconvert.t(0.5)
004109c4          st0_1 - temp2_1
004109c4          
004109d2          if ((((st0_1 < temp2_1 ? 1 : 0) << 8
004109d2                  | (is_unordered.t(st0_1, temp2_1) ? 1 : 0) << 0xa
004109d2                  | (st0_1 == temp2_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0)
004109d9              long double st0_2 = sub_410350(&var_c)
004109de              long double temp3_1 = fconvert.t(0.5)
004109de              st0_2 - temp3_1
004109de              
004109ec              if ((((st0_2 < temp3_1 ? 1 : 0) << 8
004109ec                      | (is_unordered.t(st0_2, temp3_1) ? 1 : 0) << 0xa
004109ec                      | (st0_2 == temp3_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0)
004109ec                  break
004109ec          
004109ee          i = *arg1
004109f0          ecx_1 += 1
004109f2          esi_1 += 0xc
004109fa      while (ecx_1 - 1 s< i)
004109fa  
00410a0f  sub_410420(&var_c, &var_18, arg2)
00410a16  int32_t result
00410a16  int80_t st0_3
00410a16  st0_3, result = sub_410460(arg2, arg2)
00410a3d  *arg3 = fconvert.s(fconvert.t(arg1[3]) * fconvert.t(arg2[2])
00410a3d      + fconvert.t(arg1[2]) * fconvert.t(arg2[1])
00410a3d      + fconvert.t(arg1[1]) * fconvert.t(*arg2))
00410a42  return result

00410a43           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00410a50    long double sub_410a50(int32_t* arg1)

00410a59  int32_t i = 2
00410a5e  float var_28 = 0f
00410a5e  
00410a68  if (*arg1 s<= 2)
00410afa      return fconvert.t(0f)
00410afa  
00410a6f  void* edi = &arg1[5]
00410a6f  
00410ae4  do
00410a87      float var_18 = fconvert.s(fconvert.t(*(edi - 4)) - fconvert.t(arg1[1]))
00410a90      float var_14_1 = fconvert.s(fconvert.t(*edi) - fconvert.t(arg1[2]))
00410a9a      float var_10_1 = fconvert.s(fconvert.t(*(edi + 4)) - fconvert.t(arg1[3]))
00410aa4      float var_24 = fconvert.s(fconvert.t(*(edi + 8)) - fconvert.t(arg1[1]))
00410aae      float var_20_1 = fconvert.s(fconvert.t(*(edi + 0xc)) - fconvert.t(arg1[2]))
00410ab8      float var_1c_1 = fconvert.s(fconvert.t(*(edi + 0x10)) - fconvert.t(arg1[3]))
00410abc      float var_c
00410abc      sub_410420(&var_18, &var_24, &var_c)
00410ad6      i += 1
00410ad7      edi += 0xc
00410ae0      var_28 = fconvert.s(sub_410350(&var_c) * fconvert.t(0.5) + fconvert.t(var_28))
00410ae4  while (i s< *arg1)
00410ae4  
00410af0  return fconvert.t(var_28)

00410afb                                                                                   90 90 90 90 90                             .....

00410b00    float* sub_410b00(int32_t* arg1, float* arg2)

00410b0f  *arg2 = fconvert.s(fconvert.t(data_430b50))
00410b17  arg2[1] = data_430b54
00410b20  arg2[2] = data_430b58
00410b25  int32_t i = 0
00410b25  
00410b29  if (*arg1 s> 0)
00410b2b      void* ecx_2 = &arg1[2]
00410b2b      
00410b4d      do
00410b31          long double x87_r7_2 = fconvert.t(*(ecx_2 - 4)) + fconvert.t(*arg2)
00410b33          i += 1
00410b34          ecx_2 += 0xc
00410b37          *arg2 = fconvert.s(x87_r7_2)
00410b3f          arg2[1] = fconvert.s(fconvert.t(*(ecx_2 - 0xc)) + fconvert.t(arg2[1]))
00410b48          arg2[2] = fconvert.s(fconvert.t(*(ecx_2 - 8)) + fconvert.t(arg2[2]))
00410b4d      while (i s< *arg1)
00410b4d  
00410b52  long double x87_r7_8 = fconvert.t(1.0) / float.t(*arg1)
00410b5c  *arg2 = fconvert.s(x87_r7_8 * fconvert.t(*arg2))
00410b63  arg2[1] = fconvert.s(x87_r7_8 * fconvert.t(arg2[1]))
00410b69  arg2[2] = fconvert.s(x87_r7_8 * fconvert.t(arg2[2]))
00410b6c  return arg2

00410b6d                                         90 90 90                                                               ...

00410b70    int80_t sub_410b70(float* arg1, float arg2)

00410b79  int32_t i_1 = 0xffffffff
00410b7c  float var_28 = -8192f
00410b84  int32_t i = 0
00410b86  float* edx = arg1
00410b86  
00410ba8  do
00410b8a      long double x87_r7_2 = fabs(fconvert.t(*edx))
00410b8c      long double temp0_1 = fconvert.t(var_28)
00410b8c      x87_r7_2 - temp0_1
00410b8c      
00410b95      if ((((x87_r7_2 < temp0_1 ? 1 : 0) << 8
00410b95              | (is_unordered.t(x87_r7_2, temp0_1) ? 1 : 0) << 0xa
00410b95              | (x87_r7_2 == temp0_1 ? 1 : 0) << 0xe | 0x3800):1.b & 0x41) == 0)
00410b97          var_28 = fconvert.s(x87_r7_2)
00410b9b          i_1 = i
00410b9b      
00410ba1      i += 1
00410ba2      edx = &edx[1]
00410ba8  while (i s< 3)
00410ba8  
00410bad  if (i_1 == 0xffffffff)
00410bb4      sub_40f970("BaseWindingForPlane: no axis fou…")
00410bb4  
00410bc1  float ecx = data_430b54
00410bc7  float edx_1 = data_430b58
00410bcd  float var_24 = data_430b50
00410bd7  float var_1c = edx_1
00410bd7  
00410bdb  if (i_1 s>= 0)
00410be0      if (i_1 s<= 1)
00410bf1          var_1c = 1f
00410be0      else if (i_1 == 2)
00410be7          var_24 = 1f
00410be7  
00410c24  sub_4103e0(&var_24, 
00410c24      fconvert.d(fneg(fconvert.t(var_1c) * fconvert.t(arg1[2])
00410c24          + fconvert.t(ecx) * fconvert.t(arg1[1])
00410c24          + fconvert.t(var_24) * fconvert.t(*arg1))), 
00410c24      arg1, &var_24)
00410c33  int80_t result = sub_410460(&var_24, &var_24)
00410c4b  float var_c = fconvert.s(fconvert.t(arg2) * fconvert.t(*arg1))
00410c56  float var_8 = fconvert.s(fconvert.t(arg2) * fconvert.t(arg1[1]))
00410c61  float var_4 = fconvert.s(fconvert.t(arg2) * fconvert.t(arg1[2]))
00410c65  float var_18
00410c65  sub_410420(&var_24, arg1, &var_18)
00410c76  var_24 = fconvert.s(fconvert.t(var_24) * fconvert.t(8192f))
00410c84  float var_20_1 = fconvert.s(fconvert.t(ecx) * fconvert.t(8192f))
00410c92  float var_1c_1 = fconvert.s(fconvert.t(var_1c) * fconvert.t(8192f))
00410ca0  var_18 = fconvert.s(fconvert.t(var_18) * fconvert.t(8192f))
00410cae  float var_14
00410cae  float var_14_1 = fconvert.s(fconvert.t(var_14) * fconvert.t(8192f))
00410cbc  float var_10
00410cbc  float var_10_1 = fconvert.s(fconvert.t(var_10) * fconvert.t(8192f))
00410cc0  void* eax_2 = sub_4106a0(4)
00410cd0  *(eax_2 + 4) = fconvert.s(fconvert.t(var_c) - fconvert.t(var_18))
00410cdb  *(eax_2 + 8) = fconvert.s(fconvert.t(var_8) - fconvert.t(var_14_1))
00410ce6  *(eax_2 + 0xc) = fconvert.s(fconvert.t(var_4) - fconvert.t(var_10_1))
00410cf0  *(eax_2 + 4) = fconvert.s(fconvert.t(var_24) + fconvert.t(*(eax_2 + 4)))
00410cfa  *(eax_2 + 8) = fconvert.s(fconvert.t(var_20_1) + fconvert.t(*(eax_2 + 8)))
00410d04  *(eax_2 + 0xc) = fconvert.s(fconvert.t(var_1c_1) + fconvert.t(*(eax_2 + 0xc)))
00410d0f  *(eax_2 + 0x10) = fconvert.s(fconvert.t(var_18) + fconvert.t(var_c))
00410d1c  *(eax_2 + 0x14) = fconvert.s(fconvert.t(var_14_1) + fconvert.t(var_8))
00410d27  *(eax_2 + 0x18) = fconvert.s(fconvert.t(var_10_1) + fconvert.t(var_4))
00410d31  *(eax_2 + 0x10) = fconvert.s(fconvert.t(var_24) + fconvert.t(*(eax_2 + 0x10)))
00410d3b  *(eax_2 + 0x14) = fconvert.s(fconvert.t(var_20_1) + fconvert.t(*(eax_2 + 0x14)))
00410d45  *(eax_2 + 0x18) = fconvert.s(fconvert.t(var_1c_1) + fconvert.t(*(eax_2 + 0x18)))
00410d50  *(eax_2 + 0x1c) = fconvert.s(fconvert.t(var_18) + fconvert.t(var_c))
00410d5b  *(eax_2 + 0x20) = fconvert.s(fconvert.t(var_14_1) + fconvert.t(var_8))
00410d66  *(eax_2 + 0x24) = fconvert.s(fconvert.t(var_10_1) + fconvert.t(var_4))
00410d70  *(eax_2 + 0x1c) = fconvert.s(fconvert.t(*(eax_2 + 0x1c)) - fconvert.t(var_24))
00410d7a  *(eax_2 + 0x20) = fconvert.s(fconvert.t(*(eax_2 + 0x20)) - fconvert.t(var_20_1))
00410d84  *(eax_2 + 0x24) = fconvert.s(fconvert.t(*(eax_2 + 0x24)) - fconvert.t(var_1c_1))
00410d8f  *(eax_2 + 0x28) = fconvert.s(fconvert.t(var_c) - fconvert.t(var_18))
00410d9a  *(eax_2 + 0x2c) = fconvert.s(fconvert.t(var_8) - fconvert.t(var_14_1))
00410da5  *(eax_2 + 0x30) = fconvert.s(fconvert.t(var_4) - fconvert.t(var_10_1))
00410daf  *(eax_2 + 0x28) = fconvert.s(fconvert.t(*(eax_2 + 0x28)) - fconvert.t(var_24))
00410db9  *(eax_2 + 0x2c) = fconvert.s(fconvert.t(*(eax_2 + 0x2c)) - fconvert.t(var_20_1))
00410dbf  long double x87_r7_74 = fconvert.t(*(eax_2 + 0x30)) - fconvert.t(var_1c_1)
00410dc3  *eax_2 = 4
00410dc9  *(eax_2 + 0x30) = fconvert.s(x87_r7_74)
00410dcf  return result


00410dd0    void* sub_410dd0(int32_t* arg1)

00410dd9  void* result = sub_4106a0(*arg1)
00410dde  int32_t ecx = *arg1
00410df4  int32_t esi_1
00410df4  int32_t edi_1
00410df4  edi_1, esi_1 = __builtin_memcpy(dest: result, src: arg1, n: (ecx * 0xc + 4) u>> 2 << 2)
00410dfb  __builtin_memcpy(dest: edi_1, src: esi_1, n: (ecx * 0xc + 4) & 3)
00410dff  return result


00410e00    void* sub_410e00(int32_t* arg1)

00410e08  void* result = sub_4106a0(*arg1)
00410e0d  int32_t edx = *arg1
00410e12  int32_t ecx = 0
00410e12  
00410e16  if (edx s> 0)
00410e19      void* edi_1 = result + 8
00410e19      
00410e4b      do
00410e1e          edi_1 += 0xc
00410e28          *(edi_1 - 0x10) = arg1[(edx - ecx) * 3 - 2]
00410e36          *(edi_1 - 0xc) = arg1[(*arg1 - ecx) * 3 - 1]
00410e3b          int32_t edx_9 = *arg1 - ecx
00410e3d          ecx += 1
00410e44          *(edi_1 - 8) = arg1[edx_9 * 3]
00410e47          edx = *arg1
00410e4b      while (ecx s< edx)
00410e4b  
00410e51  *result = *arg1
00410e53  return result

00410e54                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00410e60    void sub_410e60(int32_t* arg1, float* arg2, float arg3, float arg4, int32_t* arg5, int32_t* arg6)

00410e6f  int32_t* ebp = arg1
00410e78  int32_t esi = *ebp
00410e7d  int32_t ecx = 0
00410e81  float var_234 = 0f
00410e85  float var_238 = 0f
00410e89  float var_23c = 0f
00410e8d  int32_t var_220
00410e8d  float var_110
00410e8d  
00410e8d  if (esi s> 0)
00410e8f      void* edx_1 = &ebp[2]
00410e8f      
00410f02      do
00410ea6          long double x87_r7_5 = fconvert.t(*(edx_1 - 4)) * fconvert.t(*arg2)
00410ea6              + fconvert.t(*(edx_1 + 4)) * fconvert.t(arg2[2])
00410ea6              + fconvert.t(*edx_1) * fconvert.t(arg2[1]) - fconvert.t(arg3)
00410ead          long double temp2_1 = fconvert.t(arg4)
00410ead          x87_r7_5 - temp2_1
00410eb4          (&var_110)[ecx] = fconvert.s(x87_r7_5)
00410eb4          bool c1_1 = unimplemented  {fst dword [esp+ecx*4+0x13c], st0}
00410eb4          
00410ec0          if ((((x87_r7_5 < temp2_1 ? 1 : 0) << 8 | (c1_1 ? 1 : 0) << 9
00410ec0                  | (is_unordered.t(x87_r7_5, temp2_1) ? 1 : 0) << 0xa
00410ec0                  | (x87_r7_5 == temp2_1 ? 1 : 0) << 0xe | 0x3800):1.b & 0x41) != 0)
00410ed1              long double x87_r6_6 = fneg(fconvert.t(arg4))
00410ed5              x87_r7_5 - x87_r6_6
00410ed5              
00410edc              if ((((x87_r7_5 < x87_r6_6 ? 1 : 0) << 8
00410edc                      | (is_unordered.t(x87_r7_5, x87_r6_6) ? 1 : 0) << 0xa
00410edc                      | (x87_r7_5 == x87_r6_6 ? 1 : 0) << 0xe):1.b & 1) == 0)
00410ee8                  (&var_220)[ecx] = 2
00410edc              else
00410ede                  (&var_220)[ecx] = 1
00410ec0          else
00410ec4              (&var_220)[ecx] = 0
00410ec4          
00410ef0          int32_t eax_1 = (&var_220)[ecx]
00410ef4          edx_1 += 0xc
00410ef7          (&var_23c)[eax_1] += 1
00410eff          ecx += 1
00410f02      while (ecx s< esi)
00410f02  
00410f19  float eax_2 = var_23c
00410f1d  int32_t edx_2 = var_220
00410f21  (&var_110)[ecx] = fconvert.s(fconvert.t(var_110))
00410f28  *arg6 = 0
00410f2c  (&var_220)[ecx] = edx_2
00410f30  *arg5 = 0
00410f30  
00410f32  if (eax_2 == 0)
00410f3d      *arg6 = sub_410dd0(ebp)
00410f49      return 
00410f49  
00410f4e  if (var_238 == 0)
00410f59      *arg5 = sub_410dd0(ebp)
00410f65      return 
00410f65  
00410f69  int32_t edi_1 = *ebp + 4
00410f71  void* eax_5 = sub_4106a0(edi_1)
00410f80  *arg5 = eax_5
00410f82  void* eax_7 = sub_4106a0(edi_1)
00410f8c  *arg6 = eax_7
00410f91  int32_t i = 0
00410f95  int32_t i_1 = 0
00410f95  
00410f99  if (*ebp s> 0)
00410f9f      void* ecx_1 = &ebp[3]
00410f9f      
0041116e      do
00410fa2          int32_t eax_9 = (&var_220)[i]
00410fa2          
00410fa9          if (eax_9 != 2)
00411002              if (eax_9 == 0)
0041100c                  *(eax_5 + *eax_5 * 0xc + 4) = *(ecx_1 - 8)
00411018                  *(eax_5 + *eax_5 * 0xc + 8) = *(ecx_1 - 4)
00411024                  *(eax_5 + (*eax_5 + 1) * 0xc) = *ecx_1
0041102a                  *eax_5 += 1
0041102a              
00411031              if ((&var_220)[i] == 1)
0041103b                  *(eax_7 + *eax_7 * 0xc + 4) = *(ecx_1 - 8)
00411047                  *(eax_7 + *eax_7 * 0xc + 8) = *(ecx_1 - 4)
00411053                  *(eax_7 + (*eax_7 + 1) * 0xc) = *ecx_1
00411059                  *eax_7 += 1
00411059              
0041105b              int32_t var_21c[0x43]
0041105b              int32_t eax_46 = var_21c[i]
0041105b              
0041106c              if (eax_46 != 2 && eax_46 != (&var_220)[i])
00411075                  int32_t var_22c_1 = 3
00411096                  int32_t __saved_edi
00411096                  int32_t var_10c[0x43]
00411096                  long double x87_r7_10 = fconvert.t((&__saved_edi)[i + 0x4f])
00411096                      / (fconvert.t((&var_110)[i]) - fconvert.t(var_10c[i]))
00411098                  float* eax_50 = arg2
004110ac                  void* ebx_3 = &ebp[mods.dp.d(sx.q(i + 1), *ebp) * 3 + 1] - eax_50
004110ae                  int32_t edx_21 = ecx_1 - eax_50 - 8
004110b9                  float* edx_22 = &var_23c - eax_50
004110fd                  bool cond:4_1
004110fd                  
004110fd                  do
004110c1                      long double x87_r6_8
004110c1                      
004110c1                      if (*eax_50 == 0x3f800000)
004110c3                          x87_r6_8 = fconvert.t(arg3)
004110c1                      else if (*eax_50 != 0xbf800000)
004110eb                          x87_r6_8 = (fconvert.t(*(ebx_3 + eax_50))
004110eb                              - fconvert.t(*(eax_50 + edx_21))) * x87_r7_10
004110eb                              + fconvert.t(*(eax_50 + edx_21))
004110d2                      else
004110db                          x87_r6_8 = fneg(fconvert.t(arg3))
004110db                      
004110ee                      *(edx_22 + eax_50) = fconvert.s(x87_r6_8)
004110f5                      eax_50 = &eax_50[1]
004110f8                      cond:4_1 = var_22c_1 != 1
004110f9                      var_22c_1 -= 1
004110fd                  while (cond:4_1)
00411101                  ebp = arg1
00411111                  *(eax_5 + *eax_5 * 0xc + 4) = fconvert.s(fconvert.t(var_23c))
0041111e                  *(eax_5 + *eax_5 * 0xc + 8) = fconvert.s(fconvert.t(var_238))
0041112c                  *(eax_5 + (*eax_5 + 1) * 0xc) = fconvert.s(fconvert.t(var_234))
00411131                  long double x87_r7_14 = fconvert.t(var_23c)
00411136                  *eax_5 += 1
0041113a                  i = i_1
00411141                  *(eax_7 + *eax_7 * 0xc + 4) = fconvert.s(x87_r7_14)
0041114e                  *(eax_7 + *eax_7 * 0xc + 8) = fconvert.s(fconvert.t(var_238))
0041115c                  *(eax_7 + (*eax_7 + 1) * 0xc) = fconvert.s(fconvert.t(var_234))
0041115f                  *eax_7 += 1
00410fa9          else
00410fb3              *(eax_5 + *eax_5 * 0xc + 4) = *(ecx_1 - 8)
00410fbf              *(eax_5 + *eax_5 * 0xc + 8) = *(ecx_1 - 4)
00410fcb              *(eax_5 + (*eax_5 + 1) * 0xc) = *ecx_1
00410fd1              *eax_5 += 1
00410fdb              *(eax_7 + *eax_7 * 0xc + 4) = *(ecx_1 - 8)
00410fe7              *(eax_7 + *eax_7 * 0xc + 8) = *(ecx_1 - 4)
00410ff3              *(eax_7 + (*eax_7 + 1) * 0xc) = *ecx_1
00410ff9              *eax_7 += 1
00410ff9          
00411164          i += 1
00411165          ecx_1 += 0xc
0041116a          i_1 = i
0041116e      while (i s< *ebp)
0041116e  
00411180  if (*eax_5 s> edi_1 || *eax_7 s> edi_1)
00411187      sub_40f970("ClipWinding: points exceeded est…")
00411187  
00411197  if (*eax_5 s> 0x40 || *eax_7 s> 0x40)
0041119e      sub_40f970("ClipWinding: MAX_POINTS_ON_WINDI…")

004111b1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

004111c0    void sub_4111c0(void** arg1, float* arg2, float arg3, float arg4)

004111ca  int32_t* edi = arg1
004111d1  float* ebp = arg2
004111da  int32_t ecx = 0
004111dc  int32_t* ebx = *edi
004111de  float var_230 = 0f
004111e2  int32_t* var_23c = ebx
004111e6  float var_234 = 0f
004111ea  int32_t esi = *ebx
004111ec  float var_238 = 0f
004111f2  int32_t var_220
004111f2  float var_110
004111f2  
004111f2  if (esi s> 0)
004111f4      void* edx_1 = &ebx[2]
004111f4      
0041126c      do
0041120c          long double x87_r7_5 = fconvert.t(*(edx_1 + 4)) * fconvert.t(ebp[2])
0041120c              + fconvert.t(*(edx_1 - 4)) * fconvert.t(*ebp)
0041120c              + fconvert.t(*edx_1) * fconvert.t(ebp[1]) - fconvert.t(arg3)
00411213          long double temp2_1 = fconvert.t(arg4)
00411213          x87_r7_5 - temp2_1
0041121a          (&var_110)[ecx] = fconvert.s(x87_r7_5)
0041121a          bool c1_1 = unimplemented  {fst dword [esp+ecx*4+0x13c], st0}
0041121a          
00411226          if ((((x87_r7_5 < temp2_1 ? 1 : 0) << 8 | (c1_1 ? 1 : 0) << 9
00411226                  | (is_unordered.t(x87_r7_5, temp2_1) ? 1 : 0) << 0xa
00411226                  | (x87_r7_5 == temp2_1 ? 1 : 0) << 0xe | 0x3800):1.b & 0x41) != 0)
0041123b              long double x87_r6_6 = fneg(fconvert.t(arg4))
0041123f              x87_r7_5 - x87_r6_6
0041123f              
00411246              if ((((x87_r7_5 < x87_r6_6 ? 1 : 0) << 8
00411246                      | (is_unordered.t(x87_r7_5, x87_r6_6) ? 1 : 0) << 0xa
00411246                      | (x87_r7_5 == x87_r6_6 ? 1 : 0) << 0xe):1.b & 1) == 0)
00411252                  (&var_220)[ecx] = 2
00411246              else
00411248                  (&var_220)[ecx] = 1
00411226          else
0041122a              (&var_220)[ecx] = 0
0041122a          
0041125a          int32_t eax_2 = (&var_220)[ecx]
0041125e          edx_1 += 0xc
00411261          (&var_238)[eax_2] += 1
00411269          ecx += 1
0041126c      while (ecx s< esi)
0041126c  
00411277  int32_t edx_2 = var_220
0041127b  (&var_110)[ecx] = fconvert.s(fconvert.t(var_110))
00411282  (&var_220)[ecx] = edx_2
00411282  
0041128c  if (var_238 == 0)
0041128f      sub_410740(ebx)
00411297      *edi = 0
004112a7      return 
004112a7  
004112ac  if (var_234 != 0)
004112ba      void* eax_3 = sub_4106a0(esi + 4)
004112c6      int32_t i = 0
004112c6      
004112ca      if (*ebx s> 0)
004112d0          void* ebx_1 = &ebx[3]
004112d0          
0041140f          do
004112d3              int32_t ecx_2 = (&var_220)[i]
004112d3              
004112da              if (ecx_2 != 2)
0041130b                  if (ecx_2 == 0)
00411315                      *(eax_3 + *eax_3 * 0xc + 4) = *(ebx_1 - 8)
00411321                      *(eax_3 + *eax_3 * 0xc + 8) = *(ebx_1 - 4)
0041132d                      *(eax_3 + (*eax_3 + 1) * 0xc) = *ebx_1
00411333                      *eax_3 += 1
00411333                  
00411335                  int32_t var_21c[0x43]
00411335                  int32_t eax_22 = var_21c[i]
00411335                  
00411344                  if (eax_22 != 2 && eax_22 != ecx_2)
00411359                      int32_t temp1_1 = mods.dp.d(sx.q(i + 1), *var_23c)
00411362                      int32_t var_10c[0x43]
00411362                      long double x87_r7_10 = fconvert.t((&var_110)[i])
00411362                          / (fconvert.t((&var_110)[i]) - fconvert.t(var_10c[i]))
00411369                      int32_t var_22c_1 = 3
00411378                      float* eax_26 = ebp
004113d1                      bool cond:0_1
004113d1                      
004113d1                      do
00411395                          long double x87_r6_8
00411395                          
00411395                          if (*eax_26 == 0x3f800000)
00411397                              x87_r6_8 = fconvert.t(arg3)
00411395                          else if (*eax_26 != 0xbf800000)
004113bf                              x87_r6_8 = (
004113bf                                  fconvert.t(*(&var_23c[temp1_1 * 3 + 1] - ebp + eax_26))
004113bf                                  - fconvert.t(*(eax_26 + ebx_1 - ebp - 8))) * x87_r7_10
004113bf                                  + fconvert.t(*(eax_26 + ebx_1 - ebp - 8))
004113a6                          else
004113af                              x87_r6_8 = fneg(fconvert.t(arg3))
004113af                          
004113c2                          *(&var_238 - ebp + eax_26) = fconvert.s(x87_r6_8)
004113c9                          eax_26 = &eax_26[1]
004113cc                          cond:0_1 = var_22c_1 != 1
004113cd                          var_22c_1 -= 1
004113d1                      while (cond:0_1)
004113d5                      ebp = arg2
004113e5                      *(eax_3 + *eax_3 * 0xc + 4) = fconvert.s(fconvert.t(var_238))
004113f2                      *(eax_3 + *eax_3 * 0xc + 8) = fconvert.s(fconvert.t(var_234))
00411400                      *(eax_3 + (*eax_3 + 1) * 0xc) = fconvert.s(fconvert.t(var_230))
00411403                      *eax_3 += 1
004112da              else
004112e4                  *(eax_3 + *eax_3 * 0xc + 4) = *(ebx_1 - 8)
004112f0                  *(eax_3 + *eax_3 * 0xc + 8) = *(ebx_1 - 4)
004112fc                  *(eax_3 + (*eax_3 + 1) * 0xc) = *ebx_1
00411302                  *eax_3 += 1
00411302              
00411409              i += 1
0041140a              ebx_1 += 0xc
0041140f          while (i s< *var_23c)
0041140f          
00411415          ebx = var_23c
00411415      
0041141f      if (*eax_3 s> esi + 4)
00411426          sub_40f970("ClipWinding: points exceeded est…")
00411426      
00411431      if (*eax_3 s> 0x40)
00411438          sub_40f970("ClipWinding: MAX_POINTS_ON_WINDI…")
00411438      
00411441      sub_410740(ebx)
00411450      *arg1 = eax_3

0041145d                                                                                         90 90 90                               ...

00411460    void* sub_411460(int32_t* arg1, int32_t* arg2, float* arg3)

00411469  int32_t* ebp = arg2
0041146d  int32_t eax = *arg1
00411471  int32_t edi = 0
00411473  void* esi = nullptr
00411475  int32_t ebx = 0
00411479  float* var_2c = nullptr
0041147d  int32_t var_28 = 0
00411481  int32_t var_3c = eax
00411481  
00411485  if (eax s> 0)
0041148b      int32_t ecx_1 = *ebp
00411491      int32_t var_24_1 = ecx_1
00411495      void* var_38_1 = &arg1[1]
00411495      
0041157f      do
0041149c          esi = var_38_1
004114a4          ebx = 0
004114bc          var_2c = &arg1[mods.dp.d(sx.q(edi + 1), var_3c) * 3 + 1]
004114bc          
004114c0          if (ecx_1 s> 0)
004114c9              void* var_34_1 = &ebp[1]
004114c9              
004114d6              while (true)
004114d6                  int32_t i = 0
004114db                  int32_t temp1_2 = mods.dp.d(sx.q(ebx + 1), ecx_1)
004114ea                  float* edx_8 = &ebp[temp1_2 * 3 + 1]
004114ec                  int32_t ecx_3 = neg.d(&ebp[temp1_2 * 3 + 1])
004114ec                  
00411534                  do
00411509                      long double x87_r7_3 =
00411509                          fabs(fconvert.t(*(var_38_1 + ecx_3 + edx_8)) - fconvert.t(*edx_8))
0041150b                      long double temp6_1 = fconvert.t(0.10000000000000001)
0041150b                      x87_r7_3 - temp6_1
00411511                      void* eax_9
00411511                      eax_9.w = (x87_r7_3 < temp6_1 ? 1 : 0) << 8
00411511                          | (is_unordered.t(x87_r7_3, temp6_1) ? 1 : 0) << 0xa
00411511                          | (x87_r7_3 == temp6_1 ? 1 : 0) << 0xe
00411511                      
00411516                      if ((eax_9:1.b & 0x41) == 0)
00411516                          break
00411516                      
0041151e                      long double x87_r7_6 = fabs(fconvert.t(*(edx_8 + var_2c + ecx_3))
0041151e                          - fconvert.t(*(var_34_1 - &ebp[temp1_2 * 3 + 1] + edx_8)))
00411520                      long double temp7_1 = fconvert.t(0.10000000000000001)
00411520                      x87_r7_6 - temp7_1
00411526                      eax_9.w = (x87_r7_6 < temp7_1 ? 1 : 0) << 8
00411526                          | (is_unordered.t(x87_r7_6, temp7_1) ? 1 : 0) << 0xa
00411526                          | (x87_r7_6 == temp7_1 ? 1 : 0) << 0xe
00411526                      
0041152b                      if ((eax_9:1.b & 0x41) == 0)
0041152b                          break
0041152b                      
0041152d                      i += 1
0041152e                      edx_8 = &edx_8[1]
00411534                  while (i s< 3)
00411534                  
00411539                  if (i == 3)
00411556                      ecx_1 = var_24_1
00411556                      
0041155c                      if (ebx s>= ecx_1)
0041155c                          goto label_411562
0041155c                      
0041158b                      ebp = arg2
0041158f                      edi = var_28
0041158f                      goto label_411593
0041158f                  
0041153f                  ebx += 1
00411544                  var_34_1 += 0xc
00411548                  ecx_1 = var_24_1
00411548                  
0041154e                  if (ebx s>= ecx_1)
00411562                      label_411562:
00411562                      ebp = arg2
00411562                      break
00411562                  
004114cf                  ebp = arg2
004114cf          
0041156a          edi += 1
00411577          var_28 = edi
0041157b          var_38_1 += 0xc
0041157f      while (edi s< var_3c)
0041157f      
00411593      label_411593:
00411593      eax = var_3c
00411593  
00411599  if (edi == eax)
004115a4      return 0
004115a4  
004115b0  int32_t ecx_8 = mods.dp.d(sx.q(eax + edi - 1), var_3c) * 3
004115c7  float var_18 = fconvert.s(fconvert.t(*esi) - fconvert.t(arg1[ecx_8 + 1]))
004115d1  float var_14 = fconvert.s(fconvert.t(*(esi + 4)) - fconvert.t(arg1[ecx_8 + 2]))
004115e2  float var_10 = fconvert.s(fconvert.t(*(esi + 8)) - fconvert.t(arg1[ecx_8 + 3]))
004115e6  float var_c
004115e6  sub_410420(arg3, &var_18, &var_c)
004115f5  sub_410460(&var_c, &var_c)
00411606  int32_t edx_17 = mods.dp.d(sx.q(ebx + 2), *ebp) * 3
00411613  var_18 = fconvert.s(fconvert.t(ebp[edx_17 + 1]) - fconvert.t(*esi))
0041163b  float var_8
0041163b  float var_4
0041163b  long double x87_r7_22 = fconvert.t(var_4)
0041163b      * fconvert.t(fconvert.s(fconvert.t(ebp[edx_17 + 3]) - fconvert.t(*(esi + 8))))
0041163b      + fconvert.t(var_8)
0041163b      * fconvert.t(fconvert.s(fconvert.t(ebp[edx_17 + 2]) - fconvert.t(*(esi + 4))))
00411645  long double x87_r7_23 = x87_r7_22 + fconvert.t(var_c) * fconvert.t(var_18)
00411647  long double temp2 = fconvert.t(0.0050000000000000001)
00411647  x87_r7_23 - temp2
0041164d  void* eax_17
0041164d  eax_17.w = (x87_r7_23 < temp2 ? 1 : 0) << 8
0041164d      | (is_unordered.t(x87_r7_23, temp2) ? 1 : 0) << 0xa
0041164d      | (x87_r7_23 == temp2 ? 1 : 0) << 0xe | 0x3800
0041164d  
00411652  if ((eax_17:1.b & 0x41) == 0)
0041165f      return 0
0041165f  
00411660  long double temp3 = fconvert.t(-0.0050000000000000001)
00411660  x87_r7_23 - temp3
00411666  int32_t var_24_2 = 1
0041166e  eax_17.w = (x87_r7_23 < temp3 ? 1 : 0) << 8
0041166e      | (is_unordered.t(x87_r7_23, temp3) ? 1 : 0) << 0xa
0041166e      | (x87_r7_23 == temp3 ? 1 : 0) << 0xe
0041166e  
00411673  if ((eax_17:1.b & 1) == 0)
00411675      var_24_2 = 0
00411675  
0041168b  int32_t eax_21 = mods.dp.d(sx.q(edi + 2), *arg1) * 3
004116a2  var_18 = fconvert.s(fconvert.t(arg1[eax_21 + 1]) - fconvert.t(*var_2c))
004116ac  float var_14_2 = fconvert.s(fconvert.t(arg1[eax_21 + 2]) - fconvert.t(var_2c[1]))
004116bb  float var_10_2 = fconvert.s(fconvert.t(arg1[eax_21 + 3]) - fconvert.t(var_2c[2]))
004116bf  sub_410420(arg3, &var_18, &var_c)
004116ce  sub_410460(&var_c, &var_c)
004116d3  int32_t ecx_10 = *ebp
004116e2  int32_t eax_26 = mods.dp.d(sx.q(ecx_10 + ebx - 1), ecx_10) * 3
004116ef  var_18 = fconvert.s(fconvert.t(ebp[eax_26 + 1]) - fconvert.t(*var_2c))
00411717  long double x87_r7_39 = fconvert.t(var_4)
00411717      * fconvert.t(fconvert.s(fconvert.t(ebp[eax_26 + 3]) - fconvert.t(var_2c[2])))
00411717      + fconvert.t(var_8)
00411717      * fconvert.t(fconvert.s(fconvert.t(ebp[eax_26 + 2]) - fconvert.t(var_2c[1])))
00411721  long double x87_r7_40 = x87_r7_39 + fconvert.t(var_c) * fconvert.t(var_18)
00411723  long double temp4 = fconvert.t(0.0050000000000000001)
00411723  x87_r7_40 - temp4
00411729  void* eax_27
00411729  eax_27.w = (x87_r7_40 < temp4 ? 1 : 0) << 8
00411729      | (is_unordered.t(x87_r7_40, temp4) ? 1 : 0) << 0xa
00411729      | (x87_r7_40 == temp4 ? 1 : 0) << 0xe | 0x3800
00411729  
0041172e  if ((eax_27:1.b & 0x41) == 0)
0041173b      return 0
0041173b  
0041173c  long double temp5 = fconvert.t(-0.0050000000000000001)
0041173c  x87_r7_40 - temp5
00411742  arg2 = 1
0041174a  eax_27.w = (x87_r7_40 < temp5 ? 1 : 0) << 8
0041174a      | (is_unordered.t(x87_r7_40, temp5) ? 1 : 0) << 0xa
0041174a      | (x87_r7_40 == temp5 ? 1 : 0) << 0xe
0041174a  
0041174f  if ((eax_27:1.b & 1) == 0)
00411751      arg2 = nullptr
00411751  
00411762  void* result = sub_4106a0(*arg1 + ecx_10)
00411767  int32_t esi_3 = *arg1
0041176e  int32_t var_3c_1 = esi_3
0041177c  int32_t edi_4
0041177c  
0041177c  for (int32_t i_1 = mods.dp.d(sx.q(edi + 1), esi_3); i_1 != edi; 
0041177c          i_1 = mods.dp.d(sx.q(i_1 + 1), edi_4))
00411790      if (i_1 != mods.dp.d(sx.q(edi + 1), var_3c_1) || arg2 != 0)
00411796          int32_t eax_36 = i_1 * 3
004117a5          *(result + *result * 0xc + 4) = arg1[eax_36 + 1]
004117b5          *(result + *result * 0xc + 8) = arg1[eax_36 + 2]
004117c6          *(result + (*result + 1) * 0xc) = arg1[i_1 * 3 + 3]
004117cc          *result += 1
004117cc      
004117d2      edi_4 = *arg1
004117da      var_3c_1 = edi_4
004117de      edi = var_28
004117de  
004117e8  int32_t edi_5 = *ebp
004117e8  
004117f5  for (int32_t i_2 = mods.dp.d(sx.q(ebx + 1), edi_5); i_2 != ebx; 
004117f5          i_2 = mods.dp.d(sx.q(i_2 + 1), edi_5))
00411807      if (i_2 != mods.dp.d(sx.q(ebx + 1), edi_5) || var_24_2 != 0)
00411809          int32_t edx_41 = i_2 * 3
00411819          *(result + *result * 0xc + 4) = ebp[edx_41 + 1]
00411825          *(result + *result * 0xc + 8) = ebp[edx_41 + 2]
00411837          *(result + (*result + 1) * 0xc) = ebp[i_2 * 3 + 3]
0041183d          *result += 1
0041183d      
0041183f      edi_5 = *ebp
0041183f  
00411857  return result

00411858                                                                          90 90 90 90 90 90 90 90                          ........

00411860    int32_t sub_411860() __pure

00411865  return &data_255e160

00411866                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00411870    int32_t sub_411870(int32_t* arg1)

00411873  int32_t __saved_ebx_1
00411873  int32_t __saved_ebx = __saved_ebx_1
00411874  int32_t __saved_ebp_1
00411874  int32_t __saved_ebp = __saved_ebp_1
00411875  int32_t __saved_esi_1
00411875  int32_t __saved_esi = __saved_esi_1
00411876  int32_t __saved_edi_1
00411876  int32_t __saved_edi = __saved_edi_1
0041187b  int32_t eax = *arg1
0041187b  
00411880  if (eax s< 3)
00411882      int32_t var_40 = eax
00411883      char* var_44_1 = "winding %i points"
00411888      char* var_48 = &data_255e160
0041188d      sub_41e430(&data_255e160, "winding %i points")
004118a1      return 1
004118a1  
004118a3  long double st0 = sub_410a50(arg1)
004118a8  long double temp0 = fconvert.t(1f)
004118a8  st0 - temp0
004118a8  
004118b6  if ((((st0 < temp0 ? 1 : 0) << 8 | (is_unordered.t(st0, temp0) ? 1 : 0) << 0xa
004118b6          | (st0 == temp0 ? 1 : 0) << 0xe | 0x3800):1.b & 1) != 0)
004118bb      int32_t var_44
004118bb      var_44.q = fconvert.d(st0)
004118be      char* var_48_1 = "winding %f area"
004118c3      char* var_4c_1 = &data_255e160
004118c8      sub_41e430(&data_255e160, "winding %f area")
004118dc      return 2
004118dc  
004118ea  float var_2c
004118ea  float var_c
004118ea  sub_410940(arg1, &var_c, &var_2c)
004118ef  int32_t edx = *arg1
004118f4  int32_t ebp = 0
004118f4  
004118f8  if (edx s> 0)
004118fe      void* edi_1 = &arg1[1]
004118fe      
00411a59      do
00411901          int32_t i = 0
00411903          void* esi = edi_1
00411932          float* var_4c
00411932          
00411932          do
00411905              long double x87_r7_1 = fconvert.t(*esi)
00411907              long double temp1_1 = fconvert.t(8192f)
00411907              x87_r7_1 - temp1_1
00411912              long double x87_r7_2
00411912              long double temp2_1
00411912              
00411912              if ((((x87_r7_1 < temp1_1 ? 1 : 0) << 8
00411912                      | (is_unordered.t(x87_r7_1, temp1_1) ? 1 : 0) << 0xa
00411912                      | (x87_r7_1 == temp1_1 ? 1 : 0) << 0xe):1.b & 0x41) != 0)
00411918                  x87_r7_2 = fconvert.t(*esi)
0041191a                  temp2_1 = fconvert.t(-8192f)
0041191a                  x87_r7_2 - temp2_1
0041191a              
00411925              if ((((x87_r7_1 < temp1_1 ? 1 : 0) << 8
00411925                      | (is_unordered.t(x87_r7_1, temp1_1) ? 1 : 0) << 0xa
00411925                      | (x87_r7_1 == temp1_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0 || ((
00411925                      (x87_r7_2 < temp2_1 ? 1 : 0) << 8
00411925                      | (is_unordered.t(x87_r7_2, temp2_1) ? 1 : 0) << 0xa
00411925                      | (x87_r7_2 == temp2_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
00411a6f                  float* var_44_2
00411a6f                  var_44_2.q = fconvert.d(fconvert.t(*(edi_1 + 8)))
00411a78                  var_4c.q = fconvert.d(fconvert.t(*(edi_1 + 4)))
00411a80                  double var_54_1 = fconvert.d(fconvert.t(*edi_1))
00411a83                  int32_t i_1 = i
00411a84                  char* var_5c = "winding point %d BUGUS_RANGE '%f…"
00411a89                  char* var_60 = &data_255e160
00411a8e                  sub_41e430(&data_255e160, "winding point %d BUGUS_RANGE '%f…")
00411aa2                  return 3
00411aa2              
0041192b              i += 1
0041192c              esi += 4
00411932          while (i s< 3)
00411932          
00411934          long double x87_r7_3 = fconvert.t(*edi_1)
00411951          int32_t esi_2 = ebp + 1 - edx
00411953          int32_t esi_3 = neg.d(esi_2)
00411959          int32_t esi_5 = sbb.d(esi_3, esi_3, esi_2 != 0) & (ebp + 1)
0041195b          float var_8
0041195b          float var_4
0041195b          long double x87_r6_5 = x87_r7_3 * fconvert.t(var_c)
0041195b              + fconvert.t(var_4) * fconvert.t(*(edi_1 + 8))
0041195b              + fconvert.t(var_8) * fconvert.t(*(edi_1 + 4)) - fconvert.t(var_2c)
0041195f          long double temp4_1 = fconvert.t(-0.10000000000000001)
0041195f          x87_r6_5 - temp4_1
0041196a          long double temp5_1
0041196a          
0041196a          if ((((x87_r6_5 < temp4_1 ? 1 : 0) << 8
0041196a                  | (is_unordered.t(x87_r6_5, temp4_1) ? 1 : 0) << 0xa
0041196a                  | (x87_r6_5 == temp4_1 ? 1 : 0) << 0xe | 0x3000):1.b & 1) == 0)
00411970              temp5_1 = fconvert.t(0.10000000000000001)
00411970              x87_r6_5 - temp5_1
00411970          
0041197b          if ((((x87_r6_5 < temp4_1 ? 1 : 0) << 8
0041197b                  | (is_unordered.t(x87_r6_5, temp4_1) ? 1 : 0) << 0xa
0041197b                  | (x87_r6_5 == temp4_1 ? 1 : 0) << 0xe | 0x3000):1.b & 1) != 0 || ((
0041197b                  (x87_r6_5 < temp5_1 ? 1 : 0) << 8
0041197b                  | (is_unordered.t(x87_r6_5, temp5_1) ? 1 : 0) << 0xa
0041197b                  | (x87_r6_5 == temp5_1 ? 1 : 0) << 0xe | 0x3800):1.b & 0x41) == 0)
00411ae5              int32_t var_40_7 = ebp
00411ae6              char* var_44_5 = "winding point %d off plane"
00411aeb              char* var_48_5 = &data_255e160
00411af2              sub_41e430(&data_255e160, "winding point %d off plane")
00411b06              return 4
00411b06          
00411985          int32_t edx_1 = esi_5 * 3
00411997          float var_18 = fconvert.s(fconvert.t(arg1[edx_1 + 1]) - x87_r7_3)
004119a3          float var_14_1 =
004119a3              fconvert.s(fconvert.t(arg1[edx_1 + 2]) - fconvert.t(*(edi_1 + 4)))
004119ad          float var_10_1 =
004119ad              fconvert.s(fconvert.t(arg1[edx_1 + 3]) - fconvert.t(*(edi_1 + 8)))
004119b1          long double st0_1 = sub_410350(&var_18)
004119b6          long double temp6_1 = fconvert.t(0.10000000000000001)
004119b6          st0_1 - temp6_1
004119b6          
004119c4          if ((((st0_1 < temp6_1 ? 1 : 0) << 8
004119c4                  | (is_unordered.t(st0_1, temp6_1) ? 1 : 0) << 0xa
004119c4                  | (st0_1 == temp6_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
00411aa3              int32_t var_40_5 = esi_5
00411aa4              int32_t var_44_3 = ebp
00411aa5              char* var_48_4 = "winding degenerate edge %d-%d"
00411aaa              char* var_4c_2 = &data_255e160
00411aaf              sub_41e430(&data_255e160, "winding degenerate edge %d-%d")
00411ac3              return 5
00411ac3          
004119d9          float var_24
004119d9          sub_410420(&var_c, &var_18, &var_24)
004119e6          var_4c = &var_24
004119e7          int64_t var_54
004119e7          var_54:4.d = &var_24
004119e8          sub_410460()
00411a03          int32_t ecx_1 = 0
00411a0e          edx = *arg1
00411a0e          
00411a1e          if (edx s> 0)
00411a20              float* esi_7 = &arg1[2]
00411a20              
00411a50              do
00411a25                  if (ecx_1 != ebp)
00411a3d                      float var_20
00411a3d                      float var_1c
00411a3d                      long double x87_r7_18 = fconvert.t(var_1c) * fconvert.t(esi_7[1])
00411a3d                          + fconvert.t(var_24) * fconvert.t(esi_7[-1])
00411a3d                          + fconvert.t(var_20) * fconvert.t(*esi_7)
00411a3f                      long double temp7_1 = fconvert.t(fconvert.s(
00411a3f                          fconvert.t(var_24) * fconvert.t(*edi_1)
00411a3f                          + fconvert.t(var_1c) * fconvert.t(*(edi_1 + 8))
00411a3f                          + fconvert.t(var_20) * fconvert.t(*(edi_1 + 4))
00411a3f                          + fconvert.t(0.10000000000000001)))
00411a3f                      x87_r7_18 - temp7_1
00411a3f                      
00411a48                      if ((((x87_r7_18 < temp7_1 ? 1 : 0) << 8
00411a48                              | (is_unordered.t(x87_r7_18, temp7_1) ? 1 : 0) << 0xa
00411a48                              | (x87_r7_18 == temp7_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0)
00411ac4                          char* var_40_6 = "winding non-convex"
00411ac9                          char* var_44_4 = &data_255e160
00411ace                          sub_41e430(&data_255e160, "winding non-convex")
00411ae2                          return 6
00411ae2                  
00411a4a                  ecx_1 += 1
00411a4b                  esi_7 = &esi_7[3]
00411a50              while (ecx_1 s< edx)
00411a50          
00411a52          ebp += 1
00411a54          edi_1 += 0xc
00411a59      while (ebp s< edx)
00411a59  
00411a68  return 0

00411b07                       90 90 90 90 90 90 90 90 90                                                         .........

00411b10    void* sub_411b10(int32_t* arg1, int32_t* arg2, int32_t arg3)

00411b1d  if (arg3 s> *arg1)
00411b24      sub_40f970("AddWindingPoint: num > w->numpoi…")
00411b24  
00411b2e  if (arg3 s< 0)
00411b35      sub_40f970("AddWindingPoint: num < 0")
00411b35  
00411b41  void* result = sub_4106a0(*arg1 + 1)
00411b4b  int32_t ecx_1 = *arg1 + 1
00411b4c  int32_t i = 0
00411b50  *result = ecx_1
00411b50  
00411b52  if (ecx_1 s> 0)
00411b54      void* edx_1 = &arg1[2]
00411b5c      void* ecx_2 = result + 8
00411b5c      
00411b91      do
00411b61          if (i != arg3)
00411b75              int32_t ebp_4 = *(edx_1 - 4)
00411b78              edx_1 += 0xc
00411b7b              *(ecx_2 - 4) = ebp_4
00411b81              *ecx_2 = *(edx_1 - 0xc)
00411b86              *(ecx_2 + 4) = *(edx_1 - 8)
00411b61          else
00411b65              *(ecx_2 - 4) = *arg2
00411b6b              *ecx_2 = arg2[1]
00411b70              *(ecx_2 + 4) = arg2[2]
00411b70          
00411b8b          i += 1
00411b8c          ecx_2 += 0xc
00411b91      while (i s< *result)
00411b91  
00411b97  return result

00411b98                                                                          90 90 90 90 90 90 90 90                          ........

00411ba0    void sub_411ba0(int32_t* arg1, float* arg2, float arg3, int32_t* arg4, int32_t* arg5)

00411ba4  float* ecx = arg2
00411bab  *arg5 = 0
00411bb8  float* edi = arg4
00411bcd  long double x87_r7_4 = fconvert.t(ecx[1]) * fconvert.t(edi[1])
00411bcd      + fconvert.t(ecx[2]) * fconvert.t(edi[2]) + fconvert.t(*ecx) * fconvert.t(*edi)
00411bcd      - fconvert.t(arg3)
00411bd1  long double temp2 = fconvert.t(-0.20000000000000001)
00411bd1  x87_r7_4 - temp2
00411bd7  int32_t* eax
00411bd7  eax.w = (x87_r7_4 < temp2 ? 1 : 0) << 8 | (is_unordered.t(x87_r7_4, temp2) ? 1 : 0) << 0xa
00411bd7      | (x87_r7_4 == temp2 ? 1 : 0) << 0xe | 0x3800
00411bd7  
00411bdc  if ((eax:1.b & 1) == 0)
00411be2      long double temp3_1 = fconvert.t(0.20000000000000001)
00411be2      x87_r7_4 - temp3_1
00411be8      eax.w = (x87_r7_4 < temp3_1 ? 1 : 0) << 8
00411be8          | (is_unordered.t(x87_r7_4, temp3_1) ? 1 : 0) << 0xa
00411be8          | (x87_r7_4 == temp3_1 ? 1 : 0) << 0xe
00411be8      
00411bed      if ((eax:1.b & 0x41) != 0)
00411bf7          arg4 = nullptr
00411bff          int32_t ebx_1 = *arg1
00411bff          
00411c04          if (ebx_1 s> 0)
00411c0a              void* esi_1 = &arg1[2]
00411c0a              
00411c1e              while (true)
00411c1f                  int32_t temp1_1 = mods.dp.d(sx.q(arg4 + 1), ebx_1)
00411c21                  int32_t eax_3 = temp1_1 * 3
00411c2f                  void* ebx_2 = &arg1[eax_3]
00411c33                  float eax_4 = &arg1[temp1_1 * 3 + 3]
00411c3f                  float var_c =
00411c3f                      fconvert.s(fconvert.t(arg1[eax_3 + 1]) - fconvert.t(*(esi_1 - 4)))
00411c48                  float var_8_1 = fconvert.s(fconvert.t(*(ebx_2 + 8)) - fconvert.t(*esi_1))
00411c58                  float var_4_1 = fconvert.s(fconvert.t(*eax_4) - fconvert.t(*(esi_1 + 4)))
00411c5c                  float var_30
00411c5c                  sub_410420(ecx, &var_c, &var_30)
00411c6b                  sub_410460(&var_30, &var_30)
00411ca5                  float var_2c
00411ca5                  float var_28
00411ca5                  long double x87_r7_16 = fconvert.t(var_28) * fconvert.t(edi[2])
00411ca5                      + fconvert.t(var_2c) * fconvert.t(edi[1])
00411ca5                      + fconvert.t(var_30) * fconvert.t(*edi) - (
00411ca5                      fconvert.t(var_28) * fconvert.t(*(esi_1 + 4))
00411ca5                      + fconvert.t(var_2c) * fconvert.t(*esi_1)
00411ca5                      + fconvert.t(var_30) * fconvert.t(*(esi_1 - 4)))
00411ca7                  long double temp4_1 = fconvert.t(-0.20000000000000001)
00411ca7                  x87_r7_16 - temp4_1
00411ca7                  
00411cb2                  if ((((x87_r7_16 < temp4_1 ? 1 : 0) << 8
00411cb2                          | (is_unordered.t(x87_r7_16, temp4_1) ? 1 : 0) << 0xa
00411cb2                          | (x87_r7_16 == temp4_1 ? 1 : 0) << 0xe | 0x3800):1.b & 1) == 0)
00411cb8                      long double temp5_1 = fconvert.t(0.20000000000000001)
00411cb8                      x87_r7_16 - temp5_1
00411cb8                      
00411cc3                      if ((((x87_r7_16 < temp5_1 ? 1 : 0) << 8
00411cc3                              | (is_unordered.t(x87_r7_16, temp5_1) ? 1 : 0) << 0xa
00411cc3                              | (x87_r7_16 == temp5_1 ? 1 : 0) << 0xe):1.b & 0x41) != 0)
00411cdc                          float var_18 =
00411cdc                              fconvert.s(fconvert.t(*edi) - fconvert.t(*(esi_1 - 4)))
00411ce5                          float var_14_1 =
00411ce5                              fconvert.s(fconvert.t(edi[1]) - fconvert.t(*esi_1))
00411cef                          float var_10_1 =
00411cef                              fconvert.s(fconvert.t(edi[2]) - fconvert.t(*(esi_1 + 4)))
00411cf8                          float var_24 =
00411cf8                              fconvert.s(fconvert.t(*edi) - fconvert.t(*(ebx_2 + 4)))
00411d02                          float var_20_1 =
00411d02                              fconvert.s(fconvert.t(edi[1]) - fconvert.t(*(ebx_2 + 8)))
00411d0b                          float var_1c_1 =
00411d0b                              fconvert.s(fconvert.t(edi[2]) - fconvert.t(*eax_4))
00411d0f                          long double st0_2 = sub_410460(&var_18, &var_18)
00411d14                          long double temp6_1 = fconvert.t(0.5)
00411d14                          st0_2 - temp6_1
00411d14                          
00411d22                          if ((((st0_2 < temp6_1 ? 1 : 0) << 8
00411d22                                  | (is_unordered.t(st0_2, temp6_1) ? 1 : 0) << 0xa
00411d22                                  | (st0_2 == temp6_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
00411d22                              break
00411d22                          
00411d32                          long double st0_3 = sub_410460(&var_24, &var_24)
00411d37                          long double temp7_1 = fconvert.t(0.5)
00411d37                          st0_3 - temp7_1
00411d37                          
00411d45                          if ((((st0_3 < temp7_1 ? 1 : 0) << 8
00411d45                                  | (is_unordered.t(st0_3, temp7_1) ? 1 : 0) << 0xa
00411d45                                  | (st0_3 == temp7_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
00411d45                              break
00411d45                          
00411d61                          long double x87_r7_34 =
00411d61                              fconvert.t(var_1c_1) * fconvert.t(var_10_1)
00411d61                              + fconvert.t(var_20_1) * fconvert.t(var_14_1)
00411d61                              + fconvert.t(var_24) * fconvert.t(var_18)
00411d63                          long double temp8_1 = fconvert.t(-0.98999999999999999)
00411d63                          x87_r7_34 - temp8_1
00411d63                          
00411d6e                          if ((((x87_r7_34 < temp8_1 ? 1 : 0) << 8
00411d6e                                  | (is_unordered.t(x87_r7_34, temp8_1) ? 1 : 0) << 0xa
00411d6e                                  | (x87_r7_34 == temp8_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
00411da0                              *arg5 = arg4 + 1
00411dab                              return 
00411dab                  
00411d78                  ebx_1 = *arg1
00411d7b                  esi_1 += 0xc
00411d7e                  bool cond:0_1 = arg4 + 1 s< ebx_1
00411d80                  arg4 += 1
00411d80                  
00411d84                  if (not(cond:0_1))
00411d93                      return 
00411d93                  
00411c0f                  ecx = arg2

00411db8                                                                          90 90 90 90 90 90 90 90                          ........

00411dc0    void sub_411dc0(int32_t* arg1, int32_t* arg2, float* arg3, float* arg4, float* arg5)

00411dc3  int32_t eax = 0
00411dc9  int32_t* edi = arg1
00411dcd  int32_t ecx = *edi
00411dcd  
00411dd1  if (ecx s<= 0)
00412164      return 
00412164  
00411dda  void* ebx = &edi[2]
00411ddc  void* var_48 = ebx
00411ddc  
004120e7  do
00411de0      int32_t ebp_2 = eax + 1
00411dea      int32_t temp1_1 = mods.dp.d(sx.q(ebp_2), ecx)
00411dec      int32_t eax_3 = temp1_1 * 3
00411e02      float var_18 = fconvert.s(fconvert.t(edi[eax_3 + 1]) - fconvert.t(*(ebx - 4)))
00411e0b      float var_14_1 = fconvert.s(fconvert.t(edi[eax_3 + 2]) - fconvert.t(*ebx))
00411e15      float var_10_1 = fconvert.s(fconvert.t(edi[temp1_1 * 3 + 3]) - fconvert.t(*(ebx + 4)))
00411e19      long double st0_1 = sub_410350(&var_18)
00411e1e      long double temp2_1 = fconvert.t(0.20000000000000001)
00411e1e      st0_1 - temp2_1
00411e1e      
00411e2c      if ((((st0_1 < temp2_1 ? 1 : 0) << 8 | (is_unordered.t(st0_1, temp2_1) ? 1 : 0) << 0xa
00411e2c              | (st0_1 == temp2_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
00411e4f          float var_3c
00411e4f          sub_410420(&var_18, arg3, &var_3c)
00411e5e          sub_410460(&var_3c, &var_3c)
00411e72          int32_t* esi_1 = arg2
00411e79          int32_t eax_6 = 0
00411e84          int32_t ecx_3 = *esi_1
00411e8a          float var_38
00411e8a          float var_34
00411e8a          float var_4c_1 = fconvert.s(fconvert.t(var_38) * fconvert.t(*ebx)
00411e8a              + fconvert.t(var_34) * fconvert.t(*(ebx + 4))
00411e8a              + fconvert.t(var_3c) * fconvert.t(*(ebx - 4)))
00411e8a          
00411e8e          if (ecx_3 s> 0)
00411e94              void* ebp_1 = &esi_1[2]
00411e94              
004120cc              do
00411e9d                  int32_t temp1_2 = mods.dp.d(sx.q(eax_6 + 1), ecx_3)
00411e9f                  int32_t eax_9 = temp1_2 * 3
00411eb5                  float var_c =
00411eb5                      fconvert.s(fconvert.t(esi_1[eax_9 + 1]) - fconvert.t(*(ebp_1 - 4)))
00411ebf                  float var_8_1 =
00411ebf                      fconvert.s(fconvert.t(esi_1[eax_9 + 2]) - fconvert.t(*ebp_1))
00411ec9                  float var_4_1 = fconvert.s(fconvert.t(esi_1[temp1_2 * 3 + 3])
00411ec9                      - fconvert.t(*(ebp_1 + 4)))
00411ecd                  long double st0_3 = sub_410350(&var_c)
00411ed2                  long double temp3_1 = fconvert.t(0.20000000000000001)
00411ed2                  st0_3 - temp3_1
00411ed2                  
00411ee0                  if ((((st0_3 < temp3_1 ? 1 : 0) << 8
00411ee0                          | (is_unordered.t(st0_3, temp3_1) ? 1 : 0) << 0xa
00411ee0                          | (st0_3 == temp3_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
00411f03                      float var_30
00411f03                      sub_410420(&var_c, arg3, &var_30)
00411f12                      sub_410460(&var_30, &var_30)
00411f33                      float var_2c
00411f33                      float var_28
00411f33                      long double x87_r7_24 = fconvert.t(var_2c) * fconvert.t(*ebp_1)
00411f33                          + fconvert.t(var_28) * fconvert.t(*(ebp_1 + 4))
00411f33                          + fconvert.t(var_30) * fconvert.t(*(ebp_1 - 4))
00411f39                      long double x87_r6_10 = fconvert.t(var_4c_1) - x87_r7_24
00411f3b                      long double temp4_1 = fconvert.t(-0.10000000000000001)
00411f3b                      x87_r6_10 - temp4_1
00411f3b                      
00411f46                      if ((((x87_r6_10 < temp4_1 ? 1 : 0) << 8
00411f46                              | (is_unordered.t(x87_r6_10, temp4_1) ? 1 : 0) << 0xa
00411f46                              | (x87_r6_10 == temp4_1 ? 1 : 0) << 0xe | 0x3000):1.b & 1) != 0)
00411f57                          x87_r7_24 = x87_r6_10
00411f5f                          label_411f5f:
00411f5f                          var_30 = fconvert.s(fneg(fconvert.t(var_30)))
00411f69                          var_2c = fconvert.s(fneg(fconvert.t(var_2c)))
00411f73                          var_28 = fconvert.s(fneg(fconvert.t(var_28)))
00411f79                          long double x87_r7_26 = fconvert.t(var_4c_1) - fneg(x87_r7_24)
00411f7d                          long double temp6_1 = fconvert.t(-0.10000000000000001)
00411f7d                          x87_r7_26 - temp6_1
00411f7d                          
00411f88                          if ((((x87_r7_26 < temp6_1 ? 1 : 0) << 8
00411f88                                  | (is_unordered.t(x87_r7_26, temp6_1) ? 1 : 0) << 0xa
00411f88                                  | (x87_r7_26 == temp6_1 ? 1 : 0) << 0xe | 0x3800):1.b & 1) == 0)
00411f8e                              long double temp7_1 = fconvert.t(0.10000000000000001)
00411f8e                              x87_r7_26 - temp7_1
00411f8e                              
00411f99                              if ((((x87_r7_26 < temp7_1 ? 1 : 0) << 8
00411f99                                      | (is_unordered.t(x87_r7_26, temp7_1) ? 1 : 0) << 0xa
00411f99                                      | (x87_r7_26 == temp7_1 ? 1 : 0) << 0xe):1.b & 0x41) != 0)
00411f99                                  goto label_411fa3
00411f46                      else
00411f48                          long double temp5_1 = fconvert.t(0.10000000000000001)
00411f48                          x87_r6_10 - temp5_1
00411f48                          
00411f53                          if ((((x87_r6_10 < temp5_1 ? 1 : 0) << 8
00411f53                                  | (is_unordered.t(x87_r6_10, temp5_1) ? 1 : 0) << 0xa
00411f53                                  | (x87_r6_10 == temp5_1 ? 1 : 0) << 0xe | 0x3800):1.b & 0x41)
00411f53                                  == 0)
00411f53                              goto label_411f5f
00411f53                          
00411fa3                          label_411fa3:
00411fcb                          int32_t i
00411fcb                          
00411fcb                          for (i = 0; i s< 3; i += 1)
00411fa9                              long double x87_r7_28 =
00411fa9                                  fconvert.t((&var_3c)[i]) - fconvert.t((&var_30)[i])
00411fad                              long double temp8_1 = fconvert.t(-0.0001)
00411fad                              x87_r7_28 - temp8_1
00411fad                              
00411fb8                              if ((((x87_r7_28 < temp8_1 ? 1 : 0) << 8
00411fb8                                      | (is_unordered.t(x87_r7_28, temp8_1) ? 1 : 0) << 0xa
00411fb8                                      | (x87_r7_28 == temp8_1 ? 1 : 0) << 0xe | 0x3800):1.b & 1)
00411fb8                                      != 0)
00411fb8                                  break
00411fb8                              
00411fba                              long double temp9_1 = fconvert.t(0.0001)
00411fba                              x87_r7_28 - temp9_1
00411fba                              
00411fc5                              if ((((x87_r7_28 < temp9_1 ? 1 : 0) << 8
00411fc5                                      | (is_unordered.t(x87_r7_28, temp9_1) ? 1 : 0) << 0xa
00411fc5                                      | (x87_r7_28 == temp9_1 ? 1 : 0) << 0xe):1.b & 0x41) == 0)
00411fc5                                  break
00411fc5                          
00411fd4                          if (i == 3)
00411fda                              int32_t i_5 = *edi
00411fdc                              int32_t esi_2 = 0
00411fde                              int32_t ebx_1 = 0
00411fe2                              int32_t var_20_1 = 0
00411fe6                              int32_t var_24_1 = 0
00411fe6                              
00411fea                              if (i_5 s> 0)
00411fec                                  void* ecx_6 = &edi[2]
00411fef                                  int32_t i_3 = i_5
0041203c                                  int32_t i_1
0041203c                                  
0041203c                                  do
00412009                                      long double x87_r7_33 =
00412009                                          fconvert.t(var_34) * fconvert.t(*(ecx_6 + 4))
00412009                                          + fconvert.t(var_3c) * fconvert.t(*(ecx_6 - 4))
00412009                                          + fconvert.t(var_38) * fconvert.t(*ecx_6)
00412009                                          - fconvert.t(var_4c_1)
0041200d                                      long double temp10_1 = fconvert.t(0.10000000000000001)
0041200d                                      x87_r7_33 - temp10_1
00412013                                      i_5.w = (x87_r7_33 < temp10_1 ? 1 : 0) << 8
00412013                                          | (is_unordered.t(x87_r7_33, temp10_1) ? 1 : 0)
00412013                                          << 0xa | (x87_r7_33 == temp10_1 ? 1 : 0) << 0xe
00412013                                          | 0x3800
00412013                                      
00412018                                      if ((i_5:1.b & 0x41) != 0)
00412027                                          long double temp12_1 =
00412027                                              fconvert.t(-0.10000000000000001)
00412027                                          x87_r7_33 - temp12_1
0041202d                                          i_5.w = (x87_r7_33 < temp12_1 ? 1 : 0) << 8 | (
0041202d                                              is_unordered.t(x87_r7_33, temp12_1) ? 1 : 0)
0041202d                                              << 0xa | (x87_r7_33 == temp12_1 ? 1 : 0) << 0xe
0041202d                                          
00412032                                          if ((i_5:1.b & 1) == 0)
00412037                                              esi_2 += 1
00412032                                          else
00412034                                              ebx_1 += 1
00412018                                      else
00412021                                          var_24_1 += 1
00412021                                      
00412038                                      ecx_6 += 0xc
0041203b                                      i_1 = i_3
0041203b                                      i_3 -= 1
0041203c                                  while (i_1 != 1)
0041203e                                  var_20_1 = ebx_1
0041203e                              
00412046                              int32_t esi_3 = 0
00412048                              int32_t edi_1 = 0
0041204a                              int32_t ebx_2 = 0
0041204c                              int32_t i_6 = *arg2
0041204c                              
00412050                              if (i_6 s> 0)
00412052                                  void* ecx_8 = &arg2[2]
00412055                                  int32_t i_4 = i_6
0041209a                                  int32_t i_2
0041209a                                  
0041209a                                  do
0041206f                                      long double x87_r7_38 =
0041206f                                          fconvert.t(var_34) * fconvert.t(*(ecx_8 + 4))
0041206f                                          + fconvert.t(var_3c) * fconvert.t(*(ecx_8 - 4))
0041206f                                          + fconvert.t(var_38) * fconvert.t(*ecx_8)
0041206f                                          - fconvert.t(var_4c_1)
00412073                                      long double temp11_1 = fconvert.t(0.10000000000000001)
00412073                                      x87_r7_38 - temp11_1
00412079                                      i_6.w = (x87_r7_38 < temp11_1 ? 1 : 0) << 8
00412079                                          | (is_unordered.t(x87_r7_38, temp11_1) ? 1 : 0)
00412079                                          << 0xa | (x87_r7_38 == temp11_1 ? 1 : 0) << 0xe
00412079                                          | 0x3800
00412079                                      
0041207e                                      if ((i_6:1.b & 0x41) != 0)
00412085                                          long double temp13_1 =
00412085                                              fconvert.t(-0.10000000000000001)
00412085                                          x87_r7_38 - temp13_1
0041208b                                          i_6.w = (x87_r7_38 < temp13_1 ? 1 : 0) << 8 | (
0041208b                                              is_unordered.t(x87_r7_38, temp13_1) ? 1 : 0)
0041208b                                              << 0xa | (x87_r7_38 == temp13_1 ? 1 : 0) << 0xe
0041208b                                          
00412090                                          if ((i_6:1.b & 1) == 0)
00412095                                              esi_3 += 1
00412090                                          else
00412092                                              edi_1 += 1
0041207e                                      else
00412082                                          ebx_2 += 1
00412082                                      
00412096                                      ecx_8 += 0xc
00412099                                      i_2 = i_4
00412099                                      i_4 -= 1
0041209a                                  while (i_2 != 1)
0041209a                              
004120aa                              if (var_24_1 != 0 && var_20_1 != 0)
004120b1                                  sub_410080("FindPlaneSeperatingWindings: win…")
004120aa                              else if (ebx_2 != 0 && edi_1 != 0)
004120b1                                  sub_410080("FindPlaneSeperatingWindings: win…")
004120fd                              else if ((var_24_1 != 0 || var_20_1 != 0)
004120fd                                      && (ebx_2 != 0 || edi_1 != 0))
0041211c                                  if (var_24_1 == 0 && edi_1 == 0)
0041213d                                      label_41213d:
0041213d                                      *arg4 = fconvert.s(fconvert.t(var_3c))
00412143                                      arg4[1] = var_38
0041214b                                      arg4[2] = var_34
0041214e                                      *arg5 = fconvert.s(fconvert.t(var_4c_1))
0041215a                                      return 
0041215a                                  
00412124                                  if (var_20_1 == 0 && ebx_2 == 0)
00412124                                      goto label_41213d
00412124                              
004120b9                              edi = arg1
004120bd                              esi_1 = arg2
00411ee0                  else
00411ee7                      sub_410080("FindPlaneSeperatingWindings: win…")
00411ee7                  
004120c1                  eax_6 += 1
004120c5                  ecx_3 = *esi_1
004120c7                  ebp_1 += 0xc
004120cc              while (eax_6 s< ecx_3)
004120cc              
004120d2              ebx = var_48
00411e2c      else
00411e33          sub_410080("FindPlaneSeperatingWindings: win…")
00411e33      
004120da      ecx = *edi
004120dc      eax = ebp_2
004120de      ebx += 0xc
004120e3      var_48 = ebx
004120e7  while (eax s< ecx)

00412165                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

00412170    int32_t sub_412170(int32_t* arg1, int32_t* arg2, float* arg3, float* arg4, float arg5, float arg6)

00412185  if (arg1 != 0 && arg2 != 0)
00412187      int32_t esi_1 = *arg1
00412189      int32_t edx_1 = 0
0041218d      int32_t* eax
0041218d      
0041218d      if (esi_1 s> 0)
00412193          void* ecx_1 = &arg1[2]
00412193          
004121c1          do
004121aa              long double x87_r7_5 = fconvert.t(*(ecx_1 + 4)) * fconvert.t(arg4[2])
004121aa                  + fconvert.t(*(ecx_1 - 4)) * fconvert.t(*arg4)
004121aa                  + fconvert.t(*ecx_1) * fconvert.t(arg4[1]) - fconvert.t(arg6)
004121ae              long double temp0_1 = fconvert.t(0.20000000000000001)
004121ae              x87_r7_5 - temp0_1
004121b4              eax.w = (x87_r7_5 < temp0_1 ? 1 : 0) << 8
004121b4                  | (is_unordered.t(x87_r7_5, temp0_1) ? 1 : 0) << 0xa
004121b4                  | (x87_r7_5 == temp0_1 ? 1 : 0) << 0xe
004121b4              
004121b9              if ((eax:1.b & 0x41) == 0)
0041220d                  return 1
0041220d              
004121bb              edx_1 += 1
004121bc              ecx_1 += 0xc
004121c1          while (edx_1 s< esi_1)
004121c1      
004121c3      int32_t esi_2 = *arg2
004121c5      int32_t edx_2 = 0
004121c5      
004121c9      if (esi_2 s> 0)
004121cf          void* ecx_2 = &arg2[2]
004121cf          
004121e6          while (true)
004121e6              long double x87_r7_10 = fconvert.t(*(ecx_2 - 4)) * fconvert.t(*arg3)
004121e6                  + fconvert.t(*(ecx_2 + 4)) * fconvert.t(arg3[2])
004121e6                  + fconvert.t(*ecx_2) * fconvert.t(arg3[1]) - fconvert.t(arg5)
004121ea              long double temp1_1 = fconvert.t(0.20000000000000001)
004121ea              x87_r7_10 - temp1_1
004121f0              eax.w = (x87_r7_10 < temp1_1 ? 1 : 0) << 8
004121f0                  | (is_unordered.t(x87_r7_10, temp1_1) ? 1 : 0) << 0xa
004121f0                  | (x87_r7_10 == temp1_1 ? 1 : 0) << 0xe
004121f0              
004121f5              if ((eax:1.b & 0x41) == 0)
0041220d                  return 1
0041220d              
004121f7              edx_2 += 1
004121f8              ecx_2 += 0xc
004121f8              
004121fd              if (edx_2 s>= esi_2)
00412204                  return 0
00412204  
00412204  return 0

0041220e                                            90 90                                                                ..

00412210    int32_t sub_412210(char* arg1)

00412218  int32_t edi = 0
00412218  
0041221c  if (data_42d428 != 0)
00412222      void** eax = &data_42d428
00412227      void** esi_1 = &data_42d428
00412244      int32_t i
00412244      
00412244      do
00412229          char* eax_1 = *eax
0041222d          int32_t eax_2
0041222d          int32_t edx
0041222d          eax_2, edx = sub_426fe0(eax_1, edx, i, arg1, eax_1)
0041222d          
00412237          if (eax_2 == 0)
00412259              return *((edi << 3) + &data_42d42c)
00412259          
00412239          i = esi_1[2]
0041223c          esi_1 = &esi_1[2]
0041223f          edi += 1
00412240          eax = esi_1
00412244      while (i != 0)
00412244  
0041224e  return 0x8000

0041225a                                                                                90 90 90 90 90 90                            ......

00412260    int32_t sub_412260(int32_t arg1)

00412274  int16_t var_104 = data_42d4c8
00412284  void s
00412284  int16_t* edi = __builtin_memset(&s, c: 0, n: 0x100)
0041228a  void* var_10c = &var_104:1
0041228c  *edi = 0
0041228e  sub_40feb0(arg1, var_10c)
004122a7  return sub_412210(&var_104)

004122a8                          90 90 90 90 90 90 90 90                                                          ........

004122b0    int32_t sub_4122b0(int32_t arg1, char* arg2, uint32_t arg3)

004122b7  int32_t edi = arg1
004122bb  int32_t i = 0xffffffff
004122c0  char* ebx = arg2
004122c0  
004122c4  while (i != 0)
004122c4      bool cond:0_1 = 0 != *edi
004122c4      edi += 1
004122c4      i -= 1
004122c4      
004122c4      if (not(cond:0_1))
004122c4          break
004122c4  
004122c9  char* edi_1 = ebx
004122cd  int32_t i_1 = 0xffffffff
004122cd  
004122d0  while (i_1 != 0)
004122d0      bool cond:1_1 = 0 != *edi_1
004122d0      edi_1 = &edi_1[1]
004122d0      i_1 -= 1
004122d0      
004122d0      if (not(cond:1_1))
004122d0          break
004122d0  
004122d5  int32_t var_8 = 0
004122d5  
004122df  if (not.d(i) - 1 - (not.d(i_1) - 1) s>= 0)
00412359      bool cond:3_1
00412359      
00412359      do
004122e1          int32_t eax
004122e1          eax.b = *ebx
004122e3          arg2 = nullptr
004122e3          
004122ed          if (eax.b != 0)
004122f3              char* esi_1 = ebx
004122f5              void* edi_3 = arg1 - ebx
00412335              uint32_t eax_1
00412335              
00412335              do
004122fd                  int32_t ecx_3
004122fd                  
004122fd                  if (arg3 == 0)
0041230f                      uint32_t eax_2 = sub_41e9cf(sx.d(*(edi_3 + esi_1)))
0041231a                      eax_1, ecx_3 = sub_41e9cf(sx.d(*esi_1))
0041231a                      
00412324                      if (eax_2 != eax_1)
00412324                          break
004122fd                  else
004122ff                      eax_1.b = *(edi_3 + esi_1)
00412302                      ecx_3.b = *esi_1
00412302                      
00412306                      if (eax_1.b != ecx_3.b)
00412306                          break
0041232a                  eax_1.b = esi_1[1]
0041232e                  esi_1 = &esi_1[1]
00412331                  arg2 = &arg2[1]
00412335              while (eax_1.b != 0)
00412335          
0041233f          if (*(arg2 + ebx) == 0)
00412370              return arg1
00412370          
0041234f          cond:3_1 = var_8 + 1 s<= not.d(i) - 1 - (not.d(i_1) - 1)
00412351          var_8 += 1
00412355          arg1 += 1
00412359      while (cond:3_1)
00412359  
00412364  return 0

00412371                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00412380    int32_t sub_412380(char* arg1, char* arg2, uint32_t arg3)

00412389  char* esi = arg1
00412391  int32_t ebx
00412391  ebx.b = *esi
00412391  
00412395  if (ebx.b != 0)
0041239b      char* ebp_1 = arg2
0041239b      
00412443      do
004123a5          if (ebx.b != 0x2a)
0041240d              if (ebx.b != 0x3f)
00412418                  if (arg3 == 0)
00412426                      uint32_t eax_3 = sub_41e9cf(sx.d(*ebp_1))
00412426                      
0041243b                      if (sub_41e9cf(sx.d(ebx.b)) != eax_3)
00412465                          return 0
00412418                  else if (ebx.b != *ebp_1)
00412465                      return 0
00412465              
0041243d              esi = &esi[1]
0041243e              ebp_1 = &ebp_1[1]
004123a5          else
004123a7              uint32_t eax
004123a7              eax.b = esi[1]
004123aa              esi = &esi[1]
004123ab              int32_t ecx_1 = 0
004123af              char var_400[0x400]
004123af              
004123af              if (eax.b != 0)
004123b3                  while (eax.b != 0x2a)
004123b7                      if (eax.b == 0x3f)
004123b7                          break
004123b7                      
004123b9                      esi = &esi[1]
004123ba                      var_400[ecx_1] = eax.b
004123be                      ecx_1 += 1
004123bf                      eax.b = *esi
004123bf                      
004123c3                      if (eax.b == 0)
004123c3                          break
004123c3              
004123c5              var_400[ecx_1] = 0
004123ca              char (* edi_1)[0x400] = &var_400
004123ce              int32_t i = 0xffffffff
004123ce              
004123d3              while (i != 0)
004123d3                  bool cond:0_1 = 0 != *edi_1
004123d3                  edi_1 = &(*edi_1)[1]
004123d3                  i -= 1
004123d3                  
004123d3                  if (not(cond:0_1))
004123d3                      break
004123d3              
004123d8              if (not.d(i) != 1)
004123e8                  int32_t eax_2 = sub_4122b0(ebp_1, &var_400, arg3)
004123e8                  
004123f4                  if (eax_2 == 0)
00412465                      return 0
00412465                  
004123f6                  char (* edi_2)[0x400] = &var_400
004123fa                  int32_t i_1 = 0xffffffff
004123fa                  
004123ff                  while (i_1 != 0)
004123ff                      bool cond:1_1 = 0 != *edi_2
004123ff                      edi_2 = &(*edi_2)[1]
004123ff                      i_1 -= 1
004123ff                      
004123ff                      if (not(cond:1_1))
004123ff                          break
004123ff                  
00412406                  ebp_1 = not.d(i_1) - 1 + eax_2
00412406          
0041243f          ebx.b = *esi
00412443      while (ebx.b != 0)
00412443  
00412458  return 1

00412466                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00412470    char* sub_412470(PSTR arg1, char* arg2)

00412477  PSTR lpFileName = arg1
0041247f  char* s_2 = nullptr
00412485  char* result = nullptr
00412489  char* var_394 = nullptr
0041248d  int32_t i
0041248d  
0041248d  if (lpFileName != 0)
00412493      PSTR lpFileName_2 = lpFileName
00412495      i = 0xffffffff
00412495      
0041249a      while (i != 0)
0041249a          bool cond:2_1 = 0 != *lpFileName_2
0041249a          lpFileName_2 = &lpFileName_2[1]
0041249a          i -= 1
0041249a          
0041249a          if (not(cond:2_1))
0041249a              break
0041249a  
0041249f  char* var_3c0
0041249f  char var_244[0x104]
0041249f  WIN32_FIND_DATAA findFileData
0041249f  var_114
0041249f  
0041249f  if (lpFileName == 0 || not.d(i) == 1)
00412a37      char* lpFileName_1 = arg2
00412a47      HANDLE hFindFile_1 =
00412a47          FindFirstFileA(lpFileName: lpFileName_1, lpFindFileData: &findFileData)
00412a47      
00412a54      if (hFindFile_1 != 0xffffffff)
00412a76          while (true)
00412a76              sub_41f2dc(lpFileName_1, &var_244, nullptr, nullptr, nullptr)
00412a7b              char (* edi_33)[0x104] = &var_244
00412a82              int32_t i_1 = 0xffffffff
00412a87              char* var_3bc_2 = nullptr
00412a87              
00412a89              while (i_1 != 0)
00412a89                  bool cond:4_1 = 0 != *edi_33
00412a89                  edi_33 = &(*edi_33)[1]
00412a89                  i_1 -= 1
00412a89                  
00412a89                  if (not(cond:4_1))
00412a89                      break
00412a89              
00412a8e              var_3c0 = nullptr
00412a9a              sub_41f2dc(lpFileName_1, nullptr, &var_3c0 + not.d(i_1) - 1 + 0x17c, var_3c0, 
00412a9a                  var_3bc_2)
00412aac              sub_4144f0(&var_244, 0x104)
00412ab1              void* edi_34 = &var_114
00412ab8              int32_t i_2 = 0xffffffff
00412ab8              
00412ac4              while (i_2 != 0)
00412ac4                  bool cond:5_1 = 0 != *edi_34
00412ac4                  edi_34 += 1
00412ac4                  i_2 -= 1
00412ac4                  
00412ac4                  if (not(cond:5_1))
00412ac4                      break
00412ac4              
00412ac6              int32_t ecx_46 = not.d(i_2)
00412ad3              char (* edi_36)[0x104] = &var_244
00412ad5              int32_t i_3 = 0xffffffff
00412ad5              
00412ad8              while (i_3 != 0)
00412ad8                  bool cond:6_1 = 0 != *edi_36
00412ad8                  edi_36 = &(*edi_36)[1]
00412ad8                  i_3 -= 1
00412ad8                  
00412ad8                  if (not(cond:6_1))
00412ad8                      break
00412ad8              
00412ae0              int32_t esi_19
00412ae0              int32_t edi_38
00412ae0              edi_38, esi_19 = __builtin_memcpy(dest: edi_36 - 1, src: edi_34 - ecx_46, 
00412ae0                  n: ecx_46 u>> 2 << 2)
00412ae7              __builtin_memcpy(dest: edi_38, src: esi_19, n: ecx_46 & 3)
00412ae9              char* s = sub_41e583(0x31c)
00412ae9              
00412af5              if (s == 0)
00412afc                  sub_40f970("out of memory")
00412afc              
00412b13              __builtin_memset(s, c: 0, n: 0x31c)
00412b1a              char (* edi_40)[0x104] = &var_244
00412b21              *s = data_43032c
00412b23              int32_t i_4 = 0xffffffff
00412b23              
00412b28              while (i_4 != 0)
00412b28                  bool cond:7_1 = 0 != *edi_40
00412b28                  edi_40 = &(*edi_40)[1]
00412b28                  i_4 -= 1
00412b28                  
00412b28                  if (not(cond:7_1))
00412b28                      break
00412b28              
00412b2a              int32_t ecx_51 = not.d(i_4)
00412b3d              int32_t esi_21
00412b3d              int32_t edi_43
00412b3d              edi_43, esi_21 = __builtin_memcpy(dest: &s[0x104], src: edi_40 - ecx_51, 
00412b3d                  n: ecx_51 u>> 2 << 2)
00412b46              __builtin_memcpy(dest: edi_43, src: esi_21, n: ecx_51 & 3)
00412b48              char (* edi_44)[0x104] = &var_244
00412b4f              int32_t i_5 = 0xffffffff
00412b4f              
00412b52              while (i_5 != 0)
00412b52                  bool cond:8_1 = 0 != *edi_44
00412b52                  edi_44 = &(*edi_44)[1]
00412b52                  i_5 -= 1
00412b52                  
00412b52                  if (not(cond:8_1))
00412b52                      break
00412b52              
00412b54              int32_t ecx_55 = not.d(i_5)
00412b61              int32_t esi_23
00412b61              int32_t edi_47
00412b61              edi_47, esi_23 = __builtin_memcpy(dest: &s[0x208], src: edi_44 - ecx_55, 
00412b61                  n: ecx_55 u>> 2 << 2)
00412b68              __builtin_memcpy(dest: edi_47, src: esi_23, n: ecx_55 & 3)
00412b73              char (* var_3a8_36)[0x104] = &var_244
00412b74              *(s + 0x310) = 0
00412b7a              *(s + 0x314) = 0
00412b8a              *(s + 0x30c) = sub_412260(var_3a8_36)
00412b90              *(s + 0x318) = 0
00412b90              
00412b96              if (s_2 == 0)
00412ba0                  result = s
00412b96              else
00412b98                  *(s_2 + 0x318) = s
00412b98              
00412bbd              if (FindNextFileA(hFindFile: hFindFile_1, lpFindFileData: &findFileData) == 0)
00412bbd                  break
00412bbd              
00412a5c              s_2 = s
00412a60              lpFileName_1 = arg2
0041249f  else
004124ae      HANDLE hFindFile = FindFirstFileA(lpFileName, lpFindFileData: &findFileData)
004124ae      
004124bb      if (hFindFile != 0xffffffff)
004124d3          while (true)
004124d3              char var_348[0x104]
004124d3              sub_41f2dc(lpFileName, &var_348, nullptr, nullptr, nullptr)
004124d8              char (* edi_1)[0x104] = &var_348
004124dc              int32_t i_6 = 0xffffffff
004124e1              char* var_3bc_1 = nullptr
004124e1              
004124e3              while (i_6 != 0)
004124e3                  bool cond:10_1 = 0 != *edi_1
004124e3                  edi_1 = &(*edi_1)[1]
004124e3                  i_6 -= 1
004124e3                  
004124e3                  if (not(cond:10_1))
004124e3                      break
004124e3              
004124e8              var_3c0 = nullptr
004124f1              sub_41f2dc(lpFileName, nullptr, &var_3c0 + not.d(i_6) - 1 + 0x78, var_3c0, 
004124f1                  var_3bc_1)
00412503              sub_4144f0(&var_348, 0x104)
00412508              void* edi_2 = &var_114
0041250f              int32_t i_7 = 0xffffffff
0041250f              
0041251b              while (i_7 != 0)
0041251b                  bool cond:11_1 = 0 != *edi_2
0041251b                  edi_2 += 1
0041251b                  i_7 -= 1
0041251b                  
0041251b                  if (not(cond:11_1))
0041251b                      break
0041251b              
0041251d              int32_t ecx_5 = not.d(i_7)
00412523              char (* edi_4)[0x104] = &var_348
00412527              int32_t i_8 = 0xffffffff
00412527              
0041252a              while (i_8 != 0)
0041252a                  bool cond:12_1 = 0 != *edi_4
0041252a                  edi_4 = &(*edi_4)[1]
0041252a                  i_8 -= 1
0041252a                  
0041252a                  if (not(cond:12_1))
0041252a                      break
0041252a              
00412532              int32_t esi_2
00412532              int32_t edi_6
00412532              edi_6, esi_2 =
00412532                  __builtin_memcpy(dest: edi_4 - 1, src: edi_2 - ecx_5, n: ecx_5 u>> 2 << 2)
0041253e              __builtin_memcpy(dest: edi_6, src: esi_2, n: ecx_5 & 3)
00412548              void var_36c
00412548              sub_41efb1(&var_348, &var_36c)
00412557              int16_t var_366
00412557              
00412557              if ((var_366:1.b & 0x40) == 0)
00412619                  int32_t* eax_2 = sub_41df39(&var_348, "rb")
00412619                  
00412625                  if (eax_2 == 0)
0041296e                      char (* var_3a8_24)[0x104] = &var_348
00412974                      sub_40f9c0("can't open pak file %s")
00412981                      FindClose(hFindFile)
00412993                      return 0
00412993                  
00412640                  int32_t var_37c
00412640                  
00412640                  if (sub_41dcbb(&var_37c, 1, 0xc, eax_2) != 0xc)
00412a05                      label_412a05:
00412a05                      sub_41ddd2(eax_2)
00412a12                      FindClose(hFindFile)
00412a1c                      char (* var_3a8_32)[0x104] = &var_348
00412a22                      sub_40f9c0("invalid pak file %s")
00412a36                      return 0
00412a36                  
00412646                  int32_t eax_4 = var_37c
00412646                  
00412656                  if (eax_4 != 0x4b434150 && eax_4 != 0x4b415053)
0041264f                      goto label_412a05
0041264f                  
00412677                  int32_t var_378
00412677                  
00412677                  if (sub_41de4f(eax_2, sub_40ff30(var_378), FILE_BEGIN) != 0)
00412677                      goto label_412a05
00412677                  
00412685                  void* var_388_1
00412685                  int32_t var_374
00412685                  uint32_t i_20
00412685                  
00412685                  if (var_37c == 0x4b434150)
00412697                      i_20 = sub_40ff30(var_374) u>> 6
004126a9                      void* edi_14 = sub_41e583(i_20 << 6)
004126a9                      
004126b4                      if (edi_14 == 0)
004126bb                          sub_40f970("out of memory")
004126bb                      
004126d3                      if (sub_41dcbb(edi_14, 0x40, i_20, eax_2) != i_20)
00412994                          sub_41ddd2(eax_2)
0041299a                          sub_41e29e(edi_14)
004129a7                          FindClose(hFindFile)
004129b1                          char (* var_3a8_27)[0x104] = &var_348
004129b7                          sub_40f9c0("can't read the Quake pak file di…")
004129cb                          return 0
004129cb                      
004126d9                      sub_41ddd2(eax_2)
004126e4                      void* eax_13 = sub_41e583(i_20 << 7)
004126f0                      var_388_1 = eax_13
004126f0                      
004126f4                      if (eax_13 == 0)
004126fb                          sub_40f970("out of memory")
004126fb                      
00412705                      if (i_20 s> 0)
00412707                          void* ebx = eax_13 + 0x7c
0041270a                          void* ebp_2 = edi_14 + 0x3c
0041270d                          uint32_t i_21 = i_20
00412760                          bool cond:22_1
00412760                          
00412760                          do
00412711                              void* edi_15 = ebp_2 - 0x3c
00412714                              int32_t i_9 = 0xffffffff
00412714                              
0041271c                              while (i_9 != 0)
0041271c                                  bool cond:21_1 = 0 != *edi_15
0041271c                                  edi_15 += 1
0041271c                                  i_9 -= 1
0041271c                                  
0041271c                                  if (not(cond:21_1))
0041271c                                      break
0041271c                              
0041271e                              int32_t ecx_20 = not.d(i_9)
0041272b                              int32_t esi_9
0041272b                              int32_t edi_18
0041272b                              edi_18, esi_9 = __builtin_memcpy(dest: ebx - 0x7c, 
0041272b                                  src: edi_15 - ecx_20, n: ecx_20 u>> 2 << 2)
00412732                              __builtin_memcpy(dest: edi_18, src: esi_9, n: ecx_20 & 3)
0041273d                              *(ebx - 4) = sub_40ff30(*(ebp_2 - 4))
00412749                              *ebx = sub_40ff30(*ebp_2)
00412752                              ebp_2 += 0x40
00412755                              ebx += 0x80
0041275b                              cond:22_1 = i_21 != 1
0041275c                              i_21 -= 1
00412760                          while (cond:22_1)
00412766                          lpFileName = arg1
00412766                      
00412772                      sub_41e29e(edi_14)
004126d3                      goto label_41280d
004126d3                  
0041278b                  uint32_t i_18 = sub_40ff30(var_374) u>> 7
00412790                  uint32_t i_19 = i_18
00412798                  void* eax_21 = sub_41e583(i_18 << 7)
004127a4                  var_388_1 = eax_21
004127a4                  
004127a8                  if (eax_21 == 0)
004127af                      sub_40f970("out of memory")
004127af                  
004127ca                  if (sub_41dcbb(eax_21, 0x80, i_18, eax_2) != i_18)
004129cc                      sub_41ddd2(eax_2)
004129d2                      sub_41e29e(eax_21)
004129df                      FindClose(hFindFile)
004129e9                      char (* var_3a8_29)[0x104] = &var_348
004129ef                      sub_40f9c0("can't read the Sin pak file dir …")
00412a03                      return 0
00412a03                  
004127d0                  sub_41ddd2(eax_2)
004127d0                  
004127da                  if (i_18 s> 0)
004127e4                      void* esi_11 = var_388_1 + 0x7c
00412807                      uint32_t i_10
00412807                      
00412807                      do
004127f0                          *(esi_11 - 4) = sub_40ff30(*(esi_11 - 4))
004127fb                          *esi_11 = sub_40ff30(*esi_11)
00412800                          esi_11 += 0x80
00412806                          i_10 = i_18
00412806                          i_18 -= 1
00412807                      while (i_10 != 1)
00412809                      i_20 = i_19
0041280d                      label_41280d:
0041280d                      
0041280f                      if (i_20 s> 0)
00412815                          void* ebp_3 = var_388_1
00412819                          uint32_t i_22 = i_20
0041292d                          bool cond:23_1
0041292d                          
0041292d                          do
0041281e                              sub_4144d0(ebp_3)
0041281e                              
00412838                              if (sub_412380(arg2, ebp_3, 0) != 0)
00412848                                  char* s_1 = sub_41e583(0x31c)
00412848                                  
0041284f                                  if (s_1 == 0)
00412856                                      sub_40f970("out of memory")
00412856                                  
0041286d                                  __builtin_memset(s: s_1, c: 0, n: 0x31c)
0041286f                                  char (* edi_21)[0x104] = &var_348
00412873                                  int32_t i_11 = 0xffffffff
00412873                                  
00412876                                  while (i_11 != 0)
00412876                                      bool cond:24_1 = 0 != *edi_21
00412876                                      edi_21 = &(*edi_21)[1]
00412876                                      i_11 -= 1
00412876                                      
00412876                                      if (not(cond:24_1))
00412876                                          break
00412876                                  
00412878                                  int32_t ecx_28 = not.d(i_11)
00412886                                  int32_t esi_13
00412886                                  int32_t edi_24
00412886                                  edi_24, esi_13 = __builtin_memcpy(dest: s_1, 
00412886                                      src: edi_21 - ecx_28, n: ecx_28 u>> 2 << 2)
0041288f                                  __builtin_memcpy(dest: edi_24, src: esi_13, n: ecx_28 & 3)
00412891                                  char (* edi_25)[0x104] = &var_348
00412895                                  int32_t i_12 = 0xffffffff
00412895                                  
00412898                                  while (i_12 != 0)
00412898                                      bool cond:25_1 = 0 != *edi_25
00412898                                      edi_25 = &(*edi_25)[1]
00412898                                      i_12 -= 1
00412898                                      
00412898                                      if (not(cond:25_1))
00412898                                          break
00412898                                  
0041289a                                  int32_t ecx_32 = not.d(i_12)
004128ad                                  int32_t esi_15
004128ad                                  int32_t edi_28
004128ad                                  edi_28, esi_15 = __builtin_memcpy(dest: &s_1[0x104], 
004128ad                                      src: edi_25 - ecx_32, n: ecx_32 u>> 2 << 2)
004128b6                                  __builtin_memcpy(dest: edi_28, src: esi_15, n: ecx_32 & 3)
004128b8                                  void* edi_29 = ebp_3
004128ba                                  int32_t i_13 = 0xffffffff
004128ba                                  
004128bd                                  while (i_13 != 0)
004128bd                                      bool cond:26_1 = 0 != *edi_29
004128bd                                      edi_29 += 1
004128bd                                      i_13 -= 1
004128bd                                      
004128bd                                      if (not(cond:26_1))
004128bd                                          break
004128bd                                  
004128bf                                  int32_t ecx_36 = not.d(i_13)
004128cc                                  int32_t esi_17
004128cc                                  int32_t edi_32
004128cc                                  edi_32, esi_17 = __builtin_memcpy(dest: &s_1[0x208], 
004128cc                                      src: edi_29 - ecx_36, n: ecx_36 u>> 2 << 2)
004128d3                                  __builtin_memcpy(dest: edi_32, src: esi_17, n: ecx_36 & 3)
004128d8                                  *(s_1 + 0x310) = *(ebp_3 + 0x78)
004128e1                                  *(s_1 + 0x314) = *(ebp_3 + 0x7c)
004128ec                                  *(s_1 + 0x30c) = sub_412260(ebp_3)
004128f9                                  *(s_1 + 0x318) = 0
004128f9                                  
00412905                                  if (var_394 == 0)
0041290f                                      result = s_1
00412905                                  else
00412907                                      *(var_394 + 0x318) = s_1
00412907                                  
00412913                                  var_394 = s_1
00412917                                  lpFileName = arg1
00412917                              
00412922                              ebp_3 += 0x80
00412928                              cond:23_1 = i_22 != 1
00412929                              i_22 -= 1
0041292d                          while (cond:23_1)
0041292d                  
00412938                  sub_41e29e(var_388_1)
00412557              else
0041255d                  PSTR lpFileName_3 = lpFileName
0041255f                  int32_t i_14 = 0xffffffff
0041255f                  
0041256b                  while (i_14 != 0)
0041256b                      bool cond:13_1 = 0 != *lpFileName_3
0041256b                      lpFileName_3 = &lpFileName_3[1]
0041256b                      i_14 -= 1
0041256b                      
0041256b                      if (not(cond:13_1))
0041256b                          break
0041256b                  
0041256d                  int32_t ecx_10 = not.d(i_14)
00412571                  int32_t var_3a8_2 = 0x104
0041257f                  int32_t esi_4
0041257f                  int32_t edi_8
0041257f                  edi_8, esi_4 = __builtin_memcpy(dest: &var_244, 
0041257f                      src: lpFileName_3 - ecx_10, n: ecx_10 u>> 2 << 2)
00412586                  __builtin_memcpy(dest: edi_8, src: esi_4, n: ecx_10 & 3)
00412590                  sub_4144f0(&var_244, var_3a8_2)
00412595                  char* edi_9 = arg2
0041259c                  int32_t i_15 = 0xffffffff
0041259c                  
004125a8                  while (i_15 != 0)
004125a8                      bool cond:14_1 = 0 != *edi_9
004125a8                      edi_9 = &edi_9[1]
004125a8                      i_15 -= 1
004125a8                      
004125a8                      if (not(cond:14_1))
004125a8                          break
004125a8                  
004125aa                  int32_t ecx_14 = not.d(i_15)
004125b0                  char (* edi_11)[0x104] = &var_244
004125b4                  int32_t i_16 = 0xffffffff
004125b4                  
004125b7                  while (i_16 != 0)
004125b7                      bool cond:15_1 = 0 != *edi_11
004125b7                      edi_11 = &(*edi_11)[1]
004125b7                      i_16 -= 1
004125b7                      
004125b7                      if (not(cond:15_1))
004125b7                          break
004125b7                  
004125bf                  int32_t esi_6
004125bf                  int32_t edi_13
004125bf                  edi_13, esi_6 = __builtin_memcpy(dest: edi_11 - 1, src: edi_9 - ecx_14, 
004125bf                      n: ecx_14 u>> 2 << 2)
004125cd                  char (* var_3b0_2)[0x104] = &var_244
004125ce                  __builtin_memcpy(dest: edi_13, src: esi_6, n: ecx_14 & 3)
004125d2                  char* result_1 = sub_412470(0, var_3b0_2)
004125d2                  
004125dc                  if (s_2 == 0)
004125e6                      result = result_1
004125dc                  else
004125de                      *(s_2 + 0x318) = result_1
004125de                  
004125ea                  var_394 = result_1
004125ea                  
004125f6                  for (char* i_17 = *(result_1 + 0x318); i_17 != 0; i_17 = *(i_17 + 0x318))
004125fc                      var_394 = i_17
004125fc              
00412955              if (FindNextFileA(hFindFile, lpFindFileData: &findFileData) == 0)
00412955                  break
00412955              
004124c3              s_2 = var_394
00412bd1  return result

00412bd2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00412be0    char* sub_412be0(int32_t arg1)

00412be6  int32_t i = 0xffffffff
00412bf1  int32_t edi = arg1
00412bf1  
00412bf8  while (i != 0)
00412bf8      bool cond:0_1 = 0 != *edi
00412bf8      edi += 1
00412bf8      i -= 1
00412bf8      
00412bf8      if (not(cond:0_1))
00412bf8          break
00412bf8  
00412bfa  int32_t ecx = not.d(i)
00412c07  char var_30c[0x104]
00412c07  int32_t esi_1
00412c07  int32_t edi_2
00412c07  edi_2, esi_1 = __builtin_memcpy(dest: &var_30c, src: edi - ecx, n: ecx u>> 2 << 2)
00412c0e  __builtin_memcpy(dest: edi_2, src: esi_1, n: ecx & 3)
00412c15  sub_4144d0(&var_30c)
00412c1a  char (* edi_3)[0x104] = &var_30c
00412c1e  int32_t i_1 = 0xffffffff
00412c1e  
00412c2a  while (i_1 != 0)
00412c2a      bool cond:1_1 = 0 != *edi_3
00412c2a      edi_3 = &(*edi_3)[1]
00412c2a      i_1 -= 1
00412c2a      
00412c2a      if (not(cond:1_1))
00412c2a          break
00412c2a  
00412c2c  int32_t ecx_4 = not.d(i_1)
00412c40  void var_208
00412c40  int32_t esi_3
00412c40  int32_t edi_5
00412c40  edi_5, esi_3 = __builtin_memcpy(dest: &var_208, src: edi_3 - ecx_4, n: ecx_4 u>> 2 << 2)
00412c47  __builtin_memcpy(dest: edi_5, src: esi_3, n: ecx_4 & 3)
00412c51  void* eax_2 = sub_4122b0(&var_208, ".pak", 0)
00412c51  
00412c5b  if (eax_2 != 0)
00412c60      void* eax_3 = eax_2 + 4
00412c60      
00412c65      if (*(eax_2 + 4) != 0)
00412c67          *eax_3 = 0
00412c67          
00412c6a          while (true)
00412c6a              char ecx_8 = *(eax_3 + 1)
00412c6d              eax_3 += 1
00412c6d              
00412c71              if (ecx_8 != 0x5c)
00412c76                  if (ecx_8 != 0x2f)
00412c76                      break
00412c76          
00412c78          void* edi_6 = eax_3
00412c7a          int32_t i_2 = 0xffffffff
00412c7a          
00412c86          while (i_2 != 0)
00412c86              bool cond:2_1 = 0 != *edi_6
00412c86              edi_6 += 1
00412c86              i_2 -= 1
00412c86              
00412c86              if (not(cond:2_1))
00412c86                  break
00412c86          
00412c88          int32_t ecx_9 = not.d(i_2)
00412c9c          char var_104[0x104]
00412c9c          int32_t esi_5
00412c9c          int32_t edi_8
00412c9c          edi_8, esi_5 =
00412c9c              __builtin_memcpy(dest: &var_104, src: edi_6 - ecx_9, n: ecx_9 u>> 2 << 2)
00412ca3          __builtin_memcpy(dest: edi_8, src: esi_5, n: ecx_9 & 3)
00412cbe          return sub_412470(&var_208, &var_104)
00412cbe  
00412cd6  return sub_412470(nullptr, &var_30c)

00412cd7                                                                       90 90 90 90 90 90 90 90 90                         .........

00412ce0    int32_t sub_412ce0(void* arg1, int32_t* arg2)

00412ce1  void* ebp = arg1
00412ce1  
00412cef  if (*(ebp + 0x134) == 0)
00412cfe      *(ebp + 0x134) = sub_4105b0(0x400)
00412cfe  
00412d0a  int32_t* esi = arg2
00412d13  int32_t result = 0
00412d15  __builtin_memset(s: *(ebp + 0x134), c: 0, n: 0x400)
00412d15  
00412d1a  if (*esi != 0)
00412d21      arg2 = esi
00412d21      
00412db6      do
00412d2d          int32_t* ebx_1 = nullptr
00412d2f          result = sx.d(**esi)
00412d32          int32_t* edx_1 = *(*(ebp + 0x134) + (result << 2))
00412d32          
00412d37          if (edx_1 != 0)
00412d39              while (true)
00412d39                  int32_t edi_1 = *edx_1
00412d3b                  int32_t i = 0xffffffff
00412d3e                  result = 0
00412d3e                  
00412d40                  while (i != 0)
00412d40                      bool cond:1_1 = 0 != *edi_1
00412d40                      edi_1 += 1
00412d40                      i -= 1
00412d40                      
00412d40                      if (not(cond:1_1))
00412d40                          break
00412d40                  
00412d42                  int32_t edi_2 = *esi
00412d49                  int32_t i_1 = 0xffffffff
00412d49                  
00412d4c                  while (i_1 != 0)
00412d4c                      bool cond:2_1 = 0 != *edi_2
00412d4c                      edi_2 += 1
00412d4c                      i_1 -= 1
00412d4c                      
00412d4c                      if (not(cond:2_1))
00412d4c                          break
00412d4c                  
00412d53                  if (not.d(i) - 1 u< not.d(i_1) - 1)
00412d66                      esi[2] = edx_1
00412d66                      
00412d69                      if (ebx_1 == 0)
00412d76                          ebp = arg1
00412d7a                          result = sx.d(**esi)
00412d83                          *(*(ebp + 0x134) + (result << 2)) = esi
00412d69                      else
00412d6b                          ebp = arg1
00412d6f                          ebx_1[2] = esi
00412d6f                      
00412d88                      if (edx_1 != 0)
00412d88                          goto label_412dac
00412d88                      
00412d88                      goto label_412d8c
00412d88                  
00412d55                  ebx_1 = edx_1
00412d57                  edx_1 = edx_1[2]
00412d57                  
00412d5c                  if (edx_1 == 0)
00412d5e                      ebp = arg1
00412d62                      break
00412d62          
00412d8c          label_412d8c:
00412d8c          esi[2] = 0
00412d8c          
00412d93          if (ebx_1 == 0)
00412da2              result = sx.d(**esi)
00412da5              *(*(ebp + 0x134) + (result << 2)) = esi
00412d93          else
00412d95              ebx_1[2] = esi
00412d95          
00412dac          label_412dac:
00412dac          esi = &arg2[3]
00412daf          arg2 = esi
00412db6      while (*esi != 0)
00412db6  
00412dc0  return result

00412dc1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00412dd0    void sub_412dd0(void* arg1, void* arg2)

00412de5  if ((*(arg1 + 0x12c) & 1) == 0)
00412dfc      void var_400
00412dfc      void arg_c
00412dfc      sub_41e690(&var_400, arg2, &arg_c)
00412e0b      void* var_414_1 = &var_400
00412e0c      int32_t var_418_1 = *(arg1 + 0x120)
00412e0d      void* var_41c_1 = arg1
00412e13      sub_410030("error: file %s, line %d: %s\n")

00412e23           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00412e30    void sub_412e30(void* arg1, void* arg2)

00412e45  if ((*(arg1 + 0x12c) & 2) == 0)
00412e5c      void var_400
00412e5c      void arg_c
00412e5c      sub_41e690(&var_400, arg2, &arg_c)
00412e6b      void* var_414_1 = &var_400
00412e6c      int32_t var_418_1 = *(arg1 + 0x120)
00412e6d      void* var_41c_1 = arg1
00412e73      sub_410030("warning: file %s, line %d: %s\n")

00412e83           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00412e90    int32_t sub_412e90(void* arg1, int32_t* arg2)

00412e97  if (arg2 != 0)
00412ea0      int32_t eax = sub_412ce0(arg1, arg2)
00412ea8      *(arg1 + 0x130) = arg2
00412eb0      return eax
00412eb0  
00412ebb  int32_t eax_1 = sub_412ce0(arg1, &data_42d568)
00412ec3  *(arg1 + 0x130) = &data_42d568
00412ece  return eax_1

00412ecf                                               90                                                                 .

00412ed0    int32_t sub_412ed0(void* arg1)

00412ee0  while (true)
00412ee0      char i
00412ee0      
00412ee0      if (**(arg1 + 0x108) s<= 0x20)
00412f07          char* eax_2
00412f07          
00412f07          do
00412ee2              eax_2 = *(arg1 + 0x108)
00412ee8              i = *eax_2
00412ee8              
00412eec              if (i == 0)
00412f89                  return 0
00412f89              
00412ef5              if (i == 0xa)
00412ef7                  *(arg1 + 0x120) += 1
00412ef7              
00412efe              *(arg1 + 0x108) = &eax_2[1]
00412f07          while (eax_2[1] s<= 0x20)
00412f07      
00412f09      char* eax_4 = *(arg1 + 0x108)
00412f09      
00412f11      if (*eax_4 == 0x2f)
00412f13          i = eax_4[1]
00412f16          void* eax_5 = &eax_4[1]
00412f16          
00412f19          if (i == 0x2f)
00412f1b              *(arg1 + 0x108) = eax_5
00412f1b              
00412f31              do
00412f21                  eax_5 += 1
00412f22                  *(arg1 + 0x108) = eax_5
00412f28                  i = *eax_5
00412f28                  
00412f2c                  if (i == 0)
00412f89                      return 0
00412f31              while (i != 0xa)
00412f31              
00412f33              *(arg1 + 0x120) += 1
00412f3a              label_412f3a:
00412f3a              *(arg1 + 0x108) = eax_5 + 1
00412f3a              
00412f43              if (*(eax_5 + 1) == 0)
00412f43                  break
00412f43              
00412f43              continue
00412f19          else if (i == 0x2a)
00412f4c              *(arg1 + 0x108) = eax_5
00412f4c              
00412f52              while (true)
00412f52                  eax_5 += 1
00412f53                  *(arg1 + 0x108) = eax_5
00412f59                  i = *eax_5
00412f59                  
00412f5d                  if (i == 0)
00412f89                      return 0
00412f89                  
00412f62                  if (i == 0xa)
00412f64                      *(arg1 + 0x120) += 1
00412f64                  
00412f6d                  if (*eax_5 == 0x2a)
00412f72                      if (*(eax_5 + 1) == 0x2f)
00412f72                          break
00412f72              
00412f7a              eax_5 = *(arg1 + 0x108) + 1
00412f7b              *(arg1 + 0x108) = eax_5
00412f7b              
00412f84              if (*eax_5 == 0)
00412f84                  break
00412f84              
00412f84              goto label_412f3a
00412f84      
00412f90      return 1
00412f90  
00412f89  return 0

00412f91                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00412fa0    int32_t sub_412fa0(void* arg1, char* arg2)

00412fac  char* edi_1 = *(arg1 + 0x108) + 1
00412faf  *(arg1 + 0x108) = edi_1
00412fb5  char eax = *edi_1
00412fc0  int32_t ecx_1
00412fc0  
00412fc0  if (sx.d(eax) - 0x22 u> 0x56)
004130c3      label_4130c3:
004130c3      
004130c3      if (eax s< 0x30 || eax s> 0x39)
004130cb          sub_412dd0(arg1, "unknown escape char")
004130cb      
004130d9      ecx_1 = 0
004130db      int32_t i = sx.d(**(arg1 + 0x108))
004130db      
004130e1      if (i s>= 0x30)
004130e6          while (i s<= 0x39)
004130f1              char* edi_4 = *(arg1 + 0x108) + 1
004130f2              ecx_1 = i + ecx_1 * 0xa - 0x30
004130f8              *(arg1 + 0x108) = edi_4
004130fe              i = sx.d(*edi_4)
004130fe              
00413104              if (i s< 0x30)
00413104                  break
00413104      
00413113      *(arg1 + 0x108) -= 1
00413113      
00413119      if (ecx_1 s> 0xff)
00413121          sub_412e30(arg1, "too large value in escape charac…")
00413129          ecx_1 = 0xff
00412fc0  else
00412fc8      int32_t edx_1
00412fc8      edx_1.b = *(sx.d(eax) + &jump_table_41314c[4]:2)
00412fc8      
00412fce      switch (edx_1)
0041302f          case 0
0041302f              ecx_1 = 0x22
00413025          case 1
00413025              ecx_1 = 0x27
00413039          case 2
00413039              ecx_1 = 0x3f
00412fd5          case 3
00412fd5              ecx_1 = 0x5c
0041301b          case 4
0041301b              ecx_1 = 7
00413007          case 5
00413007              ecx_1 = 8
00413011          case 6
00413011              ecx_1 = 0xc
00412fdf          case 7
00412fdf              ecx_1 = 0xa
00412fe9          case 8
00412fe9              ecx_1 = 0xd
00412ff3          case 9
00412ff3              ecx_1 = 9
00412ffd          case 0xa
00412ffd              ecx_1 = 0xb
00413044          case 0xb
00413044              *(arg1 + 0x108) = &edi_1[1]
0041304a              ecx_1 = 0
0041304a              
0041304c              while (true)
0041304c                  char* edx_2 = *(arg1 + 0x108)
00413052                  int32_t eax_1 = sx.d(*edx_2)
00413052                  
0041305d                  if (eax_1 s>= 0x30 && eax_1 s<= 0x39)
00413065                      ecx_1 = (ecx_1 << 4) + eax_1 - 0x30
00413068                      *(arg1 + 0x108) = &edx_2[1]
0041306e                      continue
0041306e                  
00413078                  if (eax_1 s>= 0x41 && eax_1 s<= 0x5a)
00413080                      ecx_1 = (ecx_1 << 4) + eax_1 - 0x37
00413083                      *(arg1 + 0x108) = &edx_2[1]
00413089                      continue
00413089                  
0041308e                  if (eax_1 s< 0x61)
0041308e                      break
0041308e                  
00413093                  if (eax_1 s> 0x7a)
00413093                      break
00413093                  
0041309b                  ecx_1 = (ecx_1 << 4) + eax_1 - 0x57
0041309e                  *(arg1 + 0x108) = &edx_2[1]
0041309e              
004130b3              *(arg1 + 0x108) -= 1
004130b3              
004130b9              if (ecx_1 s> 0xff)
00413121                  sub_412e30(arg1, "too large value in escape charac…")
00413129                  ecx_1 = 0xff
00412fce          case 0xc
00412fce              goto label_4130c3
00412fce  
0041313a  *(arg1 + 0x108) += 1
00413140  *arg2 = ecx_1.b
00413148  return 1

00413149                             8d 49 00                                                                       .I.
0041314c  uint32_t jump_table_41314c[0xd] = 
0041314c  {
0041314c      [0x0] =  0x0041302f
00413150      [0x1] =  0x00413025
00413154      [0x2] =  0x00413039
00413158      [0x3] =  0x00412fd5
0041315c      [0x4] =  0x0041301b
00413160      [0x5] =  0x00413007
00413164      [0x6] =  0x00413011
00413168      [0x7] =  0x00412fdf
0041316c      [0x8] =  0x00412fe9
00413170      [0x9] =  0x00412ff3
00413174      [0xa] =  0x00412ffd
00413178      [0xb] =  0x00413043
0041317c      [0xc] =  0x004130bd
00413180  }
00413180  uint8_t lookup_table_413180[0x57] = 
00413180  {
00413180      [0x00] =  0x00
00413181      [0x01] =  0x0c
00413182      [0x02] =  0x0c
00413183      [0x03] =  0x0c
00413184      [0x04] =  0x0c
00413185      [0x05] =  0x01
00413186      [0x06] =  0x0c
00413187      [0x07] =  0x0c
00413188      [0x08] =  0x0c
00413189      [0x09] =  0x0c
0041318a      [0x0a] =  0x0c
0041318b      [0x0b] =  0x0c
0041318c      [0x0c] =  0x0c
0041318d      [0x0d] =  0x0c
0041318e      [0x0e] =  0x0c
0041318f      [0x0f] =  0x0c
00413190      [0x10] =  0x0c
00413191      [0x11] =  0x0c
00413192      [0x12] =  0x0c
00413193      [0x13] =  0x0c
00413194      [0x14] =  0x0c
00413195      [0x15] =  0x0c
00413196      [0x16] =  0x0c
00413197      [0x17] =  0x0c
00413198      [0x18] =  0x0c
00413199      [0x19] =  0x0c
0041319a      [0x1a] =  0x0c
0041319b      [0x1b] =  0x0c
0041319c      [0x1c] =  0x0c
0041319d      [0x1d] =  0x02
0041319e      [0x1e] =  0x0c
0041319f      [0x1f] =  0x0c
004131a0      [0x20] =  0x0c
004131a1      [0x21] =  0x0c
004131a2      [0x22] =  0x0c
004131a3      [0x23] =  0x0c
004131a4      [0x24] =  0x0c
004131a5      [0x25] =  0x0c
004131a6      [0x26] =  0x0c
004131a7      [0x27] =  0x0c
004131a8      [0x28] =  0x0c
004131a9      [0x29] =  0x0c
004131aa      [0x2a] =  0x0c
004131ab      [0x2b] =  0x0c
004131ac      [0x2c] =  0x0c
004131ad      [0x2d] =  0x0c
004131ae      [0x2e] =  0x0c
004131af      [0x2f] =  0x0c
004131b0      [0x30] =  0x0c
004131b1      [0x31] =  0x0c
004131b2      [0x32] =  0x0c
004131b3      [0x33] =  0x0c
004131b4      [0x34] =  0x0c
004131b5      [0x35] =  0x0c
004131b6      [0x36] =  0x0c
004131b7      [0x37] =  0x0c
004131b8      [0x38] =  0x0c
004131b9      [0x39] =  0x0c
004131ba      [0x3a] =  0x03
004131bb      [0x3b] =  0x0c
004131bc      [0x3c] =  0x0c
004131bd      [0x3d] =  0x0c
004131be      [0x3e] =  0x0c
004131bf      [0x3f] =  0x04
004131c0      [0x40] =  0x05
004131c1      [0x41] =  0x0c
004131c2      [0x42] =  0x0c
004131c3      [0x43] =  0x0c
004131c4      [0x44] =  0x06
004131c5      [0x45] =  0x0c
004131c6      [0x46] =  0x0c
004131c7      [0x47] =  0x0c
004131c8      [0x48] =  0x0c
004131c9      [0x49] =  0x0c
004131ca      [0x4a] =  0x0c
004131cb      [0x4b] =  0x0c
004131cc      [0x4c] =  0x07
004131cd      [0x4d] =  0x0c
004131ce      [0x4e] =  0x0c
004131cf      [0x4f] =  0x0c
004131d0      [0x50] =  0x08
004131d1      [0x51] =  0x0c
004131d2      [0x52] =  0x09
004131d3      [0x53] =  0x0c
004131d4      [0x54] =  0x0a
004131d5      [0x55] =  0x0c
004131d6      [0x56] =  0x0b
004131d7  }

004131d7                                                                       90 90 90 90 90 90 90 90 90                         .........

004131e0    int32_t sub_4131e0(void* arg1, char* arg2, int32_t arg3)

004131eb  char* ebx
004131eb  
004131eb  if (arg3 != 0x22)
00413201      ebx = arg2
00413203      *(arg2 + 0x400) = 2
004131eb  else
004131ed      ebx = arg2
004131f1      *(ebx + 0x400) = 1
004131f1  
0041320d  void* esi = arg1
00413211  char* edi = 1
00413216  void* ebp = &ebx[1]
00413221  *ebx = **(esi + 0x108)
0041322a  *(esi + 0x108) += 1
0041322a  
00413230  while (true)
00413230      arg1 = ebp
00413230      
0041323a      while (true)
0041323a          if (edi s>= 0x3fe)
004132ea              int32_t var_14_3 = 0x400
004132f5              sub_412dd0(esi, "string longer than MAX_TOKEN = %…")
00413303              return 0
00413303          
00413240          char* ecx_1 = *(esi + 0x108)
00413246          void* eax_2
00413246          eax_2.b = *ecx_1
00413246          
00413253          if (eax_2.b == 0x5c && (*(esi + 0x12c) & 8) == 0)
00413257              sub_412fa0(esi, ebp)
00413267              edi = &edi[1]
00413268              ebp += 1
00413269              break
00413269          
00413272          if (sx.d(eax_2.b) != arg3)
004132c5              if (eax_2.b == 0)
00413341                  *(edi + ebx) = 0
00413345                  sub_412dd0(esi, "missing trailing quote")
00413353                  return 0
00413353              
004132c9              if (eax_2.b == 0xa)
00413354                  char* var_14_4 = ebx
0041335b                  *(edi + ebx) = 0
0041335f                  sub_412dd0(esi, "newline inside string %s")
0041336d                  return 0
0041336d              
004132cf              *ebp = eax_2.b
004132d8              edi = &edi[1]
004132d9              ebp += 1
004132db              arg1 = ebp
004132df              *(esi + 0x108) += 1
00413272          else
00413274              eax_2.b = *(esi + 0x12c)
0041327f              *(esi + 0x108) = &ecx_1[1]
0041327f              
00413285              if ((eax_2.b & 4) != 0)
00413285                  goto label_41331f
00413285              
0041328b              int32_t ebx_1 = *(esi + 0x120)
00413292              int32_t eax_3
00413292              int32_t edx_1
00413292              eax_3, edx_1 = sub_412ed0(esi)
0041329c              char* eax_4
0041329c              
0041329c              if (eax_3 != 0)
0041329e                  eax_4 = *(esi + 0x108)
0041329e              
004132ad              if (eax_3 == 0 || sx.d(*eax_4) != arg3)
0041330f                  *(esi + 0x120) = ebx_1
00413315                  ebx = arg2
00413319                  *(esi + 0x108) = &ecx_1[1]
0041331f                  label_41331f:
0041331f                  edx_1.b = arg3.b
00413328                  *(edi + ebx) = edx_1.b
0041332c                  *(&edi[1] + ebx) = 0
00413330                  *(ebx + 0x404) = &edi[1]
0041333a                  return 1
0041333a              
004132af              ebx = arg2
004132b3              ebp = arg1
004132b8              *(esi + 0x108) = &eax_4[1]

0041336e                                            90 90                                                                ..

00413370    int32_t sub_413370(void* arg1, char* arg2)

00413379  *(arg2 + 0x400) = 4
0041338b  *arg2 = **(arg1 + 0x108)
00413393  char* eax_2 = *(arg1 + 0x108) + 1
00413394  char* i = 1
00413399  *(arg1 + 0x108) = eax_2
00413399  
004133d4  do
0041339f      eax_2.b = *eax_2
0041339f      
004133bb      if ((eax_2.b s< 0x61 || eax_2.b s> 0x7a) && (eax_2.b s< 0x41 || eax_2.b s> 0x5a)
004133bb              && (eax_2.b s< 0x30 || eax_2.b s> 0x39) && eax_2.b != 0x5f)
004133ed          *(i + arg2) = 0
004133f1          *(arg2 + 0x404) = i
004133fd          return 1
004133fd      
004133bd      *(i + arg2) = eax_2.b
004133c6      i = &i[1]
004133c7      eax_2 = *(arg1 + 0x108) + 1
004133ce      *(arg1 + 0x108) = eax_2
004133d4  while (i s< 0x400)
004133d4  
004133d6  int32_t var_8 = 0x400
004133e1  sub_412dd0(arg1, "name longer than MAX_TOKEN = %d")
004133ec  return 0

004133fe                                                                                            90 90                                ..

00413400    int32_t sub_413400(char* arg1, char* arg2, int32_t* arg3, int32_t* arg4)

00413407  int32_t eax = 0
00413416  *arg3 = 0
00413418  *arg4 = 0
0041341a  arg4[1] = 0
0041341a  
00413420  if ((arg2:1.b & 8) != 0)
00413422      char* edx_1 = arg1
00413426      char* ecx
00413426      ecx.b = *edx_1
00413426      
0041342a      while (ecx.b != 0)
0041342f          if (ecx.b == 0x2e)
00413433              if (eax != 0)
004135ae                  return eax
004135ae              
00413439              eax = 0xa
0041343e              edx_1 = &edx_1[1]
00413433              goto label_413453
00413433          
00413443          if (eax == 0)
00413484              *arg4 = fconvert.d(float.t(sx.d(ecx.b) - 0x30)
00413484                  + fconvert.t(*arg4) * fconvert.t(10.0))
00413443          else
00413453              label_413453:
00413453              int32_t var_4_1 = 0
0041345b              long double x87_r6_1 = float.t(eax.q)
00413462              eax *= 0xa
00413468              *arg4 =
00413468                  fconvert.d(float.t(sx.d(*edx_1) - 0x30) / x87_r6_1 + fconvert.t(*arg4))
00413468          
00413486          ecx.b = edx_1[1]
00413489          edx_1 = &edx_1[1]
00413489      
00413490      int16_t x87control
00413490      int32_t eax_2 = __ftol(x87control, fconvert.t(*arg4))
00413495      *arg3 = eax_2
0041349d      return eax_2
0041349d  
004134a1  if ((arg2.b & 8) != 0)
004134a3      char* edx_2 = arg1
004134a7      eax.b = *edx_2
004134a7      
004134ab      while (eax.b != 0)
004134af          edx_2 = &edx_2[1]
004134ba          *arg3 = sx.d(eax.b) + *arg3 * 0xa - 0x30
004134bc          eax.b = *edx_2
004134bc      
004134c4      int32_t var_4_2 = 0
004134d0      *arg4 = fconvert.d(float.t((*arg3).q))
004134d8      return eax
004134d8  
004134dc  if ((arg2:1.b & 1) != 0)
004134e2      void* edx_5 = &arg1[2]
004134e2      
004134e7      while (*edx_5 != 0)
004134eb          int32_t eax_4 = *arg3 << 4
004134ee          *arg3 = eax_4
004134f0          int32_t ecx_6 = eax_4
004134f2          eax_4.b = *edx_5
004134fa          int32_t ecx_7
004134fa          
004134fa          if (eax_4.b s>= 0x61 && eax_4.b s<= 0x66)
004134fc              eax = sx.d(eax_4.b)
004134ff              ecx_7 = eax + ecx_6 - 0x57
004134fa          else if (eax_4.b s< 0x41 || eax_4.b s> 0x46)
00413516              eax = sx.d(eax_4.b)
00413519              ecx_7 = eax + ecx_6 - 0x30
0041350b          else
0041350d              eax = sx.d(eax_4.b)
00413510              ecx_7 = eax + ecx_6 - 0x37
00413510          
0041351d          edx_5 += 1
0041351e          *arg3 = ecx_7
0041351e      
00413526      int32_t var_4_3 = 0
00413532      *arg4 = fconvert.d(float.t((*arg3).q))
0041353a      return eax
0041353a  
0041353e  if ((arg2:1.b & 2) != 0)
00413544      char* ecx_9 = &arg1[1]
00413545      eax.b = *ecx_9
00413545      
00413549      while (eax.b != 0)
0041354d          ecx_9 = &ecx_9[1]
00413555          *arg3 = sx.d(eax.b) + (*arg3 << 3) - 0x30
00413557          eax.b = *ecx_9
00413557      
0041355d      int32_t eax_5 = *arg3
0041355f      int32_t var_4_4 = 0
0041356b      *arg4 = fconvert.d(float.t(eax_5.q))
00413573      return eax_5
00413573  
00413577  if ((arg2:1.b & 4) != 0)
0041357d      char* ecx_11 = &arg1[2]
00413580      eax.b = *ecx_11
00413580      
00413584      while (eax.b != 0)
00413588          ecx_11 = &ecx_11[1]
00413590          *arg3 = sx.d(eax.b) + (*arg3 << 1) - 0x30
00413592          eax.b = *ecx_11
00413592      
00413598      eax = *arg3
0041359a      int32_t var_4_5 = 0
004135a6      *arg4 = fconvert.d(float.t(eax.q))
004135a6  
004135ae  return eax

004135af                                               90                                                                 .

004135b0    int32_t sub_4135b0(void* arg1, char* arg2)

004135b7  char* esi = arg2
004135bc  char* ecx = nullptr
004135be  *(esi + 0x400) = 3
004135c8  char* edi = *(arg1 + 0x108)
004135ce  char edx = *edi
004135d3  void* edx_3
004135d3  
004135d3  if (edx != 0x30)
00413703      label_413703:
00413703      int32_t edi_5 = 0
00413705      int32_t ebp_1 = 0
00413705      
0041370a      if (edx == 0x30)
0041370c          edi_5 = 1
0041370c      
00413717      while (true)
00413717          ecx = &ecx[1]
00413718          char* edx_6
00413718          edx_6.b = **(arg1 + 0x108)
0041371a          *(ecx + esi - 1) = edx_6.b
00413724          char* edx_8 = *(arg1 + 0x108) + 1
0041372b          *(arg1 + 0x108) = edx_8
0041372b          
00413731          if (ecx s>= 0x400)
0041375b              int32_t var_14_2 = 0x400
00413766              sub_412dd0(arg1, "number longer than MAX_TOKEN = %…")
00413774              return 0
00413774          
00413733          edx_8.b = *edx_8
00413733          
00413738          if (edx_8.b != 0x2e)
00413749              if (edx_8.b != 0x38 && edx_8.b != 0x39)
0041374e                  if (edx_8.b s< 0x30)
0041374e                      break
0041374e                  
00413753                  if (edx_8.b s> 0x39)
00413753                      break
00413753                  
00413753                  continue
00413753              
00413757              edi_5 = 0
00413738          else
0041373a              ebp_1 = 1
0041373a      
00413775      edx_3 = *(esi + 0x404)
00413775      
0041377d      if (edi_5 == 0)
00413784          edx_3 |= 8
0041377d      else
0041377f          edx_3:1.b |= 2
0041377f      
00413789      *(esi + 0x404) = edx_3
00413789      
0041378f      if (ebp_1 != 0)
00413791          edx_3:1.b |= 8
00413794          *(esi + 0x404) = edx_3
004135d3  else
004135d9      int32_t ebx
004135d9      ebx.b = edi[1]
004135d9      
004135e4      if (ebx.b == 0x78 || ebx.b == 0x58)
004135ea          *esi = 0x30
004135f3          char* edi_2 = *(arg1 + 0x108) + 1
004135f6          *(arg1 + 0x108) = edi_2
004135fc          char* ecx_1
004135fc          ecx_1.b = *edi_2
004135fe          esi[1] = ecx_1.b
00413607          char* edx_2 = *(arg1 + 0x108) + 1
00413608          ecx = 2
0041360d          *(arg1 + 0x108) = edx_2
0041360d          
00413613          while (true)
00413613              edx_2.b = *edx_2
00413613              
00413627              if ((edx_2.b s< 0x30 || edx_2.b s> 0x39)
00413627                      && (edx_2.b s< 0x61 || edx_2.b s> 0x66))
0041362c                  if (edx_2.b s< 0x41)
0041362c                      break
0041362c                  
0041362e                  if (edx_2.b s> 0x41)
0041362e                      break
0041362e              
00413630              *(ecx + esi) = edx_2.b
00413639              ecx = &ecx[1]
0041363a              char* ebx_2 = *(arg1 + 0x108) + 1
00413641              *(arg1 + 0x108) = ebx_2
00413647              edx_2 = ebx_2
00413647              
00413649              if (ecx s>= 0x400)
0041364b                  int32_t var_14 = 0x400
00413656                  sub_412dd0(arg1, "hexadecimal number longer than M…")
00413664                  return 0
00413664          
0041366b          edx_3:1.b = (*(esi + 0x404)):1.b | 1
00413794          *(esi + 0x404) = edx_3
004135e4      else
00413676          if (edx != 0x30)
00413676              goto label_413703
00413676          
0041367c          ebx.b = edi[1]
0041367c          
00413687          if (ebx.b != 0x62 && ebx.b != 0x42)
00413682              goto label_413703
00413682          
00413689          *esi = 0x30
00413692          char* edi_4 = *(arg1 + 0x108) + 1
00413695          *(arg1 + 0x108) = edi_4
0041369d          ecx = 2
004136a2          esi[1] = *edi_4
004136ab          char* edx_5 = *(arg1 + 0x108) + 1
004136ac          *(arg1 + 0x108) = edx_5
004136ac          
004136b2          while (true)
004136b2              edx_5.b = *edx_5
004136b2              
004136bc              if (edx_5.b != 0x30 && edx_5.b != 0x31)
004136e1                  edx_3:1.b = (*(esi + 0x404)):1.b | 4
004136e4                  break
004136e4              
004136be              *(ecx + esi) = edx_5.b
004136c7              ecx = &ecx[1]
004136c8              char* ebx_4 = *(arg1 + 0x108) + 1
004136cf              *(arg1 + 0x108) = ebx_4
004136d5              edx_5 = ebx_4
004136d5              
004136d7              if (ecx s>= 0x400)
004136e9                  int32_t var_14_1 = 0x400
004136f4                  sub_412dd0(arg1, "binary number longer than MAX_TO…")
00413702                  return 0
00413702          
00413794          *(esi + 0x404) = edx_3
00413794  
0041379a  arg2 = 2
0041380c  bool cond:5_1
0041380c  
0041380c  do
004137ac      char* edi_6 = *(arg1 + 0x108)
004137b2      edx_3.b = *edi_6
004137b2      
004137b7      if (edx_3.b == 0x6c)
004137ef          label_4137ef:
004137ef          *(arg1 + 0x108) = &edi_6[1]
004137fd          *(esi + 0x404) |= 0x2000
004137b7      else if (edx_3.b != 0x4c)
004137cb          if (edx_3.b == 0x75)
004137de              label_4137de:
004137de              *(arg1 + 0x108) = &edi_6[1]
004137fd              *(esi + 0x404) |= 0x4000
004137cb          else if (edx_3.b == 0x55 && ((*(esi + 0x404)).w:1.b & 0x48) == 0)
004137db              goto label_4137de
004137bc      else if ((*(esi + 0x404) & 0x2000) == 0)
004137c4          goto label_4137ef
004137c4      
00413807      cond:5_1 = arg2 != 1
00413808      arg2 -= 1
0041380c  while (cond:5_1)
0041380e  *(ecx + esi) = 0
00413828  sub_413400(esi, *(esi + 0x404), &esi[0x408], &esi[0x410])
0041382d  int32_t eax_4 = *(esi + 0x404)
0041382d  
00413839  if ((eax_4:1.b & 8) == 0)
0041383b      eax_4:1.b |= 0x10
0041383e      *(esi + 0x404) = eax_4
0041383e  
0041384d  return 1

0041384e                                            90 90                                                                ..

00413850    int32_t sub_413850(void* arg1, char* arg2)

0041386c  for (int32_t* i = *(*(arg1 + 0x134) + (sx.d(**(arg1 + 0x108)) << 2)); i != 0; i = i[2])
0041386e      void* esi_1 = *i
00413871      int32_t j = 0xffffffff
00413874      void* edi_1 = esi_1
00413874      
00413878      while (j != 0)
00413878          bool cond:0_1 = 0 != *edi_1
00413878          edi_1 += 1
00413878          j -= 1
00413878          
00413878          if (not(cond:0_1))
00413878              break
00413878      
0041387a      void* eax_1 = *(arg1 + 0x108)
0041387a      
00413890      if (eax_1 + not.d(j) - 1 u<= *(arg1 + 0x10c)
00413890              && sub_41f430(eax_1, esi_1, not.d(j) - 1) == 0)
004138ba          sub_41e720(arg2, esi_1, 0x400)
004138ca          *(arg1 + 0x108) += not.d(j) - 1
004138d0          *(arg2 + 0x400) = 5
004138de          *(arg2 + 0x404) = i[1]
004138ec          return 1
004138ec  
004138ae  return 0

004138ed                                         90 90 90                                                               ...

004138f0    int32_t sub_4138f0(void* arg1, int32_t arg2)

004138f4  char* ecx = nullptr
004138f4  
00413904  if (**(arg1 + 0x108) s> 0x20)
0041392f      char* edx_3
0041392f      
0041392f      do
0041390c          char* edx_1
0041390c          edx_1.b = **(arg1 + 0x108)
0041390c          
00413911          if (edx_1.b == 0x3b)
00413911              break
00413911          
00413919          if (ecx s>= 0x400)
0041394b              int32_t __saved_edi = 0x400
00413956              sub_412dd0(arg1, "primitive token longer than MAX_…")
00413961              return 0
00413961          
0041391b          ecx[arg2] = edx_1.b
00413924          ecx = &ecx[1]
00413925          edx_3 = *(arg1 + 0x108) + 1
00413926          *(arg1 + 0x108) = edx_3
0041392f      while (*edx_3 s> 0x20)
0041392f  
00413932  ecx[arg2] = 0
00413941  __builtin_memcpy(dest: arg1 + 0x138, src: arg2, n: 0x430)
0041394a  return 1

00413962        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00413970    int32_t sub_413970(void* arg1, char* arg2)

0041397f  if (*(arg1 + 0x128) != 0)
00413990      *(arg1 + 0x128) = 0
0041399a      __builtin_memcpy(dest: arg2, src: arg1 + 0x138, n: 0x430)
004139a4      return 1
004139a4  
004139ab  int32_t ecx = *(arg1 + 0x120)
004139b5  *(arg1 + 0x110) = *(arg1 + 0x108)
004139bb  *(arg1 + 0x124) = ecx
004139ca  __builtin_memset(s: arg2, c: 0, n: 0x430)
004139cc  int32_t eax_3 = *(arg1 + 0x108)
004139d3  *(arg1 + 0x114) = eax_3
004139d9  *(arg2 + 0x418) = eax_3
004139df  int32_t eax_4 = sub_412ed0(arg1)
004139df  
004139e9  if (eax_4 == 0)
004139ee      return eax_4
004139ee  
004139ef  int32_t eax_5 = *(arg1 + 0x108)
004139f5  *(arg1 + 0x118) = eax_5
004139fb  *(arg2 + 0x41c) = eax_5
00413a07  *(arg2 + 0x420) = *(arg1 + 0x120)
00413a19  *(arg2 + 0x424) = *(arg1 + 0x120) - *(arg1 + 0x124)
00413a1f  char* edi_2 = *(arg1 + 0x108)
00413a25  int32_t eax_7
00413a25  eax_7.b = *edi_2
00413a25  
00413a29  if (eax_7.b == 0x22)
00413a2f      int32_t eax_8 = sub_4131e0(arg1, arg2, 0x22)
00413a2f      
00413a39      if (eax_8 == 0)
00413a42          return eax_8
00413a29  else if (eax_7.b != 0x27)
00413a65      char ecx_1
00413a65      
00413a65      if ((eax_7.b s< 0x30 || eax_7.b s> 0x39) && eax_7.b == 0x2e)
00413a6b          ecx_1 = edi_2[1]
00413a6b      
00413a76      if ((eax_7.b s< 0x30 || eax_7.b s> 0x39)
00413a76              && (eax_7.b != 0x2e || ecx_1 s< 0x30 || ecx_1 s> 0x39))
00413a91          if ((*(arg1 + 0x12c) & 0x10) != 0)
00413aa0              return sub_4138f0(arg1, arg2)
00413aa0          
00413ab3          if ((eax_7.b s< 0x61 || eax_7.b s> 0x7a) && (eax_7.b s< 0x41 || eax_7.b s> 0x5a)
00413ab3                  && eax_7.b != 0x5f)
00413ad3              if (sub_413850(arg1, arg2) == 0)
00413adb                  sub_412dd0(arg1, "can't read token")
00413ae8                  return 0
00413ab3          else
00413ab7              int32_t eax_12 = sub_413370(arg1, arg2)
00413ab7              
00413ac1              if (eax_12 == 0)
00413ac6                  return eax_12
00413a76      else
00413a7a          int32_t eax_10 = sub_4135b0(arg1, arg2)
00413a7a          
00413a84          if (eax_10 == 0)
00413a89              return eax_10
00413a45  else
00413a4b      int32_t eax_9 = sub_4131e0(arg1, arg2, 0x27)
00413a4b      
00413a55      if (eax_9 == 0)
00413a5e          return eax_9
00413a5e  
00413af4  __builtin_memcpy(dest: arg1 + 0x138, src: arg2, n: 0x430)
00413afe  return 1

00413aff                                                                                               90                                 .

00413b00    int32_t sub_413b00(void* arg1, char* arg2)

00413b1f  char var_430[0x430]
00413b1f  
00413b1f  if (sub_413970(arg1, &var_430) == 0)
00413b28      char* var_43c_1 = arg2
00413b2f      sub_412dd0(arg1, "couldn't find expected %s")
00413b41      return 0
00413b41  
00413b49  int32_t ebx
00413b49  int32_t var_43c_2 = ebx
00413b4b  char* esi = arg2
00413b4d  char (* eax_2)[0x430] = &var_430
00413b51  int32_t eax_4
00413b51  
00413b51  while (true)
00413b51      char edx_1 = *eax_2
00413b53      ebx.b = *esi
00413b57      bool c_1 = edx_1 u< ebx.b
00413b57      
00413b59      if (edx_1 == ebx.b)
00413b5d          if (edx_1 == 0)
00413b75              eax_4 = 0
00413b77              break
00413b77          
00413b5f          edx_1 = (*eax_2)[1]
00413b62          ebx.b = esi[1]
00413b67          c_1 = edx_1 u< ebx.b
00413b67          
00413b69          if (edx_1 == ebx.b)
00413b6b              eax_2 = &(*eax_2)[2]
00413b6e              esi = &esi[2]
00413b6e              
00413b73              if (edx_1 != 0)
00413b73                  continue
00413b73              
00413b75              eax_4 = 0
00413b77              break
00413b77      
00413b79      bool c_2 = unimplemented  {sbb eax, eax}
00413b7b      eax_4 = sbb.d(sbb.d(eax_2, eax_2, c_1), 0xffffffff, c_2)
00413b7b      break
00413b7b  
00413b82  if (eax_4 == 0)
00413bb0      return 1
00413bb0  
00413b88  char (* var_43c_3)[0x430] = &var_430
00413b89  char* __saved_esi_1 = arg2
00413b90  sub_412dd0(arg1, "expected %s, found %s")
00413ba2  return 0

00413bb1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00413bc0    int32_t sub_413bc0(void* arg1, int32_t arg2, int32_t arg3, char* arg4)

00413bcf  void* ebp = arg1
00413bcf  
00413be4  if (sub_413970(ebp, arg4) == 0)
00413bec      sub_412dd0(ebp, "couldn't read expected token")
00413c00      return 0
00413c00  
00413c01  int32_t eax_2 = *(arg4 + 0x400)
00413c10  int32_t var_400
00413c10  int16_t var_3fc
00413c10  int32_t ecx
00413c10  
00413c10  if (eax_2 != arg2)
00413c19      if (arg2 == 1)
00413c20          ecx.w = (*"ng")[0].w
00413c2d          var_400 = (*"string")[0].d
00413c31          int16_t var_3fc_1 = ecx.w
00413c36          char var_3fa_1 = data_42db14[6][0]
00413c19      else if (arg2 == 2)
00413c4c          var_400 = (*"literal")[0].d
00413c50          var_3fc.d = (*"ral")[0].d
00413c3f      else if (arg2 == 3)
00413c61          eax_2.w = (*"er")[0].w
00413c67          ecx.b = data_42db04[6][0]
00413c6d          var_400 = (*"number")[0].d
00413c71          int16_t var_3fc_2 = eax_2.w
00413c76          char var_3fa_2 = ecx.b
00413c59      else if (arg2 == 4)
00413c87          eax_2.b = data_42dafc[4][0]
00413c8c          var_400 = (*"name")[0].d
00413c90          var_3fc.b = eax_2.b
00413c7f      else if (arg2 == 5)
00413cac          var_400 = (*"punctuation")[0].d
00413cb0          var_3fc.d = (*"tuation")[0].d
00413cb4          int32_t var_3f8_1 = (*"ion")[0].d
00413cb4      
00413cbc      char* var_414_1 = arg4
00413cbd      int32_t* var_418_2 = &var_400
00413cc4      sub_412dd0(ebp, "expected a %s, found %s")
00413cd8      return 0
00413cd8  
00413cdc  if (eax_2 != 3)
00413e62      if (eax_2 == 5)
00413e6d          if (arg3 s< 0)
00413e75              sub_412dd0(ebp, "BUG: wrong punctuation subtype")
00413e89              return 0
00413e89          
00413e90          if (*(arg4 + 0x404) != arg3)
00413e9b              char* var_414_3 = arg4
00413e9c              int32_t* eax_15 = *(ebp + 0x130) + arg3 * 0xc
00413eab              int32_t var_420_2 = *eax_15
00413eb1              int32_t var_41c = eax_15[1]
00413eb7              int32_t var_418_5 = eax_15[2]
00413eba              sub_412dd0(ebp, "expected %s, found %s")
00413ece              return 0
00413cdc  else if ((*(arg4 + 0x404) & arg3) != arg3)
00413cfc      if ((arg3.b & 8) != 0)
00413d09          var_400 = (*"decimal")[0].d
00413d0d          var_3fc.d = (*"mal")[0].d
00413d0d      
00413d14      if ((arg3:1.b & 1) != 0)
00413d1c          var_400 = data_42dacc
00413d1c      
00413d23      if ((arg3:1.b & 2) != 0)
00413d2a          ecx.w = (*"l")[0].w
00413d31          var_400 = (*"octal")[0].d
00413d35          int16_t var_3fc_3 = ecx.w
00413d35      
00413d3d      if ((arg3:1.b & 4) != 0)
00413d44          ecx.w = (*"ry")[0].w
00413d4b          var_400 = (*"binary")[0].d
00413d4f          int32_t eax_11
00413d4f          eax_11.b = data_42dabc[6][0]
00413d54          int16_t var_3fc_4 = ecx.w
00413d59          char var_3fa_3 = eax_11.b
00413d59      
00413d60      if ((arg3:1.b & 0x20) != 0)
00413d62          char* edi_1 = " long"
00413d67          int32_t i = 0xffffffff
00413d67          
00413d70          while (i != 0)
00413d70              bool cond:0_1 = 0 != *edi_1
00413d70              edi_1 = &edi_1[1]
00413d70              i -= 1
00413d70              
00413d70              if (not(cond:0_1))
00413d70                  break
00413d70          
00413d72          int32_t ecx_3 = not.d(i)
00413d78          int32_t* edi_3 = &var_400
00413d7c          int32_t i_1 = 0xffffffff
00413d7c          
00413d7f          while (i_1 != 0)
00413d7f              bool cond:1_1 = 0 != *edi_3
00413d7f              edi_3 += 1
00413d7f              i_1 -= 1
00413d7f              
00413d7f              if (not(cond:1_1))
00413d7f                  break
00413d7f          
00413d87          int32_t esi_2
00413d87          int32_t edi_5
00413d87          edi_5, esi_2 =
00413d87              __builtin_memcpy(dest: edi_3 - 1, src: edi_1 - ecx_3, n: ecx_3 u>> 2 << 2)
00413d8b          ebp = arg1
00413d95          __builtin_memcpy(dest: edi_5, src: esi_2, n: ecx_3 & 3)
00413d95      
00413d9a      if ((arg3:1.b & 0x40) != 0)
00413d9c          char* edi_6 = " unsigned"
00413da1          int32_t i_2 = 0xffffffff
00413da1          
00413daa          while (i_2 != 0)
00413daa              bool cond:2_1 = 0 != *edi_6
00413daa              edi_6 = &edi_6[1]
00413daa              i_2 -= 1
00413daa              
00413daa              if (not(cond:2_1))
00413daa                  break
00413daa          
00413dac          int32_t ecx_8 = not.d(i_2)
00413db2          int32_t* edi_8 = &var_400
00413db6          int32_t i_3 = 0xffffffff
00413db6          
00413db9          while (i_3 != 0)
00413db9              bool cond:3_1 = 0 != *edi_8
00413db9              edi_8 += 1
00413db9              i_3 -= 1
00413db9              
00413db9              if (not(cond:3_1))
00413db9                  break
00413db9          
00413dc1          int32_t esi_4
00413dc1          int32_t edi_10
00413dc1          edi_10, esi_4 =
00413dc1              __builtin_memcpy(dest: edi_8 - 1, src: edi_6 - ecx_8, n: ecx_8 u>> 2 << 2)
00413dc5          ebp = arg1
00413dcf          __builtin_memcpy(dest: edi_10, src: esi_4, n: ecx_8 & 3)
00413dcf      
00413dd4      if ((arg3:1.b & 8) != 0)
00413dd6          char* edi_11 = " float"
00413ddb          int32_t i_4 = 0xffffffff
00413ddb          
00413de4          while (i_4 != 0)
00413de4              bool cond:4_1 = 0 != *edi_11
00413de4              edi_11 = &edi_11[1]
00413de4              i_4 -= 1
00413de4              
00413de4              if (not(cond:4_1))
00413de4                  break
00413de4          
00413de6          int32_t ecx_13 = not.d(i_4)
00413dec          int32_t* edi_13 = &var_400
00413df0          int32_t i_5 = 0xffffffff
00413df0          
00413df3          while (i_5 != 0)
00413df3              bool cond:5_1 = 0 != *edi_13
00413df3              edi_13 += 1
00413df3              i_5 -= 1
00413df3              
00413df3              if (not(cond:5_1))
00413df3                  break
00413df3          
00413dfb          int32_t esi_6
00413dfb          int32_t edi_15
00413dfb          edi_15, esi_6 =
00413dfb              __builtin_memcpy(dest: edi_13 - 1, src: edi_11 - ecx_13, n: ecx_13 u>> 2 << 2)
00413dff          ebp = arg1
00413e09          __builtin_memcpy(dest: edi_15, src: esi_6, n: ecx_13 & 3)
00413e09      
00413e0e      if ((arg3:1.b & 0x10) != 0)
00413e10          char* edi_16 = " integer"
00413e15          int32_t i_6 = 0xffffffff
00413e15          
00413e1e          while (i_6 != 0)
00413e1e              bool cond:6_1 = 0 != *edi_16
00413e1e              edi_16 = &edi_16[1]
00413e1e              i_6 -= 1
00413e1e              
00413e1e              if (not(cond:6_1))
00413e1e                  break
00413e1e          
00413e20          int32_t ecx_18 = not.d(i_6)
00413e26          int32_t* edi_18 = &var_400
00413e2a          int32_t i_7 = 0xffffffff
00413e2a          
00413e2d          while (i_7 != 0)
00413e2d              bool cond:7_1 = 0 != *edi_18
00413e2d              edi_18 += 1
00413e2d              i_7 -= 1
00413e2d              
00413e2d              if (not(cond:7_1))
00413e2d                  break
00413e2d          
00413e35          int32_t esi_8
00413e35          int32_t edi_20
00413e35          edi_20, esi_8 =
00413e35              __builtin_memcpy(dest: edi_18 - 1, src: edi_16 - ecx_18, n: ecx_18 u>> 2 << 2)
00413e3c          __builtin_memcpy(dest: edi_20, src: esi_8, n: ecx_18 & 3)
00413e3c      
00413e42      char* var_414_2 = arg4
00413e43      int32_t* var_418_3 = &var_400
00413e4a      sub_412dd0(ebp, "expected %s, found %s")
00413e5e      return 0
00413e5e  
00413ede  return 1

00413edf                                                                                               90                                 .

00413ee0    int32_t sub_413ee0(void* arg1, char* arg2)

00413ef5  if (sub_413970(arg1, arg2) != 0)
00413f0f      return 1
00413f0f  
00413efd  sub_412dd0(arg1, "couldn't read expected token")
00413f08  return 0


00413f10    int32_t sub_413f10(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00413f2e  char var_430[0x400]
00413f2e  
00413f2e  if (sub_413970(arg1, &var_430) != 0)
00413f54      int32_t var_30
00413f54      int32_t var_2c
00413f54      
00413f54      if (var_30 == arg2 && (var_2c & arg3) == arg3)
00413f67          __builtin_memcpy(dest: arg4, src: &var_430, n: 0x430)
00413f76          return 1
00413f76      
00413f7d      *(arg1 + 0x108) = *(arg1 + 0x110)
00413f7d  
00413f8c  return 0

00413f8d                                         90 90 90                                                               ...

00413f90    void* sub_413f90(void* arg1)

00413f94  *(arg1 + 0x128) = 1
00413f9e  return arg1

00413f9f                                                                                               90                                 .

00413fa0    int32_t sub_413fa0(char* arg1)

00413fa8  while (*arg1 == 0x22)
00413faf      void* edi_1 = &arg1[1]
00413fb1      int32_t i = 0xffffffff
00413fb1      
00413fb6      while (i != 0)
00413fb6          bool cond:3_1 = 0 != *edi_1
00413fb6          edi_1 += 1
00413fb6          i -= 1
00413fb6          
00413fb6          if (not(cond:3_1))
00413fb6              break
00413fb6      
00413fb8      int32_t ecx_1 = not.d(i)
00413fc5      int32_t esi_2
00413fc5      int32_t edi_4
00413fc5      edi_4, esi_2 = __builtin_memcpy(dest: arg1, src: edi_1 - ecx_1, n: ecx_1 u>> 2 << 2)
00413fcc      __builtin_memcpy(dest: edi_4, src: esi_2, n: ecx_1 & 3)
00413fcc  
00413fd5  char* edi_5 = arg1
00413fd7  int32_t i_1 = 0xffffffff
00413fd7  
00413fdc  while (i_1 != 0)
00413fdc      bool cond:0_1 = 0 != *edi_5
00413fdc      edi_5 = &edi_5[1]
00413fdc      i_1 -= 1
00413fdc      
00413fdc      if (not(cond:0_1))
00413fdc          break
00413fdc  
00413fe6  if (arg1[not.d(i_1) - 2] == 0x22)
00414007      int32_t i_3
00414007      
00414007      do
00413fe8          char* edi_6 = arg1
00413fea          int32_t i_2 = 0xffffffff
00413fea          
00413fef          while (i_2 != 0)
00413fef              bool cond:1_1 = 0 != *edi_6
00413fef              edi_6 = &edi_6[1]
00413fef              i_2 -= 1
00413fef              
00413fef              if (not(cond:1_1))
00413fef                  break
00413fef          
00413ff4          char* edi_7 = arg1
00413ff6          arg1[not.d(i_2) - 2] = 0
00413ffa          i_3 = 0xffffffff
00413ffa          
00413ffd          while (i_3 != 0)
00413ffd              bool cond:2_1 = 0 != *edi_7
00413ffd              edi_7 = &edi_7[1]
00413ffd              i_3 -= 1
00413ffd              
00413ffd              if (not(cond:2_1))
00413ffd                  break
00414007      while (arg1[not.d(i_3) - 2] == 0x22)
00414007  
0041400a  return 0

0041400b                                   90 90 90 90 90                                                             .....

00414010    int32_t sub_414010(void* arg1, int32_t arg2)

00414018  *(arg1 + 0x12c) = arg2
0041401e  return arg2

0041401f                                                                                               90                                 .

00414020    int32_t* sub_414020(int32_t* arg1, void* arg2, void* arg3)

0041402c  int32_t* eax = sub_41df39(arg1, "rb")
0041402c  
0041403c  if (eax == 0)
00414040      return eax
00414040  
00414048  if (arg2 != 0)
0041404e      sub_41de4f(eax, arg2, FILE_BEGIN)
0041404e  
00414057  void* ebp = arg3
00414057  
0041405d  if (ebp == 0)
0041406a      ebp = sub_40fbd0(eax) - arg2
0041406a  
00414078  void* s = sub_410570(ebp + 0x571)
00414083  __builtin_memset(s, c: 0, n: 0x570)
00414085  int32_t* edi_2 = arg1
00414087  int32_t i = 0xffffffff
00414087  
0041408a  while (i != 0)
0041408a      bool cond:1_1 = 0 != *edi_2
0041408a      edi_2 += 1
0041408a      i -= 1
0041408a      
0041408a      if (not(cond:1_1))
0041408a          break
0041408a  
0041408c  int32_t ecx = not.d(i)
004140a1  int32_t esi_2
004140a1  int32_t edi_5
004140a1  edi_5, esi_2 = __builtin_memcpy(dest: s, src: edi_2 - ecx, n: ecx u>> 2 << 2)
004140a9  __builtin_memcpy(dest: edi_5, src: esi_2, n: ecx & 3)
004140ab  *(s + 0x104) = s + 0x570
004140b1  *(s + 0x570 + ebp) = 0
004140b5  void* eax_5 = *(s + 0x104)
004140c0  *(s + 0x108) = eax_5
004140c6  *(s + 0x110) = eax_5
004140ce  *(s + 0x11c) = ebp
004140d4  *(s + 0x10c) = eax_5 + ebp
004140da  *(s + 0x128) = 0
004140e4  *(s + 0x120) = 1
004140ea  *(s + 0x124) = 1
004140f0  sub_412e90(s, nullptr)
004140f0  
0041410e  if (sub_41dcbb(*(s + 0x104), ebp, 1, eax) != 1)
00414111      sub_4105e0(s)
00414119      s = nullptr
00414119  
0041411c  sub_41ddd2(eax)
00414129  return s

0041412a                                90 90 90 90 90 90                                                            ......

00414130    void* sub_414130(int32_t arg1, void* arg2, int32_t arg3)

0041413f  void* s = sub_410570(arg2 + 0x571)
0041414f  __builtin_memset(s, c: 0, n: 0x570)
00414151  int32_t edi_1 = arg3
00414155  int32_t i = 0xffffffff
00414155  
00414158  while (i != 0)
00414158      bool cond:0_1 = 0 != *edi_1
00414158      edi_1 += 1
00414158      i -= 1
00414158      
00414158      if (not(cond:0_1))
00414158          break
00414158  
0041415a  int32_t ecx = not.d(i)
0041416f  int32_t esi_1
0041416f  int32_t edi_4
0041416f  edi_4, esi_1 = __builtin_memcpy(dest: s, src: edi_1 - ecx, n: ecx u>> 2 << 2)
00414177  __builtin_memcpy(dest: edi_4, src: esi_1, n: ecx & 3)
00414179  *(s + 0x104) = s + 0x570
0041417f  *(s + 0x570 + arg2) = 0
00414183  void* eax_2 = *(s + 0x104)
00414189  *(s + 0x11c) = arg2
0041418f  *(s + 0x108) = eax_2
00414195  *(s + 0x110) = eax_2
0041419d  *(s + 0x128) = 0
004141a7  *(s + 0x10c) = eax_2 + arg2
004141b2  *(s + 0x120) = 1
004141b8  *(s + 0x124) = 1
004141be  sub_412e90(s, nullptr)
004141d7  int32_t esi_3
004141d7  int32_t edi_6
004141d7  edi_6, esi_3 = __builtin_memcpy(dest: *(s + 0x104), src: arg1, n: arg2 u>> 2 << 2)
004141e0  __builtin_memcpy(dest: edi_6, src: esi_3, n: arg2 & 3)
004141e6  return s

004141e7                       90 90 90 90 90 90 90 90 90                                                         .........

004141f0    int32_t sub_4141f0()

004141f0  uint32_t dwNumberOfProcessors = data_42db3c
004141f0  
004141fb  if (dwNumberOfProcessors == 0xffffffff)
00414202      SYSTEM_INFO systemInfo
00414202      GetSystemInfo(lpSystemInfo: &systemInfo)
00414208      dwNumberOfProcessors = systemInfo.dwNumberOfProcessors
0041420f      data_42db3c = dwNumberOfProcessors
0041420f      
00414219      if (dwNumberOfProcessors s< 1 || dwNumberOfProcessors s> 0x20)
0041421b          dwNumberOfProcessors = 1
00414220          data_42db3c = 1
00414220  
00414225  uint32_t dwNumberOfProcessors_1 = dwNumberOfProcessors
00414233  return sub_40fa00("%i threads\n")

00414234                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00414240    int32_t sub_414240()

00414247  if (data_255e108 == 0)
00414256      return sub_40f970("ThreadLock: !threaded")
00414256  
0041425c  EnterCriticalSection(lpCriticalSection: &data_255e120)
00414262  int32_t result = data_430b5c
00414262  
00414269  if (result != 0)
00414270      result = sub_40f970("Recursive ThreadLock\n")
00414270  
00414278  data_430b5c = 1
00414282  return result

00414283           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

00414290    int32_t sub_414290()

00414297  if (data_255e108 == 0)
004142a6      return sub_40f970("ThreadUnlock: !threaded")
004142a6  
004142ae  if (data_430b5c == 0)
004142b5      sub_40f970("ThreadUnlock without lock\n")
004142b5  
004142c2  data_430b5c = 0
004142d2  return LeaveCriticalSection(lpCriticalSection: &data_255e120)

004142d3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

004142e0    int32_t sub_4142e0()

004142e5  sub_410030("Win32 multi-threading\n")
004142f2  InitializeCriticalSection(lpCriticalSection: &data_255e120)
004142fa  data_255e108 = 1
00414304  data_255e0fc = 0
00414309  data_255e100 = 0
0041430e  return 0

0041430f                                               90                                                                 .

00414310    int32_t sub_414310()

00414315  int32_t result = DeleteCriticalSection(lpCriticalSection: &data_255e120)
0041431b  data_255e108 = 0
00414325  return result

00414326                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00414330    int32_t sub_414330(LPTHREAD_START_ROUTINE arg1)

0041433e  if (data_42db3c == 1)
00414340      int32_t ecx = data_255e0fc
00414340      
00414348      if (ecx s>= 1)
00414400          return 1
00414400      
00414353      data_255e0fc = ecx + 1
00414359      arg1(lpThreadParameter: 0xffffffff)
00414365      int32_t result = data_255e0fc - 1
00414366      data_255e0fc = result
0041436c      return result
0041436c  
0041436d  sub_414240()
0041436d  
0041437f  if (data_255e0fc s< data_42db3c)
00414383      void* eax_3 = sub_41e583(0x10)
00414383      
0041438f      if (eax_3 == 0)
00414396          sub_40f970("can't allocate memory for thread…")
00414396      
0041439e      int32_t lpParameter = data_255e100
004143a7      *(eax_3 + 4) = lpParameter
004143bf      *eax_3 = CreateThread(lpThreadAttributes: nullptr, dwStackSize: 0, 
004143bf          lpStartAddress: arg1, lpParameter, 
004143bf          dwCreationFlags: THREAD_CREATE_RUN_IMMEDIATELY, lpThreadId: eax_3 + 8)
004143c1      *(eax_3 + 0xc) = 0
004143c8      void* eax_6 = data_255e104
004143c8      
004143cf      if (eax_6 == 0)
004143d6          data_255e138 = eax_3
004143cf      else
004143d1          *(eax_6 + 0xc) = eax_3
004143d1      
004143e7      int32_t ecx_4 = data_255e0fc + 1
004143e8      int32_t eax_8 = data_255e100 + 1
004143e9      data_255e104 = eax_3
004143ef      data_255e0fc = ecx_4
004143f5      data_255e100 = eax_8
004143f5  
004143fa  return sub_414290()

00414401     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00414410    void sub_414410(int32_t arg1)

00414418  if (arg1 != 0xffffffff)
0041441b      sub_414240()
00414420      void* esi_1 = data_255e138
00414426      void* eax_1 = nullptr
00414426      
0041442a      if (esi_1 == 0)
00414477          label_414477:
00414477          int32_t var_c_2 = arg1
0041447d          sub_40f970("couldn't find thread with id %d")
0041442a      else
0041442f          while (*(esi_1 + 4) != arg1)
00414431              eax_1 = esi_1
00414433              esi_1 = *(esi_1 + 0xc)
00414433              
00414438              if (esi_1 == 0)
00414438                  goto label_414477
00414438          
0041443e          if (eax_1 == 0)
0041444b              data_255e138 = *(esi_1 + 0xc)
0041443e          else
00414443              *(eax_1 + 0xc) = *(esi_1 + 0xc)
00414443          
00414456          if (*(esi_1 + 0xc) == 0)
00414458              data_255e104 = eax_1
00414458          
0041445e          sub_41e29e(esi_1)
0041446f          data_255e0fc -= 1
0041446f          
00414475          if (esi_1 == 0)
00414475              goto label_414477
00414475      
00414485      sub_414290()

0041448d                                         90 90 90                                                               ...

00414490    int32_t sub_414490()

00414490  sub_414240()
00414490  
0041449c  for (int32_t* i = data_255e138; i != 0; i = data_255e138)
004144a6      HANDLE hHandle = *i
004144a8      sub_414290()
004144b0      WaitForSingleObject(hHandle, dwMilliseconds: 0xffffffff)
004144b2      sub_414240()
004144b2  
004144c2  return sub_414290() __tailcall

004144c7                       90 90 90 90 90 90 90 90 90                                                         .........

004144d0    int32_t sub_4144d0(char* arg1)

004144d0  char* ecx = arg1
004144d4  char i = *ecx
004144d4  
004144d8  while (i != 0)
004144e0      if (i == 0x2f || i == 0x5c)
004144e2          *ecx = 0x5c
004144e2      
004144e5      i = ecx[1]
004144e8      ecx = &ecx[1]
004144e8  
004144ed  return i

004144ee                                            90 90                                                                ..

004144f0    char* sub_4144f0(char* arg1, int32_t arg2)

004144f5  char* edi = arg1
004144f7  int32_t i = 0xffffffff
004144fa  char* result = nullptr
004144fa  
004144fc  while (i != 0)
004144fc      bool cond:0_1 = 0 != *edi
004144fc      edi = &edi[1]
004144fc      i -= 1
004144fc      
004144fc      if (not(cond:0_1))
004144fc          break
004144fc  
00414501  if (not.d(i) != 1)
00414503      char* edi_1 = arg1
00414505      int32_t i_1 = 0xffffffff
00414505      
00414508      while (i_1 != 0)
00414508          bool cond:1_1 = 0 != *edi_1
00414508          edi_1 = &edi_1[1]
00414508          i_1 -= 1
00414508          
00414508          if (not(cond:1_1))
00414508              break
00414508      
00414512      if (arg1[not.d(i_1) - 2] != 0x2f)
00414514          char* edi_2 = arg1
00414516          int32_t i_2 = 0xffffffff
00414519          result = nullptr
00414519          
0041451b          while (i_2 != 0)
0041451b              bool cond:2_1 = 0 != *edi_2
0041451b              edi_2 = &edi_2[1]
0041451b              i_2 -= 1
0041451b              
0041451b              if (not(cond:2_1))
0041451b                  break
0041451b          
00414525          if (arg1[not.d(i_2) - 2] != 0x5c)
00414527              char* edi_3 = arg1
00414529              int32_t i_3 = 0xffffffff
00414529              
0041452e              while (i_3 != 0)
0041452e                  bool cond:3_1 = 0 != *edi_3
0041452e                  edi_3 = &edi_3[1]
0041452e                  i_3 -= 1
0041452e                  
0041452e                  if (not(cond:3_1))
0041452e                      break
0041452e              
00414540              return sub_41f470(arg1, U"\", arg2 - (not.d(i_3) - 1))
00414540  
00414549  return result

0041454a                                90 90 90 90 90 90                                                            ......

00414550    int32_t sub_414550(void* arg1)

0041455e  int32_t result = *(arg1 + 0x44)
0041455e  
00414563  if (result == 0)
004146cd      return result
004146cd  
0041456f  sub_40fa00("--- LeakFile ---\n")
00414574  int32_t __saved_ebp_1 = 0x279bf20
00414583  void var_400
00414583  sub_41e430(&var_400, "%s.lin")
00414597  int32_t* i_4 = sub_41df39(&var_400, U"w")
0041459e  int32_t* i_2 = i_4
0041459e  
004145a2  if (i_4 == 0)
004145a8      void* __saved_ebx_1 = &var_400
004145ae      sub_40f970("Couldn't open %s\n")
004145ae  
004145b9  void* i_6 = arg1 + 4
004145bf  int32_t var_414_1 = 0
004145c7  void* var_438_1
004145c7  void* var_430_1
004145c7  float var_40c
004145c7  float var_408
004145c7  
004145c7  if (*(arg1 + 0x44) s> 1)
004145ce      int32_t* i_3 = i_2
004145d3      int32_t* i_1 = i_2
004145d3      
00414668      do
004145da          int32_t var_410_1 = *(i_6 + 0x40)
004145de          int32_t* i = *(i_6 + 0x50)
004145de          
004145e3          if (i != 0)
0041461a              do
004145ec                  int32_t ecx_1
004145ec                  ecx_1.b = i[8] == i_6
004145f1                  int32_t* i_5 = i[ecx_1 + 8]
004145f5                  int32_t edx_2 = i_5[0x10]
004145f5                  
00414600                  if (edx_2 != 0 && edx_2 s< var_410_1)
00414602                      i_3 = i_5
00414604                      i_1 = i
00414609                      var_410_1 = i_3[0x10]
00414609                  
00414611                  int32_t ecx_2
00414611                  ecx_2.b = ecx_1 == 0
00414614                  i = i[ecx_2 + 0xa]
0041461a              while (i != 0)
0041461a              
0041461c              i_4 = i_2
0041461c          
00414629          i_6 = i_3
0041462b          sub_410b00(i_1[0xc], &var_40c)
00414634          float var_404
00414634          var_430_1.q = fconvert.d(fconvert.t(var_404))
0041463e          var_438_1.q = fconvert.d(fconvert.t(var_408))
00414648          int32_t var_440
00414648          var_440.q = fconvert.d(fconvert.t(var_40c))
00414651          sub_41e4d9(i_4, "%f %f %f\n")
00414664          var_414_1 += 1
00414668      while (i_3[0x10] s> 1)
00414668  
0041467e  sub_40e730(*(i_6 + 0x44), "origin", &var_40c)
00414694  var_430_1.q = fconvert.d(fconvert.t(var_408))
0041469e  var_438_1.q = fconvert.d(fconvert.t(var_40c))
004146a7  sub_41e4d9(i_4, "%f %f %f\n")
004146b1  int32_t var_444_1 = var_414_1 + 1
004146b7  sub_40fa00("%5i point linefile\n")
004146bd  return sub_41ddd2(i_4)

004146ce                                            90 90                                                                ..

004146d0    void* sub_4146d0(void* arg1)

004146d5  void* result = nullptr
004146d7  int32_t i_1 = 3
004146dc  float* edx = arg1 + 8
004146fe  int32_t i
004146fe  
004146fe  do
004146df      long double x87_r7_1 = fconvert.t(*edx)
004146e1      long double temp0_1 = fconvert.t(0f)
004146e1      x87_r7_1 - temp0_1
004146e7      void* const eax
004146e7      eax.w = (x87_r7_1 < temp0_1 ? 1 : 0) << 8
004146e7          | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
004146e7          | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe
004146e7      
004146ec      if ((eax:1.b & 1) == 0)
004146f5          eax = nullptr
004146ec      else
004146ee          eax = 1
004146ee      
004146f7      edx -= 4
004146fa      i = i_1
004146fa      i_1 -= 1
004146fb      result = eax + (result << 1)
004146fe  while (i != 1)
00414703  return result

00414704              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00414710    int32_t sub_414710(float arg1)

00414711  float* ecx = arg1
00414715  long double x87_r7 = fconvert.t(*ecx)
00414717  long double temp0 = fconvert.t(1.0)
00414717  x87_r7 - temp0
00414717  
00414722  if ((((x87_r7 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7, temp0) ? 1 : 0) << 0xa
00414722          | (x87_r7 == temp0 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
00414728      long double x87_r7_1 = fconvert.t(*ecx)
0041472a      long double temp1_1 = fconvert.t(-1.0)
0041472a      x87_r7_1 - temp1_1
0041472a      
00414735      if ((((x87_r7_1 < temp1_1 ? 1 : 0) << 8
00414735              | (is_unordered.t(x87_r7_1, temp1_1) ? 1 : 0) << 0xa
00414735              | (x87_r7_1 == temp1_1 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
0041473b          long double x87_r7_2 = fconvert.t(ecx[1])
0041473e          long double temp2 = fconvert.t(1.0)
0041473e          x87_r7_2 - temp2
0041473e          
00414749          if ((((x87_r7_2 < temp2 ? 1 : 0) << 8
00414749                  | (is_unordered.t(x87_r7_2, temp2) ? 1 : 0) << 0xa
00414749                  | (x87_r7_2 == temp2 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
0041474f              long double x87_r7_3 = fconvert.t(ecx[1])
00414752              long double temp3_1 = fconvert.t(-1.0)
00414752              x87_r7_3 - temp3_1
00414752              
0041475d              if ((((x87_r7_3 < temp3_1 ? 1 : 0) << 8
0041475d                      | (is_unordered.t(x87_r7_3, temp3_1) ? 1 : 0) << 0xa
0041475d                      | (x87_r7_3 == temp3_1 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
00414763                  long double x87_r7_4 = fconvert.t(ecx[2])
00414766                  long double temp4 = fconvert.t(1.0)
00414766                  x87_r7_4 - temp4
00414766                  
00414771                  if ((((x87_r7_4 < temp4 ? 1 : 0) << 8
00414771                          | (is_unordered.t(x87_r7_4, temp4) ? 1 : 0) << 0xa
00414771                          | (x87_r7_4 == temp4 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
00414773                      long double x87_r7_5 = fconvert.t(ecx[2])
00414776                      long double temp5_1 = fconvert.t(-1.0)
00414776                      x87_r7_5 - temp5_1
00414776                      
00414781                      if ((((x87_r7_5 < temp5_1 ? 1 : 0) << 8
00414781                              | (is_unordered.t(x87_r7_5, temp5_1) ? 1 : 0) << 0xa
00414781                              | (x87_r7_5 == temp5_1 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
00414785                          long double x87_r7_7 = fabs(fconvert.t(*ecx))
0041478c                          arg1 = fconvert.s(fabs(fconvert.t(ecx[1])))
00414795                          float __saved_ecx = fconvert.s(fabs(fconvert.t(ecx[2])))
00414799                          long double temp6 = fconvert.t(arg1)
00414799                          x87_r7_7 - temp6
00414799                          
004147a2                          if ((((x87_r7_7 < temp6 ? 1 : 0) << 8
004147a2                                  | (is_unordered.t(x87_r7_7, temp6) ? 1 : 0) << 0xa
004147a2                                  | (x87_r7_7 == temp6 ? 1 : 0) << 0xe | 0x3800):1.b & 1) == 0)
004147a4                              long double temp7_1 = fconvert.t(__saved_ecx)
004147a4                              x87_r7_7 - temp7_1
004147a4                              
004147ad                              if ((((x87_r7_7 < temp7_1 ? 1 : 0) << 8
004147ad                                      | (is_unordered.t(x87_r7_7, temp7_1) ? 1 : 0) << 0xa
004147ad                                      | (x87_r7_7 == temp7_1 ? 1 : 0) << 0xe | 0x3800):1.b & 1)
004147ad                                      == 0)
004147b7                                  return 3
004147b7                          
004147b8                          long double x87_r6_4 = fconvert.t(arg1)
004147bc                          x87_r6_4 - x87_r7_7
004147bc                          
004147c5                          if ((((x87_r6_4 < x87_r7_7 ? 1 : 0) << 8
004147c5                                  | (is_unordered.t(x87_r6_4, x87_r7_7) ? 1 : 0) << 0xa
004147c5                                  | (x87_r6_4 == x87_r7_7 ? 1 : 0) << 0xe | 0x3800):1.b & 1) == 0)
004147c7                              long double x87_r7_8 = fconvert.t(arg1)
004147cb                              long double temp8_1 = fconvert.t(__saved_ecx)
004147cb                              x87_r7_8 - temp8_1
004147cb                              
004147d4                              if ((((x87_r7_8 < temp8_1 ? 1 : 0) << 8
004147d4                                      | (is_unordered.t(x87_r7_8, temp8_1) ? 1 : 0) << 0xa
004147d4                                      | (x87_r7_8 == temp8_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
004147dc                                  return 4
004147dc                          
004147e3                          return 5
004147e3                  
004147ea                  return 2
004147ea          
004147f1          return 1
004147f1  
004147f5  return 0

004147f6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00414800    int32_t sub_414800(float* arg1, float* arg2, float arg3)

0041480c  long double x87_r7_2 = fabs(fconvert.t(*arg1) - fconvert.t(*arg2))
0041480e  long double temp0 = fconvert.t(0.0001)
0041480e  x87_r7_2 - temp0
0041480e  
00414819  if ((((x87_r7_2 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7_2, temp0) ? 1 : 0) << 0xa
00414819          | (x87_r7_2 == temp0 ? 1 : 0) << 0xe):1.b & 1) != 0)
00414821      long double x87_r7_5 = fabs(fconvert.t(arg1[1]) - fconvert.t(arg2[1]))
00414823      long double temp1_1 = fconvert.t(0.0001)
00414823      x87_r7_5 - temp1_1
00414823      
0041482e      if ((((x87_r7_5 < temp1_1 ? 1 : 0) << 8
0041482e              | (is_unordered.t(x87_r7_5, temp1_1) ? 1 : 0) << 0xa
0041482e              | (x87_r7_5 == temp1_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
00414836          long double x87_r7_8 = fabs(fconvert.t(arg1[2]) - fconvert.t(arg2[2]))
00414838          long double temp2_1 = fconvert.t(0.0001)
00414838          x87_r7_8 - temp2_1
00414838          
00414843          if ((((x87_r7_8 < temp2_1 ? 1 : 0) << 8
00414843                  | (is_unordered.t(x87_r7_8, temp2_1) ? 1 : 0) << 0xa
00414843                  | (x87_r7_8 == temp2_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
0041484c              long double x87_r7_11 = fabs(fconvert.t(arg1[3]) - fconvert.t(arg3))
0041484e              long double temp3_1 = fconvert.t(0.02)
0041484e              x87_r7_11 - temp3_1
0041484e              
00414859              if ((((x87_r7_11 < temp3_1 ? 1 : 0) << 8
00414859                      | (is_unordered.t(x87_r7_11, temp3_1) ? 1 : 0) << 0xa
00414859                      | (x87_r7_11 == temp3_1 ? 1 : 0) << 0xe):1.b & 1) != 0)
00414860                  return 1
00414860  
00414863  return 0

00414864              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00414870    int32_t sub_414870(void* arg1)

0041487f  int32_t eax_1
0041487f  int32_t edx
0041487f  int16_t x87control
0041487f  edx:eax_1 = sx.q(__ftol(x87control, fabs(fconvert.t(*(arg1 + 0xc)))))
00414888  int32_t result = (eax_1 + (edx & 7)) s>> 3 & 0x3ff
00414894  *(arg1 + 0x18) = *((result << 2) + &data_4b5000)
00414897  *((result << 2) + &data_4b5000) = arg1
0041489f  return result


004148a0    int32_t sub_4148a0(float* arg1, float arg2)

004148ab  long double st0 = sub_410350(arg1)
004148b0  long double temp0 = fconvert.t(0.5)
004148b0  st0 - temp0
004148b0  
004148be  if ((((st0 < temp0 ? 1 : 0) << 8 | (is_unordered.t(st0, temp0) ? 1 : 0) << 0xa
004148be          | (st0 == temp0 ? 1 : 0) << 0xe):1.b & 1) != 0)
004148c5      sub_40f970("FloatPlane: bad normal")
004148c5  
004148cd  int32_t eax_1 = data_255e0e8
004148cd  
004148db  if (eax_1 + 2 s> 0x10000)
004148e2      sub_40f970("MAX_MAPFILE_PLANES")
004148e7      eax_1 = data_255e0e8
004148e7  
00414902  *(eax_1 * 0x1c + &data_239e0c0) = *arg1
0041490b  *(eax_1 * 0x1c + &data_239e0c4) = arg1[1]
0041490e  int32_t edx_2 = arg1[2]
00414911  *(eax_1 * 0x1c + &data_239e0cc) = arg2
00414914  *(eax_1 * 0x1c + &data_239e0c8) = edx_2
00414917  int32_t eax_4 = sub_414710(eax_1 * 0x1c + &data_239e0c0)
0041491d  *(eax_1 * 0x1c + 0x239e0ec) = eax_4
00414920  *(eax_1 * 0x1c + &data_239e0d0) = eax_4
00414928  *(eax_1 * 0x1c + 0x239e0d4) = sub_4146d0(eax_1 * 0x1c + &data_239e0c0)
00414937  *(eax_1 * 0x1c + 0x239e0dc) = fconvert.s(fconvert.t(data_430b50) - fconvert.t(*arg1))
00414943  *(eax_1 * 0x1c + 0x239e0e0) = fconvert.s(fconvert.t(data_430b54) - fconvert.t(arg1[1]))
0041494f  *(eax_1 * 0x1c + 0x239e0e4) = fconvert.s(fconvert.t(data_430b58) - fconvert.t(arg1[2]))
00414958  *(eax_1 * 0x1c + 0x239e0e8) = fconvert.s(fneg(fconvert.t(arg2)))
00414960  *(eax_1 * 0x1c + 0x239e0f0) = sub_4146d0(eax_1 * 0x1c + 0x239e0dc)
0041496f  data_255e0e8 += 2
0041496f  
0041497b  if (*(eax_1 * 0x1c + &data_239e0d0) s< 3)
0041497d      long double x87_r7_9 = fconvert.t(*(eax_1 * 0x1c + &data_239e0c0))
0041497f      long double temp1_1 = fconvert.t(0f)
0041497f      x87_r7_9 - temp1_1
00414985      int32_t eax_7
00414985      eax_7.w = (x87_r7_9 < temp1_1 ? 1 : 0) << 8
00414985          | (is_unordered.t(x87_r7_9, temp1_1) ? 1 : 0) << 0xa
00414985          | (x87_r7_9 == temp1_1 ? 1 : 0) << 0xe
00414985      
0041498a      if ((eax_7:1.b & 1) != 0)
004149b8          label_4149b8:
004149b8          void var_1c
004149b8          __builtin_memcpy(dest: &var_1c, src: eax_1 * 0x1c + &data_239e0c0, n: 0x1c)
004149c4          __builtin_memcpy(dest: eax_1 * 0x1c + &data_239e0c0, 
004149c4              src: eax_1 * 0x1c + 0x239e0dc, n: 0x1c)
004149d1          __builtin_memcpy(dest: eax_1 * 0x1c + 0x239e0dc, src: &var_1c, n: 0x1c)
004149d3          sub_414870(eax_1 * 0x1c + &data_239e0c0)
004149d9          sub_414870(eax_1 * 0x1c + 0x239e0dc)
004149f1          return data_255e0e8 - 1
004149f1      
0041498c      long double x87_r7_10 = fconvert.t(*(eax_1 * 0x1c + &data_239e0c4))
0041498f      long double temp2_1 = fconvert.t(0f)
0041498f      x87_r7_10 - temp2_1
00414995      eax_7.w = (x87_r7_10 < temp2_1 ? 1 : 0) << 8
00414995          | (is_unordered.t(x87_r7_10, temp2_1) ? 1 : 0) << 0xa
00414995          | (x87_r7_10 == temp2_1 ? 1 : 0) << 0xe
00414995      
0041499a      if ((eax_7:1.b & 1) != 0)
0041499a          goto label_4149b8
0041499a      
0041499c      long double x87_r7_11 = fconvert.t(*(eax_1 * 0x1c + &data_239e0c8))
0041499f      long double temp3_1 = fconvert.t(0f)
0041499f      x87_r7_11 - temp3_1
004149a5      eax_7.w = (x87_r7_11 < temp3_1 ? 1 : 0) << 8
004149a5          | (is_unordered.t(x87_r7_11, temp3_1) ? 1 : 0) << 0xa
004149a5          | (x87_r7_11 == temp3_1 ? 1 : 0) << 0xe
004149a5      
004149aa      if ((eax_7:1.b & 1) != 0)
004149aa          goto label_4149b8
004149aa  
004149f3  sub_414870(eax_1 * 0x1c + &data_239e0c0)
004149f9  sub_414870(eax_1 * 0x1c + 0x239e0dc)
00414a10  return data_255e0e8 - 2

00414a11                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00414a20    int32_t sub_414a20(int32_t* arg1)

00414a28  int32_t i = 0
00414a2a  float* esi = arg1
00414a61  int16_t result
00414a61  
00414a61  do
00414a34      long double x87_r7_3 = fabs(fconvert.t(*esi) - fconvert.t(1f))
00414a36      long double temp0_1 = fconvert.t(0.0001)
00414a36      x87_r7_3 - temp0_1
00414a3c      result = (x87_r7_3 < temp0_1 ? 1 : 0) << 8
00414a3c          | (is_unordered.t(x87_r7_3, temp0_1) ? 1 : 0) << 0xa
00414a3c          | (x87_r7_3 == temp0_1 ? 1 : 0) << 0xe
00414a3c      
00414a41      if ((result:1.b & 1) != 0)
00414a66          arg1[2] = 0
00414a69          arg1[1] = 0
00414a6c          *arg1 = 0
00414a6f          arg1[i] = 0x3f800000
00414a77          return result
00414a77      
00414a4b      long double x87_r7_6 = fabs(fconvert.t(*esi) - fconvert.t(-1f))
00414a4d      long double temp1_1 = fconvert.t(0.0001)
00414a4d      x87_r7_6 - temp1_1
00414a53      result = (x87_r7_6 < temp1_1 ? 1 : 0) << 8
00414a53          | (is_unordered.t(x87_r7_6, temp1_1) ? 1 : 0) << 0xa
00414a53          | (x87_r7_6 == temp1_1 ? 1 : 0) << 0xe
00414a53      
00414a58      if ((result:1.b & 1) != 0)
00414a78          arg1[2] = 0
00414a7b          arg1[1] = 0
00414a7e          *arg1 = 0
00414a81          arg1[i] = 0xbf800000
00414a89          return result
00414a89      
00414a5a      i += 1
00414a5b      esi = &esi[1]
00414a61  while (i s< 3)
00414a61  
00414a65  return result

00414a8a                                90 90 90 90 90 90                                                            ......

00414a90    int32_t sub_414a90(float arg1, int32_t* arg2)

00414a96  sub_414a20(arg1)
00414a9f  float ecx = *arg2
00414ab4  long double x87_r7_2 = fabs(fconvert.t(ecx) - sub_4103c0(ecx))
00414ab6  long double temp0 = fconvert.t(0.02)
00414ab6  x87_r7_2 - temp0
00414abc  int16_t result = (x87_r7_2 < temp0 ? 1 : 0) << 8
00414abc      | (is_unordered.t(x87_r7_2, temp0) ? 1 : 0) << 0xa
00414abc      | (x87_r7_2 == temp0 ? 1 : 0) << 0xe
00414abc  
00414ac1  if ((result:1.b & 1) != 0)
00414ac8      long double st0_1
00414ac8      st0_1, result = sub_4103c0(ecx)
00414acd      *arg2 = fconvert.s(st0_1)
00414acd  
00414ad3  return result

00414ad4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

00414ae0    int32_t sub_414ae0(float* arg1)

00414b01  float arg_8
00414b01  int32_t eax_1
00414b01  int32_t edx
00414b01  edx:eax_1 = sx.q(__ftol(sub_414a90(arg1, &arg_8), fabs(fconvert.t(arg_8))))
00414b01  
00414b47  for (int32_t i = 0xffffffff; i s<= 1; i += 1)
00414b27      for (float* j =
00414b27              *((((i + ((eax_1 + (edx & 7)) s>> 3 & 0x3ff)) & 0x3ff) << 2) + &data_4b5000); j != 0; 
00414b27              j = j[6])
00414b3a          if (sub_414800(j, arg1, arg_8) != 0)
00414b84              int32_t edx_6 = (j - &data_239e0c0) s/ 0x1c
00414b8a              *((edx_6 << 2) + &data_dde060) += 1
00414b91              return edx_6
00414b91  
00414b4f  int32_t eax_4 = sub_4148a0(arg1, arg_8)
00414b62  *((eax_4 << 2) + &data_dde060) += 1
00414b6a  return eax_4

00414b92                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00414ba0    int32_t sub_414ba0(int32_t* arg1, int32_t arg2, int32_t* arg3)

00414ba3  int32_t* eax = arg2
00414bad  int32_t ecx = *eax
00414bbb  int32_t edx_2 = eax[1]
00414bc2  int32_t eax_1 = eax[2]
00414bc5  int32_t edi_1 = arg1[1] - edx_2
00414bcb  int32_t edi_2 = arg1[2]
00414bce  float var_c = fconvert.s(float.t(*arg1 - ecx))
00414be0  float var_8 = fconvert.s(float.t(edi_1))
00414bef  float var_4 = fconvert.s(float.t(edi_2 - eax_1))
00414bf7  int32_t ecx_2 = arg3[1] - edx_2
00414c04  int32_t edx_4 = arg3[2] - eax_1
00414c0a  float var_18 = fconvert.s(float.t(*arg3 - ecx))
00414c1f  float var_14 = fconvert.s(float.t(ecx_2))
00414c29  float var_10 = fconvert.s(float.t(edx_4))
00414c2d  float var_24
00414c2d  sub_410420(&var_c, &var_18, &var_24)
00414c3c  sub_410460(&var_24, &var_24)
00414c67  float var_20
00414c67  float var_1c
00414c67  int32_t var_48 = fconvert.s(float.t(arg1[2]) * fconvert.t(var_1c)
00414c67      + float.t(arg1[1]) * fconvert.t(var_20) + float.t(*arg1) * fconvert.t(var_24))
00414c77  return sub_414ae0(&var_24)

00414c78                                                                          90 90 90 90 90 90 90 90                          ........

00414c80    int32_t sub_414c80(void* arg1)

00414c91  int32_t var_12c = 0
00414c95  int32_t var_124 = 0
00414ca2  float var_114
00414ca2  int32_t* var_120 = &var_114
00414ca6  float* var_128 = arg1 + 0x14
00414ef5  int32_t var_118
00414ef5  float var_110
00414ef5  float var_10c
00414ef5  bool cond:3_1
00414ef5  
00414ef5  do
00414cae      int32_t var_130_1 = 0xffffffff
00414cb6      int32_t ebp_2 = var_12c << 5
00414cb9      var_118 = ebp_2
00414eca      bool cond:0_1
00414eca      
00414eca      do
00414cbd          int32_t ecx_1 = *(arg1 + 0x2c)
00414cc0          int32_t* esi_1 = *(arg1 + 0x30)
00414cc3          int32_t edi_1 = 0
00414cc7          int32_t var_134_1 = 0
00414cc7          
00414ccb          if (ecx_1 s> 0)
00414cfe              do
00414ce6                  long double x87_r7_2 =
00414ce6                      fconvert.t(*(((*esi_1 * 7 + var_124) << 2) + &data_239e0c0))
00414ced                  long double temp2_1 = fconvert.t(fconvert.s(float.t(var_130_1)))
00414ced                  x87_r7_2 - temp2_1
00414cf1                  int32_t eax_2
00414cf1                  eax_2.w = (x87_r7_2 < temp2_1 ? 1 : 0) << 8
00414cf1                      | (is_unordered.t(x87_r7_2, temp2_1) ? 1 : 0) << 0xa
00414cf1                      | (x87_r7_2 == temp2_1 ? 1 : 0) << 0xe
00414cf1                  
00414cf6                  if ((eax_2:1.b & 0x40) != 0)
00414cf6                      break
00414cf6                  
00414cf8                  edi_1 += 1
00414cf9                  esi_1 = &esi_1[8]
00414cfe              while (edi_1 s< ecx_1)
00414cfe              
00414d00              var_134_1 = edi_1
00414d00          
00414d06          if (edi_1 == ecx_1)
00414d16              if (data_255e0c0 == 0x10000)
00414d1d                  sub_40f970("MAX_MAP_BRUSHSIDES")
00414d1d              
00414d34              var_10c = 0f
00414d3c              data_255e0c0 += 1
00414d42              int32_t ecx_2 = *(arg1 + 0x2c)
00414d45              var_110 = 0f
00414d4d              var_114 = 0f
00414d55              *var_120 = fconvert.s(float.t(var_130_1))
00414d5f              *(arg1 + 0x2c) = ecx_2 + 1
00414d62              float var_11c_1
00414d62              
00414d62              if (var_130_1 != 1)
00414d79                  var_11c_1 = fconvert.s(fneg(fconvert.t(*var_128)))
00414d62              else
00414d6b                  var_11c_1 = var_128[3]
00414d6b              
00414d85              float var_148_1 = var_11c_1
00414d8c              *esi_1 = sub_414ae0(&var_114)
00414d97              esi_1[1] = *(*(arg1 + 0x30) + 4)
00414da0              esi_1[4] = *(*(arg1 + 0x30) + 0x10)
00414da9              esi_1[7].b |= 4
00414dad              esi_1[5] = *(*(arg1 + 0x30) + 0x14)
00414db6              data_255e0e4 += 1
00414db6          
00414dbf          if (edi_1 != var_12c)
00414dc5              int32_t edx_9 = *(arg1 + 0x30)
00414dcc              int32_t ebp_3 = ebp_2 + edx_9
00414dd9              int32_t eax_12 = var_134_1 << 5
00414ddc              void var_e8
00414ddc              __builtin_memcpy(dest: &var_e8, src: ebp_3, n: 0x20)
00414de8              __builtin_memcpy(dest: ebp_3, src: eax_12 + edx_9, n: 0x20)
00414dfa              __builtin_memcpy(dest: eax_12 + *(arg1 + 0x30), src: &var_e8, n: 0x20)
00414e0c              int32_t eax_15 = (*(arg1 + 0x30) - 0x1f9e0a0) s>> 5
00414e0f              int32_t edx_11 = eax_15 + var_12c
00414e12              int32_t ecx_9 = edx_11 * 3
00414e26              void var_c8
00414e26              __builtin_memcpy(dest: &var_c8, src: ecx_9 * 0x14 + &data_65e040, n: 0x3c)
00414e2e              int32_t eax_16 = eax_15 + var_134_1
00414e30              ebp_2 = var_118
00414e34              int32_t ecx_12 = eax_16 * 3
00414e4a              __builtin_memcpy(dest: ecx_9 * 0x14 + &data_65e040, 
00414e4a                  src: ecx_12 * 0x14 + &data_65e040, n: 0x3c)
00414e59              __builtin_memcpy(dest: ecx_12 * 0x14 + &data_65e040, src: &var_c8, n: 0x3c)
00414e69              int32_t ecx_15 = edx_11 * 7
00414e7c              void var_8c
00414e7c              __builtin_memcpy(dest: &var_8c, src: ecx_15 * 0x14 + &data_e1e080, n: 0x8c)
00414e87              int32_t ecx_18 = eax_16 * 7
00414e9a              __builtin_memcpy(dest: ecx_15 * 0x14 + &data_e1e080, 
00414e9a                  src: ecx_18 * 0x14 + &data_e1e080, n: 0x8c)
00414eaa              __builtin_memcpy(dest: ecx_18 * 0x14 + &data_e1e080, src: &var_8c, n: 0x8c)
00414eaa          
00414eb8          ebp_2 += 0x20
00414ebb          cond:0_1 = var_130_1 + 2 s<= 1
00414ebe          var_130_1 += 2
00414ec2          var_12c += 1
00414ec6          var_118 = ebp_2
00414eca      while (cond:0_1)
00414ee6      cond:3_1 = var_124 + 1 s< 3
00414ee9      var_124 += 1
00414eed      var_120 = &var_120[1]
00414ef1      var_128 = &var_128[1]
00414ef5  while (cond:3_1)
00414efb  int32_t i = *(arg1 + 0x2c)
00414efb  
00414f01  if (i != 6)
00414f07      int32_t i_1 = 6
00414f07      
00414f0f      if (i s> 6)
00414f15          int32_t var_124_1 = 0xc0
00414f15          
004151f3          do
00414f24              int32_t* edi_9 = *(*(arg1 + 0x30) + var_124_1 + 8)
00414f2a              int32_t* var_f8_1 = edi_9
00414f2a              
00414f2e              if (edi_9 != 0)
00414f34                  int32_t esi_12 = *edi_9
00414f36                  int32_t ecx_20 = 0
00414f36                  
00414f3a                  if (esi_12 s> 0)
004151d4                      do
00414f40                          int32_t ebp_5 = ecx_20 + 1
00414f43                          int32_t ecx_21 = ecx_20 * 3
00414f4d                          long double x87_r7_6 = fconvert.t(edi_9[ecx_21 + 1])
00414f51                          int32_t temp1_1 = mods.dp.d(sx.q(ebp_5), esi_12)
00414f53                          int32_t esi_13 = &edi_9[ecx_21]
00414f5a                          var_118 = esi_13
00414f5e                          int32_t eax_25 = temp1_1 * 3
00414f6c                          float var_108 =
00414f6c                              fconvert.s(x87_r7_6 - fconvert.t(edi_9[eax_25 + 1]))
00414f76                          float* eax_27 = &edi_9[ebp_5 * 3]
00414f81                          float var_104 = fconvert.s(fconvert.t(*(esi_13 + 8))
00414f81                              - fconvert.t(edi_9[eax_25 + 2]))
00414f90                          float var_100_1 = fconvert.s(fconvert.t(*eax_27)
00414f90                              - fconvert.t(edi_9[temp1_1 * 3 + 3]))
00414f94                          long double st0_1 = sub_410460(&var_108, &var_108)
00414f99                          long double temp3_1 = fconvert.t(0.5)
00414f99                          st0_1 - temp3_1
00414f99                          
00414fa7                          if ((((st0_1 < temp3_1 ? 1 : 0) << 8
00414fa7                                  | (is_unordered.t(st0_1, temp3_1) ? 1 : 0) << 0xa
00414fa7                                  | (st0_1 == temp3_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
00414fb2                              sub_414a20(&var_108)
00414fba                              int32_t j = 0
00414fbc                              float* eax_29 = &var_108
00414fbc                              
00414fd9                              do
00414fc0                                  float edx_19 = *eax_29
00414fc0                                  
00414fc8                                  if (edx_19 == 0xbf800000)
00414fc8                                      break
00414fc8                                  
00414fd0                                  if (edx_19 == 0x3f800000)
00414fd0                                      break
00414fd0                                  
00414fd2                                  j += 1
00414fd3                                  eax_29 = &eax_29[1]
00414fd9                              while (j s< 3)
00414fd9                              
00414fde                              if (j == 3)
00414fe8                                  int32_t j_2 = j
00414fec                                  float var_f4
00414fec                                  float* var_120_1 = &var_f4
00414ff0                                  int32_t var_130_2 = 0xffffffff
00414ff0                                  
00415014                                  while (true)
00415014                                      int32_t var_ec_1 = 0
0041501c                                      int32_t var_f0_1 = 0
00415024                                      var_f4 = 0f
0041502c                                      *var_120_1 = fconvert.s(float.t(var_130_2))
0041503d                                      sub_410420(&var_108, &var_f4, &var_114)
0041504c                                      long double st0_2 = sub_410460(&var_114, &var_114)
00415051                                      long double temp4_1 = fconvert.t(0.5)
00415051                                      st0_2 - temp4_1
00415051                                      
0041505f                                      if ((((st0_2 < temp4_1 ? 1 : 0) << 8
0041505f                                              | (is_unordered.t(st0_2, temp4_1) ? 1 : 0)
0041505f                                              << 0xa | (st0_2 == temp4_1 ? 1 : 0) << 0xe):1.b & 1)
0041505f                                              == 0)
00415079                                          int32_t j_1 = 0
00415088                                          float var_11c_2 = fconvert.s(fconvert.t(var_110)
00415088                                              * fconvert.t(*(esi_13 + 8))
00415088                                              + fconvert.t(var_10c) * fconvert.t(*eax_27)
00415088                                              + fconvert.t(var_114)
00415088                                              * fconvert.t(*(esi_13 + 4)))
00415088                                          
0041508c                                          if (*(arg1 + 0x2c) s> 0)
00415092                                              int32_t* edi_10 = nullptr
00415092                                              
00415115                                              do
004150bf                                                  if (sub_414800(
004150bf                                                          *(edi_10 + *(arg1 + 0x30)) * 0x1c +
004150bf                                                              &data_239e0c0, 
004150bf                                                          &var_114, var_11c_2) != 0)
004150bf                                                      break
004150bf                                                  
004150c4                                                  int32_t* eax_35 =
004150c4                                                      *(edi_10 + *(arg1 + 0x30) + 8)
004150c4                                                  
004150ca                                                  if (eax_35 != 0)
004150cc                                                      int32_t esi_14 = *eax_35
004150ce                                                      int32_t ecx_27 = 0
004150ce                                                      
004150d2                                                      if (esi_14 s> 0)
004150d4                                                          float* edx_23 = &eax_35[1]
004150d4                                                          
00415106                                                          do
004150ef                                                              long double x87_r7_23 =
004150ef                                                                  fconvert.t(var_110)
004150ef                                                                  * fconvert.t(edx_23[1])
004150ef                                                                  + fconvert.t(var_10c)
004150ef                                                                  * fconvert.t(edx_23[2])
004150ef                                                                  + fconvert.t(var_114)
004150ef                                                                  * fconvert.t(*edx_23)
004150ef                                                                  - fconvert.t(var_11c_2)
004150f3                                                              long double temp6_1 =
004150f3                                                                  fconvert.t(0.10000000000000001)
004150f3                                                              x87_r7_23 - temp6_1
004150f9                                                              eax_35.w =
004150f9                                                                  (x87_r7_23 < temp6_1 ? 1 : 0) << 8 | (
004150f9                                                                  is_unordered.t(x87_r7_23, temp6_1) ? 1
004150f9                                                                  : 0) << 0xa
004150f9                                                                  | (x87_r7_23 == temp6_1 ? 1 : 0) << 0xe
004150f9                                                              
004150fe                                                              if ((eax_35:1.b & 0x41) == 0)
004150fe                                                                  break
004150fe                                                              
00415100                                                              ecx_27 += 1
00415101                                                              edx_23 = &edx_23[3]
00415106                                                          while (ecx_27 s< esi_14)
00415106                                                      
0041510a                                                      if (ecx_27 != esi_14)
0041510a                                                          break
0041510a                                                  
0041510f                                                  j_1 += 1
00415110                                                  edi_10 = &edi_10[8]
00415115                                              while (j_1 s< *(arg1 + 0x2c))
00415115                                              
0041511b                                              edi_9 = var_f8_1
0041511b                                          
00415122                                          if (j_1 == *(arg1 + 0x2c))
0041512e                                              if (data_255e0c0 == 0x10000)
00415135                                                  sub_40f970("MAX_MAP_BRUSHSIDES")
00415135                                              
00415144                                              data_255e0c0 += 1
00415157                                              int32_t* esi_17 =
00415157                                                  (*(arg1 + 0x2c) << 5) + *(arg1 + 0x30)
0041515d                                              float var_148_6 = var_11c_2
00415164                                              *esi_17 = sub_414ae0(&var_114)
0041516f                                              esi_17[1] = *(*(arg1 + 0x30) + 4)
00415178                                              esi_17[4] = *(*(arg1 + 0x30) + 0x10)
00415181                                              esi_17[7].b |= 4
00415185                                              esi_17[5] = *(*(arg1 + 0x30) + 0x14)
0041518f                                              data_239e0a0 += 1
00415199                                              *(arg1 + 0x2c) += 1
00415199                                      
004151a3                                      bool cond:7_1 = var_130_2 + 2 s<= 1
004151a6                                      var_130_2 += 2
004151a6                                      
004151aa                                      if (cond:7_1)
00415008                                          esi_13 = var_118
004151aa                                      else
004151bb                                          bool cond:9_1 = j_2 != 1
004151bc                                          var_120_1 = &var_120_1[1]
004151c0                                          j_2 -= 1
004151c0                                          
004151c4                                          if (not(cond:9_1))
004151c4                                              break
004151c4                                          
00414ffa                                          esi_13 = var_118
00414ffe                                          var_130_2 = 0xffffffff
00414ffe                          
004151ce                          esi_12 = *edi_9
004151d0                          ecx_20 = ebp_5
004151d4                      while (ecx_20 s< esi_12)
004151d4              
004151e5              i = i_1 + 1
004151eb              i_1 = i
004151ef              var_124_1 += 0x20
004151f3          while (i s< *(arg1 + 0x2c))
004151f3  
00415203  return i

00415204              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00415210    int32_t sub_415210(void* arg1)

00415215  int32_t* esi = arg1
00415222  sub_4104f0(&esi[5], &esi[8])
00415231  int32_t var_4 = 0
00415235  int16_t top
00415235  
00415235  if (esi[0xb] s> 0)
0041523c      int32_t var_8_1 = 0
0041532b      bool cond:1_1
0041532b      
0041532b      do
00415251          int32_t edx_2 = *(esi[0xc] + var_8_1) * 7
00415263          void* i =
00415263              sub_410b70((edx_2 << 2) + &data_239e0c0, *((edx_2 << 2) + &data_239e0cc))
00415263          top -= 1
00415263          unimplemented  {call sub_410b70}
00415268          int32_t ecx_3 = esi[0xb]
0041526e          int32_t edi_1 = 0
00415270          arg1 = i
00415270          
00415276          if (ecx_3 s> 0)
00415278              int32_t ebp_1 = 0
00415278              
0041527c              while (i != 0)
00415282                  if (var_4 != edi_1)
00415284                      void* edx_3 = esi[0xc]
00415287                      int32_t* ecx_4 = edx_3 + ebp_1
0041528a                      edx_3.b = *(edx_3 + ebp_1 + 0x1c)
0041528a                      
00415291                      if ((edx_3.b & 4) == 0)
004152a1                          int32_t ecx_6 = (*ecx_4 ^ 1) * 7
004152b8                          sub_4111c0(&arg1, (ecx_6 << 2) + &data_239e0c0, 
004152b8                              *((ecx_6 << 2) + &data_239e0cc), 0f)
004152b8                          top -= 1
004152b8                          unimplemented  {call sub_4111c0}
004152bd                          i = arg1
004152bd                  
004152c7                  edi_1 += 1
004152c8                  ebp_1 += 0x20
004152c8                  
004152cd                  if (edi_1 s>= esi[0xb])
004152cd                      break
004152cd          
004152d6          void* ecx_9 = esi[0xc] + var_8_1
004152d8          *(ecx_9 + 8) = i
004152d8          
004152e1          if (arg1 != 0)
004152e3              *(ecx_9 + 0x1c) |= 2
004152e7              void* eax_9 = arg1
004152eb              int32_t i_1 = 0
004152eb              
004152f0              if (*eax_9 s> 0)
004152f2                  int32_t ebp_2 = 0
004152f2                  
00415310                  do
004152fe                      sub_410520(eax_9 + ebp_2 + 4, &esi[5], &esi[8])
004152fe                      unimplemented  {call sub_410520}
00415303                      eax_9 = arg1
0041530a                      i_1 += 1
0041530b                      ebp_2 += 0xc
00415310                  while (i_1 s< *eax_9)
00415310          
00415321          cond:1_1 = var_4 + 1 s< esi[0xb]
00415323          var_4 += 1
00415327          var_8_1 += 0x20
0041532b      while (cond:1_1)
0041532b  
00415334  int32_t i_2 = 0
00415336  void* ecx_13 = &esi[8]
00415336  
0041537d  do
00415338      unimplemented  {fld st0, dword [ecx-0xc]}
0041533b      long double temp0_1 = fconvert.t(-5000f)
0041533b      unimplemented  {fcomp st0, dword [&data_4291ac]} f- temp0_1
0041533b      bool c0_1 = unimplemented  {fcomp st0, dword [&data_4291ac]} f< temp0_1
0041533b      bool c2_1 = is_unordered.t(unimplemented  {fcomp st0, dword [&data_4291ac]}, temp0_1)
0041533b      bool c3_1 = unimplemented  {fcomp st0, dword [&data_4291ac]} f== temp0_1
0041533b      unimplemented  {fcomp st0, dword [&data_4291ac]}
00415341      int32_t eax_1
00415341      eax_1.w = (c0_1 ? 1 : 0) << 8 | (c2_1 ? 1 : 0) << 0xa | (c3_1 ? 1 : 0) << 0xe
00415341          | (top & 7) << 0xb
00415346      char* var_20_4
00415346      
00415346      if ((eax_1:1.b & 1) != 0)
0041539e          label_41539e:
0041539e          int32_t __saved_ebp_2 = esi[1]
0041539f          int32_t var_1c_4 = *esi
004153a0          var_20_4 = "entity %i, brush %i: bounds out …"
004153a5          label_4153a5:
004153a5          sub_410030(var_20_4)
004153ad          esi[0xb] = 0
004153bb          return 1
004153bb      
00415348      unimplemented  {fld st0, dword [ecx]}
0041534a      long double temp1_1 = fconvert.t(5000f)
0041534a      unimplemented  {fcomp st0, dword [&data_4291a8]} f- temp1_1
0041534a      bool c0_2 = unimplemented  {fcomp st0, dword [&data_4291a8]} f< temp1_1
0041534a      bool c2_2 = is_unordered.t(unimplemented  {fcomp st0, dword [&data_4291a8]}, temp1_1)
0041534a      bool c3_2 = unimplemented  {fcomp st0, dword [&data_4291a8]} f== temp1_1
0041534a      unimplemented  {fcomp st0, dword [&data_4291a8]}
00415350      eax_1.w = (c0_2 ? 1 : 0) << 8 | (c2_2 ? 1 : 0) << 0xa | (c3_2 ? 1 : 0) << 0xe
00415350          | (top & 7) << 0xb
00415350      
00415355      if ((eax_1:1.b & 0x41) == 0)
00415355          goto label_41539e
00415355      
00415357      unimplemented  {fld st0, dword [ecx-0xc]}
0041535a      long double temp2_1 = fconvert.t(5000f)
0041535a      unimplemented  {fcomp st0, dword [&data_4291a8]} f- temp2_1
0041535a      bool c0_3 = unimplemented  {fcomp st0, dword [&data_4291a8]} f< temp2_1
0041535a      bool c2_3 = is_unordered.t(unimplemented  {fcomp st0, dword [&data_4291a8]}, temp2_1)
0041535a      bool c3_3 = unimplemented  {fcomp st0, dword [&data_4291a8]} f== temp2_1
0041535a      unimplemented  {fcomp st0, dword [&data_4291a8]}
00415360      eax_1.w = (c0_3 ? 1 : 0) << 8 | (c2_3 ? 1 : 0) << 0xa | (c3_3 ? 1 : 0) << 0xe
00415360          | (top & 7) << 0xb
00415360      
00415365      if ((eax_1:1.b & 0x41) == 0)
00415390          label_415390:
00415390          int32_t __saved_ebp_1 = esi[1]
00415391          int32_t var_1c_3 = *esi
00415392          var_20_4 = "entity %i, brush %i: no visible …"
00415397          goto label_4153a5
00415397      
00415367      unimplemented  {fld st0, dword [ecx]}
00415369      long double temp3_1 = fconvert.t(-5000f)
00415369      unimplemented  {fcomp st0, dword [&data_4291ac]} f- temp3_1
00415369      bool c0_4 = unimplemented  {fcomp st0, dword [&data_4291ac]} f< temp3_1
00415369      bool c2_4 = is_unordered.t(unimplemented  {fcomp st0, dword [&data_4291ac]}, temp3_1)
00415369      bool c3_4 = unimplemented  {fcomp st0, dword [&data_4291ac]} f== temp3_1
00415369      unimplemented  {fcomp st0, dword [&data_4291ac]}
0041536f      eax_1.w = (c0_4 ? 1 : 0) << 8 | (c2_4 ? 1 : 0) << 0xa | (c3_4 ? 1 : 0) << 0xe
0041536f          | (top & 7) << 0xb
0041536f      
00415374      if ((eax_1:1.b & 1) != 0)
00415374          goto label_415390
00415374      
00415376      i_2 += 1
00415377      ecx_13 += 4
0041537d  while (i_2 s< 3)
0041537d  
0041538a  return 1

004153bc                                                                                      90 90 90 90                              ....

004153c0    void sub_4153c0(void* arg1)

004153c0  int32_t ecx
004153c0  int32_t var_4_1 = ecx
004153c7  int32_t ebp = 0
004153c9  int32_t var_4 = 0
004153c9  
004153d0  if (*(arg1 + 0x2c) s> 0)
004154a7      bool cond:0_1
004154a7      
004154a7      do
004153e0          int32_t* esi_2 = *(arg1 + 0x30) + ebp
004153e2          int32_t* eax_1 = esi_2[2]
004153e7          int32_t* eax_3
004153e7          
004153e7          if (eax_1 != 0)
00415407              if (sub_406f30(eax_1) == 0)
00415424                  eax_3 = sub_411870(esi_2[2])
00415424                  
00415439                  if (eax_3 == 1 || eax_3 == 2 || eax_3 == 3)
00415440                      char* var_18_5 = &data_255e160
00415444                      int32_t var_1c_1 = *(arg1 + 4)
0041544a                      sub_410080("MarkBrushBevels: brush %d %s")
00415452                      esi_2[7].w |= 4
00415407              else
00415409                  esi_2[7].w |= 4
00415410                  int32_t var_18_3 = *(arg1 + 4)
00415416                  sub_410080("MarkBrushBevels: brush %d tiny w…")
004153e7          else
004153ec              int32_t var_18_1 = *(arg1 + 4)
004153f2              sub_410080("MarkBrushBevels: brush %d no win…")
00415452              esi_2[7].w |= 4
00415452          
00415456          eax_3.w = esi_2[7].w
00415456          
0041545c          if ((4 & eax_3.b) != 0)
00415463              esi_2[7].w = eax_3.w & 0xfffd
00415467              int32_t esi_3 = *esi_2
00415467              
00415473              if (esi_3 s> 0 && esi_3 s< data_255e0e8)
00415486                  if (*(esi_3 * 0x1c + &data_239e0d0) s>= 3)
00415490                      data_239e0a0 += 1
00415486                  else
00415488                      data_255e0e4 += 1
00415488          
0041549e          ebp += 0x20
004154a1          cond:0_1 = var_4 + 1 s< *(arg1 + 0x2c)
004154a3          var_4 += 1
004154a7      while (cond:0_1)

004154b3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

004154c0    int32_t sub_4154c0(int32_t* arg1)

004154ce  int32_t var_8 = 0
004154ce  
004154d6  if (data_dde044 s> 0)
004154dc      int32_t* esi_1 = arg1
004154e0      void* ecx_1 = &data_4b6000
004154e5      void* var_10_1 = &data_4b6000
004154e9      int32_t eax_1 = *esi_1
0041556f      bool cond:1_1
0041556f      
0041556f      do
004154f7          if (eax_1 == *ecx_1)
004154f9              int32_t eax_3 = esi_1[0xb]
004154fc              int32_t edx_2 = *(ecx_1 + 0x2c)
00415501              int32_t var_c_1 = eax_3
00415501              
00415505              if (eax_3 == edx_2)
00415507                  int32_t ebx_1 = 0
00415507                  
0041550b                  if (eax_3 s> 0)
0041550d                      int32_t* edi_1 = esi_1[0xc]
0041550d                      
00415543                      do
00415510                          int32_t ecx_2 = 0
00415510                          
00415514                          if (edx_2 s<= 0)
00415514                              break
00415514                          
0041551c                          int32_t eax_5 = *(var_10_1 + 0x30)
0041551c                          
00415529                          while (((*edi_1 ^ *eax_5) & 0xfffffffe) != 0)
0041552b                              ecx_2 += 1
0041552c                              eax_5 += 0x20
0041552c                              
00415531                              if (ecx_2 s>= edx_2)
00415531                                  goto label_415547
00415531                          
00415537                          if (ecx_2 s>= edx_2)
00415547                              label_415547:
00415547                              eax_3 = var_c_1
00415547                              break
00415547                          
00415539                          eax_3 = var_c_1
0041553d                          ebx_1 += 1
0041553e                          edi_1 = &edi_1[8]
00415543                      while (ebx_1 s< eax_3)
00415543                  
0041554d                  if (ebx_1 s>= eax_3)
0041558b                      return 1
0041558b                  
0041554f                  ecx_1 = var_10_1
00415553                  esi_1 = arg1
00415553          
00415562          ecx_1 += 0x34
00415565          cond:1_1 = var_8 + 1 s< data_dde044
00415567          var_8 += 1
0041556b          var_10_1 = ecx_1
0041556f      while (cond:1_1)
0041556f  
0041557e  return 0

0041558c                                      90 90 90 90                                                              ....

00415590    int32_t sub_415590(int32_t* arg1, void* arg2)

004155a8  if (data_279bee8 == 0 || (*(arg2 + 8) & 0x38) == 0)
004155b5      int32_t var_68_1 = *(arg2 + 4)
004155b5      
004155c6      if (sub_41e4d9(arg1, " { //brush %d\n") s< 0)
004155d1          return 0
004155d1      
004155d5      int32_t i_1 = 0
004155d5      
004155df      if (*(arg2 + 0x2c) s> 0)
00415bdc          int32_t i
00415bdc          
00415bdc          do
004155f0              int32_t* eax_6 = (i_1 << 5) + *(arg2 + 0x30)
004155f3              int32_t* var_54_1 = eax_6
004155f3              
004155fb              if ((eax_6[7].b & 4) == 0)
00415605                  unimplemented  {fld st0, dword [edx]}
00415607                  long double temp0_1 = fconvert.t(0f)
00415607                  unimplemented  {fcomp st0, dword [&data_429148]} f- temp0_1
00415607                  bool c0_1 = unimplemented  {fcomp st0, dword [&data_429148]} f< temp0_1
00415607                  bool c2_1 = is_unordered.t(
00415607                      unimplemented  {fcomp st0, dword [&data_429148]}, temp0_1)
00415607                  bool c3_1 = unimplemented  {fcomp st0, dword [&data_429148]} f== temp0_1
00415607                  unimplemented  {fcomp st0, dword [&data_429148]}
0041560d                  int16_t top
0041560d                  eax_6.w = (c0_1 ? 1 : 0) << 8 | (c2_1 ? 1 : 0) << 0xa
0041560d                      | (c3_1 ? 1 : 0) << 0xe | (top & 7) << 0xb
00415612                  int32_t ebx_1
00415612                  int16_t x87control
00415612                  
00415612                  if ((eax_6:1.b & 0x40) == 0)
00415640                      label_415640:
0041564e                      unimplemented  {fld st0, dword [eax+0x239e0c8]}
00415654                      unimplemented  {fmul st0, dword [edx+0x8]}
00415657                      unimplemented  {fld st0, dword [eax+0x239e0c4]}
0041565d                      unimplemented  {fmul st0, dword [edx+0x4]}
00415666                      unimplemented  {faddp st1, st0}
00415666                      unimplemented  {faddp st1, st0}
00415668                      unimplemented  {fld st0, dword [ecx]}
0041566a                      unimplemented  {fmul st0, dword [edx]}
0041566c                      unimplemented  {faddp st1, st0}
0041566c                      unimplemented  {faddp st1, st0}
0041566e                      unimplemented  {fadd dword [eax+0x239e0cc]}
00415674                      float var_4c_1 =
00415674                          fconvert.s(unimplemented  {fstp dword [esp+0x18], st0})
00415674                      unimplemented  {fstp dword [esp+0x18], st0}
0041567c                      float var_68_2 = var_4c_1
0041567e                      int32_t eax_11
0041567e                      eax_11, x87control = sub_414ae0(*var_54_1 * 0x1c + &data_239e0c0)
00415686                      ebx_1 = eax_11
00415612                  else
00415614                      unimplemented  {fld st0, dword [edx+0x4]}
00415617                      long double temp1_1 = fconvert.t(0f)
00415617                      unimplemented  {fcomp st0, dword [&data_429148]} f- temp1_1
00415617                      bool c0_2 =
00415617                          unimplemented  {fcomp st0, dword [&data_429148]} f< temp1_1
00415617                      bool c2_2 = is_unordered.t(
00415617                          unimplemented  {fcomp st0, dword [&data_429148]}, temp1_1)
00415617                      bool c3_2 =
00415617                          unimplemented  {fcomp st0, dword [&data_429148]} f== temp1_1
00415617                      unimplemented  {fcomp st0, dword [&data_429148]}
0041561d                      eax_6.w = (c0_2 ? 1 : 0) << 8 | (c2_2 ? 1 : 0) << 0xa
0041561d                          | (c3_2 ? 1 : 0) << 0xe | (top & 7) << 0xb
0041561d                      
00415622                      if ((eax_6:1.b & 0x40) == 0)
00415622                          goto label_415640
00415622                      
00415624                      unimplemented  {fld st0, dword [edx+0x8]}
00415627                      long double temp2_1 = fconvert.t(0f)
00415627                      unimplemented  {fcomp st0, dword [&data_429148]} f- temp2_1
00415627                      bool c0_3 =
00415627                          unimplemented  {fcomp st0, dword [&data_429148]} f< temp2_1
00415627                      bool c2_3 = is_unordered.t(
00415627                          unimplemented  {fcomp st0, dword [&data_429148]}, temp2_1)
00415627                      bool c3_3 =
00415627                          unimplemented  {fcomp st0, dword [&data_429148]} f== temp2_1
00415627                      unimplemented  {fcomp st0, dword [&data_429148]}
0041562d                      eax_6.w = (c0_3 ? 1 : 0) << 8 | (c2_3 ? 1 : 0) << 0xa
0041562d                          | (c3_3 ? 1 : 0) << 0xe | (top & 7) << 0xb
0041562d                      
00415632                      if ((eax_6:1.b & 0x40) == 0)
00415632                          goto label_415640
00415632                      
00415638                      ebx_1 = *var_54_1
00415638                  
0041568a                  int32_t eax_12
0041568a                  eax_12.b = ebx_1.b & 0xfe
00415693                  int32_t ecx_6 = eax_12 * 7
004156a9                  int32_t* eax_14
004156a9                  long double st0_1
004156a9                  st0_1, eax_14 = sub_410b70((ecx_6 << 2) + &data_239e0c0, 
004156a9                      *((ecx_6 << 2) + &data_239e0cc))
004156a9                  int16_t top_10 = top - 1
004156a9                  unimplemented  {call sub_410b70}
004156ae                  int32_t* edi_1 = eax_14
004156b3                  int32_t* var_4c_2 = 3
004156bb                  int32_t* esi_1 = &edi_1[1]
00415713                  bool cond:1_1
00415713                  
00415713                  do
004156be                      int32_t j_1 = 3
00415708                      int32_t j
00415708                      
00415708                      do
004156c3                          unimplemented  {fld st0, dword [esi]}
004156c5                          unimplemented  {fabs }
004156c7                          long double temp3_1 = fconvert.t(0.01)
004156c7                          unimplemented  {fcomp st0, qword [&data_4291c0]} f- temp3_1
004156c7                          bool c0_4 =
004156c7                              unimplemented  {fcomp st0, qword [&data_4291c0]} f< temp3_1
004156c7                          bool c2_4 = is_unordered.t(
004156c7                              unimplemented  {fcomp st0, qword [&data_4291c0]}, temp3_1)
004156c7                          bool c3_4 =
004156c7                              unimplemented  {fcomp st0, qword [&data_4291c0]} f== temp3_1
004156c7                          unimplemented  {fcomp st0, qword [&data_4291c0]}
004156cd                          eax_14.w = (c0_4 ? 1 : 0) << 8 | (c2_4 ? 1 : 0) << 0xa
004156cd                              | (c3_4 ? 1 : 0) << 0xe | (top_10 & 7) << 0xb
004156cd                          
004156d2                          if ((eax_14:1.b & 1) == 0)
004156dc                              unimplemented  {fld st0, dword [esi]}
004156de                              eax_14, x87control = __ftol(x87control, st0_1)
004156e3                              int32_t* var_48_1 = eax_14
004156e7                              unimplemented  {fild st0, dword [esp+0x1c]}
004156eb                              unimplemented  {fld st0, st0}
004156ed                              unimplemented  {fsub st0, dword [esi]}
004156ef                              unimplemented  {fabs }
004156f1                              long double temp4_1 = fconvert.t(0.01)
004156f1                              unimplemented  {fcomp st0, qword [&data_4291c0]} f- temp4_1
004156f1                              bool c0_5 = unimplemented  {fcomp st0, qword [&data_4291c0]}
004156f1                                  f< temp4_1
004156f1                              bool c2_5 = is_unordered.t(
004156f1                                  unimplemented  {fcomp st0, qword [&data_4291c0]}, temp4_1)
004156f1                              bool c3_5 = unimplemented  {fcomp st0, qword [&data_4291c0]}
004156f1                                  f== temp4_1
004156f1                              unimplemented  {fcomp st0, qword [&data_4291c0]}
004156f7                              eax_14.w = (c0_5 ? 1 : 0) << 8 | (c2_5 ? 1 : 0) << 0xa
004156f7                                  | (c3_5 ? 1 : 0) << 0xe | ((top_10 - 1) & 7) << 0xb
004156f7                              
004156fc                              if ((eax_14:1.b & 1) == 0)
00415702                                  unimplemented  {fstp st0, st0}
00415702                                  unimplemented  {fstp st0, st0}
004156fc                              else
004156fe                                  *esi_1 =
004156fe                                      fconvert.s(unimplemented  {fstp dword [esi], st0})
004156fe                                  unimplemented  {fstp dword [esi], st0}
004156d2                          else
004156d4                              *esi_1 = 0
004156d4                          
00415704                          esi_1 = &esi_1[1]
00415707                          j = j_1
00415707                          j_1 -= 1
00415708                      while (j != 1)
0041570e                      cond:1_1 = var_4c_2 != 1
0041570f                      var_4c_2 -= 1
00415713                  while (cond:1_1)
00415722                  unimplemented  {fld st0, dword [edi+ecx*4]}
00415728                  int32_t eax_16
00415728                  int16_t x87control_1
00415728                  eax_16, x87control_1 = __ftol(x87control, st0_1)
0041572d                  unimplemented  {fld st0, dword [ebp+0x8]}
00415730                  int32_t var_68_4 = eax_16
00415731                  int32_t eax_17
00415731                  int16_t x87control_2
00415731                  eax_17, x87control_2 = __ftol(x87control_1, st0_1)
00415736                  unimplemented  {fld st0, dword [ebp+0x4]}
00415739                  int32_t var_6c_3 = eax_17
0041573a                  int32_t eax_18
0041573a                  int16_t x87control_3
0041573a                  eax_18, x87control_3 = __ftol(x87control_2, st0_1)
00415743                  int32_t var_70_2 = eax_18
00415743                  
00415754                  if (sub_41e4d9(arg1, "  ( %5i %5i %5i ) ") s< 0)
00415c01                      return 0
00415c01                  
00415768                  unimplemented  {fld st0, dword [edi+edx*4]}
0041576e                  int32_t eax_20
0041576e                  int16_t x87control_4
0041576e                  eax_20, x87control_4 = __ftol(x87control_3, st0_1)
00415773                  unimplemented  {fld st0, dword [esi+0x8]}
00415776                  int32_t var_68_5 = eax_20
00415777                  int32_t eax_21
00415777                  int16_t x87control_5
00415777                  eax_21, x87control_5 = __ftol(x87control_4, st0_1)
0041577c                  unimplemented  {fld st0, dword [esi+0x4]}
0041577f                  int32_t var_6c_4 = eax_21
00415780                  int32_t eax_22
00415780                  int16_t x87control_6
00415780                  eax_22, x87control_6 = __ftol(x87control_5, st0_1)
00415789                  int32_t var_70_3 = eax_22
00415789                  
0041579a                  if (sub_41e4d9(arg1, "( %5i %5i %5i ) ") s< 0)
00415c01                      return 0
00415c01                  
004157a0                  unimplemented  {fld st0, dword [edi+0x24]}
004157a3                  int32_t eax_24
004157a3                  int16_t x87control_7
004157a3                  eax_24, x87control_7 = __ftol(x87control_6, st0_1)
004157a8                  unimplemented  {fld st0, dword [edi+0x20]}
004157ab                  int32_t var_68_6 = eax_24
004157ac                  int32_t eax_25
004157ac                  int16_t x87control_8
004157ac                  eax_25, x87control_8 = __ftol(x87control_7, st0_1)
004157b1                  unimplemented  {fld st0, dword [edi+0x1c]}
004157b4                  int32_t var_6c_5 = eax_25
004157b5                  int32_t eax_26
004157b5                  eax_26, x87control = __ftol(x87control_8, st0_1)
004157b5                  int16_t top_32
004157b5                  top = top_32
004157ba                  int32_t var_70_4 = eax_26
004157ba                  
004157cb                  if (sub_41e4d9(arg1, "( %5i %5i %5i ) ") s< 0)
00415c01                      return 0
00415c01                  
004157d2                  sub_410740(edi_1)
004157de                  int32_t eax_29 = var_54_1[1]
004157e4                  char* var_68_8
004157e4                  
004157e4                  if (eax_29 != 0xffffffff)
0041587d                      if (data_65e020 == 4 && eax_29 == 0)
00415883                          int16_t eax_34 = (*(arg2 + 8)).w
00415883                          
00415889                          if ((eax_34:1.b & 0x10) != 0)
0041588b                              var_68_8 = "generic/misc/fence 0 0 0 1 1"
00415889                          else if ((eax_34.b & 0x40) == 0)
004158b1                              var_68_8 = "generic/misc/red 0 0 0 1 1"
00415894                          else
00415896                              var_68_8 = "generic/misc/volumetric_base 0 0…"
00415896                          
00415889                          goto label_41589c
00415889                      
004158b8                      int32_t eax_36 = eax_29 * 3
004158cb                      void var_18
004158cb                      sub_410460(&(&data_586020)[eax_36 * 9], &var_18)
004158cb                      unimplemented  {call sub_410460}
004158d0                      unimplemented  {fdivr st0, dword [&data_42914c]}
004158df                      float var_40_1 =
004158df                          fconvert.s(unimplemented  {fstp dword [esp+0x34], st0})
004158df                      unimplemented  {fstp dword [esp+0x34], st0}
004158e3                      void var_c
004158e3                      sub_410460(&(&data_586030)[eax_36 * 9], &var_c)
004158e3                      unimplemented  {call sub_410460}
004158e8                      unimplemented  {fdivr st0, dword [&data_42914c]}
004158fd                      float var_3c_1 =
004158fd                          fconvert.s(unimplemented  {fstp dword [esp+0x44], st0})
004158fd                      unimplemented  {fstp dword [esp+0x44], st0}
00415901                      int32_t var_30
00415901                      int32_t var_24
00415901                      long double st0_2 =
00415901                          sub_41c8e0((ecx_6 << 2) + &data_239e0c0, &var_30, &var_24)
00415901                      unimplemented  {call sub_41c8e0}
00415910                      unimplemented  {fld st0, dword [esp+0x3c]}
00415914                      unimplemented  {fmul st0, dword [eax+0x8]}
00415917                      unimplemented  {fld st0, dword [esp+0x38]}
0041591b                      unimplemented  {fmul st0, dword [eax+0x4]}
0041591e                      unimplemented  {faddp st1, st0}
0041591e                      unimplemented  {faddp st1, st0}
00415920                      unimplemented  {fld st0, dword [esp+0x34]}
00415924                      unimplemented  {fmul st0, dword [eax]}
00415926                      unimplemented  {faddp st1, st0}
00415926                      unimplemented  {faddp st1, st0}
00415928                      unimplemented  {fld st0, dword [esp+0x48]}
0041592c                      unimplemented  {fmul st0, dword [eax+0x8]}
0041592f                      unimplemented  {fld st0, dword [esp+0x44]}
00415933                      unimplemented  {fmul st0, dword [eax+0x4]}
00415936                      unimplemented  {faddp st1, st0}
00415936                      unimplemented  {faddp st1, st0}
00415938                      unimplemented  {fld st0, dword [esp+0x40]}
0041593c                      unimplemented  {fmul st0, dword [eax]}
0041593e                      unimplemented  {faddp st1, st0}
0041593e                      unimplemented  {faddp st1, st0}
00415940                      float var_34_1 =
00415940                          fconvert.s(unimplemented  {fstp dword [esp+0x30], st0})
00415940                      unimplemented  {fstp dword [esp+0x30], st0}
00415944                      unimplemented  {fld st0, dword [esi+0xc]}
00415947                      unimplemented  {fsub st0, st1}
00415949                      int32_t eax_40
00415949                      int16_t x87control_9
00415949                      eax_40, x87control_9 = __ftol(x87control, st0_2)
0041594e                      unimplemented  {fstp st0, st0}
0041594e                      unimplemented  {fstp st0, st0}
00415950                      unimplemented  {fld st0, dword [esi+0x1c]}
00415953                      unimplemented  {fsub st0, dword [esp+0x30]}
00415959                      void* eax_41
00415959                      int16_t x87control_10
00415959                      eax_41, x87control_10 = __ftol(x87control_9, st0_2)
0041595e                      unimplemented  {fld st0, dword [esp+0x34]}
00415962                      long double temp7_1 = fconvert.t(0f)
00415962                      unimplemented  {fcomp st0, dword [&data_429148]} f- temp7_1
00415962                      bool c0_6 =
00415962                          unimplemented  {fcomp st0, dword [&data_429148]} f< temp7_1
00415962                      bool c2_6 = is_unordered.t(
00415962                          unimplemented  {fcomp st0, dword [&data_429148]}, temp7_1)
00415962                      bool c3_6 =
00415962                          unimplemented  {fcomp st0, dword [&data_429148]} f== temp7_1
00415962                      unimplemented  {fcomp st0, dword [&data_429148]}
0041596a                      eax_41.w = (c0_6 ? 1 : 0) << 8 | (c2_6 ? 1 : 0) << 0xa
0041596a                          | (c3_6 ? 1 : 0) << 0xe | (top & 7) << 0xb
0041596a                      
0041596f                      if ((eax_41:1.b & 0x40) != 0)
00415975                          unimplemented  {fld st0, dword [esp+0x38]}
00415979                          long double temp8_1 = fconvert.t(0f)
00415979                          unimplemented  {fcomp st0, dword [&data_429148]} f- temp8_1
00415979                          bool c0_7 =
00415979                              unimplemented  {fcomp st0, dword [&data_429148]} f< temp8_1
00415979                          bool c2_7 = is_unordered.t(
00415979                              unimplemented  {fcomp st0, dword [&data_429148]}, temp8_1)
00415979                          bool c3_7 =
00415979                              unimplemented  {fcomp st0, dword [&data_429148]} f== temp8_1
00415979                          unimplemented  {fcomp st0, dword [&data_429148]}
00415984                          eax_41.w = (c0_7 ? 1 : 0) << 8 | (c2_7 ? 1 : 0) << 0xa
00415984                              | (c3_7 ? 1 : 0) << 0xe | (top & 7) << 0xb
00415984                      
00415990                      unimplemented  {fld st0, dword [esp+0x40]}
00415994                      long double temp9_1 = fconvert.t(0f)
00415994                      unimplemented  {fcomp st0, dword [&data_429148]} f- temp9_1
00415994                      bool c0_8 =
00415994                          unimplemented  {fcomp st0, dword [&data_429148]} f< temp9_1
00415994                      bool c2_8 = is_unordered.t(
00415994                          unimplemented  {fcomp st0, dword [&data_429148]}, temp9_1)
00415994                      bool c3_8 =
00415994                          unimplemented  {fcomp st0, dword [&data_429148]} f== temp9_1
00415994                      unimplemented  {fcomp st0, dword [&data_429148]}
0041599a                      eax_41.w = (c0_8 ? 1 : 0) << 8 | (c2_8 ? 1 : 0) << 0xa
0041599a                          | (c3_8 ? 1 : 0) << 0xe | (top & 7) << 0xb
0041599a                      
0041599f                      if ((eax_41:1.b & 0x40) != 0)
004159a5                          unimplemented  {fld st0, dword [esp+0x44]}
004159a9                          long double temp10_1 = fconvert.t(0f)
004159a9                          unimplemented  {fcomp st0, dword [&data_429148]} f- temp10_1
004159a9                          bool c0_9 =
004159a9                              unimplemented  {fcomp st0, dword [&data_429148]} f< temp10_1
004159a9                          bool c2_9 = is_unordered.t(
004159a9                              unimplemented  {fcomp st0, dword [&data_429148]}, temp10_1)
004159a9                          bool c3_9 =
004159a9                              unimplemented  {fcomp st0, dword [&data_429148]} f== temp10_1
004159a9                          unimplemented  {fcomp st0, dword [&data_429148]}
004159b4                          eax_41.w = (c0_9 ? 1 : 0) << 8 | (c2_9 ? 1 : 0) << 0xa
004159b4                              | (c3_9 ? 1 : 0) << 0xe | (top & 7) << 0xb
004159b4                      
004159c0                      unimplemented  {fld st0, dword [esp+edx*4+0x4c]}
004159c4                      long double temp11_1 = fconvert.t(0f)
004159c4                      unimplemented  {fcomp st0, dword [&data_429148]} f- temp11_1
004159c4                      bool c0_10 =
004159c4                          unimplemented  {fcomp st0, dword [&data_429148]} f< temp11_1
004159c4                      bool c2_10 = is_unordered.t(
004159c4                          unimplemented  {fcomp st0, dword [&data_429148]}, temp11_1)
004159c4                      bool c3_10 =
004159c4                          unimplemented  {fcomp st0, dword [&data_429148]} f== temp11_1
004159c4                      unimplemented  {fcomp st0, dword [&data_429148]}
004159ca                      eax_41.w = (c0_10 ? 1 : 0) << 8 | (c2_10 ? 1 : 0) << 0xa
004159ca                          | (c3_10 ? 1 : 0) << 0xe | (top & 7) << 0xb
004159cf                      int16_t top_64
004159cf                      
004159cf                      if ((eax_41:1.b & 0x40) == 0)
004159f8                          unimplemented  {fld st0, dword [esp+ecx+0x4c]}
004159fc                          unimplemented  {fld st0, dword [esp+edx*4+0x4c]}
00415a00                          __fpatan(x: unimplemented  {fpatan }, y: unimplemented  {fpatan })
00415a00                          unimplemented  {fpatan }
00415a00                          unimplemented  {fpatan }
00415a00                          top_64 = top - 1
00415a02                          unimplemented  {fmul st0, qword [&data_429250]}
004159cf                      else
004159d4                          unimplemented  {fld st0, dword [esp+ecx+0x4c]}
004159d8                          long double temp12_1 = fconvert.t(0f)
004159d8                          unimplemented  {fcomp st0, dword [&data_429148]} f- temp12_1
004159d8                          bool c0_11 =
004159d8                              unimplemented  {fcomp st0, dword [&data_429148]} f< temp12_1
004159d8                          bool c2_11 = is_unordered.t(
004159d8                              unimplemented  {fcomp st0, dword [&data_429148]}, temp12_1)
004159d8                          bool c3_11 =
004159d8                              unimplemented  {fcomp st0, dword [&data_429148]} f== temp12_1
004159d8                          unimplemented  {fcomp st0, dword [&data_429148]}
004159de                          eax_41.w = (c0_11 ? 1 : 0) << 8 | (c2_11 ? 1 : 0) << 0xa
004159de                              | (c3_11 ? 1 : 0) << 0xe | (top & 7) << 0xb
004159de                          
004159e3                          if ((eax_41:1.b & 0x41) != 0)
004159ed                              top_64 = top - 1
004159ed                              unimplemented  {fld st0, qword [&data_429258]}
004159e3                          else
004159e5                              top_64 = top - 1
004159e5                              unimplemented  {fld st0, qword [&data_429260]}
004159e5                      
00415a08                      long double temp13_1 = fconvert.t(0f)
00415a08                      unimplemented  {fcom st0, dword [&data_429148]} f- temp13_1
00415a08                      bool c0_12 =
00415a08                          unimplemented  {fcom st0, dword [&data_429148]} f< temp13_1
00415a08                      bool c2_12 = is_unordered.t(
00415a08                          unimplemented  {fcom st0, dword [&data_429148]}, temp13_1)
00415a08                      bool c3_12 =
00415a08                          unimplemented  {fcom st0, dword [&data_429148]} f== temp13_1
00415a0e                      eax_41.w = (c0_12 ? 1 : 0) << 8 | (c2_12 ? 1 : 0) << 0xa
00415a0e                          | (c3_12 ? 1 : 0) << 0xe | (top_64 & 7) << 0xb
00415a0e                      
00415a13                      if ((eax_41:1.b & 1) != 0)
00415a15                          unimplemented  {fadd dword [&data_429248]}
00415a15                      
00415a1b                      long double temp14_1 = fconvert.t(360f)
00415a1b                      unimplemented  {fcom st0, dword [&data_429248]} f- temp14_1
00415a1b                      bool c0_13 =
00415a1b                          unimplemented  {fcom st0, dword [&data_429248]} f< temp14_1
00415a1b                      bool c2_13 = is_unordered.t(
00415a1b                          unimplemented  {fcom st0, dword [&data_429248]}, temp14_1)
00415a1b                      bool c3_13 =
00415a1b                          unimplemented  {fcom st0, dword [&data_429248]} f== temp14_1
00415a21                      eax_41.w = (c0_13 ? 1 : 0) << 8 | (c2_13 ? 1 : 0) << 0xa
00415a21                          | (c3_13 ? 1 : 0) << 0xe | (top_64 & 7) << 0xb
00415a21                      
00415a26                      if ((eax_41:1.b & 1) == 0)
00415a28                          unimplemented  {fsub st0, dword [&data_429248]}
00415a28                      
00415a2e                      unimplemented  {fld st0, dword [esp+edx*4+0x34]}
00415a32                      long double temp15_1 = fconvert.t(0f)
00415a32                      unimplemented  {fcomp st0, dword [&data_429148]} f- temp15_1
00415a32                      bool c0_14 =
00415a32                          unimplemented  {fcomp st0, dword [&data_429148]} f< temp15_1
00415a32                      bool c2_14 = is_unordered.t(
00415a32                          unimplemented  {fcomp st0, dword [&data_429148]}, temp15_1)
00415a32                      bool c3_14 =
00415a32                          unimplemented  {fcomp st0, dword [&data_429148]} f== temp15_1
00415a32                      unimplemented  {fcomp st0, dword [&data_429148]}
00415a3c                      eax_41.w = (c0_14 ? 1 : 0) << 8 | (c2_14 ? 1 : 0) << 0xa
00415a3c                          | (c3_14 ? 1 : 0) << 0xe | (top_64 & 7) << 0xb
00415a41                      int16_t top_71
00415a41                      
00415a41                      if ((eax_41:1.b & 0x40) == 0)
00415a64                          unimplemented  {fld st0, dword [esp+ecx+0x34]}
00415a68                          unimplemented  {fld st0, dword [edx]}
00415a6a                          __fpatan(x: unimplemented  {fpatan }, y: unimplemented  {fpatan })
00415a6a                          unimplemented  {fpatan }
00415a6a                          unimplemented  {fpatan }
00415a6a                          top_71 = top_64 - 1
00415a6c                          unimplemented  {fmul st0, qword [&data_429250]}
00415a41                      else
00415a43                          unimplemented  {fld st0, dword [esp+ecx+0x34]}
00415a47                          long double temp16_1 = fconvert.t(0f)
00415a47                          unimplemented  {fcomp st0, dword [&data_429148]} f- temp16_1
00415a47                          bool c0_15 =
00415a47                              unimplemented  {fcomp st0, dword [&data_429148]} f< temp16_1
00415a47                          bool c2_15 = is_unordered.t(
00415a47                              unimplemented  {fcomp st0, dword [&data_429148]}, temp16_1)
00415a47                          bool c3_15 =
00415a47                              unimplemented  {fcomp st0, dword [&data_429148]} f== temp16_1
00415a47                          unimplemented  {fcomp st0, dword [&data_429148]}
00415a4d                          eax_41.w = (c0_15 ? 1 : 0) << 8 | (c2_15 ? 1 : 0) << 0xa
00415a4d                              | (c3_15 ? 1 : 0) << 0xe | (top_64 & 7) << 0xb
00415a4d                          
00415a52                          if ((eax_41:1.b & 0x41) != 0)
00415a5c                              top_71 = top_64 - 1
00415a5c                              unimplemented  {fld st0, qword [&data_429258]}
00415a52                          else
00415a54                              top_71 = top_64 - 1
00415a54                              unimplemented  {fld st0, qword [&data_429260]}
00415a54                      
00415a72                      long double temp17_1 = fconvert.t(0f)
00415a72                      unimplemented  {fcom st0, dword [&data_429148]} f- temp17_1
00415a72                      bool c0_16 =
00415a72                          unimplemented  {fcom st0, dword [&data_429148]} f< temp17_1
00415a72                      bool c2_16 = is_unordered.t(
00415a72                          unimplemented  {fcom st0, dword [&data_429148]}, temp17_1)
00415a72                      bool c3_16 =
00415a72                          unimplemented  {fcom st0, dword [&data_429148]} f== temp17_1
00415a78                      eax_41.w = (c0_16 ? 1 : 0) << 8 | (c2_16 ? 1 : 0) << 0xa
00415a78                          | (c3_16 ? 1 : 0) << 0xe | (top_71 & 7) << 0xb
00415a78                      
00415a7d                      if ((eax_41:1.b & 1) != 0)
00415a7f                          unimplemented  {fadd dword [&data_429248]}
00415a7f                      
00415a85                      long double temp18_1 = fconvert.t(360f)
00415a85                      unimplemented  {fcom st0, dword [&data_429248]} f- temp18_1
00415a85                      bool c0_17 =
00415a85                          unimplemented  {fcom st0, dword [&data_429248]} f< temp18_1
00415a85                      bool c2_17 = is_unordered.t(
00415a85                          unimplemented  {fcom st0, dword [&data_429248]}, temp18_1)
00415a85                      bool c3_17 =
00415a85                          unimplemented  {fcom st0, dword [&data_429248]} f== temp18_1
00415a8b                      eax_41.w = (c0_17 ? 1 : 0) << 8 | (c2_17 ? 1 : 0) << 0xa
00415a8b                          | (c3_17 ? 1 : 0) << 0xe | (top_71 & 7) << 0xb
00415a8b                      
00415a90                      if ((eax_41:1.b & 1) == 0)
00415a92                          unimplemented  {fsub st0, dword [&data_429248]}
00415a92                      
00415a98                      unimplemented  {fsub st0, st1}
00415a9a                      int32_t eax_42
00415a9a                      int16_t x87control_11
00415a9a                      eax_42, x87control_11 = __ftol(x87control_10, st0_2)
00415aa1                      unimplemented  {fstp st0, st0}
00415aa1                      unimplemented  {fstp st0, st0}
00415aa1                      
00415aa3                      if (eax_42 s< 0)
00415aa5                          eax_42 += 0x168
00415aa5                      
00415aaf                      if (eax_42 s>= 0x168)
00415ab1                          eax_42 -= 0x168
00415ab1                      
00415ab6                      int32_t var_68_11 = eax_42
00415abb                      int32_t var_70_6 = eax_40
00415abc                      void* var_74_2 = &(&data_586048)[eax_36 * 9]
00415abc                      
00415acd                      if (sub_41e4d9(arg1, "%s %d %d %d") s< 0)
00415c01                          return 0
00415c01                      
00415ad3                      unimplemented  {fld st0, dword [esp+0x24]}
00415ad7                      int32_t eax_44
00415ad7                      int16_t x87control_12
00415ad7                      eax_44, x87control_12 = __ftol(x87control_11, st0_2)
00415adc                      int32_t ecx_9 = eax_44
00415ade                      int32_t var_44_2 = ecx_9
00415ae2                      unimplemented  {fild st0, dword [esp+0x20]}
00415ae6                      unimplemented  {fsubr st0, dword [esp+0x24]}
00415aea                      unimplemented  {fabs }
00415aec                      long double temp19_1 = fconvert.t(0.001)
00415aec                      unimplemented  {fcomp st0, qword [&data_4291e0]} f- temp19_1
00415aec                      bool c0_18 =
00415aec                          unimplemented  {fcomp st0, qword [&data_4291e0]} f< temp19_1
00415aec                      bool c2_18 = is_unordered.t(
00415aec                          unimplemented  {fcomp st0, qword [&data_4291e0]}, temp19_1)
00415aec                      bool c3_18 =
00415aec                          unimplemented  {fcomp st0, qword [&data_4291e0]} f== temp19_1
00415aec                      unimplemented  {fcomp st0, qword [&data_4291e0]}
00415aec                      int16_t top_79 = top_71 + 2
00415af2                      eax_44.w = (c0_18 ? 1 : 0) << 8 | (c2_18 ? 1 : 0) << 0xa
00415af2                          | (c3_18 ? 1 : 0) << 0xe | (top_79 & 7) << 0xb
00415af2                      
00415af7                      if ((eax_44:1.b & 1) == 0)
00415b12                          unimplemented  {fld st0, dword [esp+0x24]}
00415b19                          unimplemented  {fstp qword [esp], st0}
00415b19                          
00415b2c                          if (sub_41e4d9(arg1, " %4f") s< 0)
00415c01                              return 0
00415af7                      else
00415af9                          int32_t var_68_12 = ecx_9
00415af9                          
00415b0a                          if (sub_41e4d9(arg1, &data_42dd28) s< 0)
00415c01                              return 0
00415c01                      
00415b32                      unimplemented  {fld st0, dword [esp+0x28]}
00415b36                      int32_t eax_47
00415b36                      eax_47, x87control = __ftol(x87control_12, st0_2)
00415b3b                      int32_t ecx_10 = eax_47
00415b3d                      int32_t var_44_3 = ecx_10
00415b41                      unimplemented  {fild st0, dword [esp+0x20]}
00415b45                      unimplemented  {fsubr st0, dword [esp+0x28]}
00415b49                      unimplemented  {fabs }
00415b4b                      long double temp20_1 = fconvert.t(0.001)
00415b4b                      unimplemented  {fcomp st0, qword [&data_4291e0]} f- temp20_1
00415b4b                      bool c0_19 =
00415b4b                          unimplemented  {fcomp st0, qword [&data_4291e0]} f< temp20_1
00415b4b                      bool c2_19 = is_unordered.t(
00415b4b                          unimplemented  {fcomp st0, qword [&data_4291e0]}, temp20_1)
00415b4b                      bool c3_19 =
00415b4b                          unimplemented  {fcomp st0, qword [&data_4291e0]} f== temp20_1
00415b4b                      unimplemented  {fcomp st0, qword [&data_4291e0]}
00415b4b                      top = top_79
00415b51                      eax_47.w = (c0_19 ? 1 : 0) << 8 | (c2_19 ? 1 : 0) << 0xa
00415b51                          | (c3_19 ? 1 : 0) << 0xe | (top & 7) << 0xb
00415b51                      
00415b56                      if ((eax_47:1.b & 1) == 0)
00415b71                          unimplemented  {fld st0, dword [esp+0x28]}
00415b78                          unimplemented  {fstp qword [esp], st0}
00415b78                          
00415b8b                          if (sub_41e4d9(arg1, " %4f") s< 0)
00415c01                              return 0
00415b56                      else
00415b58                          int32_t var_68_13 = ecx_10
00415b58                          
00415b69                          if (sub_41e4d9(arg1, &data_42dd28) s< 0)
00415c01                              return 0
00415c01                      
00415b94                      if (data_65e020 == 2)
00415ba0                          int32_t var_68_14 = (&data_586044)[eax_36 * 9]
00415ba4                          int32_t var_6c_9 = (&data_586040)[eax_36 * 9]
00415ba5                          int32_t var_70_9 = var_54_1[5]
00415ba5                          
00415bb6                          if (sub_41e4d9(arg1, " %ld %ld %ld") s< 0)
00415c01                              return 0
004157e4                  else
004157ee                      int32_t eax_30 = *(arg2 + 8)
004157ee                      
004157f6                      if ((eax_30 & 0x10000) == 0)
00415827                          if (eax_30 == 0x20000)
00415829                              int32_t eax_32 = data_65e020
00415829                              
00415831                              if (eax_32 == 4)
00415833                                  var_68_8 = "generic/misc/monster 0 0 0 1 1"
00415838                                  goto label_41589c
00415838                              
0041583d                              if (eax_32 != 2)
0041583d                                  goto label_41581b
0041583d                              
0041583f                              var_68_8 = "e1u1/clip_mon 0 0 0 1 1"
00415844                              goto label_41589c
00415844                          
00415856                          if (sub_41e4d9(arg1, "clip 0 0 0 1 1") s< 0)
00415c01                              return 0
00415c01                          
0041585f                          int32_t var_68_9 = *(arg2 + 8)
00415865                          sub_410080("brush->contents = %d\n")
004157f6                      else
004157f8                          int32_t eax_31 = data_65e020
004157f8                          
00415800                          if (eax_31 != 4)
0041580f                              if (eax_31 == 2)
00415811                                  var_68_8 = "e1u1/clip 0 0 0 1 1"
00415816                                  goto label_41589c
00415816                              
0041581b                              label_41581b:
0041581b                              var_68_8 = "clip 0 0 0 1 1"
00415820                              goto label_41589c
00415820                          
00415802                          var_68_8 = "generic/misc/clip 0 0 0 1 1"
0041589c                          label_41589c:
0041589c                          
004158a6                          if (sub_41e4d9(arg1, var_68_8) s< 0)
00415c01                              return 0
00415c01                  
00415bc8                  if (sub_41e4d9(arg1, &data_42b33c) s< 0)
00415c01                      return 0
00415c01              
00415bd2              i = i_1 + 1
00415bd6              i_1 = i
00415bdc          while (i s< *(arg2 + 0x2c))
00415bdc      
00415bf6      if (sub_41e4d9(arg1, &data_42dd0c) s< 0)
00415c01          return 0
00415c01      
00415c02      data_dde040 += 1
00415c02  
00415c14  return 1

00415c15                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

00415c20    int32_t sub_415c20(float arg1, void* arg2)

00415c27  int32_t* edi = arg1
00415c27  
00415c3b  if (sub_41e4d9(edi, &data_42de9c) s< 0)
00415c46      return 0
00415c46  
00415c47  void* ebx = arg2
00415c4f  float var_c
00415c4f  void* eax_2 = &var_c - ebx
00415c51  int32_t var_10 = 0
00415c51  
00415c5d  while (true)
00415c5d      float ebp_1 = -nanf
00415c60      arg1 = -nanf
00415c60      
00415c64      while (true)
00415c64          unimplemented  {fild st0, dword [esp+0x24]}
00415c6c          int32_t var_4_1 = 0
00415c74          int32_t var_8_1 = 0
00415c7c          var_c = 0f
00415c84          unimplemented  {fld st0, st0}
00415c8a          *(eax_2 + ebx) = fconvert.s(unimplemented  {fstp dword [eax+ebx], st0})
00415c8a          unimplemented  {fstp dword [eax+ebx], st0}
00415c8d          unimplemented  {fmul st0, dword [ebx]}
00415c8f          unimplemented  {fadd dword [&data_4291f8]}
00415c95          arg1 = fconvert.s(unimplemented  {fstp dword [esp+0x24], st0})
00415c95          unimplemented  {fstp dword [esp+0x24], st0}
00415c9f          int32_t* eax_4
00415c9f          long double st0_1
00415c9f          st0_1, eax_4 = sub_410b70(&var_c, arg1)
00415c9f          unimplemented  {call sub_410b70}
00415ca6          unimplemented  {fld st0, dword [esi+0xc]}
00415ca9          int32_t eax_5
00415ca9          int16_t x87control
00415ca9          int16_t x87control_1
00415ca9          eax_5, x87control_1 = __ftol(x87control, st0_1)
00415cae          unimplemented  {fld st0, dword [esi+0x8]}
00415cb1          int32_t var_2c_1 = eax_5
00415cb2          int32_t eax_6
00415cb2          int16_t x87control_2
00415cb2          eax_6, x87control_2 = __ftol(x87control_1, st0_1)
00415cb7          unimplemented  {fld st0, dword [esi+0x4]}
00415cba          int32_t var_30_1 = eax_6
00415cbb          int32_t eax_7
00415cbb          int16_t x87control_3
00415cbb          eax_7, x87control_3 = __ftol(x87control_2, st0_1)
00415cc0          int32_t var_34_1 = eax_7
00415cc0          
00415cd1          if (sub_41e4d9(edi, "  ( %5i %5i %5i ) ") s>= 0)
00415cd7              unimplemented  {fld st0, dword [esi+0x18]}
00415cda              int32_t eax_9
00415cda              int16_t x87control_4
00415cda              eax_9, x87control_4 = __ftol(x87control_3, st0_1)
00415cdf              unimplemented  {fld st0, dword [esi+0x14]}
00415ce2              int32_t var_24_2 = eax_9
00415ce3              int32_t eax_10
00415ce3              int16_t x87control_5
00415ce3              eax_10, x87control_5 = __ftol(x87control_4, st0_1)
00415ce8              unimplemented  {fld st0, dword [esi+0x10]}
00415ceb              int32_t var_28_2 = eax_10
00415cec              int32_t eax_11
00415cec              int16_t x87control_6
00415cec              eax_11, x87control_6 = __ftol(x87control_5, st0_1)
00415cf1              int32_t var_2c_2 = eax_11
00415cf1              
00415d02              if (sub_41e4d9(edi, "( %5i %5i %5i ) ") s>= 0)
00415d08                  unimplemented  {fld st0, dword [esi+0x24]}
00415d0b                  int32_t eax_13
00415d0b                  int16_t x87control_7
00415d0b                  eax_13, x87control_7 = __ftol(x87control_6, st0_1)
00415d10                  unimplemented  {fld st0, dword [esi+0x20]}
00415d13                  int32_t var_24_3 = eax_13
00415d14                  int32_t eax_14
00415d14                  int16_t x87control_8
00415d14                  eax_14, x87control_8 = __ftol(x87control_7, st0_1)
00415d19                  unimplemented  {fld st0, dword [esi+0x1c]}
00415d1c                  int32_t var_28_3 = eax_14
00415d1d                  int32_t eax_15
00415d1d                  eax_15, x87control = __ftol(x87control_8, st0_1)
00415d1d                  int16_t top = top - 1
00415d22                  int32_t var_2c_3 = eax_15
00415d22                  
00415d33                  if (sub_41e4d9(edi, "( %5i %5i %5i ) ") s>= 0)
00415d3a                      sub_410740(eax_4)
00415d3a                      
00415d4a                      if (data_65e020 != 4)
00415d70                          if (sub_41e4d9(edi, "e1u1/origin 0 0 0 1 1") s>= 0)
00415d78                              label_415d78:
00415d78                              
00415d82                              if (sub_41e4d9(edi, &data_42b33c) s>= 0)
00415d84                                  ebp_1 += 2
00415d8a                                  arg1 = ebp_1
00415d8a                                  
00415d8e                                  if (ebp_1 s<= 1)
00415d8e                                      continue
00415d8e                                  else
00415d98                                      ebx += 4
00415d9c                                      bool cond:1_1 = var_10 + 1 s< 3
00415d9f                                      var_10 += 1
00415d9f                                      
00415da3                                      if (cond:1_1)
00415da3                                          break
00415da3                                      
00415db9                                      if (sub_41e4d9(edi, &data_42dd0c) s>= 0)
00415dcd                                          data_dde040 += 1
00415ddc                                          return 1
00415d4a                      else if (sub_41e4d9(edi, "generic/misc/origin 0 0 0 1 1") s>= 0)
00415d5c                          goto label_415d78
00415d5c          
00415dc4          return 0

00415ddd                                                                                         90 90 90                               ...

00415de0    void* sub_415de0(void* arg1)

00415de6  int32_t esi = data_dde044
00415dec  int32_t i_1 = *(arg1 + 0x18)
00415def  int32_t edx = 0
00415df2  int32_t i = i_1
00415df2  
00415df6  if (esi s> 0)
00415df8      void* result = arg1
00415dfc      void* result_1 = &data_4b6000
00415dfc      
00415e03      while (i != 0)
00415e08          result = result_1
00415e08          
00415e10          if (*result_1 == 0 && (*(result_1 + 9) & 0x80) != 0)
00415e12              i -= 1
00415e12          
00415e13          edx += 1
00415e14          result_1 += 0x34
00415e14          
00415e19          if (edx s>= esi)
00415e1b              int32_t i_2 = i_1
00415e21              sub_410030("area portal %d brush not found\n")
00415e2e              return 0
00415e2e      
00415e31      if (edx s< esi)
00415e46          return result
00415e46  
00415e33  int32_t i_3 = i_1
00415e39  sub_410030("area portal %d brush not found\n")
00415e41  return nullptr

00415e47                       90 90 90 90 90 90 90 90 90                                                         .........

00415e50    int32_t sub_415e50(int32_t* arg1)

00415e5a  int32_t* edi = arg1
00415e5a  
00415e71  if (sub_41e4d9(edi, "//==============================…") s< 0)
00415e7f      return 0
00415e7f  
00415e87  if (data_65e020 == 4 && sub_41e4d9(edi, "// generic/misc/red is used for …") s< 0)
00415ea7      return 0
00415ea7  
00415eb8  if (sub_41e4d9(edi, "//\n//==========================…") s< 0)
00415ec6      return 0
00415ec6  
00415ecc  int32_t var_808_1 = 0
00415ecc  
00415ed6  if (data_2584ecc s> 0)
00415edc      void* esi_1 = &data_256ee94
00415ee1      void* var_804_1 = &data_256ee94
00415ee1      
00415eec      while (true)
00415eec          if (*esi_1 != 0)
00415f02              if (sub_41e4d9(edi, &data_42c9dc) s< 0)
00415e7f                  return 0
00415e7f              
00415f08              void** ebp_1 = *esi_1
00415f08              
00415f0c              if (ebp_1 != 0)
00415f12                  while (true)
00415f12                      int32_t edi_1 = ebp_1[1]
00415f15                      int32_t i = 0xffffffff
00415f15                      
00415f1e                      while (i != 0)
00415f1e                          bool cond:2_1 = 0 != *edi_1
00415f1e                          edi_1 += 1
00415f1e                          i -= 1
00415f1e                          
00415f1e                          if (not(cond:2_1))
00415f1e                              break
00415f1e                      
00415f20                      int32_t ecx_1 = not.d(i)
00415f2d                      void var_800
00415f2d                      int32_t esi_3
00415f2d                      int32_t edi_3
00415f2d                      edi_3, esi_3 = __builtin_memcpy(dest: &var_800, src: edi_1 - ecx_1, 
00415f2d                          n: ecx_1 u>> 2 << 2)
00415f34                      __builtin_memcpy(dest: edi_3, src: esi_3, n: ecx_1 & 3)
00415f3b                      sub_40e190(&var_800)
00415f40                      int32_t edi_4 = ebp_1[2]
00415f43                      int32_t i_1 = 0xffffffff
00415f43                      
00415f4f                      while (i_1 != 0)
00415f4f                          bool cond:3_1 = 0 != *edi_4
00415f4f                          edi_4 += 1
00415f4f                          i_1 -= 1
00415f4f                          
00415f4f                          if (not(cond:3_1))
00415f4f                              break
00415f4f                      
00415f51                      int32_t ecx_5 = not.d(i_1)
00415f5e                      char var_400
00415f5e                      int32_t esi_5
00415f5e                      int32_t edi_6
00415f5e                      edi_6, esi_5 = __builtin_memcpy(dest: &var_400, src: edi_4 - ecx_5, 
00415f5e                          n: ecx_5 u>> 2 << 2)
00415f65                      __builtin_memcpy(dest: edi_6, src: esi_5, n: ecx_5 & 3)
00415f6f                      sub_40e190(&var_400)
00415f74                      int32_t eax_11 = data_65e020
00415f84                      char edx_1
00415f84                      
00415f84                      if (eax_11 != 2 && eax_11 != 4)
00415fc6                          label_415fc6:
00415fc6                          
00415fc8                          if (*(esi_1 + 0x10) s< 0)
00415fc8                              goto label_41601c
00415fc8                          
00415fca                          char* esi_7 = "model"
00415fcf                          void* eax_17 = &var_800
00415fd3                          int32_t eax_19
00415fd3                          
00415fd3                          while (true)
00415fd3                              edx_1 = *eax_17
00415fd7                              char temp10_1 = *esi_7
00415fd7                              bool c_3 = edx_1 u< temp10_1
00415fd7                              
00415fd9                              if (edx_1 == temp10_1)
00415fdd                                  if (edx_1 == 0)
00415ff3                                      eax_19 = 0
00415ff5                                      break
00415ff5                                  
00415fdf                                  edx_1 = *(eax_17 + 1)
00415fe4                                  char temp14_1 = esi_7[1]
00415fe4                                  c_3 = edx_1 u< temp14_1
00415fe4                                  
00415fe7                                  if (edx_1 == temp14_1)
00415fe9                                      eax_17 += 2
00415fec                                      esi_7 = &esi_7[2]
00415fec                                      
00415ff1                                      if (edx_1 != 0)
00415ff1                                          continue
00415ff1                                      
00415ff3                                      eax_19 = 0
00415ff5                                      break
00415ff5                              
00415ff7                              bool c_4 = unimplemented  {sbb eax, eax}
00415ff9                              eax_19 = sbb.d(sbb.d(eax_17, eax_17, c_3), 0xffffffff, c_4)
00415ff9                              break
00415ff9                          
00416008                          if (eax_19 != 0 || var_400 != 0x2a)
00415ffe                              goto label_41601c
00415f84                      else if (*(esi_1 + 0x10) s< 0)
0041601c                          label_41601c:
0041601c                          char* var_81c_2 = &var_400
0041601d                          void* var_820_5 = &var_800
0041601d                          
0041602e                          if (sub_41e4d9(arg1, " "%s" "%s"\n") s< 0)
00415e7f                              return 0
00415f8b                      else
00415f8d                          char* esi_6 = "origin"
00415f92                          void* eax_13 = &var_800
00415f96                          int32_t eax_15
00415f96                          
00415f96                          while (true)
00415f96                              edx_1 = *eax_13
00415f9a                              char temp7_1 = *esi_6
00415f9a                              bool c_1 = edx_1 u< temp7_1
00415f9a                              
00415f9c                              if (edx_1 == temp7_1)
00415fa0                                  if (edx_1 == 0)
00415fb6                                      eax_15 = 0
00415fb8                                      break
00415fb8                                  
00415fa2                                  edx_1 = *(eax_13 + 1)
00415fa7                                  char temp11_1 = esi_6[1]
00415fa7                                  c_1 = edx_1 u< temp11_1
00415fa7                                  
00415faa                                  if (edx_1 == temp11_1)
00415fac                                      eax_13 += 2
00415faf                                      esi_6 = &esi_6[2]
00415faf                                      
00415fb4                                      if (edx_1 != 0)
00415fb4                                          continue
00415fb4                                      
00415fb6                                      eax_15 = 0
00415fb8                                      break
00415fb8                              
00415fba                              bool c_2 = unimplemented  {sbb eax, eax}
00415fbc                              eax_15 = sbb.d(sbb.d(eax_13, eax_13, c_1), 0xffffffff, c_2)
00415fbc                              break
00415fbc                          
00415fc1                          if (eax_15 != 0)
00415fc1                              goto label_415fc6
00416034                      ebp_1 = *ebp_1
00416034                      
00416039                      if (ebp_1 == 0)
00416039                          break
00416039              
0041604f              if (sub_40e6a0(esi_1 - 0x14, "origin") == 0)
00416064                  *(esi_1 - 0xc) = 0
00416067                  *(esi_1 - 0x10) = 0
0041606a                  *(esi_1 - 0x14) = 0
0041604f              else
00416058                  sub_40e730(esi_1 - 0x14, "origin", esi_1 - 0x14)
00416058              
0041607a              char* esi_8 = sub_40e6a0(esi_1 - 0x14, "classname")
0041607c              char* ecx_10 = "func_areaportal"
00416081              int32_t eax_24
00416081              
00416081              while (true)
00416081                  char edx_3 = *ecx_10
00416083                  char* eax_22
00416083                  eax_22.b = edx_3
00416085                  char temp0_1 = *esi_8
00416085                  bool c_5 = edx_3 u< temp0_1
00416085                  
00416087                  if (edx_3 == temp0_1)
0041608b                      if (eax_22.b == 0)
004160a1                          eax_24 = 0
004160a3                          break
004160a3                      
0041608d                      edx_3 = ecx_10[1]
00416090                      eax_22.b = edx_3
00416092                      char temp3_1 = esi_8[1]
00416092                      c_5 = edx_3 u< temp3_1
00416092                      
00416095                      if (edx_3 == temp3_1)
00416097                          ecx_10 = &ecx_10[2]
0041609a                          esi_8 = &esi_8[2]
0041609a                          
0041609f                          if (eax_22.b != 0)
0041609f                              continue
0041609f                          
004160a1                          eax_24 = 0
004160a3                          break
004160a3                  
004160a5                  bool c_6 = unimplemented  {sbb eax, eax}
004160a7                  eax_24 = sbb.d(sbb.d(eax_22, eax_22, c_5), 0xffffffff, c_6)
004160a7                  break
004160a7              
004160ac              if (eax_24 != 0)
004160e3                  int32_t ecx_11 = 0
004160e5                  int32_t i_2 = 0
004160e5                  
004160e9                  if (data_dde044 s> 0)
004160ef                      void* esi_9 = &data_4b6000
004160ef                      
00416134                      do
004160f4                          int32_t eax_29 = *esi_9
004160f4                          
00416108                          if (eax_29 == var_808_1
00416108                                  && (((*(esi_9 + 8)).w:1.b & 0x80) == 0 || eax_29 != 0))
00416111                              void* var_81c_6 = esi_1 - 0x14
00416111                              
0041611e                              if (sub_415590(arg1, esi_9) == 0)
00415e7f                                  return 0
00415e7f                              
00416124                              ecx_11 = 1
00416124                          
0041612e                          i_2 += 1
0041612f                          esi_9 += 0x34
00416134                      while (i_2 s< data_dde044)
00416134                      
00416138                      if (ecx_11 != 0)
0041613a                          long double x87_r7_1 = fconvert.t(*(esi_1 - 0x14))
0041613c                          long double temp4_1 = fconvert.t(0f)
0041613c                          x87_r7_1 - temp4_1
00416142                          int32_t eax_31
00416142                          eax_31.w = (x87_r7_1 < temp4_1 ? 1 : 0) << 8
00416142                              | (is_unordered.t(x87_r7_1, temp4_1) ? 1 : 0) << 0xa
00416142                              | (x87_r7_1 == temp4_1 ? 1 : 0) << 0xe
00416142                          
00416147                          if ((eax_31:1.b & 0x40) == 0)
00416172                              label_416172:
00416172                              
0041617c                              if (sub_415c20(arg1, esi_1 - 0x14) == 0)
00415e7f                                  return 0
00416147                          else
00416149                              long double x87_r7_2 = fconvert.t(*(esi_1 - 0x10))
0041614c                              long double temp5_1 = fconvert.t(0f)
0041614c                              x87_r7_2 - temp5_1
00416152                              eax_31.w = (x87_r7_2 < temp5_1 ? 1 : 0) << 8
00416152                                  | (is_unordered.t(x87_r7_2, temp5_1) ? 1 : 0) << 0xa
00416152                                  | (x87_r7_2 == temp5_1 ? 1 : 0) << 0xe
00416152                              
00416157                              if ((eax_31:1.b & 0x40) == 0)
00416157                                  goto label_416172
00416157                              
00416159                              long double x87_r7_3 = fconvert.t(*(esi_1 - 0xc))
0041615c                              long double temp6_1 = fconvert.t(0f)
0041615c                              x87_r7_3 - temp6_1
00416162                              eax_31.w = (x87_r7_3 < temp6_1 ? 1 : 0) << 8
00416162                                  | (is_unordered.t(x87_r7_3, temp6_1) ? 1 : 0) << 0xa
00416162                                  | (x87_r7_3 == temp6_1 ? 1 : 0) << 0xe
00416162                              
00416167                              if ((eax_31:1.b & 0x40) == 0)
00416167                                  goto label_416172
004160ac              else
004160af                  void* eax_25 = sub_415de0(esi_1 - 0x14)
004160af                  
004160b9                  if (eax_25 == 0)
00415e7f                      return 0
00415e7f                  
004160bf                  void* var_81c_5 = esi_1 - 0x14
004160bf                  
004160d3                  if (sub_415590(arg1, eax_25) == 0)
00415e7f                      return 0
00415e7f              
00416199              if (sub_41e4d9(arg1, &data_42c9d8) s< 0)
00415e7f                  return 0
00415e7f              
0041619f              esi_1 = var_804_1
004161a3              edi = arg1
004161a3          
004161b5          esi_1 += 0x2c
004161b8          bool cond:1_1 = var_808_1 + 1 s< data_2584ecc
004161ba          var_808_1 += 1
004161be          var_804_1 = esi_1
004161be          
004161c2          if (not(cond:1_1))
004161c2              break
004161c2  
004161ce  int32_t var_81c_8 = data_dde040
004161e3  int32_t result
004161e3  result.b = sub_41e4d9(edi, "//total of %d brushes\n") s>= 0
004161f0  return result

004161f1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

00416200    int32_t* sub_416200(int32_t arg1)

00416205  data_dde040 = 0
00416218  int32_t ecx
00416218  double var_8 = fconvert.d(sub_40fae0(ecx))
0041621c  int32_t var_14 = arg1
00416222  sub_410030("writing %s\n")
0041622d  int32_t* eax = sub_41df39(arg1, "wb")
0041622d  
00416239  if (eax == 0)
0041623b      int32_t var_14_1 = arg1
0041624e      return sub_410030("can't open %s\n")
0041624e  
0041625b  if (sub_415e50(eax) == 0)
0041625d      sub_41ddd2(eax)
00416262      int32_t var_18 = arg1
00416275      return sub_410030("error writing map file %s\n")
00416275  
00416276  sub_41ddd2(eax)
00416280  int32_t var_18_1 = data_dde040
00416297  var_18_1.q =
00416297      fconvert.d(sub_40fae0(sub_410030("written %d brushes\n")) - fconvert.t(var_8))
004162ac  return sub_410030("map file written in %5.0f second…")

004162ad                                         90 90 90                                                               ...

004162b0    int32_t* sub_4162b0()

004162b5  sub_410030(&data_42b33c)
004162bf  int32_t var_8 = data_dde044
004162c5  sub_410030("%6i brushes\n")
004162d0  int32_t var_10 = data_255e0c0
004162de  return sub_410030("%6i brush sides\n")

004162df                                                                                               90                                 .

004162e0    int32_t sub_4162e0()

004162e3  sub_41a530()
004162e8  sub_41a530()
004162f4  int32_t i = 0
004162f4  
004162f8  if (data_255e0c0 s> 0)
004162fa      void* edi_1 = &data_1f9e0a8
004162fa      
0041631b      do
004162ff          int32_t* eax_1 = *edi_1
004162ff          
00416303          if (eax_1 != 0)
00416306              sub_410740(eax_1)
00416306          
00416315          i += 1
00416316          edi_1 += 0x20
0041631b      while (i s< data_255e0c0)
0041631b  
00416329  data_255e0f8 = 0
0041632e  __builtin_memset(s: &data_4b6000, c: 0, n: 0xd0000)
0041633a  __builtin_memset(s: 0x1f9e0a0, c: 0, n: 0x400000)
00416346  __builtin_memset(s: &data_65e040, c: 0, n: 0x780000)
00416352  __builtin_memset(s: &data_239e0c0, c: 0, n: 0x1c0000)
0041635e  __builtin_memset(s: &data_4b5000, c: 0, n: 0x1000)
0041636a  __builtin_memset(s: &data_586020, c: 0, n: 0xd8000)
0041636c  data_255e0f4 = 0
00416371  data_255e0f0 = 0
00416380  __builtin_memset(s: &data_255e0d0, c: 0, n: 0x1c)
0041638a  int32_t i_1 = 0
0041638c  bool cond:0 = data_2584ecc s<= 0
0041638e  data_dde044 = 0
00416394  data_255e0c0 = 0
004163ac  data_239e0a0 = 0
004163b8  data_255e0c4 = 0
004163be  data_dde040 = 0
004163be  
004163c4  if (not(cond:0))
004163c7      void* ebp_1 = &data_256ee94
004163c7      
00416403      do
004163cc          int32_t* j_1 = *ebp_1
004163cc          
004163d1          if (j_1 != 0)
004163f4              int32_t* j
004163f4              
004163f4              do
004163d6                  j = *j_1
004163d9                  sub_41e29e(j_1[1])
004163e2                  sub_41e29e(j_1[2])
004163e8                  sub_4105e0(j_1)
004163f0                  j_1 = j
004163f4              while (j != 0)
004163f4          
004163fd          i_1 += 1
004163fe          ebp_1 += 0x2c
00416403      while (i_1 s< data_2584ecc)
00416403  
00416412  data_2584ecc = 0
00416418  __builtin_memset(s: &data_256ee80, c: 0, n: 0x16000)
0041641d  return 0

0041641e                                                                                            90 90                                ..

00416420    int32_t sub_416420(int32_t arg1, void* arg2, void* arg3)

00416430  int32_t* eax = sub_41df39(arg1, U"r")
00416430  
0041643c  if (eax == 0)
0041643e      int32_t var_18 = arg1
00416444      sub_410030("can't open %s\n")
00416454      return 0
00416454  
0041645b  if (arg2 != 0 && sub_41de4f(eax, arg2, FILE_BEGIN) != 0)
0041646d      int32_t var_18_1 = arg1
00416473      sub_410030("error seeking to the file %s\n")
00416479      sub_41ddd2(eax)
00416489      return 0
00416489  
0041649f  int32_t var_8
0041649f  
0041649f  if (sub_41dcbb(&var_8, 8, 1, eax) != 1)
004164a1      int32_t var_18_3 = arg1
004164a7      sub_410030("can't read the file %s\n")
004164ad      sub_41ddd2(eax)
004164bd      return 0
004164bd  
004164bf  sub_41ddd2(eax)
004164d2  var_8 = sub_40ff30(var_8)
004164d7  int32_t var_4
004164d7  int32_t eax_7 = sub_40ff30(var_4)
004164dc  int32_t ecx_1 = var_8
004164e9  int32_t var_4_1 = eax_7
004164e9  
004164ed  if (ecx_1 == 0x50534249)
004164f2      if (eax_7 == 0x26)
004164f4          sub_4162e0()
004164f9          sub_40cb70()
00416505          sub_41a440(arg1, arg2, arg3)
0041650d          sub_40ce40()
0041651d          return 1
0041651d      
00416521      if (eax_7 == 0x29)
00416521          goto label_416561
004164ed  else if (ecx_1 != 0x50534252)
0041658e      if (ecx_1 == 0x1d)
00416590          sub_4162e0()
00416595          sub_40bef0()
004165a1          sub_418f30(arg1, arg2, arg3)
004165a9          sub_40c160()
004165b9          return 1
004165b9      
004165bd      if (ecx_1 == 0x1e)
004165c3          sub_4162e0()
004165c8          sub_40b0a0()
004165d4          sub_417aa0(arg1, arg2, arg3)
004165dc          sub_40b310()
004165ec          return 1
0041655a  else if (eax_7 == 1)
00416561      label_416561:
00416561      sub_4162e0()
00416566      sub_40e7b0()
00416572      sub_41ada0(arg1, arg2, arg3)
0041657a      sub_40ead0()
0041658a      return 1
0041658a  
00416525  int32_t var_18_6 = eax_7
00416526  int32_t edx_1
00416526  edx_1.b = var_8:3.b
0041652c  int32_t eax_10
0041652c  eax_10.b = var_8:2.b
00416530  int32_t var_1c_4 = edx_1
00416533  int32_t var_20_6 = eax_10
00416534  int32_t edx_2
00416534  edx_2.b = ecx_1:1.b
0041653c  int32_t var_24_1 = edx_2
0041653d  int32_t var_28 = ecx_1 & 0xff
00416543  sub_40f970("unknown BSP format %c%c%c%c, ver…")
00416553  return 0

004165ed                                         90 90 90                                                               ...

004165f0    int32_t sub_4165f0(char* arg1)

00416608  if (sub_40fb50(arg1, "sky", 3) == 0)
00416611      return 1
00416611  
00416627  if (sub_40fb50(&arg1[1], "!lava", 5) == 0)
00416630      return 8
00416630  
00416643  if (sub_40fb50(&arg1[1], "!slime", 6) == 0)
0041664c      return 0x10
0041664c  
0041664d  int32_t eax_4
0041664d  eax_4.b = *arg1
00416650  eax_4.b -= 0x21
00416653  char temp0 = eax_4.b
00416653  eax_4.b = neg.b(eax_4.b)
00416657  int32_t eax_6
00416657  eax_6.b = sbb.d(eax_4, eax_4, temp0 != 0).b & 0xe1
0041665c  return eax_6 + 0x20

0041665d                                                                                         90 90 90                               ...

00416660    int32_t* sub_416660(void* arg1, int32_t arg2, int32_t arg3, void** arg4, int32_t* arg5)

0041666d  void* ebp = arg1
00416671  *arg5 = 0
0041667c  long double x87_r7 = fconvert.t(0f)
00416689  *arg4 = 0
00416691  float eax_2 = *(ebp + 0x28)
00416695  float var_18 = 0f
0041669d  void* edi = arg2 * 0x1c + &data_239e0c0
004166a6  void* var_14 = edi
004166aa  int32_t* var_20
004166aa  
004166aa  if (eax_2 s> 0)
004166b0      void* esi_1 = ebp + 0x34
004166b3      float i_7 = eax_2
00416737      float i
00416737      
00416737      do
004166b5          int32_t* ecx_1 = *esi_1
004166b9          var_20 = ecx_1
004166b9          
004166bd          if (ecx_1 != 0)
004166bf              eax_2 = *ecx_1
004166bf              
004166c3              if (eax_2 s> 0)
004166c5                  void* ecx_2 = &ecx_1[2]
004166c8                  float j_2 = eax_2
00416731                  float j
00416731                  
00416731                  do
004166de                      long double x87_r6_5 =
004166de                          fconvert.t(*(ecx_2 + 4)) * fconvert.t(*(edi + 8))
004166de                          + fconvert.t(*(ecx_2 - 4)) * fconvert.t(*edi)
004166de                          + fconvert.t(*ecx_2) * fconvert.t(*(edi + 4))
004166de                          - fconvert.t(*(edi + 0xc))
004166e1                      float var_1c_1 = fconvert.s(x87_r6_5)
004166e5                      long double temp3_1 = fconvert.t(0f)
004166e5                      x87_r6_5 - temp3_1
004166eb                      eax_2.w = (x87_r6_5 < temp3_1 ? 1 : 0) << 8
004166eb                          | (is_unordered.t(x87_r6_5, temp3_1) ? 1 : 0) << 0xa
004166eb                          | (x87_r6_5 == temp3_1 ? 1 : 0) << 0xe | 0x3800
004166eb                      
004166f0                      if ((eax_2:1.b & 0x41) == 0)
004166f2                          long double x87_r6_6 = fconvert.t(var_1c_1)
004166f6                          x87_r6_6 - x87_r7
004166f8                          eax_2.w = (x87_r6_6 < x87_r7 ? 1 : 0) << 8
004166f8                              | (is_unordered.t(x87_r6_6, x87_r7) ? 1 : 0) << 0xa
004166f8                              | (x87_r6_6 == x87_r7 ? 1 : 0) << 0xe | 0x3800
004166f8                          
004166fd                          if ((eax_2:1.b & 0x41) == 0)
00416701                              x87_r7 = fconvert.t(var_1c_1)
00416701                      
00416705                      long double x87_r6_7 = fconvert.t(var_1c_1)
00416709                      long double temp4_1 = fconvert.t(0f)
00416709                      x87_r6_7 - temp4_1
0041670f                      eax_2.w = (x87_r6_7 < temp4_1 ? 1 : 0) << 8
0041670f                          | (is_unordered.t(x87_r6_7, temp4_1) ? 1 : 0) << 0xa
0041670f                          | (x87_r6_7 == temp4_1 ? 1 : 0) << 0xe | 0x3800
0041670f                      
00416714                      if ((eax_2:1.b & 1) != 0)
00416716                          long double x87_r6_8 = fconvert.t(var_1c_1)
0041671a                          long double temp6_1 = fconvert.t(var_18)
0041671a                          x87_r6_8 - temp6_1
0041671e                          eax_2.w = (x87_r6_8 < temp6_1 ? 1 : 0) << 8
0041671e                              | (is_unordered.t(x87_r6_8, temp6_1) ? 1 : 0) << 0xa
0041671e                              | (x87_r6_8 == temp6_1 ? 1 : 0) << 0xe | 0x3800
0041671e                          
00416723                          if ((eax_2:1.b & 1) != 0)
00416729                              var_18 = var_1c_1
00416729                      
0041672d                      ecx_2 += 0xc
00416730                      j = j_2
00416730                      j_2 -= 1
00416731                  while (j != 1)
00416731          
00416733          esi_1 += 0x20
00416736          i = i_7
00416736          i_7 -= 1
00416737      while (i != 1)
00416737  
0041673d  long double temp0 = fconvert.t(0.10000000000000001)
0041673d  x87_r7 - temp0
00416743  eax_2.w = (x87_r7 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7, temp0) ? 1 : 0) << 0xa
00416743      | (x87_r7 == temp0 ? 1 : 0) << 0xe
00416743  
00416748  if ((eax_2:1.b & 1) != 0)
00416759      *arg5 = sub_406a00(ebp)
0041676a      return sub_410030("HL_SplitBrush: only on back\n")
0041676a  
0041676b  long double x87_r7_1 = fconvert.t(var_18)
0041676f  long double temp1 = fconvert.t(-0.10000000000000001)
0041676f  x87_r7_1 - temp1
00416775  eax_2.w = (x87_r7_1 < temp1 ? 1 : 0) << 8
00416775      | (is_unordered.t(x87_r7_1, temp1) ? 1 : 0) << 0xa
00416775      | (x87_r7_1 == temp1 ? 1 : 0) << 0xe
00416775  
0041677a  if ((eax_2:1.b & 0x41) == 0)
0041678b      *arg4 = sub_406a00(ebp)
0041679c      return sub_410030("HL_SplitBrush: only on front\n")
0041679c  
004167a2  int32_t* eax_8
004167a2  int80_t st0
004167a2  st0, eax_8 = sub_410b70(edi, *(edi + 0xc))
004167a2  int16_t top = 0xffff
004167a7  int32_t ecx_4 = *(ebp + 0x28)
004167ad  int32_t i_1 = 0
004167af  var_20 = eax_8
004167af  
004167b5  if (ecx_4 s> 0)
004167b7      void* ebx_1 = ebp + 0x2c
004167b7      
004167fc      do
004167bc          if (eax_8 == 0)
004167bc              goto label_416aba
004167bc          
004167d0          int32_t ecx_6 = (*ebx_1 ^ 1) * 7
004167e7          sub_4111c0(&var_20, (ecx_6 << 2) + &data_239e0c0, 
004167e7              *((ecx_6 << 2) + &data_239e0cc), 0f)
004167e7          top -= 1
004167e7          unimplemented  {call sub_4111c0}
004167f2          i_1 += 1
004167f3          ebx_1 += 0x20
004167f8          eax_8 = var_20
004167fc      while (i_1 s< *(ebp + 0x28))
004167fc  
00416800  int32_t eax_13
00416800  
00416800  if (eax_8 != 0)
00416807      eax_13 = sub_406f30(eax_8)
00416807  
00416811  void* eax_38
00416811  
00416811  if (eax_8 == 0 || eax_13 != 0)
00416aba      label_416aba:
00416aba      sub_410030("HL_SplitBrush: no split winding\n")
00416ac1      eax_38 = sub_407430(ebp, edi)
00416ac1      unimplemented  {call sub_407430}
00416ac1      
00416acc      if (eax_38 == 1)
00416acf          void* eax_40 = sub_406a00(ebp)
00416ade          *arg4 = eax_40
00416ae4          return eax_40
00416ae4      
00416ae8      if (eax_38 == 2)
00416aeb          eax_38 = sub_406a00(ebp)
00416af7          *arg5 = eax_38
00416811  else
00416826      if (sub_406fc0(var_20) != 0)
0041682d          sub_410030("HL_SplitBrush: WARNING huge spli…")
0041682d      
00416835      int32_t* edx_4 = var_20
00416839      void* var_10
00416839      void** esi_2 = &var_10
00416841      int32_t i_8 = 2
0041685f      int32_t i_2
0041685f      
0041685f      do
0041684b          void* eax_17 = sub_4068f0(*(ebp + 0x28) + 1)
00416850          int32_t ecx_8 = *(ebp + 0x24)
00416853          *esi_2 = eax_17
00416858          esi_2 = &esi_2[1]
0041685b          i_2 = i_8
0041685b          i_8 -= 1
0041685c          *(eax_17 + 0x24) = ecx_8
0041685f      while (i_2 != 1)
00416864      int32_t i_6 = 0
00416864      
0041686e      if (*(ebp + 0x28) s> 0)
00416874          void* ebp_1 = ebp + 0x2c
004168f3          int32_t i_3
004168f3          
004168f3          do
00416877              int32_t* eax_19 = *(ebp_1 + 8)
0041687c              var_20 = eax_19
0041687c              
00416880              if (eax_19 != 0)
00416894                  void var_8
00416894                  void var_4
00416894                  sub_410e60(eax_19, edi, *(edi + 0xc), 0f, &var_8, &var_4)
00416894                  top -= 1
00416894                  unimplemented  {call sub_410e60}
00416894                  
004168dc                  for (int32_t j_1 = 0; j_1 s< 8; j_1 += 4)
004168a4                      if (*(&var_8 + j_1) != 0)
004168a6                          void* ecx_9 = *(&var_10 + j_1)
004168ac                          int32_t edx_6 = *(ecx_9 + 0x28)
004168b9                          *(ecx_9 + 0x28) = edx_6 + 1
004168c3                          __builtin_memcpy(dest: (edx_6 << 5) + ecx_9 + 0x2c, src: ebp_1, 
004168c3                              n: 0x20)
004168c5                          int32_t ecx_10 = *(&var_8 + j_1)
004168c9                          *((edx_6 << 5) + ecx_9 + 0x48) &= 0xfffe
004168cf                          edi = var_14
004168d3                          *((edx_6 << 5) + ecx_9 + 0x34) = ecx_10
004168d3              
004168e6              i_3 = i_6 + 1
004168e7              ebp_1 += 0x20
004168ed              i_6 = i_3
004168f3          while (i_3 s< *(arg1 + 0x28))
004168f5          ebp = arg1
004168f5      
004168f7      void** edi_2 = &var_10
004168fb      arg1 = 2
004168fb      
00416903      while (true)
00416903          void* ebx_2 = *edi_2
00416906          sub_406550(ebx_2)
00416906          unimplemented  {call sub_406550}
0041690e          int32_t esi_4 = 0
00416910          void* ecx_12 = ebx_2 + 0x10
00416910          
00416913          while (true)
00416913              unimplemented  {fld st0, dword [ecx-0xc]}
00416916              long double temp8_1 = fconvert.t(-4096f)
00416916              unimplemented  {fcomp st0, dword [&data_42926c]} f- temp8_1
00416916              bool c0_7 = unimplemented  {fcomp st0, dword [&data_42926c]} f< temp8_1
00416916              bool c2_7 =
00416916                  is_unordered.t(unimplemented  {fcomp st0, dword [&data_42926c]}, temp8_1)
00416916              bool c3_7 = unimplemented  {fcomp st0, dword [&data_42926c]} f== temp8_1
00416916              unimplemented  {fcomp st0, dword [&data_42926c]}
00416916              
00416921              if ((((c0_7 ? 1 : 0) << 8 | (c2_7 ? 1 : 0) << 0xa | (c3_7 ? 1 : 0) << 0xe
00416921                      | (top & 7) << 0xb):1.b & 1) == 0)
00416923                  unimplemented  {fld st0, dword [ecx]}
00416925                  long double temp9_1 = fconvert.t(4096f)
00416925                  unimplemented  {fcomp st0, dword [&data_429268]} f- temp9_1
00416925                  bool c0_8 = unimplemented  {fcomp st0, dword [&data_429268]} f< temp9_1
00416925                  bool c2_8 = is_unordered.t(
00416925                      unimplemented  {fcomp st0, dword [&data_429268]}, temp9_1)
00416925                  bool c3_8 = unimplemented  {fcomp st0, dword [&data_429268]} f== temp9_1
00416925                  unimplemented  {fcomp st0, dword [&data_429268]}
00416925                  
00416930                  if ((((c0_8 ? 1 : 0) << 8 | (c2_8 ? 1 : 0) << 0xa | (c3_8 ? 1 : 0) << 0xe
00416930                          | (top & 7) << 0xb):1.b & 0x41) != 0)
00416932                      esi_4 += 1
00416933                      ecx_12 += 4
00416933                      
00416939                      if (esi_4 s>= 3)
00416939                          break
00416939                      
00416939                      continue
00416939              
00416942              sub_410030("HL_SplitBrush: bogus brush after…")
00416947              break
00416947          
00416953          if (*(ebx_2 + 0x28) s< 3 || esi_4 s< 3)
00416956              sub_406960(ebx_2)
00416960              *edi_2 = nullptr
00416966              sub_410030("HL_SplitBrush: numsides < 3\n")
00416966          
00416972          edi_2 = &edi_2[1]
00416975          bool cond:5_1 = arg1 != 1
00416976          arg1 -= 1
00416976          
0041697a          if (not(cond:5_1))
0041697a              break
0041697a      
0041697c      void* edi_3 = var_10
00416982      void* esi_5
00416982      void* var_c
00416982      
00416982      if (edi_3 == 0)
00416a53          if (var_c == 0)
00416a69              return sub_410030("HL_SplitBrush: split removed bru…")
00416a69          
00416a6a          esi_5 = var_c
00416982      else
00416988          esi_5 = var_c
00416988          
0041698e          if (esi_5 != 0)
004169ef              for (int32_t i_4 = 0; i_4 s< 2; i_4 += 1)
0041699f                  void* eax_28 = (&var_10)[i_4]
004169a3                  int32_t ecx_13 = *(eax_28 + 0x28)
004169b0                  *(eax_28 + 0x28) = ecx_13 + 1
004169b9                  *((ecx_13 << 5) + eax_28 + 0x48) &= 0xfffc
004169c2                  *((ecx_13 << 5) + eax_28 + 0x30) = 0
004169cb                  *((ecx_13 << 5) + eax_28 + 0x2c) = i_4 ^ arg2 ^ 1
004169cd                  *((ecx_13 << 5) + eax_28 + 0x44) = arg3
004169cd                  
004169d0                  if (i_4 != 0)
004169e8                      *((ecx_13 << 5) + eax_28 + 0x34) = edx_4
004169d0                  else
004169df                      *((ecx_13 << 5) + eax_28 + 0x34) = sub_410dd0(edx_4)
004169df              
004169f1              void** esi_7 = &var_10
004169f5              int32_t i_9 = 2
00416a2f              int32_t i_5
00416a2f              
00416a2f              do
004169fa                  void* edi_4 = *esi_7
004169fd                  sub_406780(edi_4)
004169fd                  unimplemented  {call sub_406780}
00416a02                  long double temp11_1 = fconvert.t(1f)
00416a02                  unimplemented  {fcomp st0, dword [&data_42914c]} f- temp11_1
00416a02                  bool c0_9 = unimplemented  {fcomp st0, dword [&data_42914c]} f< temp11_1
00416a02                  bool c2_9 = is_unordered.t(
00416a02                      unimplemented  {fcomp st0, dword [&data_42914c]}, temp11_1)
00416a02                  bool c3_9 = unimplemented  {fcomp st0, dword [&data_42914c]} f== temp11_1
00416a02                  unimplemented  {fcomp st0, dword [&data_42914c]}
00416a02                  
00416a10                  if ((((c0_9 ? 1 : 0) << 8 | (c2_9 ? 1 : 0) << 0xa | (c3_9 ? 1 : 0) << 0xe
00416a10                          | (top & 7) << 0xb):1.b & 1) != 0)
00416a13                      sub_406960(edi_4)
00416a1d                      *esi_7 = nullptr
00416a23                      sub_410030("HL_SplitBrush: tiny volume after…")
00416a23                  
00416a2b                  esi_7 = &esi_7[1]
00416a2e                  i_5 = i_9
00416a2e                  i_9 -= 1
00416a2f              while (i_5 != 1)
00416a3e              *arg4 = var_10
00416a46              *arg5 = var_c
00416a4c              return var_c
00416a73      eax_38 = sub_410030("HL_SplitBrush: split not on both…")
00416a73      
00416a7d      if (edi_3 != 0)
00416a80          sub_406960(edi_3)
00416a86          eax_38 = sub_406a00(ebp)
00416a92          *arg4 = eax_38
00416a92      
00416a96      if (esi_5 != 0)
00416a99          sub_406960(esi_5)
00416a9f          void* eax_39 = sub_406a00(ebp)
00416aae          *arg5 = eax_39
00416ab4          return eax_39
00416ab4  
00416b00  return eax_38

00416b01     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00416b10    void* __convention("regparm") sub_416b10(int32_t arg1, int32_t arg2, void* arg3, void* arg4)

00416b10  void* var_4 = arg3
00416b12  void* i_3
00416b12  void* i_4 = i_3
00416b12  
00416b18  if (i_4 s>= 0)
00416bbe      int32_t edx_1 = data_261d1fc
00416bc4      int32_t esi_1 = i_4 * 0x18
00416bca      int32_t ecx_11 = *(esi_1 + data_261d100) * 5
00416bd4      int32_t var_10 = *(edx_1 + (ecx_11 << 2) + 0xc)
00416bec      sub_416660(arg4, sub_414ae0(edx_1 + (ecx_11 << 2)), i_4, &i_3, &var_4)
00416bf2      sub_406960(arg4)
00416bf7      void* i_2 = i_3
00416c00      void* eax_14
00416c00      
00416c00      if (i_2 != 0)
00416c02          eax_14 = var_4
00416c02      
00416c08      if (i_2 == 0 || eax_14 == 0)
00416c0f          sub_410030("HL_CreateBrushes_r: WARNING node…")
00416c14          eax_14 = var_4
00416c18          i_2 = i_3
00416c18      
00416c21      if (i_2 != 0)
00416c35          i_2 = sub_416b10(i_2, sx.d(*(esi_1 + data_261d100 + 4)))
00416c37          eax_14 = var_4
00416c3e          i_3 = i_2
00416c3e      
00416c44      if (eax_14 != 0)
00416c53          eax_14 = sub_416b10(eax_14, sx.d(*(esi_1 + data_261d100 + 6)))
00416c58          i_2 = i_3
00416c5f          var_4 = eax_14
00416c5f      
00416c66      if (i_2 == 0)
00416c80          return eax_14
00416c80      
00416c68      void** i_1 = i_2
00416c68      
00416c6e      for (void* i = *i_2; i != 0; i = *i_1)
00416c70          i_1 = i
00416c70      
00416c78      *i_1 = eax_14
00416c7a      return i_3
00416c7a  
00416b34  int32_t __saved_esi_3 = *(data_261d10c - (i_4 + 1) * 0x1c)
00416b34  
00416b3c  if (__saved_esi_3 + 0xf u> 0xe)
00416ba2      int32_t __saved_esi_2 = __saved_esi_3
00416ba8      sub_40f970("HL_CreateBrushes_r: unknown cont…")
00416bb4      return 0
00416bb4  
00416b3c  switch (__saved_esi_3)
00416b5c      case 0xfffffff1, 0xfffffff8, 0xfffffffa, 0xfffffffe
00416b5c          *(arg4 + 0x1c) = 1
00416b64          return arg4
00416b8f      case 0xfffffff2, 0xfffffff3, 0xfffffff4, 0xfffffff5, 0xfffffff6, 0xfffffff7, 
00416b8f              0xfffffff9
00416b8f          int32_t __saved_esi_1 = __saved_esi_3
00416b95          sub_40f970("HL_CreateBrushes_r: found conten…")
00416ba1          return 0
00416b86      case 0xfffffffb
00416b86          *(arg4 + 0x1c) = 8
00416b8e          return arg4
00416b78      case 0xfffffffc
00416b78          *(arg4 + 0x1c) = 0x10
00416b80          return arg4
00416b6a      case 0xfffffffd
00416b6a          *(arg4 + 0x1c) = 0x20
00416b72          return arg4
00416b4a      case 0xffffffff
00416b4a          sub_406960(arg4)
00416b56          return 0

00416c81     8d 49 00                                                                                       .I.
00416c84  uint32_t jump_table_416c84[0xf] = 
00416c84  {
00416c84      [0x0] =  0x00416b57
00416c88      [0x1] =  0x00416b8f
00416c8c      [0x2] =  0x00416b8f
00416c90      [0x3] =  0x00416b8f
00416c94      [0x4] =  0x00416b8f
00416c98      [0x5] =  0x00416b8f
00416c9c      [0x6] =  0x00416b8f
00416ca0      [0x7] =  0x00416b57
00416ca4      [0x8] =  0x00416b8f
00416ca8      [0x9] =  0x00416b57
00416cac      [0xa] =  0x00416b81
00416cb0      [0xb] =  0x00416b73
00416cb4      [0xc] =  0x00416b65
00416cb8      [0xd] =  0x00416b57
00416cbc      [0xe] =  0x00416b45
00416cc0  }

00416cc0    void* sub_416cc0(int32_t arg1)

00416cd5  int32_t edx = data_261d100
00416cdb  int32_t esi_1 = arg1 << 6
00416ce2  int32_t ecx = *(esi_1 + data_261d0b4 + 0x24) * 3
00416ce5  void* eax_2 = edx + (ecx << 3)
00416ced  int32_t var_24 = sx.d(*(edx + (ecx << 3) + 8))
00416cf5  float var_20 = fconvert.s(float.t(var_24))
00416cfd  var_24 = sx.d(*(eax_2 + 0xa))
00416d05  float var_1c = fconvert.s(float.t(var_24))
00416d0d  var_24 = sx.d(*(eax_2 + 0xc))
00416d15  float var_18 = fconvert.s(float.t(var_24))
00416d1d  var_24 = sx.d(*(eax_2 + 0xe))
00416d25  float var_14 = fconvert.s(float.t(var_24))
00416d2d  var_24 = sx.d(*(eax_2 + 0x10))
00416d35  float var_10 = fconvert.s(float.t(var_24))
00416d3d  var_24 = sx.d(*(eax_2 + 0x12))
00416d41  int32_t i = 0
00416d47  float var_c = fconvert.s(float.t(var_24))
00416d47  
00416d6d  do
00416d4f      long double x87_r7_7 = fconvert.t(*(&var_20 + i)) - fconvert.t(8f)
00416d55      i += 4
00416d5b      *(&var_24 + i) = fconvert.s(x87_r7_7)
00416d69      *(&var_18 + i) = fconvert.s(fconvert.t(*(&var_18 + i)) + fconvert.t(8f))
00416d6d  while (i s< 0xc)
00416d6d  
00416d7e  sub_410520(&var_20, &data_255e0f0, &data_255e0d0)
00416d92  sub_410520(&var_14, &data_255e0f0, &data_255e0d0)
00416d92  
00416d9c  if (arg1 == 0)
00416dbf      float* var_48
00416dbf      var_48.q = fconvert.d(fconvert.t(data_255e0d0))
00416dcb      double var_50_1 = fconvert.d(fconvert.t(data_255e0f8))
00416dd7      double var_58_1 = fconvert.d(fconvert.t(data_255e0f4))
00416de3      double var_60_1 = fconvert.d(fconvert.t(data_255e0f0))
00416deb      sub_410030("brush size: %5.0f,%5.0f,%5.0f to…")
00416deb  
00416dfd  void* eax_3 = sub_4066b0(&var_20, &var_14)
00416e06  *(eax_3 + 4) = var_20
00416e0d  *(eax_3 + 8) = var_1c
00416e14  *(eax_3 + 0xc) = var_18
00416e1b  *(eax_3 + 0x10) = var_14
00416e22  *(eax_3 + 0x14) = var_10
00416e29  *(eax_3 + 0x18) = var_c
00416e2c  void* ecx_7 = data_261d0b4
00416e32  int32_t edx_7 = *(esi_1 + ecx_7 + 0x24)
00416e36  int32_t var_3c_1 = edx_7
00416e45  return sub_416b10(eax_3, edx_7, ecx_7, eax_3)

00416e46                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00416e50    int32_t* sub_416e50(int32_t* arg1, int32_t arg2)

00416e54  int32_t* j_1 = arg1
00416e54  
00416e5d  if (j_1 == 0)
00416e66      return 0
00416e66  
00416e6b  int32_t var_4
00416e6b  
00416e6b  if (arg2 == 0)
00416e6d      int32_t __saved_ebx_1 = 0
00416e73      var_4 = 0
00416e77      sub_40fa00("%5d brushes merged")
00416e77  
00416f5f  int32_t i
00416f5f  
00416f5f  do
00416e83      int32_t* j = j_1
00416e83      
00416e85      if (j_1 != 0)
00416e91          do
00416e87              int32_t* j_3 = *j
00416e87              
00416e8b              if (j_3 == 0)
00416e8b                  break
00416e8b              
00416e8d              j = j_3
00416e91          while (j != 0)
00416e91      
00416e95      i = 0
00416e99      arg1 = nullptr
00416e9d      int32_t* j_2 = j_1
00416e9d      
00416ea1      while (j_1 != 0)
00416ea7          int32_t* j_6 = *j_1
00416ea9          int32_t* j_5 = j_1
00416ea9          
00416ead          if (j_6 == 0)
00416f3b              label_416f3b:
00416f3b              int32_t* ecx_7 = arg1
00416f3f              j_1 = *j_1
00416f41              arg1 = j_2
00416f45              *j_2 = ecx_7
00416ead          else
00416ebb              void* eax_3
00416ebb              
00416ebb              while (true)
00416ebb                  if (j_1[7] == j_6[7])
00416ebf                      eax_3 = sub_409480(j_1, j_6)
00416ebf                      
00416ec9                      if (eax_3 != 0)
00416ec9                          break
00416ec9                  
00416ecb                  j_5 = j_6
00416ecd                  j_6 = *j_6
00416ecd                  
00416ed1                  if (j_6 == 0)
00416ed1                      goto label_416f3b
00416ed1              
00416ed8              *(eax_3 + 0x1c) = j_1[7]
00416edb              *j = eax_3
00416ee3              *j_5 = *j_6
00416ee6              j_1 = *j_1
00416ee9              sub_406960(j_2)
00416eef              sub_406960(j_6)
00416ef7              j = j_1
00416ef7              
00416efb              if (j_1 != 0)
00416f07                  do
00416efd                      int32_t* j_4 = *j
00416efd                      
00416f01                      if (j_4 == 0)
00416f01                          break
00416f01                      
00416f03                      j = j_4
00416f07                  while (j != 0)
00416f07              
00416f14              i += 1
00416f14              
00416f18              if (arg2 == 0)
00416f21                  int32_t var_20_3 = var_4
00416f27                  var_4 += 1
00416f2b                  sub_40fa00("\r%5d")
00416f2b              
00416f35              if (j_6 == 0)
00416f35                  goto label_416f3b
00416f35          
00416f49          j_2 = j_1
00416f49      
00416f59      j_1 = arg1
00416f5f  while (i != 0)
00416f5f  
00416f6d  if (arg2 == 0)
00416f74      sub_40fa00(&data_42b33c)
00416f74  
00416f85  return arg1

00416f86                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00416f90    int32_t* sub_416f90(int16_t* arg1, void* arg2)

00416f9c  void* eax_1 = sub_410dd0(arg2)
00416fb2  int32_t ecx = sx.d(*arg1)
00416fb6  bool cond:0 = arg1[1] == 0
00416fbb  arg2 = eax_1
00416fca  float var_14
00416fca  __builtin_memcpy(dest: &var_14, src: data_261d1fc + ecx * 0x14, n: 0x14)
00416fcc  int16_t top
00416fcc  
00416fcc  if (not(cond:0))
00416fd4      var_14 = fconvert.s(fneg(fconvert.t(var_14)))
00416fde      float var_10
00416fde      float var_10_1 = fconvert.s(fneg(fconvert.t(var_10)))
00416fe8      float var_c
00416fe8      float var_c_1 = fconvert.s(fneg(fconvert.t(var_c)))
00416ff2      float var_8
00416ff2      float var_8_1 = fconvert.s(fneg(fconvert.t(var_8)))
00416ff2      top = 0
00416ff2  
00416ff6  int32_t i = 0
00416ff6  
00416ffc  if (arg1[4] s> 0)
004170e0      do
00417004          if (eax_1 == 0)
00417004              goto label_41710d
00417004          
00417017          *(data_261d0e4 + ((*(arg1 + 4) + i) << 2))
0041704e          unimplemented  {fld st0, dword [esi]}
00417061          unimplemented  {fsub st0, dword [eax+edx*4]}
0041706c          float var_20 = fconvert.s(unimplemented  {fstp dword [esp+0x24], st0})
0041706c          unimplemented  {fstp dword [esp+0x24], st0}
00417070          unimplemented  {fld st0, dword [esi+0x4]}
00417073          unimplemented  {fsub st0, dword [eax+0x4]}
00417076          float var_1c_1 = fconvert.s(unimplemented  {fstp dword [esp+0x28], st0})
00417076          unimplemented  {fstp dword [esp+0x28], st0}
0041707a          unimplemented  {fld st0, dword [esi+0x8]}
0041707d          unimplemented  {fsub st0, dword [eax+0x8]}
00417085          float var_18_1 = fconvert.s(unimplemented  {fstp dword [esp+0x30], st0})
00417085          unimplemented  {fstp dword [esp+0x30], st0}
00417089          float var_2c
00417089          sub_410420(&var_20, &var_14, &var_2c)
00417098          int32_t ecx_3 = sub_410460(&var_2c, &var_2c)
00417098          unimplemented  {call sub_410460}
0041709d          unimplemented  {fstp st0, st0}
0041709d          unimplemented  {fstp st0, st0}
0041709f          unimplemented  {fld st0, dword [esp+0x24]}
004170a3          unimplemented  {fmul st0, dword [esi]}
004170a5          unimplemented  {fld st0, dword [esp+0x28]}
004170a9          unimplemented  {fmul st0, dword [esi+0x4]}
004170b3          unimplemented  {faddp st1, st0}
004170b3          unimplemented  {faddp st1, st0}
004170b5          unimplemented  {fld st0, dword [esp+0x18]}
004170b9          unimplemented  {fmul st0, dword [esi+0x8]}
004170c1          int32_t var_44_2 = ecx_3
004170c6          unimplemented  {faddp st1, st0}
004170c6          unimplemented  {faddp st1, st0}
004170c8          float var_44_3 = fconvert.s(unimplemented  {fstp dword [esp], st0})
004170c8          unimplemented  {fstp dword [esp], st0}
004170cd          sub_4111c0(&arg2, &var_2c, var_44_3, 0.899999976f)
004170cd          top -= 1
004170cd          unimplemented  {call sub_4111c0}
004170d6          eax_1 = arg2
004170dd          i += 1
004170e0      while (i s< sx.d(arg1[4]))
004170e0  
004170e8  if (eax_1 == 0)
0041710d      label_41710d:
0041710d      unimplemented  {fld st0, dword [&data_429148]}
0041711a      return eax_1
0041711a  
004170eb  sub_410a50(eax_1)
004170eb  unimplemented  {call sub_410a50}
004170f4  arg1 = fconvert.s(unimplemented  {fstp dword [esp+0x44], st0})
004170f4  unimplemented  {fstp dword [esp+0x44], st0}
004170f9  int32_t eax_7 = sub_410740(arg2)
004170fe  unimplemented  {fld st0, dword [esp+0x48]}
0041710c  return eax_7

0041711b                                                                                   90 90 90 90 90                             .....

00417120    void sub_417120(int16_t* arg1)

00417120  int16_t* eax = arg1
00417143  float var_14
00417143  __builtin_memcpy(dest: &var_14, src: data_261d1fc + sx.d(*eax) * 0x14, n: 0x14)
00417143  
0041714b  if (eax[1] != 0)
00417153      var_14 = fconvert.s(fneg(fconvert.t(var_14)))
0041715d      float var_10
0041715d      float var_10_1 = fconvert.s(fneg(fconvert.t(var_10)))
00417167      float var_c
00417167      float var_c_1 = fconvert.s(fneg(fconvert.t(var_c)))
00417171      float var_8
00417171      float var_8_1 = fconvert.s(fneg(fconvert.t(var_8)))
00417171  
00417179  int32_t var_34 = 0
0041717d  int32_t* var_40 = nullptr
00417181  int32_t var_38 = 0
00417185  void* arg_4
00417185  
00417185  if (eax[4] s<= 0)
00417300      sub_406960(arg_4)
00417311      return 
00417311  
0041718b  void* ebx = arg_4
0041718b  
004171a6  while (true)
004171a6      int32_t ebp_2 = data_261d11c
004171ac      int32_t eax_3 = *(data_261d0e4 + ((*(eax + 4) + var_38) << 2))
004171b1      int32_t edx_1
004171b1      edx_1.b = eax_3 s> 0
004171b8      int32_t eax_4
004171b8      int32_t edx_2
004171b8      edx_2:eax_4 = sx.q(eax_3)
004171bd      int32_t edx_3 = data_261d0f4
004171c3      int32_t eax_7 = ((eax_4 ^ edx_2) - edx_2) << 1
004171c8      int32_t ecx_3
004171c8      ecx_3.w = *(edx_3 + ((eax_7 + edx_1) << 1))
004171cf      float* esi_2 = ebp_2 + ecx_3 * 0xc
004171d7      int32_t ecx_5
004171d7      ecx_5.b = edx_1 == 0
004171e0      int32_t eax_8
004171e0      eax_8.w = *(edx_3 + ((ecx_5 + eax_7) << 1))
004171e8      int32_t edx_4 = eax_8 * 3
004171ef      void* eax_9 = ebp_2 + (edx_4 << 2)
004171f7      float var_20 = fconvert.s(fconvert.t(*esi_2) - fconvert.t(*(ebp_2 + (edx_4 << 2))))
00417201      float var_1c_1 = fconvert.s(fconvert.t(esi_2[1]) - fconvert.t(*(eax_9 + 4)))
00417212      float var_18_1 = fconvert.s(fconvert.t(esi_2[2]) - fconvert.t(*(eax_9 + 8)))
00417216      float var_2c
00417216      sub_410420(&var_20, &var_14, &var_2c)
00417225      sub_410460(&var_2c, &var_2c)
00417250      float var_28
00417250      float var_24
00417250      float var_68_1 = fconvert.s(fconvert.t(var_24) * fconvert.t(esi_2[2])
00417250          + fconvert.t(var_2c) * fconvert.t(*esi_2)
00417250          + fconvert.t(var_28) * fconvert.t(esi_2[1]))
00417263      int32_t* var_3c
00417263      sub_4074d0(ebx, sub_414ae0(&var_2c), &arg_4, &var_3c)
00417268      int32_t* eax_11 = var_3c
00417268      
00417271      if (eax_11 != 0)
00417276          eax_11[7] = *(ebx + 0x1c)
00417281          *var_3c = var_40
0041728c          var_40 = var_3c
00417290          var_34 += 1
00417290      
00417294      void* eax_15 = arg_4
00417294      
0041729a      if (eax_15 == 0)
004172df          sub_410030("HL_SplitBrushWithFace: no new br…")
004172e9          sub_4069e0(var_40)
004172fa          return 
004172fa      
004172a3      *(eax_15 + 0x1c) = *(ebx + 0x1c)
004172ae      ebx = arg_4
004172b3      bool cond:1_1 = var_38 + 1 s< sx.d(arg1[4])
004172b5      var_38 += 1
004172b5      
004172b9      if (not(cond:1_1))
004172b9          break
004172b9      
00417191      eax = arg1
00417191  
004172c5  if (var_34 == 0)
004172c8      sub_406960(ebx)
004172d9      return 
004172d9  
00417318  *ebx = var_40

00417324              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

00417330    int32_t* sub_417330(int32_t* arg1, int32_t arg2)

00417335  int32_t esi = arg2
0041735e  int32_t var_28
0041735e  
0041735e  if (esi == 0)
00417365      sub_40fa00("texturing brushes\n")
0041736a      int32_t var_4c_1 = 0
00417370      var_28 = 0
00417374      sub_40fa00("%5d brushes")
00417374  
0041737c  int32_t* result = arg1
00417382  int32_t* var_34 = result
00417382  
00417386  if (result != 0)
00417396      int32_t* i
00417396      
00417396      do
0041738c          i = *var_34
0041738c          
00417390          if (i == 0)
00417390              break
00417390          
00417392          var_34 = i
00417396      while (i != 0)
00417396  
0041739a  int32_t* result_2 = nullptr
0041739e  int32_t* result_1 = result
0041739e  
004173a2  if (result != 0)
004173b6      while (true)
004173b6          int32_t* result_4 = *result
004173ba          int32_t var_1c_1 = 0
004173ba          
004173be          if (result[0xa] s> 0)
004173c4              int32_t ecx_2 = 0
004173c6              int32_t var_18_1 = 0
00417700              bool cond:7_1
00417700              
00417700              do
004173ce                  int32_t eax_2
004173ce                  eax_2.b = *(ecx_2 + result + 0x48)
004173d2                  void* ecx_3 = ecx_2 + result + 0x2c
004173d2                  
004173dc                  if ((eax_2.b & 8) == 0)
004173e8                      int32_t eax_3 = *(ecx_3 + 0x18)
004173eb                      int32_t i_4 = 0xffffffff
004173f0                      float var_20_1 = 1f
004173f8                      int16_t top
004173f8                      
004173f8                      if (data_279c360 != 0)
00417531                          int32_t i_1 = 0
00417531                          
00417535                          if (data_261d0c0 s<= 0)
004176dc                              *(ecx_3 + 0x1c) |= 8
004176e0                              *(ecx_3 + 4) = 0xffffffff
00417535                          else
00417541                              void* edi_1 = nullptr
00417541                              
0041758c                              do
00417543                                  int32_t ecx_10 = data_261d0f8
00417543                                  
00417559                                  if (sx.d(*(edi_1 + ecx_10))
00417559                                          == *(eax_3 * 0x18 + data_261d100))
00417564                                      sub_416f90(edi_1 + ecx_10, *(ecx_3 + 8))
00417569                                      long double temp0_1 = fconvert.t(var_20_1)
00417569                                      unimplemented  {fcom st0, dword [esp+0x30]} f- temp0_1
00417569                                      bool c0_2 =
00417569                                          unimplemented  {fcom st0, dword [esp+0x30]}
00417569                                          f< temp0_1
00417569                                      bool c2_2 = is_unordered.t(
00417569                                          unimplemented  {fcom st0, dword [esp+0x30]}, 
00417569                                          temp0_1)
00417569                                      bool c3_2 =
00417569                                          unimplemented  {fcom st0, dword [esp+0x30]}
00417569                                          f== temp0_1
00417569                                      
00417575                                      if ((((c0_2 ? 1 : 0) << 8 | (c2_2 ? 1 : 0) << 0xa
00417575                                              | (c3_2 ? 1 : 0) << 0xe | (top & 7) << 0xb):1.b
00417575                                              & 0x41) != 0)
0041757f                                          unimplemented  {fstp st0, st0}
0041757f                                          unimplemented  {fstp st0, st0}
0041757f                                          top += 1
00417575                                      else
00417577                                          var_20_1 = fconvert.s(unimplemented  {fstp dword [
00417577                                              esp+0x28], st0})
00417577                                          unimplemented  {fstp dword [esp+0x28], st0}
00417577                                          top += 1
0041757b                                          i_4 = i_1
0041757b                                  
00417586                                  i_1 += 1
00417587                                  edi_1 += 0x14
0041758c                              while (i_1 s< data_261d0c0)
0041758c                              
0041758e                              label_41758e:
0041758e                              
00417590                              if (i_4 s< 0)
004176d8                                  result = result_1
004176dc                                  *(ecx_3 + 0x1c) |= 8
004176e0                                  *(ecx_3 + 4) = 0xffffffff
00417590                              else
0041759f                                  int32_t var_30_1 = 4
004175a7                                  int32_t ebx_5 = sx.d(*(data_261d0f8 + i_4 * 0x14 + 0xa))
004175bf                                  int32_t esi_4 = ebx_5 * 0x28
004175c8                                  void* ecx_13 = &(&data_586030)[ebx_5 * 0x1b]
004175ca                                  void* eax_16 = esi_4 + data_261d1f8 + 0x10
004175e8                                  bool cond:10_1
004175e8                                  
004175e8                                  do
004175ce                                      int32_t edx_13 = *(eax_16 - 0x10)
004175d1                                      eax_16 += 4
004175d4                                      *(ecx_13 - 0x10) = edx_13
004175da                                      *ecx_13 = *(eax_16 - 4)
004175e0                                      ecx_13 += 4
004175e3                                      cond:10_1 = var_30_1 != 1
004175e4                                      var_30_1 -= 1
004175e8                                  while (cond:10_1)
004175f1                                  sub_410350(&(&data_586020)[ebx_5 * 0x1b])
004175f1                                  unimplemented  {call sub_410350}
004175f6                                  long double temp3_1 = fconvert.t(0.01)
004175f6                                  unimplemented  {fcomp st0, qword [&data_4291c0]}
004175f6                                      f- temp3_1
004175f6                                  bool c0_3 =
004175f6                                      unimplemented  {fcomp st0, qword [&data_4291c0]}
004175f6                                      f< temp3_1
004175f6                                  bool c2_3 = is_unordered.t(
004175f6                                      unimplemented  {fcomp st0, qword [&data_4291c0]}, 
004175f6                                      temp3_1)
004175f6                                  bool c3_3 =
004175f6                                      unimplemented  {fcomp st0, qword [&data_4291c0]}
004175f6                                      f== temp3_1
004175f6                                  unimplemented  {fcomp st0, qword [&data_4291c0]}
004175f6                                  
00417604                                  if ((((c0_3 ? 1 : 0) << 8 | (c2_3 ? 1 : 0) << 0xa
00417604                                          | (c3_3 ? 1 : 0) << 0xe | (top & 7) << 0xb):1.b & 1)
00417604                                          != 0)
00417612                                      (&data_586020)[ebx_5 * 0x1b] = 0x3f800000
0041761c                                      (&data_586024)[ebx_5 * 0x1b] = 0
00417622                                      (&data_586028)[ebx_5 * 0x1b] = 0
00417628                                      (&data_58602c)[ebx_5 * 0x1b] = 0
00417628                                  
0041762f                                  sub_410350(&(&data_586030)[ebx_5 * 0x1b])
0041762f                                  unimplemented  {call sub_410350}
00417634                                  long double temp4_1 = fconvert.t(0.01)
00417634                                  unimplemented  {fcomp st0, qword [&data_4291c0]}
00417634                                      f- temp4_1
00417634                                  bool c0_4 =
00417634                                      unimplemented  {fcomp st0, qword [&data_4291c0]}
00417634                                      f< temp4_1
00417634                                  bool c2_4 = is_unordered.t(
00417634                                      unimplemented  {fcomp st0, qword [&data_4291c0]}, 
00417634                                      temp4_1)
00417634                                  bool c3_4 =
00417634                                      unimplemented  {fcomp st0, qword [&data_4291c0]}
00417634                                      f== temp4_1
00417634                                  unimplemented  {fcomp st0, qword [&data_4291c0]}
00417634                                  
00417642                                  if ((((c0_4 ? 1 : 0) << 8 | (c2_4 ? 1 : 0) << 0xa
00417642                                          | (c3_4 ? 1 : 0) << 0xe | (top & 7) << 0xb):1.b & 1)
00417642                                          != 0)
00417650                                      (&data_586030)[ebx_5 * 0x1b] = 0x3f800000
00417656                                      (&data_586034)[ebx_5 * 0x1b] = 0
00417659                                      (&data_586038)[ebx_5 * 0x1b] = 0
0041765c                                      (&data_58603c)[ebx_5 * 0x1b] = 0
0041765c                                  
0041765f                                  int32_t ecx_14 = data_261d1f8
00417665                                  int32_t eax_20 = data_261d0b0
0041766e                                  (&data_586040)[ebx_5 * 0x1b] = *(esi_4 + ecx_14 + 0x24)
00417674                                  (&data_586044)[ebx_5 * 0x1b] = 0
0041768c                                  int32_t i_2 = 0xffffffff
0041768f                                  int32_t edi_4 =
0041768f                                      *(eax_20 + (*(esi_4 + ecx_14 + 0x20) << 2) + 4)
0041768f                                      + eax_20
0041768f                                  
00417693                                  while (i_2 != 0)
00417693                                      bool cond:12_1 = 0 != *edi_4
00417693                                      edi_4 += 1
00417693                                      i_2 -= 1
00417693                                      
00417693                                      if (not(cond:12_1))
00417693                                          break
00417693                                  
00417695                                  int32_t ecx_16 = not.d(i_2)
004176a2                                  int32_t esi_6
004176a2                                  int32_t edi_7
004176a2                                  edi_7, esi_6 = __builtin_memcpy(
004176a2                                      dest: &(&data_586048)[ebx_5 * 0x1b], 
004176a2                                      src: edi_4 - ecx_16, n: ecx_16 u>> 2 << 2)
004176ad                                  __builtin_memcpy(dest: edi_7, src: esi_6, n: ecx_16 & 3)
004176af                                  (&data_586088)[ebx_5 * 0x1b] = 0xffffffff
004176b9                                  *(ecx_3 + 4) = ebx_5
004176b9                                  
004176c2                                  if (ebx_5 s> data_255e0e0)
004176c4                                      data_255e0e0 = ebx_5
004176c4                                  
004176ca                                  *(ecx_3 + 0x1c) |= 8
004176ce                                  result = result_1
004173f8                      else
00417404                          int32_t i_5 = 0
00417404                          
0041740a                          if (data_261d0c0 s> 0)
00417413                              void* edi = 0xffffffec
0041741b                              void* esi_1 = nullptr
004174ab                              bool cond:9_1
004174ab                              
004174ab                              do
0041741d                                  int32_t edx_3 = data_261d0f8
0041741d                                  
00417433                                  if (sx.d(*(esi_1 + edx_3))
00417433                                          == *(eax_3 * 0x18 + data_261d100))
0041743e                                      sub_416f90(esi_1 + edx_3, *(ecx_3 + 8))
00417443                                      long double temp1_1 = fconvert.t(1f)
00417443                                      unimplemented  {fcomp st0, dword [&data_42914c]}
00417443                                          f- temp1_1
00417443                                      bool c0_1 =
00417443                                          unimplemented  {fcomp st0, dword [&data_42914c]}
00417443                                          f< temp1_1
00417443                                      bool c2_1 = is_unordered.t(
00417443                                          unimplemented  {fcomp st0, dword [&data_42914c]}, 
00417443                                          temp1_1)
00417443                                      bool c3_1 =
00417443                                          unimplemented  {fcomp st0, dword [&data_42914c]}
00417443                                          f== temp1_1
00417443                                      unimplemented  {fcomp st0, dword [&data_42914c]}
00417443                                      top += 1
00417443                                      
00417451                                      if ((((c0_1 ? 1 : 0) << 8 | (c2_1 ? 1 : 0) << 0xa
00417451                                              | (c3_1 ? 1 : 0) << 0xe | (top & 7) << 0xb):1.b
00417451                                              & 0x41) == 0)
00417453                                          int32_t ecx_6 = data_261d0f8
0041745b                                          void* eax_6
0041745b                                          
0041745b                                          if (i_4 s>= 0)
0041745d                                              eax_6 = esi_1 + ecx_6
00417460                                              ecx_6.w = *(edi + ecx_6 + 0xa)
00417460                                          
00417469                                          if (i_4 s< 0 || ecx_6.w == *(eax_6 + 0xa))
00417491                                              i_4 = i_5
00417495                                              edi = esi_1
00417469                                          else
0041746f                                              void* var_4c_3 = eax_6
00417471                                              int32_t* result_7 = sub_417120(result_1)
00417471                                              top -= 1
00417471                                              unimplemented  {call sub_417120}
00417471                                              
0041747b                                              if (result_7 != 0)
004174ba                                                  int32_t** result_6 = result_1
004174c0                                                  int32_t* ecx_8 = *result_6
004174c0                                                  
004174c2                                                  if (result_2 == 0)
004174c8                                                      result_6 = result_1
004174cc                                                      arg1 = ecx_8
004174c2                                                  else
004174c4                                                      *result_2 = ecx_8
004174c4                                                  
004174d0                                                  int32_t* result_5 = var_34
004174d0                                                  
004174d6                                                  if (result_5 == result_6)
004174d8                                                      int32_t* result_3 = result_2
004174dc                                                      result_4 = result_7
004174e0                                                      result_5 = result_2
004174e0                                                  
004174e4                                                  if (result_5 == 0)
004174ea                                                      arg1 = result_7
004174e4                                                  else
004174e6                                                      *result_5 = result_7
004174e6                                                  
004174ef                                                  sub_406960(result_6)
004174fd                                                  result_1 = result_2
00417501                                                  var_34 = arg1
00417501                                                  
00417505                                                  if (arg1 != 0)
00417515                                                      int32_t* i_3
00417515                                                      
00417515                                                      do
0041750b                                                          i_3 = *var_34
0041750b                                                          
0041750f                                                          if (i_3 == 0)
0041750f                                                              break
0041750f                                                          
00417511                                                          var_34 = i_3
00417515                                                      while (i_3 != 0)
00417515                                                  
00417523                                                  if (i_5 s>= data_261d0c0)
00417523                                                      goto label_41758e
00417523                                                  
00417708                                                  result = result_1
00417708                                                  goto label_41770c
00417708                                              
00417481                                              int32_t var_4c_4 = var_28
00417487                                              sub_410080("brush %d: no real texture split")
00417487                                  
004174a2                                  esi_1 += 0x14
004174a5                                  cond:9_1 = i_5 + 1 s< data_261d0c0
004174a7                                  i_5 += 1
004174ab                              while (cond:9_1)
004174ab                              goto label_41758e
004174ab                          
004176dc                          *(ecx_3 + 0x1c) |= 8
004176e0                          *(ecx_3 + 4) = 0xffffffff
004176e0                  
004176f3                  ecx_2 = var_18_1 + 0x20
004176f6                  cond:7_1 = var_1c_1 + 1 s< result[0xa]
004176f8                  var_1c_1 += 1
004176fc                  var_18_1 = ecx_2
00417700              while (cond:7_1)
00417700          
0041770c          label_41770c:
0041770c          esi = arg2
0041770c          
0041771a          if (esi == 0 && result_2 != result)
00417721              int32_t var_4c_9 = var_28 + 1
00417727              var_28 += 1
0041772b              sub_40fa00("\r%5d")
0041772b          
00417737          result_2 = result
0041773d          result_1 = result_4
0041773d          
00417741          if (result_4 == 0)
00417741              break
00417741          
004173ab          result = result_1
004173ab      
00417747      result = arg1
00417747  
0041774e  if (esi == 0)
00417755      sub_40fa00(&data_42b33c)
00417755  
00417765  return result

00417766                    90 90 90 90 90 90 90 90 90 90                                                        ..........

00417770    void sub_417770(void** arg1)

00417771  void** i = arg1
00417771  
00417777  if (i != 0)
00417780      void** edi_1 = arg1
00417780      
00417816      do
00417784          int32_t* j_1 = i[7]
00417784          
00417794          if (j_1 == 0x20 || j_1 == 0x10 || j_1 == 8)
00417799              int32_t j = 0
00417799              
0041779d              if (i[0xa] s> 0)
0041779f                  void* ebx_1 = &i[0xc]
0041779f                  
004177ca                  do
004177a2                      edi_1 = *ebx_1
004177a2                      
004177bf                      if (sub_4165f0(&(&data_586048)[edi_1 * 0x1b]) == i[7])
004177bf                          break
004177bf                      
004177c4                      j += 1
004177c5                      ebx_1 += 0x20
004177ca                  while (j s< i[0xa])
004177ca              
004177cf              if (j s< i[0xa])
00417823                  label_417823:
00417823                  
00417825                  if (edi_1 s< 0)
00417825                      goto label_417804
00417825                  
0041782a                  j_1 = nullptr
0041782a                  
0041782e                  if (i[0xa] s> 0)
00417830                      void* ecx_5 = &i[0xc]
00417830                      
0041783e                      do
00417833                          *ecx_5 = edi_1
00417838                          j_1 += 1
00417839                          ecx_5 += 0x20
0041783e                      while (j_1 s< i[0xa])
004177cf              else
004177d6                  edi_1 = 0xffffffff
004177d9                  void** ebx_2 = nullptr
004177d9                  
004177dd                  if (data_255e0e0 s> 0)
004177df                      int32_t* ebp_1 = &data_586048
004177df                      
004177e5                      while (true)
004177f2                          if (sub_4165f0(ebp_1) == i[7])
00417821                              edi_1 = ebx_2
00417821                              break
00417821                          
004177f9                          ebx_2 += 1
004177fa                          ebp_1 = &ebp_1[0x1b]
004177fa                          
004177ff                          if (ebx_2 s>= data_255e0e0)
004177ff                              goto label_417804
004177ff                      
004177f2                      goto label_417823
004177f2                  
00417804                  label_417804:
00417804                  int32_t var_14_3 = i[7]
0041780a                  sub_410030("brush contents %d with wrong tex…")
0041780a          
00417812          i = *i
00417816      while (i != 0)

00417842        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

00417850    float sub_417850(void* arg1, float arg2)

00417850  int32_t ecx
00417850  int32_t var_4_1 = ecx
00417851  int32_t eax = data_dde044
00417851  
0041785b  if (eax s>= 0x4000)
00417862      sub_40f970("nummapbrushes == MAX_MAPFILE_BRU…")
00417867      eax = data_dde044
00417867  
00417897  *(eax * 0x34 + &data_4b6030) = (data_255e0c0 << 5) + 0x1f9e0a0
004178a5  int32_t i = 0
004178b6  int32_t var_4 = 0xffffffff
004178ba  *(eax * 0x34 + &data_4b6000) = (arg2 i- &data_256ee80) s/ 0x2c
004178bc  int32_t edx_4 = data_dde044
004178c2  int32_t ecx_6 = *(arg2 i+ 0xc)
004178c5  *(eax * 0x34 + 0x4b6010) = 0xffffffff
004178ca  *(eax * 0x34 + 0x4b6004) = edx_4 - ecx_6
004178cd  int32_t i_1 = 0
004178cf  *(eax * 0x34 + &data_4b602c) = 0
004178cf  
004178d7  if (*(arg1 + 0x28) s> 0)
004178d9      void* edi_1 = arg1 + 0x2c
004178d9      
00417948      do
004178df          if (*(edi_1 + 8) != 0)
004178e1              int32_t eax_6 = data_255e0c0
004178e1              
004178eb              if (eax_6 s>= 0x20000)
004178f2                  sub_40f970("MAX_MAPFILE_BRUSHSIDES")
004178f7                  eax_6 = data_255e0c0
004178ff                  i_1 = 0
004178ff              
0041790c              *((eax_6 << 5) + 0x1f9e0b4) = *(arg1 + 0x1c)
0041790f              *((eax_6 << 5) + 0x1f9e0b8) = 0
00417914              *((eax_6 << 5) + 0x1f9e0a0) = *edi_1
00417916              int32_t ecx_9 = *(edi_1 + 4)
0041791c              *((eax_6 << 5) + 0x1f9e0a4) = ecx_9
0041791c              
0041791f              if (ecx_9 != 0xffffffff)
00417921                  *((eax_6 << 5) + 0x1f9e0bc) |= 8
00417927                  var_4 = ecx_9
00417927              
00417932              data_255e0c0 += 1
0041793c              *(eax * 0x34 + &data_4b602c) += 1
0041793c          
00417942          i += 1
00417943          edi_1 += 0x20
00417948      while (i s< *(arg1 + 0x28))
00417948      
0041794f      if (var_4 != 0xffffffff)
0041796a          if (*(eax * 0x34 + &data_4b602c) s> 0)
0041796c              int32_t ecx_13 = 0
0041796c              
0041798d              do
0041796e                  int32_t eax_16 = *(eax * 0x34 + &data_4b6030)
0041796e                  
0041797c                  if (*(ecx_13 + eax_16 + 4) == 0xffffffff)
00417982                      *(ecx_13 + eax_16 + 4) = var_4
00417982                  
00417987                  i_1 += 1
00417988                  ecx_13 += 0x20
0041798d              while (i_1 s< *(eax * 0x34 + &data_4b602c))
0041798d          
00417992          *(eax * 0x34 + 0x4b6008) = *(arg1 + 0x1c)
00417992          
0041799c          if (data_279c334 != 0)
004179b3              return sub_405050(eax * 0x34 + &data_4b6000, arg2, 1)
004179b3          
004179b5          sub_415210(eax * 0x34 + &data_4b6000)
004179bb          sub_414c80(eax * 0x34 + &data_4b6000)
004179ce          data_dde044 += 1
004179db          *(arg2 i+ 0x10) += 1
004179e0          return arg2
004179e0  
00417951  *(eax * 0x34 + &data_4b602c) = 0
0041795a  int32_t eax_14 = data_4b4fe4 + 1
0041795d  data_4b4fe4 = eax_14
00417964  return eax_14

004179e1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

004179f0    int32_t* sub_4179f0(float arg1, int32_t arg2)

004179f1  int32_t __saved_edi_3 = arg2
00417a03  int32_t* esi = sub_417330(sub_416cc0(__saved_edi_3), __saved_edi_3)
00417a06  sub_417770(esi)
00417a0b  int32_t* result = data_279beec
00417a0b  
00417a15  if (result == 0)
00417a19      result = sub_416e50(esi, __saved_edi_3)
00417a21      esi = result
00417a21  
00417a25  if (__saved_edi_3 == 0)
00417a2c      sub_40fa00("converting brushes to map brushe…")
00417a31      int32_t __saved_edi_2 = __saved_edi_3
00417a37      arg2 = __saved_edi_3
00417a3b      result = sub_40fa00("%5d brushes")
00417a3b  
00417a45  if (esi != 0)
00417a84      int32_t* i
00417a84      
00417a84      do
00417a4d          i = *esi
00417a51          sub_417850(esi, arg1)
00417a57          *esi = 0
00417a5d          result = sub_406960(esi)
00417a5d          
00417a67          if (__saved_edi_3 == 0)
00417a6e              int32_t var_14_2 = arg2 + 1
00417a74              arg2 += 1
00417a78              result = sub_40fa00("\r%5d")
00417a78          
00417a82          esi = i
00417a84      while (i != 0)
00417a84  
00417a8c  if (__saved_edi_3 == 0)
00417a93      result = sub_40fa00(&data_42b33c)
00417a93  
00417a99  return result

00417a9a                                                                                90 90 90 90 90 90                            ......

00417aa0    int32_t sub_417aa0(int32_t arg1, void* arg2, void* arg3)

00417aa8  sub_410030("-- HL_LoadMapFromBSP --\n")
00417ab5  void* var_14 = arg2
00417ab6  int32_t var_18 = arg1
00417abc  data_65e020 = 3
00417ac6  sub_40fa00("loading map from %s at %d\n")
00417ad2  sub_40bb30(arg1, arg2, arg3)
00417ad7  data_4b4fe4 = 0
00417ae1  sub_40be90()
00417af0  sub_4104f0(&data_255e0f0, &data_255e0d0)
00417afa  sub_40fa00("creating Half-Life brushes\n")
00417b09  char* var_10
00417b09  
00417b09  if (data_279c360 == 0)
00417b12      var_10 = "placing textures correctly\n"
00417b09  else
00417b0b      var_10 = "creating minimum number of brush…"
00417b0b  
00417b17  sub_40fa00(var_10)
00417b24  int32_t ebp = 0
00417b24  
00417b28  if (data_2584ecc s> 0)
00417b2e      void* edi_1 = &data_256ee80
00417b2e      
00417b3e      while (true)
00417b3e          *(edi_1 + 0xc) = data_dde044
00417b42          *(edi_1 + 0x10) = 0
00417b49          char* eax_3 = sub_40e6a0(edi_1, "classname")
00417b49          
00417b53          if (eax_3 == 0)
00417b8d              label_417b8d:
00417b8d              char* eax_6 = sub_40e6a0(edi_1, "model")
00417b8d              
00417b9c              if (eax_6 != 0 && *eax_6 == 0x2a)
00417baa                  sub_4179f0(edi_1, sub_41e293(&eax_6[1]))
00417b53          else
00417b55              char* esi_1 = "worldspawn"
00417b5a              int32_t eax_5
00417b5a              
00417b5a              while (true)
00417b5a                  char edx_1 = *eax_3
00417b5e                  char temp0_1 = *esi_1
00417b5e                  bool c_1 = edx_1 u< temp0_1
00417b5e                  
00417b60                  if (edx_1 == temp0_1)
00417b64                      if (edx_1 == 0)
00417b7a                          eax_5 = 0
00417b7c                          break
00417b7c                      
00417b66                      edx_1 = eax_3[1]
00417b6b                      char temp3_1 = esi_1[1]
00417b6b                      c_1 = edx_1 u< temp3_1
00417b6b                      
00417b6e                      if (edx_1 == temp3_1)
00417b70                          eax_3 = &eax_3[2]
00417b73                          esi_1 = &esi_1[2]
00417b73                          
00417b78                          if (edx_1 != 0)
00417b78                              continue
00417b78                          
00417b7a                          eax_5 = 0
00417b7c                          break
00417b7c                  
00417b7e                  bool c_2 = unimplemented  {sbb eax, eax}
00417b80                  eax_5 = sbb.d(sbb.d(eax_3, eax_3, c_1), 0xffffffff, c_2)
00417b80                  break
00417b80              
00417b85              if (eax_5 != 0)
00417b85                  goto label_417b8d
00417b85              
00417baa              sub_4179f0(edi_1, eax_5)
00417baa          
00417bb7          ebp += 1
00417bb8          edi_1 += 0x2c
00417bb8          
00417bbd          if (ebp s>= data_2584ecc)
00417bbd              break
00417bbd  
00417bc8  int32_t var_10_3 = data_dde044
00417bce  sub_40fa00("%5d map brushes\n")
00417bd9  int32_t var_18_1 = data_4b4fe4
00417bea  return sub_40fa00("%5d clip brushes\n")

00417beb                                   90 90 90 90 90                                                             .....

00417bf0    int32_t sub_417bf0(char* arg1)

00417c05  if (sub_40fbb0(arg1, "clip") != 0)
00417c0a      if (*arg1 == 0x2a)
00417c1f          if (sub_40fb50(&arg1[1], "lava", 4) == 0)
00417c27              return 8
00417c27          
00417c30          int32_t eax_3 = sub_40fb50(&arg1[1], "slime", 5)
00417c38          int32_t eax_4 = neg.d(eax_3)
00417c43          return (sbb.d(eax_4, eax_4, eax_3 != 0) & 0x10) + 0x10
00417c43      
00417c4c      sub_40fb50(arg1, "sky", 3)
00417c4c  
00417c5a  return 1

00417c5b                                                                                   90 90 90 90 90                             .....

00417c60    int32_t* sub_417c60(void* arg1, int32_t arg2, int32_t arg3, void** arg4, int32_t* arg5)

00417c6d  void* ebp = arg1
00417c71  *arg5 = 0
00417c7c  long double x87_r7 = fconvert.t(0f)
00417c89  *arg4 = 0
00417c91  float eax_2 = *(ebp + 0x28)
00417c95  float var_18 = 0f
00417c9d  void* edi = arg2 * 0x1c + &data_239e0c0
00417ca6  void* var_14 = edi
00417caa  int32_t* var_20
00417caa  
00417caa  if (eax_2 s> 0)
00417cb0      void* esi_1 = ebp + 0x34
00417cb3      float i_7 = eax_2
00417d37      float i
00417d37      
00417d37      do
00417cb5          int32_t* ecx_1 = *esi_1
00417cb9          var_20 = ecx_1
00417cb9          
00417cbd          if (ecx_1 != 0)
00417cbf              eax_2 = *ecx_1
00417cbf              
00417cc3              if (eax_2 s> 0)
00417cc5                  void* ecx_2 = &ecx_1[2]
00417cc8                  float j_2 = eax_2
00417d31                  float j
00417d31                  
00417d31                  do
00417cde                      long double x87_r6_5 =
00417cde                          fconvert.t(*(ecx_2 + 4)) * fconvert.t(*(edi + 8))
00417cde                          + fconvert.t(*(ecx_2 - 4)) * fconvert.t(*edi)
00417cde                          + fconvert.t(*ecx_2) * fconvert.t(*(edi + 4))
00417cde                          - fconvert.t(*(edi + 0xc))
00417ce1                      float var_1c_1 = fconvert.s(x87_r6_5)
00417ce5                      long double temp3_1 = fconvert.t(0f)
00417ce5                      x87_r6_5 - temp3_1
00417ceb                      eax_2.w = (x87_r6_5 < temp3_1 ? 1 : 0) << 8
00417ceb                          | (is_unordered.t(x87_r6_5, temp3_1) ? 1 : 0) << 0xa
00417ceb                          | (x87_r6_5 == temp3_1 ? 1 : 0) << 0xe | 0x3800
00417ceb                      
00417cf0                      if ((eax_2:1.b & 0x41) == 0)
00417cf2                          long double x87_r6_6 = fconvert.t(var_1c_1)
00417cf6                          x87_r6_6 - x87_r7
00417cf8                          eax_2.w = (x87_r6_6 < x87_r7 ? 1 : 0) << 8
00417cf8                              | (is_unordered.t(x87_r6_6, x87_r7) ? 1 : 0) << 0xa
00417cf8                              | (x87_r6_6 == x87_r7 ? 1 : 0) << 0xe | 0x3800
00417cf8                          
00417cfd                          if ((eax_2:1.b & 0x41) == 0)
00417d01                              x87_r7 = fconvert.t(var_1c_1)
00417d01                      
00417d05                      long double x87_r6_7 = fconvert.t(var_1c_1)
00417d09                      long double temp4_1 = fconvert.t(0f)
00417d09                      x87_r6_7 - temp4_1
00417d0f                      eax_2.w = (x87_r6_7 < temp4_1 ? 1 : 0) << 8
00417d0f                          | (is_unordered.t(x87_r6_7, temp4_1) ? 1 : 0) << 0xa
00417d0f                          | (x87_r6_7 == temp4_1 ? 1 : 0) << 0xe | 0x3800
00417d0f                      
00417d14                      if ((eax_2:1.b & 1) != 0)
00417d16                          long double x87_r6_8 = fconvert.t(var_1c_1)
00417d1a                          long double temp6_1 = fconvert.t(var_18)
00417d1a                          x87_r6_8 - temp6_1
00417d1e                          eax_2.w = (x87_r6_8 < temp6_1 ? 1 : 0) << 8
00417d1e                              | (is_unordered.t(x87_r6_8, temp6_1) ? 1 : 0) << 0xa
00417d1e                              | (x87_r6_8 == temp6_1 ? 1 : 0) << 0xe | 0x3800
00417d1e                          
00417d23                          if ((eax_2:1.b & 1) != 0)
00417d29                              var_18 = var_1c_1
00417d29                      
00417d2d                      ecx_2 += 0xc
00417d30                      j = j_2
00417d30                      j_2 -= 1
00417d31                  while (j != 1)
00417d31          
00417d33          esi_1 += 0x20
00417d36          i = i_7
00417d36          i_7 -= 1
00417d37      while (i != 1)
00417d37  
00417d3d  long double temp0 = fconvert.t(0.10000000000000001)
00417d3d  x87_r7 - temp0
00417d43  eax_2.w = (x87_r7 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7, temp0) ? 1 : 0) << 0xa
00417d43      | (x87_r7 == temp0 ? 1 : 0) << 0xe
00417d43  
00417d48  if ((eax_2:1.b & 1) != 0)
00417d59      *arg5 = sub_406a00(ebp)
00417d6a      return sub_410030("Q1_SplitBrush: only on back\n")
00417d6a  
00417d6b  long double x87_r7_1 = fconvert.t(var_18)
00417d6f  long double temp1 = fconvert.t(-0.10000000000000001)
00417d6f  x87_r7_1 - temp1
00417d75  eax_2.w = (x87_r7_1 < temp1 ? 1 : 0) << 8
00417d75      | (is_unordered.t(x87_r7_1, temp1) ? 1 : 0) << 0xa
00417d75      | (x87_r7_1 == temp1 ? 1 : 0) << 0xe
00417d75  
00417d7a  if ((eax_2:1.b & 0x41) == 0)
00417d8b      *arg4 = sub_406a00(ebp)
00417d9c      return sub_410030("Q1_SplitBrush: only on front\n")
00417d9c  
00417da2  int32_t* eax_8
00417da2  int80_t st0
00417da2  st0, eax_8 = sub_410b70(edi, *(edi + 0xc))
00417da2  int16_t top = 0xffff
00417da7  int32_t ecx_4 = *(ebp + 0x28)
00417dad  int32_t i_1 = 0
00417daf  var_20 = eax_8
00417daf  
00417db5  if (ecx_4 s> 0)
00417db7      void* ebx_1 = ebp + 0x2c
00417db7      
00417dfc      do
00417dbc          if (eax_8 == 0)
00417dbc              goto label_4180ba
00417dbc          
00417dd0          int32_t ecx_6 = (*ebx_1 ^ 1) * 7
00417de7          sub_4111c0(&var_20, (ecx_6 << 2) + &data_239e0c0, 
00417de7              *((ecx_6 << 2) + &data_239e0cc), 0f)
00417de7          top -= 1
00417de7          unimplemented  {call sub_4111c0}
00417df2          i_1 += 1
00417df3          ebx_1 += 0x20
00417df8          eax_8 = var_20
00417dfc      while (i_1 s< *(ebp + 0x28))
00417dfc  
00417e00  int32_t eax_13
00417e00  
00417e00  if (eax_8 != 0)
00417e07      eax_13 = sub_406f30(eax_8)
00417e07  
00417e11  void* eax_38
00417e11  
00417e11  if (eax_8 == 0 || eax_13 != 0)
004180ba      label_4180ba:
004180ba      sub_410030("Q1_SplitBrush: no split winding\n")
004180c1      eax_38 = sub_407430(ebp, edi)
004180c1      unimplemented  {call sub_407430}
004180c1      
004180cc      if (eax_38 == 1)
004180cf          void* eax_40 = sub_406a00(ebp)
004180de          *arg4 = eax_40
004180e4          return eax_40
004180e4      
004180e8      if (eax_38 == 2)
004180eb          eax_38 = sub_406a00(ebp)
004180f7          *arg5 = eax_38
00417e11  else
00417e26      if (sub_406fc0(var_20) != 0)
00417e2d          sub_410030("Q1_SplitBrush: WARNING huge spli…")
00417e2d      
00417e35      int32_t* edx_4 = var_20
00417e39      void* var_10
00417e39      void** esi_2 = &var_10
00417e41      int32_t i_8 = 2
00417e5f      int32_t i_2
00417e5f      
00417e5f      do
00417e4b          void* eax_17 = sub_4068f0(*(ebp + 0x28) + 1)
00417e50          int32_t ecx_8 = *(ebp + 0x24)
00417e53          *esi_2 = eax_17
00417e58          esi_2 = &esi_2[1]
00417e5b          i_2 = i_8
00417e5b          i_8 -= 1
00417e5c          *(eax_17 + 0x24) = ecx_8
00417e5f      while (i_2 != 1)
00417e64      int32_t i_6 = 0
00417e64      
00417e6e      if (*(ebp + 0x28) s> 0)
00417e74          void* ebp_1 = ebp + 0x2c
00417ef3          int32_t i_3
00417ef3          
00417ef3          do
00417e77              int32_t* eax_19 = *(ebp_1 + 8)
00417e7c              var_20 = eax_19
00417e7c              
00417e80              if (eax_19 != 0)
00417e94                  void var_8
00417e94                  void var_4
00417e94                  sub_410e60(eax_19, edi, *(edi + 0xc), 0f, &var_8, &var_4)
00417e94                  top -= 1
00417e94                  unimplemented  {call sub_410e60}
00417e94                  
00417edc                  for (int32_t j_1 = 0; j_1 s< 8; j_1 += 4)
00417ea4                      if (*(&var_8 + j_1) != 0)
00417ea6                          void* ecx_9 = *(&var_10 + j_1)
00417eac                          int32_t edx_6 = *(ecx_9 + 0x28)
00417eb9                          *(ecx_9 + 0x28) = edx_6 + 1
00417ec3                          __builtin_memcpy(dest: (edx_6 << 5) + ecx_9 + 0x2c, src: ebp_1, 
00417ec3                              n: 0x20)
00417ec5                          int32_t ecx_10 = *(&var_8 + j_1)
00417ec9                          *((edx_6 << 5) + ecx_9 + 0x48) &= 0xfffe
00417ecf                          edi = var_14
00417ed3                          *((edx_6 << 5) + ecx_9 + 0x34) = ecx_10
00417ed3              
00417ee6              i_3 = i_6 + 1
00417ee7              ebp_1 += 0x20
00417eed              i_6 = i_3
00417ef3          while (i_3 s< *(arg1 + 0x28))
00417ef5          ebp = arg1
00417ef5      
00417ef7      void** edi_2 = &var_10
00417efb      arg1 = 2
00417efb      
00417f03      while (true)
00417f03          void* ebx_2 = *edi_2
00417f06          sub_406550(ebx_2)
00417f06          unimplemented  {call sub_406550}
00417f0e          int32_t esi_4 = 0
00417f10          void* ecx_12 = ebx_2 + 0x10
00417f10          
00417f13          while (true)
00417f13              unimplemented  {fld st0, dword [ecx-0xc]}
00417f16              long double temp8_1 = fconvert.t(-4096f)
00417f16              unimplemented  {fcomp st0, dword [&data_42926c]} f- temp8_1
00417f16              bool c0_7 = unimplemented  {fcomp st0, dword [&data_42926c]} f< temp8_1
00417f16              bool c2_7 =
00417f16                  is_unordered.t(unimplemented  {fcomp st0, dword [&data_42926c]}, temp8_1)
00417f16              bool c3_7 = unimplemented  {fcomp st0, dword [&data_42926c]} f== temp8_1
00417f16              unimplemented  {fcomp st0, dword [&data_42926c]}
00417f16              
00417f21              if ((((c0_7 ? 1 : 0) << 8 | (c2_7 ? 1 : 0) << 0xa | (c3_7 ? 1 : 0) << 0xe
00417f21                      | (top & 7) << 0xb):1.b & 1) == 0)
00417f23                  unimplemented  {fld st0, dword [ecx]}
00417f25                  long double temp9_1 = fconvert.t(4096f)
00417f25                  unimplemented  {fcomp st0, dword [&data_429268]} f- temp9_1
00417f25                  bool c0_8 = unimplemented  {fcomp st0, dword [&data_429268]} f< temp9_1
00417f25                  bool c2_8 = is_unordered.t(
00417f25                      unimplemented  {fcomp st0, dword [&data_429268]}, temp9_1)
00417f25                  bool c3_8 = unimplemented  {fcomp st0, dword [&data_429268]} f== temp9_1
00417f25                  unimplemented  {fcomp st0, dword [&data_429268]}
00417f25                  
00417f30                  if ((((c0_8 ? 1 : 0) << 8 | (c2_8 ? 1 : 0) << 0xa | (c3_8 ? 1 : 0) << 0xe
00417f30                          | (top & 7) << 0xb):1.b & 0x41) != 0)
00417f32                      esi_4 += 1
00417f33                      ecx_12 += 4
00417f33                      
00417f39                      if (esi_4 s>= 3)
00417f39                          break
00417f39                      
00417f39                      continue
00417f39              
00417f42              sub_410030("Q1_SplitBrush: bogus brush after…")
00417f47              break
00417f47          
00417f53          if (*(ebx_2 + 0x28) s< 3 || esi_4 s< 3)
00417f56              sub_406960(ebx_2)
00417f60              *edi_2 = nullptr
00417f66              sub_410030("Q1_SplitBrush: numsides < 3\n")
00417f66          
00417f72          edi_2 = &edi_2[1]
00417f75          bool cond:5_1 = arg1 != 1
00417f76          arg1 -= 1
00417f76          
00417f7a          if (not(cond:5_1))
00417f7a              break
00417f7a      
00417f7c      void* edi_3 = var_10
00417f82      void* esi_5
00417f82      void* var_c
00417f82      
00417f82      if (edi_3 == 0)
00418053          if (var_c == 0)
00418069              return sub_410030("Q1_SplitBrush: split removed bru…")
00418069          
0041806a          esi_5 = var_c
00417f82      else
00417f88          esi_5 = var_c
00417f88          
00417f8e          if (esi_5 != 0)
00417fef              for (int32_t i_4 = 0; i_4 s< 2; i_4 += 1)
00417f9f                  void* eax_28 = (&var_10)[i_4]
00417fa3                  int32_t ecx_13 = *(eax_28 + 0x28)
00417fb0                  *(eax_28 + 0x28) = ecx_13 + 1
00417fb9                  *((ecx_13 << 5) + eax_28 + 0x48) &= 0xfff4
00417fc2                  *((ecx_13 << 5) + eax_28 + 0x30) = 0
00417fcb                  *((ecx_13 << 5) + eax_28 + 0x2c) = i_4 ^ arg2 ^ 1
00417fcd                  *((ecx_13 << 5) + eax_28 + 0x44) = arg3
00417fcd                  
00417fd0                  if (i_4 != 0)
00417fe8                      *((ecx_13 << 5) + eax_28 + 0x34) = edx_4
00417fd0                  else
00417fdf                      *((ecx_13 << 5) + eax_28 + 0x34) = sub_410dd0(edx_4)
00417fdf              
00417ff1              void** esi_7 = &var_10
00417ff5              int32_t i_9 = 2
0041802f              int32_t i_5
0041802f              
0041802f              do
00417ffa                  void* edi_4 = *esi_7
00417ffd                  sub_406780(edi_4)
00417ffd                  unimplemented  {call sub_406780}
00418002                  long double temp11_1 = fconvert.t(1f)
00418002                  unimplemented  {fcomp st0, dword [&data_42914c]} f- temp11_1
00418002                  bool c0_9 = unimplemented  {fcomp st0, dword [&data_42914c]} f< temp11_1
00418002                  bool c2_9 = is_unordered.t(
00418002                      unimplemented  {fcomp st0, dword [&data_42914c]}, temp11_1)
00418002                  bool c3_9 = unimplemented  {fcomp st0, dword [&data_42914c]} f== temp11_1
00418002                  unimplemented  {fcomp st0, dword [&data_42914c]}
00418002                  
00418010                  if ((((c0_9 ? 1 : 0) << 8 | (c2_9 ? 1 : 0) << 0xa | (c3_9 ? 1 : 0) << 0xe
00418010                          | (top & 7) << 0xb):1.b & 1) != 0)
00418013                      sub_406960(edi_4)
0041801d                      *esi_7 = nullptr
00418023                      sub_410030("Q1_SplitBrush: tiny volume after…")
00418023                  
0041802b                  esi_7 = &esi_7[1]
0041802e                  i_5 = i_9
0041802e                  i_9 -= 1
0041802f              while (i_5 != 1)
0041803e              *arg4 = var_10
00418046              *arg5 = var_c
0041804c              return var_c
00418073      eax_38 = sub_410030("Q1_SplitBrush: split not on both…")
00418073      
0041807d      if (edi_3 != 0)
00418080          sub_406960(edi_3)
00418086          eax_38 = sub_406a00(ebp)
00418092          *arg4 = eax_38
00418092      
00418096      if (esi_5 != 0)
00418099          sub_406960(esi_5)
0041809f          void* eax_39 = sub_406a00(ebp)
004180ae          *arg5 = eax_39
004180b4          return eax_39
004180b4  
00418100  return eax_38

00418101     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

00418110    void* __convention("regparm") sub_418110(int32_t arg1, int32_t arg2, void* arg3, void* arg4)

00418110  void* var_4 = arg3
00418112  void* i_3
00418112  void* i_4 = i_3
00418112  
00418118  if (i_4 s>= 0)
004181ab      int32_t edx_1 = data_261d01c
004181b1      int32_t esi_1 = i_4 * 0x18
004181b7      int32_t ecx_10 = *(esi_1 + data_261d030) * 5
004181c1      int32_t var_10 = *(edx_1 + (ecx_10 << 2) + 0xc)
004181d9      sub_417c60(arg4, sub_414ae0(edx_1 + (ecx_10 << 2)), i_4, &i_3, &var_4)
004181df      sub_406960(arg4)
004181e4      void* i_2 = i_3
004181ed      void* eax_13
004181ed      
004181ed      if (i_2 != 0)
004181ef          eax_13 = var_4
004181ef      
004181f5      if (i_2 == 0 || eax_13 == 0)
004181fc          sub_410030("Q1_CreateBrushes_r: WARNING node…")
00418201          eax_13 = var_4
00418205          i_2 = i_3
00418205      
0041820e      if (i_2 != 0)
00418222          i_2 = sub_418110(i_2, sx.d(*(esi_1 + data_261d030 + 4)))
00418224          eax_13 = var_4
0041822b          i_3 = i_2
0041822b      
00418231      if (eax_13 != 0)
00418240          eax_13 = sub_418110(eax_13, sx.d(*(esi_1 + data_261d030 + 6)))
00418245          i_2 = i_3
0041824c          var_4 = eax_13
0041824c      
00418253      if (i_2 == 0)
0041826d          return eax_13
0041826d      
00418255      void** i_1 = i_2
00418255      
0041825b      for (void* i = *i_2; i != 0; i = *i_1)
0041825d          i_1 = i
0041825d      
00418265      *i_1 = eax_13
00418267      return i_3
00418267  
00418134  int32_t __saved_esi_2 = *(data_261d070 - (i_4 + 1) * 0x1c)
00418134  
0041813c  if (__saved_esi_2 + 6 u> 5)
0041818f      int32_t __saved_esi_1 = __saved_esi_2
00418195      sub_40f970("Q1_CreateBrushes_r: unknown cont…")
004181a1      return 0
004181a1  
0041813c  switch (__saved_esi_2)
0041815c      case 0xfffffffa, 0xfffffffe
0041815c          *(arg4 + 0x1c) = 1
00418164          return arg4
00418186      case 0xfffffffb
00418186          *(arg4 + 0x1c) = 8
0041818e          return arg4
00418178      case 0xfffffffc
00418178          *(arg4 + 0x1c) = 0x10
00418180          return arg4
0041816a      case 0xfffffffd
0041816a          *(arg4 + 0x1c) = 0x20
00418172          return arg4
0041814a      case 0xffffffff
0041814a          sub_406960(arg4)
00418156          return 0

0041826e                                            8b ff                                                                ..
00418270  uint32_t jump_table_418270[0x6] = 
00418270  {
00418270      [0x0] =  0x00418157
00418274      [0x1] =  0x00418181
00418278      [0x2] =  0x00418173
0041827c      [0x3] =  0x00418165
00418280      [0x4] =  0x00418157
00418284      [0x5] =  0x00418145
00418288  }

00418288                          90 90 90 90 90 90 90 90                                                          ........

00418290    void* sub_418290(int32_t arg1)

004182a5  int32_t edx = data_261d030
004182ab  int32_t esi_1 = arg1 << 6
004182b2  int32_t ecx = *(esi_1 + data_261d034 + 0x24) * 3
004182b5  void* eax_2 = edx + (ecx << 3)
004182bd  int32_t var_24 = sx.d(*(edx + (ecx << 3) + 8))
004182c5  float var_20 = fconvert.s(float.t(var_24))
004182cd  var_24 = sx.d(*(eax_2 + 0xa))
004182d5  float var_1c = fconvert.s(float.t(var_24))
004182dd  var_24 = sx.d(*(eax_2 + 0xc))
004182e5  float var_18 = fconvert.s(float.t(var_24))
004182ed  var_24 = sx.d(*(eax_2 + 0xe))
004182f5  float var_14 = fconvert.s(float.t(var_24))
004182fd  var_24 = sx.d(*(eax_2 + 0x10))
00418305  float var_10 = fconvert.s(float.t(var_24))
0041830d  var_24 = sx.d(*(eax_2 + 0x12))
00418311  int32_t i = 0
00418317  float var_c = fconvert.s(float.t(var_24))
00418317  
0041833d  do
0041831f      long double x87_r7_7 = fconvert.t(*(&var_20 + i)) - fconvert.t(8f)
00418325      i += 4
0041832b      *(&var_24 + i) = fconvert.s(x87_r7_7)
00418339      *(&var_18 + i) = fconvert.s(fconvert.t(*(&var_18 + i)) + fconvert.t(8f))
0041833d  while (i s< 0xc)
0041833d  
0041834e  sub_410520(&var_20, &data_255e0f0, &data_255e0d0)
00418362  sub_410520(&var_14, &data_255e0f0, &data_255e0d0)
00418362  
0041836c  if (arg1 == 0)
0041838f      float* var_48
0041838f      var_48.q = fconvert.d(fconvert.t(data_255e0d0))
0041839b      double var_50_1 = fconvert.d(fconvert.t(data_255e0f8))
004183a7      double var_58_1 = fconvert.d(fconvert.t(data_255e0f4))
004183b3      double var_60_1 = fconvert.d(fconvert.t(data_255e0f0))
004183bb      sub_410030("brush size: %5.0f,%5.0f,%5.0f to…")
004183bb  
004183cd  void* eax_3 = sub_4066b0(&var_20, &var_14)
004183d6  *(eax_3 + 4) = var_20
004183dd  *(eax_3 + 8) = var_1c
004183e4  *(eax_3 + 0xc) = var_18
004183eb  *(eax_3 + 0x10) = var_14
004183f2  *(eax_3 + 0x14) = var_10
004183f9  *(eax_3 + 0x18) = var_c
004183fc  void* ecx_7 = data_261d034
00418402  int32_t edx_7 = *(esi_1 + ecx_7 + 0x24)
00418406  int32_t var_3c_1 = edx_7
00418415  return sub_418110(eax_3, edx_7, ecx_7, eax_3)

00418416                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00418420    int32_t* sub_418420(int16_t* arg1, void* arg2)

0041842c  void* eax_1 = sub_410dd0(arg2)
00418442  int32_t ecx = sx.d(*arg1)
00418446  bool cond:0 = arg1[1] == 0
0041844b  arg2 = eax_1
0041845a  float var_14
0041845a  __builtin_memcpy(dest: &var_14, src: data_261d01c + ecx * 0x14, n: 0x14)
0041845c  int16_t top
0041845c  
0041845c  if (not(cond:0))
00418464      var_14 = fconvert.s(fneg(fconvert.t(var_14)))
0041846e      float var_10
0041846e      float var_10_1 = fconvert.s(fneg(fconvert.t(var_10)))
00418478      float var_c
00418478      float var_c_1 = fconvert.s(fneg(fconvert.t(var_c)))
00418482      float var_8
00418482      float var_8_1 = fconvert.s(fneg(fconvert.t(var_8)))
00418482      top = 0
00418482  
00418486  int32_t i = 0
00418486  
0041848c  if (arg1[4] s> 0)
00418570      do
00418494          if (eax_1 == 0)
00418494              goto label_41859d
00418494          
004184a7          *(data_261d060 + ((*(arg1 + 4) + i) << 2))
004184de          unimplemented  {fld st0, dword [esi]}
004184f1          unimplemented  {fsub st0, dword [eax+edx*4]}
004184fc          float var_20 = fconvert.s(unimplemented  {fstp dword [esp+0x24], st0})
004184fc          unimplemented  {fstp dword [esp+0x24], st0}
00418500          unimplemented  {fld st0, dword [esi+0x4]}
00418503          unimplemented  {fsub st0, dword [eax+0x4]}
00418506          float var_1c_1 = fconvert.s(unimplemented  {fstp dword [esp+0x28], st0})
00418506          unimplemented  {fstp dword [esp+0x28], st0}
0041850a          unimplemented  {fld st0, dword [esi+0x8]}
0041850d          unimplemented  {fsub st0, dword [eax+0x8]}
00418515          float var_18_1 = fconvert.s(unimplemented  {fstp dword [esp+0x30], st0})
00418515          unimplemented  {fstp dword [esp+0x30], st0}
00418519          float var_2c
00418519          sub_410420(&var_20, &var_14, &var_2c)
00418528          int32_t ecx_3 = sub_410460(&var_2c, &var_2c)
00418528          unimplemented  {call sub_410460}
0041852d          unimplemented  {fstp st0, st0}
0041852d          unimplemented  {fstp st0, st0}
0041852f          unimplemented  {fld st0, dword [esp+0x24]}
00418533          unimplemented  {fmul st0, dword [esi]}
00418535          unimplemented  {fld st0, dword [esp+0x28]}
00418539          unimplemented  {fmul st0, dword [esi+0x4]}
00418543          unimplemented  {faddp st1, st0}
00418543          unimplemented  {faddp st1, st0}
00418545          unimplemented  {fld st0, dword [esp+0x18]}
00418549          unimplemented  {fmul st0, dword [esi+0x8]}
00418551          int32_t var_44_2 = ecx_3
00418556          unimplemented  {faddp st1, st0}
00418556          unimplemented  {faddp st1, st0}
00418558          float var_44_3 = fconvert.s(unimplemented  {fstp dword [esp], st0})
00418558          unimplemented  {fstp dword [esp], st0}
0041855d          sub_4111c0(&arg2, &var_2c, var_44_3, 0.899999976f)
0041855d          top -= 1
0041855d          unimplemented  {call sub_4111c0}
00418566          eax_1 = arg2
0041856d          i += 1
00418570      while (i s< sx.d(arg1[4]))
00418570  
00418578  if (eax_1 == 0)
0041859d      label_41859d:
0041859d      unimplemented  {fld st0, dword [&data_429148]}
004185aa      return eax_1
004185aa  
0041857b  sub_410a50(eax_1)
0041857b  unimplemented  {call sub_410a50}
00418584  arg1 = fconvert.s(unimplemented  {fstp dword [esp+0x44], st0})
00418584  unimplemented  {fstp dword [esp+0x44], st0}
00418589  int32_t eax_7 = sub_410740(arg2)
0041858e  unimplemented  {fld st0, dword [esp+0x48]}
0041859c  return eax_7

004185ab                                   90 90 90 90 90                                                             .....

004185b0    void sub_4185b0(int16_t* arg1)

004185b0  int16_t* eax = arg1
004185d3  float var_14
004185d3  __builtin_memcpy(dest: &var_14, src: data_261d01c + sx.d(*eax) * 0x14, n: 0x14)
004185d3  
004185db  if (eax[1] != 0)
004185e3      var_14 = fconvert.s(fneg(fconvert.t(var_14)))
004185ed      float var_10
004185ed      float var_10_1 = fconvert.s(fneg(fconvert.t(var_10)))
004185f7      float var_c
004185f7      float var_c_1 = fconvert.s(fneg(fconvert.t(var_c)))
00418601      float var_8
00418601      float var_8_1 = fconvert.s(fneg(fconvert.t(var_8)))
00418601  
00418609  int32_t var_34 = 0
0041860d  int32_t* var_40 = nullptr
00418611  int32_t var_38 = 0
00418615  void* arg_4
00418615  
00418615  if (eax[4] s<= 0)
00418790      sub_406960(arg_4)
004187a1      return 
004187a1  
0041861b  void* ebx = arg_4
0041861b  
00418636  while (true)
00418636      int32_t ebp_2 = data_261d044
0041863c      int32_t eax_3 = *(data_261d060 + ((*(eax + 4) + var_38) << 2))
00418641      int32_t edx_1
00418641      edx_1.b = eax_3 s> 0
00418648      int32_t eax_4
00418648      int32_t edx_2
00418648      edx_2:eax_4 = sx.q(eax_3)
0041864d      int32_t edx_3 = data_261d014
00418653      int32_t eax_7 = ((eax_4 ^ edx_2) - edx_2) << 1
00418658      int32_t ecx_3
00418658      ecx_3.w = *(edx_3 + ((eax_7 + edx_1) << 1))
0041865f      float* esi_2 = ebp_2 + ecx_3 * 0xc
00418667      int32_t ecx_5
00418667      ecx_5.b = edx_1 == 0
00418670      int32_t eax_8
00418670      eax_8.w = *(edx_3 + ((ecx_5 + eax_7) << 1))
00418678      int32_t edx_4 = eax_8 * 3
0041867f      void* eax_9 = ebp_2 + (edx_4 << 2)
00418687      float var_20 = fconvert.s(fconvert.t(*esi_2) - fconvert.t(*(ebp_2 + (edx_4 << 2))))
00418691      float var_1c_1 = fconvert.s(fconvert.t(esi_2[1]) - fconvert.t(*(eax_9 + 4)))
004186a2      float var_18_1 = fconvert.s(fconvert.t(esi_2[2]) - fconvert.t(*(eax_9 + 8)))
004186a6      float var_2c
004186a6      sub_410420(&var_20, &var_14, &var_2c)
004186b5      sub_410460(&var_2c, &var_2c)
004186e0      float var_28
004186e0      float var_24
004186e0      float var_68_1 = fconvert.s(fconvert.t(var_24) * fconvert.t(esi_2[2])
004186e0          + fconvert.t(var_2c) * fconvert.t(*esi_2)
004186e0          + fconvert.t(var_28) * fconvert.t(esi_2[1]))
004186f3      int32_t* var_3c
004186f3      sub_4074d0(ebx, sub_414ae0(&var_2c), &arg_4, &var_3c)
004186f8      int32_t* eax_11 = var_3c
004186f8      
00418701      if (eax_11 != 0)
00418706          eax_11[7] = *(ebx + 0x1c)
00418711          *var_3c = var_40
0041871c          var_40 = var_3c
00418720          var_34 += 1
00418720      
00418724      void* eax_15 = arg_4
00418724      
0041872a      if (eax_15 == 0)
0041876f          sub_410030("Q1_SplitBrushWithFace: no new br…")
00418779          sub_4069e0(var_40)
0041878a          return 
0041878a      
00418733      *(eax_15 + 0x1c) = *(ebx + 0x1c)
0041873e      ebx = arg_4
00418743      bool cond:1_1 = var_38 + 1 s< sx.d(arg1[4])
00418745      var_38 += 1
00418745      
00418749      if (not(cond:1_1))
00418749          break
00418749      
00418621      eax = arg1
00418621  
00418755  if (var_34 == 0)
00418758      sub_406960(ebx)
00418769      return 
00418769  
004187a8  *ebx = var_40

004187b4                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

004187c0    int32_t* sub_4187c0(int32_t* arg1, int32_t arg2)

004187c5  int32_t esi = arg2
004187ee  int32_t var_28
004187ee  
004187ee  if (esi == 0)
004187f5      sub_40fa00("texturing brushes\n")
004187fa      int32_t var_4c_1 = 0
00418800      var_28 = 0
00418804      sub_40fa00("%5d brushes")
00418804  
0041880c  int32_t* result = arg1
00418812  int32_t* var_34 = result
00418812  
00418816  if (result != 0)
00418826      int32_t* i
00418826      
00418826      do
0041881c          i = *var_34
0041881c          
00418820          if (i == 0)
00418820              break
00418820          
00418822          var_34 = i
00418826      while (i != 0)
00418826  
0041882a  int32_t* result_2 = nullptr
0041882e  int32_t* result_1 = result
0041882e  
00418832  if (result != 0)
00418846      while (true)
00418846          int32_t* result_4 = *result
0041884a          int32_t var_1c_1 = 0
0041884a          
0041884e          if (result[0xa] s> 0)
00418854              int32_t ecx_2 = 0
00418856              int32_t var_18_1 = 0
00418b90              bool cond:7_1
00418b90              
00418b90              do
0041885e                  int32_t eax_2
0041885e                  eax_2.b = *(ecx_2 + result + 0x48)
00418862                  void* ecx_3 = ecx_2 + result + 0x2c
00418862                  
0041886c                  if ((eax_2.b & 8) == 0)
00418878                      int32_t eax_3 = *(ecx_3 + 0x18)
0041887b                      int32_t i_4 = 0xffffffff
00418880                      float var_20_1 = 1f
00418888                      int16_t top
00418888                      
00418888                      if (data_279c360 != 0)
004189c1                          int32_t i_1 = 0
004189c1                          
004189c5                          if (data_261d054 s<= 0)
00418b6c                              *(ecx_3 + 0x1c) |= 8
00418b70                              *(ecx_3 + 4) = 0xffffffff
004189c5                          else
004189d1                              void* edi_1 = nullptr
004189d1                              
00418a1c                              do
004189d3                                  int32_t ecx_10 = data_261d018
004189d3                                  
004189e9                                  if (sx.d(*(edi_1 + ecx_10))
004189e9                                          == *(eax_3 * 0x18 + data_261d030))
004189f4                                      sub_418420(edi_1 + ecx_10, *(ecx_3 + 8))
004189f9                                      long double temp0_1 = fconvert.t(var_20_1)
004189f9                                      unimplemented  {fcom st0, dword [esp+0x30]} f- temp0_1
004189f9                                      bool c0_2 =
004189f9                                          unimplemented  {fcom st0, dword [esp+0x30]}
004189f9                                          f< temp0_1
004189f9                                      bool c2_2 = is_unordered.t(
004189f9                                          unimplemented  {fcom st0, dword [esp+0x30]}, 
004189f9                                          temp0_1)
004189f9                                      bool c3_2 =
004189f9                                          unimplemented  {fcom st0, dword [esp+0x30]}
004189f9                                          f== temp0_1
004189f9                                      
00418a05                                      if ((((c0_2 ? 1 : 0) << 8 | (c2_2 ? 1 : 0) << 0xa
00418a05                                              | (c3_2 ? 1 : 0) << 0xe | (top & 7) << 0xb):1.b
00418a05                                              & 0x41) != 0)
00418a0f                                          unimplemented  {fstp st0, st0}
00418a0f                                          unimplemented  {fstp st0, st0}
00418a0f                                          top += 1
00418a05                                      else
00418a07                                          var_20_1 = fconvert.s(unimplemented  {fstp dword [
00418a07                                              esp+0x28], st0})
00418a07                                          unimplemented  {fstp dword [esp+0x28], st0}
00418a07                                          top += 1
00418a0b                                          i_4 = i_1
00418a0b                                  
00418a16                                  i_1 += 1
00418a17                                  edi_1 += 0x14
00418a1c                              while (i_1 s< data_261d054)
00418a1c                              
00418a1e                              label_418a1e:
00418a1e                              
00418a20                              if (i_4 s< 0)
00418b68                                  result = result_1
00418b6c                                  *(ecx_3 + 0x1c) |= 8
00418b70                                  *(ecx_3 + 4) = 0xffffffff
00418a20                              else
00418a2f                                  int32_t var_30_1 = 4
00418a37                                  int32_t ebx_5 = sx.d(*(data_261d018 + i_4 * 0x14 + 0xa))
00418a4f                                  int32_t esi_4 = ebx_5 * 0x28
00418a58                                  void* ecx_13 = &(&data_586030)[ebx_5 * 0x1b]
00418a5a                                  void* eax_16 = esi_4 + data_261d078 + 0x10
00418a78                                  bool cond:10_1
00418a78                                  
00418a78                                  do
00418a5e                                      int32_t edx_13 = *(eax_16 - 0x10)
00418a61                                      eax_16 += 4
00418a64                                      *(ecx_13 - 0x10) = edx_13
00418a6a                                      *ecx_13 = *(eax_16 - 4)
00418a70                                      ecx_13 += 4
00418a73                                      cond:10_1 = var_30_1 != 1
00418a74                                      var_30_1 -= 1
00418a78                                  while (cond:10_1)
00418a81                                  sub_410350(&(&data_586020)[ebx_5 * 0x1b])
00418a81                                  unimplemented  {call sub_410350}
00418a86                                  long double temp3_1 = fconvert.t(0.01)
00418a86                                  unimplemented  {fcomp st0, qword [&data_4291c0]}
00418a86                                      f- temp3_1
00418a86                                  bool c0_3 =
00418a86                                      unimplemented  {fcomp st0, qword [&data_4291c0]}
00418a86                                      f< temp3_1
00418a86                                  bool c2_3 = is_unordered.t(
00418a86                                      unimplemented  {fcomp st0, qword [&data_4291c0]}, 
00418a86                                      temp3_1)
00418a86                                  bool c3_3 =
00418a86                                      unimplemented  {fcomp st0, qword [&data_4291c0]}
00418a86                                      f== temp3_1
00418a86                                  unimplemented  {fcomp st0, qword [&data_4291c0]}
00418a86                                  
00418a94                                  if ((((c0_3 ? 1 : 0) << 8 | (c2_3 ? 1 : 0) << 0xa
00418a94                                          | (c3_3 ? 1 : 0) << 0xe | (top & 7) << 0xb):1.b & 1)
00418a94                                          != 0)
00418aa2                                      (&data_586020)[ebx_5 * 0x1b] = 0x3f800000
00418aac                                      (&data_586024)[ebx_5 * 0x1b] = 0
00418ab2                                      (&data_586028)[ebx_5 * 0x1b] = 0
00418ab8                                      (&data_58602c)[ebx_5 * 0x1b] = 0
00418ab8                                  
00418abf                                  sub_410350(&(&data_586030)[ebx_5 * 0x1b])
00418abf                                  unimplemented  {call sub_410350}
00418ac4                                  long double temp4_1 = fconvert.t(0.01)
00418ac4                                  unimplemented  {fcomp st0, qword [&data_4291c0]}
00418ac4                                      f- temp4_1
00418ac4                                  bool c0_4 =
00418ac4                                      unimplemented  {fcomp st0, qword [&data_4291c0]}
00418ac4                                      f< temp4_1
00418ac4                                  bool c2_4 = is_unordered.t(
00418ac4                                      unimplemented  {fcomp st0, qword [&data_4291c0]}, 
00418ac4                                      temp4_1)
00418ac4                                  bool c3_4 =
00418ac4                                      unimplemented  {fcomp st0, qword [&data_4291c0]}
00418ac4                                      f== temp4_1
00418ac4                                  unimplemented  {fcomp st0, qword [&data_4291c0]}
00418ac4                                  
00418ad2                                  if ((((c0_4 ? 1 : 0) << 8 | (c2_4 ? 1 : 0) << 0xa
00418ad2                                          | (c3_4 ? 1 : 0) << 0xe | (top & 7) << 0xb):1.b & 1)
00418ad2                                          != 0)
00418ae0                                      (&data_586030)[ebx_5 * 0x1b] = 0x3f800000
00418ae6                                      (&data_586034)[ebx_5 * 0x1b] = 0
00418ae9                                      (&data_586038)[ebx_5 * 0x1b] = 0
00418aec                                      (&data_58603c)[ebx_5 * 0x1b] = 0
00418aec                                  
00418aef                                  int32_t ecx_14 = data_261d078
00418af5                                  int32_t eax_20 = data_261d048
00418afe                                  (&data_586040)[ebx_5 * 0x1b] = *(esi_4 + ecx_14 + 0x24)
00418b04                                  (&data_586044)[ebx_5 * 0x1b] = 0
00418b1c                                  int32_t i_2 = 0xffffffff
00418b1f                                  int32_t edi_4 =
00418b1f                                      *(eax_20 + (*(esi_4 + ecx_14 + 0x20) << 2) + 4)
00418b1f                                      + eax_20
00418b1f                                  
00418b23                                  while (i_2 != 0)
00418b23                                      bool cond:12_1 = 0 != *edi_4
00418b23                                      edi_4 += 1
00418b23                                      i_2 -= 1
00418b23                                      
00418b23                                      if (not(cond:12_1))
00418b23                                          break
00418b23                                  
00418b25                                  int32_t ecx_16 = not.d(i_2)
00418b32                                  int32_t esi_6
00418b32                                  int32_t edi_7
00418b32                                  edi_7, esi_6 = __builtin_memcpy(
00418b32                                      dest: &(&data_586048)[ebx_5 * 0x1b], 
00418b32                                      src: edi_4 - ecx_16, n: ecx_16 u>> 2 << 2)
00418b3d                                  __builtin_memcpy(dest: edi_7, src: esi_6, n: ecx_16 & 3)
00418b3f                                  (&data_586088)[ebx_5 * 0x1b] = 0xffffffff
00418b49                                  *(ecx_3 + 4) = ebx_5
00418b49                                  
00418b52                                  if (ebx_5 s> data_255e0e0)
00418b54                                      data_255e0e0 = ebx_5
00418b54                                  
00418b5a                                  *(ecx_3 + 0x1c) |= 8
00418b5e                                  result = result_1
00418888                      else
00418894                          int32_t i_5 = 0
00418894                          
0041889a                          if (data_261d054 s> 0)
004188a3                              void* edi = 0xffffffec
004188ab                              void* esi_1 = nullptr
0041893b                              bool cond:9_1
0041893b                              
0041893b                              do
004188ad                                  int32_t edx_3 = data_261d018
004188ad                                  
004188c3                                  if (sx.d(*(esi_1 + edx_3))
004188c3                                          == *(eax_3 * 0x18 + data_261d030))
004188ce                                      sub_418420(esi_1 + edx_3, *(ecx_3 + 8))
004188d3                                      long double temp1_1 = fconvert.t(1f)
004188d3                                      unimplemented  {fcomp st0, dword [&data_42914c]}
004188d3                                          f- temp1_1
004188d3                                      bool c0_1 =
004188d3                                          unimplemented  {fcomp st0, dword [&data_42914c]}
004188d3                                          f< temp1_1
004188d3                                      bool c2_1 = is_unordered.t(
004188d3                                          unimplemented  {fcomp st0, dword [&data_42914c]}, 
004188d3                                          temp1_1)
004188d3                                      bool c3_1 =
004188d3                                          unimplemented  {fcomp st0, dword [&data_42914c]}
004188d3                                          f== temp1_1
004188d3                                      unimplemented  {fcomp st0, dword [&data_42914c]}
004188d3                                      top += 1
004188d3                                      
004188e1                                      if ((((c0_1 ? 1 : 0) << 8 | (c2_1 ? 1 : 0) << 0xa
004188e1                                              | (c3_1 ? 1 : 0) << 0xe | (top & 7) << 0xb):1.b
004188e1                                              & 0x41) == 0)
004188e3                                          int32_t ecx_6 = data_261d018
004188eb                                          void* eax_6
004188eb                                          
004188eb                                          if (i_4 s>= 0)
004188ed                                              eax_6 = esi_1 + ecx_6
004188f0                                              ecx_6.w = *(edi + ecx_6 + 0xa)
004188f0                                          
004188f9                                          if (i_4 s< 0 || ecx_6.w == *(eax_6 + 0xa))
00418921                                              i_4 = i_5
00418925                                              edi = esi_1
004188f9                                          else
004188ff                                              void* var_4c_3 = eax_6
00418901                                              int32_t* result_7 = sub_4185b0(result_1)
00418901                                              top -= 1
00418901                                              unimplemented  {call sub_4185b0}
00418901                                              
0041890b                                              if (result_7 != 0)
0041894a                                                  int32_t** result_6 = result_1
00418950                                                  int32_t* ecx_8 = *result_6
00418950                                                  
00418952                                                  if (result_2 == 0)
00418958                                                      result_6 = result_1
0041895c                                                      arg1 = ecx_8
00418952                                                  else
00418954                                                      *result_2 = ecx_8
00418954                                                  
00418960                                                  int32_t* result_5 = var_34
00418960                                                  
00418966                                                  if (result_5 == result_6)
00418968                                                      int32_t* result_3 = result_2
0041896c                                                      result_4 = result_7
00418970                                                      result_5 = result_2
00418970                                                  
00418974                                                  if (result_5 == 0)
0041897a                                                      arg1 = result_7
00418974                                                  else
00418976                                                      *result_5 = result_7
00418976                                                  
0041897f                                                  sub_406960(result_6)
0041898d                                                  result_1 = result_2
00418991                                                  var_34 = arg1
00418991                                                  
00418995                                                  if (arg1 != 0)
004189a5                                                      int32_t* i_3
004189a5                                                      
004189a5                                                      do
0041899b                                                          i_3 = *var_34
0041899b                                                          
0041899f                                                          if (i_3 == 0)
0041899f                                                              break
0041899f                                                          
004189a1                                                          var_34 = i_3
004189a5                                                      while (i_3 != 0)
004189a5                                                  
004189b3                                                  if (i_5 s>= data_261d054)
004189b3                                                      goto label_418a1e
004189b3                                                  
00418b98                                                  result = result_1
00418b98                                                  goto label_418b9c
00418b98                                              
00418911                                              int32_t var_4c_4 = var_28
00418917                                              sub_410080("brush %d: no real texture split")
00418917                                  
00418932                                  esi_1 += 0x14
00418935                                  cond:9_1 = i_5 + 1 s< data_261d054
00418937                                  i_5 += 1
0041893b                              while (cond:9_1)
0041893b                              goto label_418a1e
0041893b                          
00418b6c                          *(ecx_3 + 0x1c) |= 8
00418b70                          *(ecx_3 + 4) = 0xffffffff
00418b70                  
00418b83                  ecx_2 = var_18_1 + 0x20
00418b86                  cond:7_1 = var_1c_1 + 1 s< result[0xa]
00418b88                  var_1c_1 += 1
00418b8c                  var_18_1 = ecx_2
00418b90              while (cond:7_1)
00418b90          
00418b9c          label_418b9c:
00418b9c          esi = arg2
00418b9c          
00418baa          if (esi == 0 && result_2 != result)
00418bb1              int32_t var_4c_9 = var_28 + 1
00418bb7              var_28 += 1
00418bbb              sub_40fa00("\r%5d")
00418bbb          
00418bc7          result_2 = result
00418bcd          result_1 = result_4
00418bcd          
00418bd1          if (result_4 == 0)
00418bd1              break
00418bd1          
0041883b          result = result_1
0041883b      
00418bd7      result = arg1
00418bd7  
00418bde  if (esi == 0)
00418be5      sub_40fa00(&data_42b33c)
00418be5  
00418bf5  return result

00418bf6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00418c00    void sub_418c00(void** arg1)

00418c01  void** i = arg1
00418c01  
00418c07  if (i != 0)
00418c10      void** edi_1 = arg1
00418c10      
00418ca6      do
00418c14          int32_t* j_1 = i[7]
00418c14          
00418c24          if (j_1 == 0x20 || j_1 == 0x10 || j_1 == 8)
00418c29              int32_t j = 0
00418c29              
00418c2d              if (i[0xa] s> 0)
00418c2f                  void* ebx_1 = &i[0xc]
00418c2f                  
00418c5a                  do
00418c32                      edi_1 = *ebx_1
00418c32                      
00418c4f                      if (sub_417bf0(&(&data_586048)[edi_1 * 0x1b]) == i[7])
00418c4f                          break
00418c4f                      
00418c54                      j += 1
00418c55                      ebx_1 += 0x20
00418c5a                  while (j s< i[0xa])
00418c5a              
00418c5f              if (j s< i[0xa])
00418cb3                  label_418cb3:
00418cb3                  
00418cb5                  if (edi_1 s< 0)
00418cb5                      goto label_418c94
00418cb5                  
00418cba                  j_1 = nullptr
00418cba                  
00418cbe                  if (i[0xa] s> 0)
00418cc0                      void* ecx_5 = &i[0xc]
00418cc0                      
00418cce                      do
00418cc3                          *ecx_5 = edi_1
00418cc8                          j_1 += 1
00418cc9                          ecx_5 += 0x20
00418cce                      while (j_1 s< i[0xa])
00418c5f              else
00418c66                  edi_1 = 0xffffffff
00418c69                  void** ebx_2 = nullptr
00418c69                  
00418c6d                  if (data_255e0e0 s> 0)
00418c6f                      int32_t* ebp_1 = &data_586048
00418c6f                      
00418c75                      while (true)
00418c82                          if (sub_417bf0(ebp_1) == i[7])
00418cb1                              edi_1 = ebx_2
00418cb1                              break
00418cb1                          
00418c89                          ebx_2 += 1
00418c8a                          ebp_1 = &ebp_1[0x1b]
00418c8a                          
00418c8f                          if (ebx_2 s>= data_255e0e0)
00418c8f                              goto label_418c94
00418c8f                      
00418c82                      goto label_418cb3
00418c82                  
00418c94                  label_418c94:
00418c94                  int32_t var_14_3 = i[7]
00418c9a                  sub_410030("brush contents %d with wrong tex…")
00418c9a          
00418ca2          i = *i
00418ca6      while (i != 0)

00418cd2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

00418ce0    float sub_418ce0(void* arg1, float arg2)

00418ce1  void* ebx = arg1
00418ce9  sub_409280(ebx)
00418cee  int32_t eax = data_dde044
00418cee  
00418cfb  if (eax s>= 0x4000)
00418d02      sub_40f970("nummapbrushes == MAX_MAPFILE_BRU…")
00418d07      eax = data_dde044
00418d07  
00418d16  int32_t i = 0
00418d31  *(eax * 0x34 + &data_4b6030) = (data_255e0c0 << 5) + 0x1f9e0a0
00418d4e  arg1 = 0xffffffff
00418d52  *(eax * 0x34 + &data_4b6000) = (arg2 i- &data_256ee80) s/ 0x2c
00418d54  int32_t edx_4 = data_dde044
00418d5a  int32_t ecx_5 = *(arg2 i+ 0xc)
00418d5d  *(eax * 0x34 + 0x4b6010) = 0xffffffff
00418d62  *(eax * 0x34 + 0x4b6004) = edx_4 - ecx_5
00418d65  int32_t i_1 = 0
00418d67  *(eax * 0x34 + &data_4b602c) = 0
00418d67  
00418d6f  if (*(ebx + 0x28) s> 0)
00418d71      void* edi_1 = ebx + 0x2c
00418d71      
00418de0      do
00418d77          if (*(edi_1 + 8) != 0)
00418d79              int32_t eax_6 = data_255e0c0
00418d79              
00418d83              if (eax_6 s>= 0x20000)
00418d8a                  sub_40f970("MAX_MAPFILE_BRUSHSIDES")
00418d8f                  eax_6 = data_255e0c0
00418d97                  i_1 = 0
00418d97              
00418da4              *((eax_6 << 5) + 0x1f9e0b4) = *(ebx + 0x1c)
00418da7              *((eax_6 << 5) + 0x1f9e0b8) = 0
00418dac              *((eax_6 << 5) + 0x1f9e0a0) = *edi_1
00418dae              void* ecx_8 = *(edi_1 + 4)
00418db4              *((eax_6 << 5) + 0x1f9e0a4) = ecx_8
00418db4              
00418db7              if (ecx_8 != 0xffffffff)
00418db9                  *((eax_6 << 5) + 0x1f9e0bc) |= 8
00418dbf                  arg1 = ecx_8
00418dbf              
00418dca              data_255e0c0 += 1
00418dd4              *(eax * 0x34 + &data_4b602c) += 1
00418dd4          
00418dda          i += 1
00418ddb          edi_1 += 0x20
00418de0      while (i s< *(ebx + 0x28))
00418de0      
00418de7      if (arg1 != 0xffffffff)
00418e01          if (*(eax * 0x34 + &data_4b602c) s> 0)
00418e03              int32_t ecx_11 = 0
00418e03              
00418e24              do
00418e05                  int32_t eax_16 = *(eax * 0x34 + &data_4b6030)
00418e05                  
00418e13                  if (*(ecx_11 + eax_16 + 4) == 0xffffffff)
00418e19                      *(ecx_11 + eax_16 + 4) = arg1
00418e19                  
00418e1e                  i_1 += 1
00418e1f                  ecx_11 += 0x20
00418e24              while (i_1 s< *(eax * 0x34 + &data_4b602c))
00418e24          
00418e29          *(eax * 0x34 + 0x4b6008) = *(ebx + 0x1c)
00418e29          
00418e33          if (data_279c334 != 0)
00418e49              return sub_405050(eax * 0x34 + &data_4b6000, arg2, 1)
00418e49          
00418e4b          sub_415210(eax * 0x34 + &data_4b6000)
00418e51          sub_414c80(eax * 0x34 + &data_4b6000)
00418e64          data_dde044 += 1
00418e71          *(arg2 i+ 0x10) += 1
00418e75          return arg2
00418e75  
00418de9  *(eax * 0x34 + &data_4b602c) = 0
00418df2  int32_t eax_14 = data_4b4fe0 + 1
00418df5  data_4b4fe0 = eax_14
00418dfb  return eax_14

00418e76                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

00418e80    int32_t* sub_418e80(float arg1, int32_t arg2)

00418e81  int32_t __saved_edi_3 = arg2
00418e93  int32_t* esi = sub_4187c0(sub_418290(__saved_edi_3), __saved_edi_3)
00418e96  sub_418c00(esi)
00418e9b  int32_t* result = data_279beec
00418e9b  
00418ea5  if (result == 0)
00418ea9      result = sub_416e50(esi, __saved_edi_3)
00418eb1      esi = result
00418eb1  
00418eb5  if (__saved_edi_3 == 0)
00418ebc      sub_40fa00("converting brushes to map brushe…")
00418ec1      int32_t __saved_edi_2 = __saved_edi_3
00418ec7      arg2 = __saved_edi_3
00418ecb      result = sub_40fa00("%5d brushes")
00418ecb  
00418ed5  if (esi != 0)
00418f14      int32_t* i
00418f14      
00418f14      do
00418edd          i = *esi
00418ee1          sub_418ce0(esi, arg1)
00418ee7          *esi = 0
00418eed          result = sub_406960(esi)
00418eed          
00418ef7          if (__saved_edi_3 == 0)
00418efe              int32_t var_14_2 = arg2 + 1
00418f04              arg2 += 1
00418f08              result = sub_40fa00("\r%5d")
00418f08          
00418f12          esi = i
00418f14      while (i != 0)
00418f14  
00418f1c  if (__saved_edi_3 == 0)
00418f23      result = sub_40fa00(&data_42b33c)
00418f23  
00418f29  return result

00418f2a                                90 90 90 90 90 90                                                            ......

00418f30    int32_t sub_418f30(int32_t arg1, void* arg2, void* arg3)

00418f38  sub_410030("-- Q1_LoadMapFromBSP --\n")
00418f45  void* var_14 = arg2
00418f46  int32_t var_18 = arg1
00418f4c  data_65e020 = 1
00418f56  sub_40fa00("loading map from %s at %d\n")
00418f62  sub_40c950(arg1, arg2, arg3)
00418f67  data_4b4fe0 = 0
00418f71  sub_40cb10()
00418f80  sub_4104f0(&data_255e0f0, &data_255e0d0)
00418f8a  sub_40fa00("creating Quake1 brushes\n")
00418f99  char* var_10
00418f99  
00418f99  if (data_279c360 == 0)
00418fa2      var_10 = "placing textures correctly\n"
00418f99  else
00418f9b      var_10 = "creating minimum number of brush…"
00418f9b  
00418fa7  sub_40fa00(var_10)
00418fb4  int32_t ebp = 0
00418fb4  
00418fb8  if (data_2584ecc s> 0)
00418fbe      void* edi_1 = &data_256ee80
00418fbe      
00418fce      while (true)
00418fce          *(edi_1 + 0xc) = data_dde044
00418fd2          *(edi_1 + 0x10) = 0
00418fd9          char* eax_3 = sub_40e6a0(edi_1, "classname")
00418fd9          
00418fe3          if (eax_3 == 0)
0041901d              label_41901d:
0041901d              char* eax_6 = sub_40e6a0(edi_1, "model")
0041901d              
0041902c              if (eax_6 != 0 && *eax_6 == 0x2a)
0041903a                  sub_418e80(edi_1, sub_41e293(&eax_6[1]))
00418fe3          else
00418fe5              char* esi_1 = "worldspawn"
00418fea              int32_t eax_5
00418fea              
00418fea              while (true)
00418fea                  char edx_1 = *eax_3
00418fee                  char temp0_1 = *esi_1
00418fee                  bool c_1 = edx_1 u< temp0_1
00418fee                  
00418ff0                  if (edx_1 == temp0_1)
00418ff4                      if (edx_1 == 0)
0041900a                          eax_5 = 0
0041900c                          break
0041900c                      
00418ff6                      edx_1 = eax_3[1]
00418ffb                      char temp3_1 = esi_1[1]
00418ffb                      c_1 = edx_1 u< temp3_1
00418ffb                      
00418ffe                      if (edx_1 == temp3_1)
00419000                          eax_3 = &eax_3[2]
00419003                          esi_1 = &esi_1[2]
00419003                          
00419008                          if (edx_1 != 0)
00419008                              continue
00419008                          
0041900a                          eax_5 = 0
0041900c                          break
0041900c                  
0041900e                  bool c_2 = unimplemented  {sbb eax, eax}
00419010                  eax_5 = sbb.d(sbb.d(eax_3, eax_3, c_1), 0xffffffff, c_2)
00419010                  break
00419010              
00419015              if (eax_5 != 0)
00419015                  goto label_41901d
00419015              
0041903a              sub_418e80(edi_1, eax_5)
0041903a          
00419047          ebp += 1
00419048          edi_1 += 0x2c
00419048          
0041904d          if (ebp s>= data_2584ecc)
0041904d              break
0041904d  
00419058  int32_t var_10_3 = data_dde044
0041905e  sub_40fa00("%5d map brushes\n")
00419069  int32_t var_18_1 = data_4b4fe0
0041907a  return sub_40fa00("%5d clip brushes\n")

0041907b                                                                                   90 90 90 90 90                             .....

00419080    void sub_419080()

00419080  void* ecx
00419080  void* var_4 = ecx
00419082  int32_t i_1 = data_2584ef0
00419082  
0041908a  if (i_1 s> 0)
0041908f      int32_t* edx_1 = &data_586040
00419094      void* ebx_1 = &data_2585020
004190e7      int32_t i
004190e7      
004190e7      do
00419099          int32_t eax_1 = *ebx_1
004190a6          __builtin_memcpy(dest: &edx_1[-8], src: ebx_1 - 0x20, n: 0x20)
004190a8          int32_t ecx_1 = *(ebx_1 + 4)
004190ab          *edx_1 = eax_1
004190ad          edx_1[1] = ecx_1
004190b0          void* edi_2 = ebx_1 + 8
004190b3          int32_t j = 0xffffffff
004190b3          
004190b8          while (j != 0)
004190b8              bool cond:0_1 = 0 != *edi_2
004190b8              edi_2 += 1
004190b8              j -= 1
004190b8              
004190b8              if (not(cond:0_1))
004190b8                  break
004190b8          
004190ba          int32_t ecx_2 = not.d(j)
004190d0          int32_t esi_4
004190d0          int32_t edi_5
004190d0          edi_5, esi_4 =
004190d0              __builtin_memcpy(dest: &edx_1[2], src: edi_2 - ecx_2, n: ecx_2 u>> 2 << 2)
004190d4          ebx_1 += 0x4c
004190da          edx_1 = &edx_1[0x1b]
004190dd          __builtin_memcpy(dest: edi_5, src: esi_4, n: ecx_2 & 3)
004190df          edx_1[-9] = 0
004190e6          i = i_1
004190e6          i_1 -= 1
004190e7      while (i != 1)

004190ef                                               90                                                                 .

004190f0    int32_t sub_4190f0(int32_t* arg1)

004190f0  int32_t ecx
004190f0  int32_t var_4 = ecx
004190f9  int32_t edi = 1
004190fe  void* ecx_1 = arg1[0xc]
00419101  int32_t ebp = arg1[0xb]
00419109  int32_t result = *(ecx_1 + 0x14)
00419112  int32_t edx_1 = *(*(ecx_1 + 4) * 0x4c + &data_2585020)
00419112  
00419119  if (ebp s> 1)
0041911b      void* esi_1 = ecx_1 + 0x20
0041911b      
0041911e      while (true)
00419131          edx_1 |= *(*(esi_1 + 4) * 0x4c + &data_2585020)
00419131          
00419135          if (*(esi_1 + 0x14) != result)
00419152              int32_t var_18_1 = arg1[1]
00419153              int32_t var_1c_1 = *arg1
00419159              sub_410030("Entity %i, Brush %i: mixed face …")
0041916e              void* var_24_1 = *(esi_1 + 4) * 0x4c + &data_2585028
00419174              sub_410030("texture name = %s\n")
0041917d              break
0041917d          
00419137          edi += 1
00419138          esi_1 += 0x20
00419138          
0041913d          if (edi s>= ebp)
0041913f              var_4 = edx_1
00419143              break
00419143  
00419183  if ((edx_1.b & 0x30) != 0)
00419185      result |= 0x10000000
00419185      
0041918e      if ((result.b & 1) != 0)
00419193          return (result & 0xfffffffe) | 2
00419193  
0041919d  return result

0041919e                                                                                            90 90                                ..

004191a0    int32_t* sub_4191a0(void* arg1, float arg2)

004191a0  int32_t eax = data_dde044
004191a0  
004191b0  if (eax s>= 0x4000)
004191b7      sub_40f970("nummapbrushes == MAX_MAPFILE_BRU…")
004191bc      eax = data_dde044
004191bc  
004191e2  *(eax * 0x34 + &data_4b6030) = (data_255e0c0 << 5) + 0x1f9e0a0
004191f3  *(eax * 0x34 + &data_4b6000) = data_2584ecc - 1
00419208  char var_430[0x408]
00419208  char (* var_4d4)[0x408] = &var_430
00419209  *(eax * 0x34 + 0x4b6004) = data_dde044 - *(arg2 i+ 0xc)
00419214  *(eax * 0x34 + 0x4b6010) = 0xffffffff
0041921b  int32_t eax_5
0041921b  int16_t x87control
0041921b  eax_5, x87control = sub_413970(arg1, var_4d4)
00419225  void* var_4ec
00419225  
00419225  if (eax_5 != 0)
0041922b      while (true)
0041922b          void* esi_1 = &data_42cd58
00419230          char (* eax_6)[0x408] = &var_430
00419237          int32_t eax_8
00419237          void* ebx
00419237          
00419237          while (true)
00419237              char edx_4 = *eax_6
00419239              ebx.b = *esi_1
0041923d              bool c_1 = edx_4 u< ebx.b
0041923d              
0041923f              if (edx_4 == ebx.b)
00419243                  if (edx_4 == 0)
0041925b                      eax_8 = 0
0041925d                      break
0041925d                  
00419245                  edx_4 = (*eax_6)[1]
00419248                  ebx.b = *(esi_1 + 1)
0041924d                  c_1 = edx_4 u< ebx.b
0041924d                  
0041924f                  if (edx_4 == ebx.b)
00419251                      eax_6 = &(*eax_6)[2]
00419254                      esi_1 += 2
00419254                      
00419259                      if (edx_4 != 0)
00419259                          continue
00419259                      
0041925b                      eax_8 = 0
0041925d                      break
0041925d              
0041925f              bool c_2 = unimplemented  {sbb eax, eax}
00419261              eax_8 = sbb.d(sbb.d(eax_6, eax_6, c_1), 0xffffffff, c_2)
00419261              break
00419261          
00419266          if (eax_8 == 0)
00419266              break
00419266          
0041926c          int32_t ebx_1 = data_255e0c0
0041926c          
00419278          if (ebx_1 s>= 0x20000)
0041927f              sub_40f970("MAX_MAPFILE_BRUSHSIDES")
00419284              ebx_1 = data_255e0c0
00419284          
00419296          int32_t var_4c0_1 = 0
0041929e          void var_474
0041929e          void* esi_2 = &var_474
00419317          bool cond:0_1
00419317          
00419317          do
004192a8              if (var_4c0_1 != 0)
004192b7                  sub_413b00(arg1, U"(,")
004192b7              
004192bf              int32_t i_3 = 3
004192f4              int32_t i
004192f4              
004192f4              do
004192ee                  *esi_2 = __ftol(sub_413ee0(arg1, &var_430), sub_41e482(&var_430))
004192f0                  esi_2 += 4
004192f3                  i = i_3
004192f3                  i_3 -= 1
004192f4              while (i != 1)
00419303              sub_413b00(arg1, ")")
00419310              cond:0_1 = var_4c0_1 + 1 s< 3
00419313              var_4c0_1 += 1
00419317          while (cond:0_1)
00419329          sub_413ee0(arg1, &var_430)
0041932e          char (* edi_1)[0x408] = &var_430
00419335          int32_t i_1 = 0xffffffff
00419335          
0041933e          while (i_1 != 0)
0041933e              bool cond:1_1 = 0 != *edi_1
0041933e              edi_1 = &(*edi_1)[1]
0041933e              i_1 -= 1
0041933e              
0041933e              if (not(cond:1_1))
0041933e                  break
0041933e          
00419340          int32_t ecx_5 = not.d(i_1)
0041934d          char var_49c[0x20]
0041934d          int32_t esi_4
0041934d          int32_t edi_3
0041934d          edi_3, esi_4 =
0041934d              __builtin_memcpy(dest: &var_49c, src: edi_1 - ecx_5, n: ecx_5 u>> 2 << 2)
00419354          __builtin_memcpy(dest: edi_3, src: esi_4, n: ecx_5 & 3)
00419356          void* esi_6 = arg1
00419366          sub_413ee0(esi_6, &var_430)
00419383          long double x87_r7_2 = float.t(sub_41e208(&var_430))
00419387          char (* var_4e8_1)[0x408] = &var_430
00419388          var_4ec = esi_6
00419389          float var_4b0 = fconvert.s(x87_r7_2)
0041938d          sub_413ee0(var_4ec, var_4e8_1)
004193b0          float var_4ac_1 = fconvert.s(float.t(sub_41e208(&var_430)))
004193b4          sub_413ee0(esi_6, &var_430)
004193d7          float var_4a8_1 = fconvert.s(float.t(sub_41e208(&var_430)))
004193db          sub_413ee0(esi_6, &var_430)
004193ed          float var_4a4_1 = fconvert.s(sub_41e482(&var_430))
004193fa          sub_413ee0(esi_6, &var_430)
0041940f          float var_4a0_1 = fconvert.s(sub_41e482(&var_430))
00419429          int32_t eax_21 = sub_41c750(&var_49c) * 0x8c
00419438          int32_t var_478_1 = *(eax_21 + 0x470f84)
0041943c          *((ebx_1 << 5) + 0x1f9e0b4) = *(eax_21 + 0x470f88)
0041943f          int32_t eax_22 = *(eax_21 + 0x470f80)
00419445          int32_t var_47c_1 = eax_22
00419449          *((ebx_1 << 5) + 0x1f9e0b8) = eax_22
00419449          
00419463          if (sub_413f10(esi_6, 3, 0, &var_430) != 0)
00419473              char* var_4d4_7 = &var_430
00419474              int32_t var_4d8_6 = 0
00419476              int32_t var_4dc_4 = 3
00419479              int32_t var_28
00419479              *((ebx_1 << 5) + 0x1f9e0b4) = var_28
0041947c              sub_413bc0(esi_6, var_4dc_4, var_4d8_6, var_4d4_7)
00419488              int32_t var_47c_2 = var_28
0041948c              *((ebx_1 << 5) + 0x1f9e0b8) = var_28
00419496              char* var_4e4_3 = &var_430
00419497              int32_t var_4e8_3 = 0
00419499              var_4ec = 3
0041949c              sub_413bc0(esi_6, var_4ec, var_4e8_3, var_4e4_3)
004194ab              int32_t var_478_2 = var_28
004194ab          
004194af          int32_t ecx_14 = *((ebx_1 << 5) + 0x1f9e0b8)
004194af          
004194b5          if ((ecx_14.b & 0x30) != 0)
004194b7              *((ebx_1 << 5) + 0x1f9e0b4) |= 0x8000000
004194b7          
004194be          int32_t eax_25 = *((ebx_1 << 5) + 0x1f9e0b4)
004194be          
004194c6          if ((eax_25 & 0x30000) != 0)
004194cd              *((ebx_1 << 5) + 0x1f9e0b4) = eax_25 | 0x8000000
004194cd          
004194d7          if (data_279bacc != 0)
004194d9              *((ebx_1 << 5) + 0x1f9e0b4) &= 0xf7ffffff
004194d9          
004194e0          int32_t eax_28 = *((ebx_1 << 5) + 0x1f9e0b4)
004194e0          
004194e8          if ((eax_28 & 0x3007f) == 0)
004194ea              eax_28.b |= 1
004194ec              *((ebx_1 << 5) + 0x1f9e0b4) = eax_28
004194ec          
004194f2          if ((ecx_14:1.b & 3) != 0)
004194fa              *((ebx_1 << 5) + 0x1f9e0b4) = 0
00419501              *((ebx_1 << 5) + 0x1f9e0b8) = ecx_14 & 0xf7ffffff
00419501          
00419504          *((ebx_1 << 5) + 0x1f9e0bc) |= 8
00419517          void var_468
00419517          void var_45c
00419517          int32_t eax_29 = sub_414ba0(&var_474, &var_468, &var_45c)
00419517          
00419524          if (eax_29 != 0xffffffff)
00419543              ebx = nullptr
00419543              
00419547              if (*(eax * 0x34 + &data_4b602c) s> 0)
00419549                  int32_t* ecx_16 = *(eax * 0x34 + &data_4b6030)
00419549                  
0041954c                  while (true)
0041954c                      int32_t eax_32 = *ecx_16
00419550                      char* var_4dc_7
00419550                      
00419550                      if (eax_32 == eax_29)
0041956e                          int32_t var_4d4_10 = *(eax * 0x34 + 0x4b6004)
0041956f                          int32_t var_4d8_9 = *(eax * 0x34 + &data_4b6000)
00419570                          var_4dc_7 = "Entity %i, Brush %i: duplicate p…"
00419550                      else if (eax_32 == (eax_29 ^ 1))
0041957d                          int32_t var_4d4_11 = *(eax * 0x34 + 0x4b6004)
0041957e                          int32_t var_4d8_10 = *(eax * 0x34 + &data_4b6000)
0041957f                          var_4dc_7 = "Entity %i, Brush %i: mirrored pl…"
00419559                      else
0041955e                          ebx += 1
0041955f                          ecx_16 = &ecx_16[8]
0041955f                          
00419564                          if (ebx s>= *(eax * 0x34 + &data_4b602c))
00419564                              break
00419564                          
00419564                          continue
00419564                      
00419584                      sub_410030(var_4dc_7)
00419589                      break
00419589              
0041958c              int32_t eax_36 = *(eax * 0x34 + &data_4b602c)
0041958c              
00419591              if (ebx == eax_36)
0041959d                  int32_t* eax_38 = (eax_36 << 5) + *(eax * 0x34 + &data_4b6030)
004195aa                  float* var_4d4_12 = &data_430b50
004195af                  float* var_4d8_11 = &var_4b0
004195b7                  *eax_38 = eax_29
004195bf                  eax_38[1] =
004195bf                      sub_41c980(eax_29 * 0x1c + &data_239e0c0, var_4d8_11, var_4d4_12)
004195c2                  int32_t eax_41 = data_255e0c0
004195d2                  data_255e0c0 = eax_41 + 1
004195e6                  __builtin_memcpy(dest: eax_41 * 0x3c + &data_65e040, src: &var_4b0, 
004195e6                      n: 0x3c)
004195eb                  esi_6 = arg1
004195f3                  *(eax * 0x34 + &data_4b602c) += 1
00419524          else
0041952c              int32_t var_4d4_9 = *(eax * 0x34 + 0x4b6004)
0041952d              int32_t var_4d8_8 = *(eax * 0x34 + &data_4b6000)
00419533              sub_410030("Entity %i, Brush %i: plane with …")
00419533          
004195ff          int32_t eax_45
004195ff          eax_45, x87control = sub_413970(esi_6, &var_430)
004195ff          
00419609          if (eax_45 == 0)
00419609              break
00419609  
00419616  *(eax * 0x34 + 0x4b6008) = sub_4190f0(eax * 0x34 + &data_4b6000)
00419616  
00419623  if (sub_4154c0(eax * 0x34 + &data_4b6000) != 0)
0041962b      int32_t eax_49 = data_255e0c8 + 1
0041962d      data_255e0c8 = eax_49
00419632      *(eax * 0x34 + &data_4b602c) = 0
00419641      return eax_49
00419641  
00419642  int32_t eax_50 = data_279c334
00419642  
0041964b  if (eax_50 != 0)
0041966a      return sub_405050(eax * 0x34 + &data_4b6000, arg2, 1)
0041966a  
0041967a  if (data_279c328 != 0 && (*(eax * 0x34 + 0x4b6008) & 0x8000000) != 0)
0041967c      *(eax * 0x34 + &data_4b602c) = 0
00419689      return eax_50
00419689  
00419696  if (data_279babc != 0 && (*(eax * 0x34 + 0x4b6008) & 0x38) != 0)
00419698      *(eax * 0x34 + &data_4b602c) = 0
004196a5      return eax_50
004196a5  
004196a7  sub_415210(eax * 0x34 + &data_4b6000)
004196a7  
004196b7  if ((*(eax * 0x34 + 0x4b6008) & 0x30000) != 0)
004196bf      int32_t i_2 = 0
004196c2      data_255e0c4 += 1
004196c2      
004196cd      if (*(eax * 0x34 + &data_4b602c) s> 0)
004196cf          int32_t ecx_21 = 0
004196cf          
004196e4          do
004196d7              i_2 += 1
004196d8              *(ecx_21 + *(eax * 0x34 + &data_4b6030) + 4) = 0xffffffff
004196df              ecx_21 += 0x20
004196e4          while (i_2 s< *(eax * 0x34 + &data_4b602c))
004196e4  
004196ed  if ((*(eax * 0x34 + 0x4b6008) & 0x1000000) == 0)
004197f9      sub_414c80(eax * 0x34 + &data_4b6000)
0041980f      data_dde044 += 1
0041981c      *(arg2 i+ 0x10) += 1
00419826      return arg2
00419826  
004196fa  if (data_2584ecc == 1)
00419702      int32_t var_4d4_17 = *(eax * 0x34 + 0x4b6004)
00419703      int32_t var_4d8_15 = *(eax * 0x34 + &data_4b6000)
0041971b      return sub_40f970("Entity %i, Brush %i: origin brus…")
0041971b  
0041973c  float var_4bc = fconvert.s((fconvert.t(*(eax * 0x34 + 0x4b6020))
0041973c      + fconvert.t(*(eax * 0x34 + &data_4b6014))) * fconvert.t(0.5))
0041974a  float var_4b8_1 = fconvert.s(fconvert.t(fconvert.s(fconvert.t(*(eax * 0x34 + 0x4b6024))
0041974a      + fconvert.t(*(eax * 0x34 + 0x4b6018)))) * fconvert.t(0.5))
00419752  long double x87_r7_13 = fconvert.t(fconvert.s(fconvert.t(*(eax * 0x34 + 0x4b6028))
00419752      + fconvert.t(*(eax * 0x34 + 0x4b601c)))) * fconvert.t(0.5)
00419758  float var_4b4_1 = fconvert.s(x87_r7_13)
0041975c  int32_t eax_55
0041975c  int16_t x87control_2
0041975c  eax_55, x87control_2 = __ftol(x87control, x87_r7_13)
00419765  int32_t var_4d4_18 = eax_55
00419766  int32_t eax_56
00419766  int16_t x87control_3
00419766  eax_56, x87control_3 = __ftol(x87control_2, fconvert.t(var_4b8_1))
0041976f  int32_t var_4d8_16 = eax_56
00419775  int32_t var_4dc_11 = __ftol(x87control_3, fconvert.t(var_4bc))
00419783  void var_450
00419783  sub_41e430(&var_450, "%i %i %i")
00419788  int32_t eax_58 = *(eax * 0x34 + &data_4b6000)
00419792  void* var_4e8_4 = &var_450
00419793  var_4ec = "origin"
004197a6  sub_40e600(eax_58 * 0x2c + &data_256ee80, var_4ec, var_4e8_4)
004197bc  *(*(eax * 0x34 + &data_4b6000) * 0x2c + &data_256ee80) = fconvert.s(fconvert.t(var_4bc))
004197d0  *(*(eax * 0x34 + &data_4b6000) * 0x2c + &data_256ee84) = fconvert.s(fconvert.t(var_4b8_1))
004197d7  int32_t eax_63 = *(eax * 0x34 + &data_4b6000)
004197e4  *(eax_63 * 0x2c + &data_256ee88) = fconvert.s(fconvert.t(var_4b4_1))
004197eb  *(eax * 0x34 + &data_4b602c) = 0
004197f7  return eax_63

00419827                       90 90 90 90 90 90 90 90 90                                                         .........

00419830    int32_t sub_419830(void* arg1)

0041983a  int32_t eax = data_256ee90
00419840  int32_t ebx = *(arg1 + 0x10)
0041984d  int32_t ebp_1 = ebx * 0x34
00419851  void* eax_1 = sub_4105b0(ebp_1)
00419873  int32_t esi_3
00419873  int32_t edi_1
00419873  edi_1, esi_3 = __builtin_memcpy(dest: eax_1, src: *(arg1 + 0xc) * 0x34 + &data_4b6000, 
00419873      n: ebp_1 u>> 2 << 2)
0041987a  __builtin_memcpy(dest: edi_1, src: esi_3, n: ebp_1 & 3)
0041988c  int32_t eax_5 = (eax + ebx) * 0x34
004198b3  sub_41f5a0(eax_5 + &data_4b6000, eax * 0x34 + &data_4b6000, data_dde044 * 0x34 - eax_5)
004198c5  int32_t esi_5
004198c5  int32_t edi_3
004198c5  edi_3, esi_5 =
004198c5      __builtin_memcpy(dest: eax * 0x34 + &data_4b6000, src: eax_1, n: ebp_1 u>> 2 << 2)
004198cf  __builtin_memcpy(dest: edi_3, src: esi_5, n: ebp_1 & 3)
004198d9  data_256ee90 += ebx
004198df  int32_t ecx_17 = data_2584ecc
004198df  
004198e8  if (ecx_17 s> 1)
004198ea      void* eax_7 = &data_256eeb8
004198ef      int32_t i_1 = ecx_17 - 1
004198fb      int32_t i
004198fb      
004198fb      do
004198f0          int32_t ebp_2 = *eax_7
004198f2          eax_7 += 0x2c
004198f7          i = i_1
004198f7          i_1 -= 1
004198f8          *(eax_7 - 0x2c) = ebp_2 + ebx
004198fb      while (i != 1)
004198fb  
004198fe  int32_t result = sub_41e29e(eax_1)
0041990d  *(arg1 + 0x10) = 0
00419918  return result

00419919                                                                             90 90 90 90 90 90 90                           .......

00419920    int32_t sub_419920(void* arg1)

00419939  char var_430[0x430]
00419939  int32_t result = sub_413970(arg1, &var_430)
00419939  
00419943  if (result == 0)
0041994e      return result
0041994e  
0041994f  void* esi = &data_42cdc4
00419954  char (* eax)[0x430] = &var_430
0041995b  int32_t eax_2
0041995b  
0041995b  while (true)
0041995b      char edx_1 = *eax
0041995f      char temp0_1 = *esi
0041995f      bool c_1 = edx_1 u< temp0_1
0041995f      
00419961      if (edx_1 == temp0_1)
00419965          if (edx_1 == 0)
0041997b              eax_2 = 0
0041997d              break
0041997d          
00419967          edx_1 = (*eax)[1]
0041996c          char temp3_1 = *(esi + 1)
0041996c          c_1 = edx_1 u< temp3_1
0041996c          
0041996f          if (edx_1 == temp3_1)
00419971              eax = &(*eax)[2]
00419974              esi += 2
00419974              
00419979              if (edx_1 != 0)
00419979                  continue
00419979              
0041997b              eax_2 = 0
0041997d              break
0041997d      
0041997f      bool c_2 = unimplemented  {sbb eax, eax}
00419981      eax_2 = sbb.d(sbb.d(eax, eax, c_1), 0xffffffff, c_2)
00419981      break
00419981  
00419986  if (eax_2 != 0)
0041998d      sub_40f970("ParseEntity: { not found")
0041998d  
00419995  int32_t eax_3 = data_2584ecc
00419995  
0041999f  if (eax_3 == 0x800)
004199a6      sub_40f970("num_entities == MAX_MAP_ENTITIES")
004199ab      eax_3 = data_2584ecc
004199ab  
004199bb  data_2584ecc = eax_3 + 1
004199d0  __builtin_memset(s: eax_3 * 0x2c + &data_256ee80, c: 0, n: 0x2c)
004199d2  int32_t eax_5 = data_dde044
004199d7  (&data_256ee90)[eax_3 * 0xb] = 0
004199de  (&data_256ee8c)[eax_3 * 0xb] = eax_5
004199de  
004199ea  while (true)
004199f4      if (sub_413970(arg1, &var_430) == 0)
004199fb          sub_40f970("ParseEntity: EOF without closing…")
004199fb      
00419a03      void* esi_1 = &data_42cd58
00419a08      char (* eax_7)[0x430] = &var_430
00419a0f      int32_t eax_9
00419a0f      char edx_3
00419a0f      
00419a0f      while (true)
00419a0f          edx_3 = *eax_7
00419a13          char temp4_1 = *esi_1
00419a13          bool c_3 = edx_3 u< temp4_1
00419a13          
00419a15          if (edx_3 == temp4_1)
00419a19              if (edx_3 == 0)
00419a2f                  eax_9 = 0
00419a31                  break
00419a31              
00419a1b              edx_3 = (*eax_7)[1]
00419a20              char temp7_1 = *(esi_1 + 1)
00419a20              c_3 = edx_3 u< temp7_1
00419a20              
00419a23              if (edx_3 == temp7_1)
00419a25                  eax_7 = &(*eax_7)[2]
00419a28                  esi_1 += 2
00419a28                  
00419a2d                  if (edx_3 != 0)
00419a2d                      continue
00419a2d                  
00419a2f                  eax_9 = 0
00419a31                  break
00419a31          
00419a33          bool c_4 = unimplemented  {sbb eax, eax}
00419a35          eax_9 = sbb.d(sbb.d(eax_7, eax_7, c_3), 0xffffffff, c_4)
00419a35          break
00419a35      
00419a3a      if (eax_9 == 0)
00419a3a          break
00419a3a      
00419a3c      void* esi_2 = &data_42cdc4
00419a41      char (* eax_10)[0x430] = &var_430
00419a48      int32_t eax_12
00419a48      
00419a48      while (true)
00419a48          edx_3 = *eax_10
00419a4c          char temp10_1 = *esi_2
00419a4c          bool c_5 = edx_3 u< temp10_1
00419a4c          
00419a4e          if (edx_3 == temp10_1)
00419a52              if (edx_3 == 0)
00419a68                  eax_12 = 0
00419a6a                  break
00419a6a              
00419a54              edx_3 = (*eax_10)[1]
00419a59              char temp14_1 = *(esi_2 + 1)
00419a59              c_5 = edx_3 u< temp14_1
00419a59              
00419a5c              if (edx_3 == temp14_1)
00419a5e                  eax_10 = &(*eax_10)[2]
00419a61                  esi_2 += 2
00419a61                  
00419a66                  if (edx_3 != 0)
00419a66                      continue
00419a66                  
00419a68                  eax_12 = 0
00419a6a                  break
00419a6a          
00419a6c          bool c_6 = unimplemented  {sbb eax, eax}
00419a6e          eax_12 = sbb.d(sbb.d(eax_10, eax_10, c_5), 0xffffffff, c_6)
00419a6e          break
00419a6e      
00419a73      if (eax_12 != 0)
00419a85          sub_413f90(arg1)
00419a8b          void* eax_13 = sub_40e1c0(arg1)
00419a96          *eax_13 = *(eax_3 * 0x2c + &data_256ee94)
00419a98          *(eax_3 * 0x2c + &data_256ee94) = eax_13
00419a73      else
00419a77          sub_4191a0(arg1, eax_3 * 0x2c + &data_256ee80)
00419a77  
00419aa7  sub_40e730(eax_3 * 0x2c + &data_256ee80, "origin", eax_3 * 0x2c + &data_256ee80)
00419aac  long double x87_r7 = fconvert.t(*(eax_3 * 0x2c + &data_256ee80))
00419aaf  long double temp8 = fconvert.t(0f)
00419aaf  x87_r7 - temp8
00419abd  void* j
00419abd  
00419abd  if ((((x87_r7 < temp8 ? 1 : 0) << 8 | (is_unordered.t(x87_r7, temp8) ? 1 : 0) << 0xa
00419abd          | (x87_r7 == temp8 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
00419ae6      label_419ae6:
00419ae6      int32_t i = 0
00419aea      int32_t i_1 = 0
00419aea      
00419aee      if ((&data_256ee90)[eax_3 * 0xb] s> 0)
00419bce          do
00419af7              j = nullptr
00419afe              int32_t eax_18 = ((&data_256ee8c)[eax_3 * 0xb] + i) * 0xd
00419afe              
00419b11              if (*((eax_18 << 2) + &data_4b602c) s> 0)
00419b17                  int32_t var_4bc_1 = 0
00419b17                  
00419bb1                  do
00419b22                      int32_t* esi_4 = *((eax_18 << 2) + &data_4b6030) + var_4bc_1
00419b2f                      int32_t eax_23 = *esi_4 * 0x1c
00419b61                      float var_4d0_5 = fconvert.s(fconvert.t(*(eax_23 + &data_239e0cc)) - (
00419b61                          fconvert.t(*(eax_23 + &data_239e0c8))
00419b61                          * fconvert.t(*(eax_3 * 0x2c + &data_256ee88))
00419b61                          + fconvert.t(*(eax_23 + &data_239e0c4))
00419b61                          * fconvert.t(*(eax_3 * 0x2c + &data_256ee84))
00419b61                          + fconvert.t(*(eax_3 * 0x2c + &data_256ee80))
00419b61                          * fconvert.t(*(eax_23 + &data_239e0c0))))
00419b63                      int32_t eax_24 = sub_414ae0(eax_23 + &data_239e0c0)
00419b71                      *esi_4 = eax_24
00419ba1                      esi_4[1] = sub_41c980(eax_24 * 0x1c + &data_239e0c0, 
00419ba1                          ((esi_4 - 0x1f9e0a0) s>> 5) * 0x3c + &data_65e040, 
00419ba1                          eax_3 * 0x2c + &data_256ee80)
00419ba7                      j += 1
00419bad                      var_4bc_1 += 0x20
00419bb1                  while (j s< *((eax_18 << 2) + &data_4b602c))
00419bb1                  
00419bb7                  i = i_1
00419bb7              
00419bbc              sub_415210((eax_18 << 2) + &data_4b6000)
00419bc7              i += 1
00419bca              i_1 = i
00419bce          while (i s< (&data_256ee90)[eax_3 * 0xb])
00419abd  else
00419abf      long double x87_r7_1 = fconvert.t(*(eax_3 * 0x2c + &data_256ee84))
00419ac2      long double temp9_1 = fconvert.t(0f)
00419ac2      x87_r7_1 - temp9_1
00419ac2      
00419acd      if ((((x87_r7_1 < temp9_1 ? 1 : 0) << 8
00419acd              | (is_unordered.t(x87_r7_1, temp9_1) ? 1 : 0) << 0xa
00419acd              | (x87_r7_1 == temp9_1 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
00419acd          goto label_419ae6
00419acd      
00419acf      long double x87_r7_2 = fconvert.t(*(eax_3 * 0x2c + &data_256ee88))
00419ad2      long double temp11_1 = fconvert.t(0f)
00419ad2      x87_r7_2 - temp11_1
00419ad2      
00419add      if ((((x87_r7_2 < temp11_1 ? 1 : 0) << 8
00419add              | (is_unordered.t(x87_r7_2, temp11_1) ? 1 : 0) << 0xa
00419add              | (x87_r7_2 == temp11_1 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
00419add          goto label_419ae6
00419add  
00419be2  char* esi_5 = sub_40e6a0(eax_3 * 0x2c + &data_256ee80, "classname")
00419be4  char* ecx_16 = "func_group"
00419bea  int32_t eax_30
00419bea  
00419bea  while (true)
00419bea      char edx_8 = *ecx_16
00419bec      j.b = *esi_5
00419bee      char* eax_28
00419bee      eax_28.b = edx_8
00419bf0      bool c_7 = edx_8 u< j.b
00419bf0      
00419bf2      if (edx_8 == j.b)
00419bf6          if (eax_28.b == 0)
00419c0e              eax_30 = 0
00419c10              break
00419c10          
00419bf8          edx_8 = ecx_16[1]
00419bfb          j.b = esi_5[1]
00419bfe          eax_28.b = edx_8
00419c00          c_7 = edx_8 u< j.b
00419c00          
00419c02          if (edx_8 == j.b)
00419c04              ecx_16 = &ecx_16[2]
00419c07              esi_5 = &esi_5[2]
00419c07              
00419c0c              if (eax_28.b != 0)
00419c0c                  continue
00419c0c              
00419c0e              eax_30 = 0
00419c10              break
00419c10      
00419c12      bool c_8 = unimplemented  {sbb eax, eax}
00419c14      eax_30 = sbb.d(sbb.d(eax_28, eax_28, c_7), 0xffffffff, c_8)
00419c14      break
00419c14  
00419c19  if (eax_30 == 0)
00419c1c      sub_419830(eax_3 * 0x2c + &data_256ee80)
00419c24      (&data_256ee90)[eax_3 * 0xb] = 0
00419c39      return 1
00419c39  
00419c48  char* esi_6 = sub_40e6a0(eax_3 * 0x2c + &data_256ee80, "classname")
00419c4a  char* ecx_17 = "func_areaportal"
00419c4f  int32_t eax_34
00419c4f  
00419c4f  while (true)
00419c4f      char edx_9 = *ecx_17
00419c51      j.b = *esi_6
00419c53      char* eax_32
00419c53      eax_32.b = edx_9
00419c55      bool c_9 = edx_9 u< j.b
00419c55      
00419c57      if (edx_9 == j.b)
00419c5b          if (eax_32.b == 0)
00419c73              eax_34 = 0
00419c75              break
00419c75          
00419c5d          edx_9 = ecx_17[1]
00419c60          j.b = esi_6[1]
00419c63          eax_32.b = edx_9
00419c65          c_9 = edx_9 u< j.b
00419c65          
00419c67          if (edx_9 == j.b)
00419c69              ecx_17 = &ecx_17[2]
00419c6c              esi_6 = &esi_6[2]
00419c6c              
00419c71              if (eax_32.b != 0)
00419c71                  continue
00419c71              
00419c73              eax_34 = 0
00419c75              break
00419c75      
00419c77      bool c_10 = unimplemented  {sbb eax, eax}
00419c79      eax_34 = sbb.d(sbb.d(eax_32, eax_32, c_9), 0xffffffff, c_10)
00419c79      break
00419c79  
00419c7e  if (eax_34 == 0)
00419c84      if ((&data_256ee90)[eax_3 * 0xb] != 1)
00419c8c          int32_t __saved_edi_2 = data_2584ecc - 1
00419c92          sub_40f970("Entity %i: func_areaportal can o…")
00419c92      
00419ca9      *(data_dde044 * 0x34 + &data_4b5fd4) = 0x8000
00419cb9      int32_t eax_39 = data_255e0dc + 1
00419cba      data_255e0dc = eax_39
00419cbf      *(eax_3 * 0x2c + &data_256ee98) = eax_39
00419cc7      int32_t __saved_edi_3 = data_255e0dc
00419cce      void var_4b0
00419cce      sub_41e430(&var_4b0, &data_42e7ec)
00419cde      sub_40e600(eax_3 * 0x2c + &data_256ee80, "style", &var_4b0)
00419ce4      sub_419830(eax_3 * 0x2c + &data_256ee80)
00419ce4  
00419cfa  return 1

00419cfb                                                                                   90 90 90 90 90                             .....

00419d00    void sub_419d00(int32_t* arg1)

00419d08  sub_410030("-- Q2_LoadMapFile --\n")
00419d0d  data_65e020 = 2
00419d17  sub_4162e0()
00419d20  int32_t i_1 = 0
00419d25  int32_t* eax = sub_414020(arg1, nullptr, nullptr)
00419d25  
00419d31  if (eax == 0)
00419d33      int32_t* var_10_1 = arg1
00419d39      sub_410030("couldn't open %s\n")
00419d44      return 
00419d44  
00419d48  sub_414010(eax, 0x1c)
00419d4e  data_255e0c0 = 0
00419d54  data_2584ecc = 0
00419d54  
00419d64  if (sub_419920(eax) != 0)
00419d71      int32_t i
00419d71      
00419d71      do
00419d67          i = sub_419920(eax)
00419d71      while (i != 0)
00419d71  
00419d7d  sub_4104f0(&data_255e0f0, &data_255e0d0)
00419d7d  
00419d8c  if (data_256ee90 s> 0)
00419d8e      void* esi_1 = &data_4b6014
00419d8e      
00419dd3      do
00419d93          long double x87_r7_1 = fconvert.t(*esi_1)
00419d95          long double temp0_1 = fconvert.t(4096f)
00419d95          x87_r7_1 - temp0_1
00419d9b          int32_t eax_2
00419d9b          eax_2.w = (x87_r7_1 < temp0_1 ? 1 : 0) << 8
00419d9b              | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
00419d9b              | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe
00419d9b          
00419da0          if ((eax_2:1.b & 0x41) != 0)
00419dad              sub_410520(esi_1, &data_255e0f0, &data_255e0d0)
00419dc0              sub_410520(esi_1 + 0xc, &data_255e0f0, &data_255e0d0)
00419dc0          
00419dcd          i_1 += 1
00419dce          esi_1 += 0x34
00419dd3      while (i_1 s< data_256ee90)
00419dd3  
00419dd5  sub_4162b0()
00419ddb  sub_4105e0(eax)
00419de3  sub_419080()

00419dec                                      90 90 90 90                                                              ....

00419df0    int32_t sub_419df0(int32_t arg1, int32_t arg2)

00419e02  int32_t result = arg1 * 7
00419e04  void* edx = data_2584e94 + (result << 2)
00419e07  int32_t ecx = 0
00419e07  
00419e0d  if (*(edx + 0x1a) u> 0)
00419e10      int32_t ebx_1 = data_255ee4c
00419e10      
00419e43      do
00419e1e          int32_t eax_1
00419e1e          eax_1.w = *(edx + 0x18)
00419e26          int32_t ebp_2 = eax_1 + ecx
00419e28          ecx += 1
00419e29          int32_t eax_2
00419e29          eax_2.w = *(ebx_1 + (ebp_2 << 1))
00419e2d          *((eax_2 << 2) + &data_493fa0) = arg2
00419e34          *((eax_2 << 2) + &data_4a3fc0) = arg1
00419e3d          result.w = *(edx + 0x1a)
00419e43      while (ecx s< result)
00419e43  
00419e49  return result

00419e4a                                90 90 90 90 90 90                                                            ......

00419e50    int32_t sub_419e50(int32_t arg1)

00419e59  *data_4a3fa0 = arg1
00419e66  int32_t result = data_4a3fa0 + 4
00419e69  int32_t edx_1 = data_430b64 + 1
00419e6f  data_4a3fa0 = result
00419e74  data_430b64 = edx_1
00419e74  
00419e7a  if (result u>= &data_4b4fe0)
00419e81      result = sub_40f970("Q2_PushNodeStack: stack overflow…")
00419e81  
00419e87  return result

00419e88                          90 90 90 90 90 90 90 90                                                          ........

00419e90    int32_t sub_419e90()

00419e90  int32_t eax_3 = data_4a3fa0
00419e90  
00419e9a  if (eax_3 u<= 0x4b3fe0)
00419e9f      return 0xffffffff
00419e9f  
00419ea9  int32_t ecx_1 = data_430b64 - 1
00419eaa  data_4a3fa0 = eax_3 - 4
00419eaf  data_430b64 = ecx_1
00419eb7  return *(eax_3 - 4)

00419eb8                                                                          90 90 90 90 90 90 90 90                          ........

00419ec0    int32_t sub_419ec0(void* arg1)

00419ec3  sub_41a7e0()
00419edb  int32_t i = 0
00419edd  int32_t j = *(*(arg1 + 0x24) * 0x30 + data_2584ec0 + 0x24)
00419f65  int32_t result
00419f65  
00419f65  do
00419ee3      if (j s>= 0)
00419f49          sub_419e50(j)
00419f4e          result = data_2584ebc
00419f5f          j = *(result + j * 0x1c + 4)
00419ee3      else
00419eef          sub_419df0(0xffffffff - j, *(arg1 + 0x24))
00419ef7          result = sub_419e90()
00419efc          i = result
00419efc          
00419f00          if (i s< 0)
00419f00              break
00419f00          
00419f15          while (*(data_2584ebc + i * 0x1c + 4) != j)
00419f17              j = i
00419f19              result = sub_419e90()
00419f1e              i = result
00419f1e              
00419f22              if (i s< 0)
00419f6e                  return result
00419f6e          
00419f28          if (i s< 0)
00419f28              break
00419f28          
00419f2b          sub_419e50(i)
00419f40          result = i * 7
00419f42          j = *(data_2584ebc + (result << 2) + 8)
00419f65  while (i s>= 0)
00419f65  
00419f6e  return result

00419f6f                                               90                                                                 .

00419f70    int32_t* sub_419f70(int32_t* arg1, float arg2)

00419f70  int32_t eax = data_dde044
00419f70  
00419f7d  if (eax s>= 0x4000)
00419f84      sub_40f970("nummapbrushes >= MAX_MAPFILE_BRU…")
00419f89      eax = data_dde044
00419f89  
00419f96  float ebp = arg2
00419fba  int32_t* ebx = arg1
00419fbe  *(eax * 0x34 + &data_4b6030) = (data_255e0c0 << 5) + 0x1f9e0a0
00419fd5  *(eax * 0x34 + &data_4b6000) = (ebp i- &data_256ee80) s/ 0x2c
00419fe7  int32_t edi_1 = 0
00419fe9  *(eax * 0x34 + 0x4b6004) = data_dde044 - *(ebp i+ 0xc)
00419ff4  int32_t var_8 = 0
00419ff8  int32_t eax_5
00419ff8  int32_t edx_7
00419ff8  edx_7:eax_5 = muls.dp.d(0x2aaaaaab, ebx - data_261d000)
00419ffa  int32_t edx_8 = edx_7 s>> 1
0041a00a  *(eax * 0x34 + 0x4b6010) = *(((edx_8 + (edx_8 u>> 0x1f)) << 2) + &data_4a3fc0)
0041a00a  
0041a012  if (ebx[1] s> 0)
0041a027      while (true)
0041a027          int16_t* ebp_1 = data_2584ee0 + ((*ebx + edi_1) << 2)
0041a02a          int32_t eax_10 = data_255e0c0
0041a02a          
0041a038          if (eax_10 s>= 0x20000)
0041a03f              sub_40f970("MAX_MAPFILE_BRUSHSIDES")
0041a044              eax_10 = data_255e0c0
0041a044          
0041a051          int32_t edx_11
0041a051          edx_11.b = *(*ebx + edi_1 + 0x255ee60)
0041a051          
0041a05f          if (edx_11.b == 0)
0041a067              *((eax_10 << 5) + 0x1f9e0bc) &= 0xfff7
0041a05f          else
0041a061              *((eax_10 << 5) + 0x1f9e0bc) |= 8
0041a061          
0041a070          *((eax_10 << 5) + 0x1f9e0b4) = ebx[2]
0041a073          int32_t ecx_8
0041a073          ecx_8.w = ebp_1[1]
0041a073          
0041a07a          if (ecx_8.w s>= 0)
0041a095              *((eax_10 << 5) + 0x1f9e0b8) = *(sx.d(ecx_8.w) * 0x4c + &data_2585020)
0041a07a          else
0041a07c              *((eax_10 << 5) + 0x1f9e0b8) = 0
0041a07c          
0041a098          int32_t edx_15 = *((eax_10 << 5) + 0x1f9e0b8)
0041a098          
0041a09e          if ((edx_15.b & 0x30) != 0)
0041a0a0              *((eax_10 << 5) + 0x1f9e0b4) |= 0x8000000
0041a0a0          
0041a0a7          int32_t ecx_11 = *((eax_10 << 5) + 0x1f9e0b4)
0041a0a7          
0041a0b0          if ((ecx_11 & 0x30000) != 0)
0041a0b8              *((eax_10 << 5) + 0x1f9e0b4) = ecx_11 | 0x8000000
0041a0b8          
0041a0c3          if (data_279bacc != 0)
0041a0c5              *((eax_10 << 5) + 0x1f9e0b4) &= 0xf7ffffff
0041a0c5          
0041a0cc          int32_t ecx_14 = *((eax_10 << 5) + 0x1f9e0b4)
0041a0cc          
0041a0d5          if ((ecx_14 & 0x3007f) == 0)
0041a0da              *((eax_10 << 5) + 0x1f9e0b4) = ecx_14 | 1
0041a0da          
0041a0e0          if ((edx_15:1.b & 3) != 0)
0041a0e8              *((eax_10 << 5) + 0x1f9e0b4) = 0
0041a0ef              *((eax_10 << 5) + 0x1f9e0b8) = edx_15 & 0xf7ffffff
0041a0ef          
0041a0f2          int32_t ecx_16 = data_261d008
0041a0fa          int32_t eax_13
0041a0fa          eax_13.w = *ebp_1
0041a0fe          int32_t eax_14 = eax_13 * 5
0041a108          int32_t var_1c_1 = *(ecx_16 + (eax_14 << 2) + 0xc)
0041a10a          int32_t eax_16 = sub_414ae0(ecx_16 + (eax_14 << 2))
0041a111          int32_t eax_17 = *(eax * 0x34 + &data_4b602c)
0041a117          int32_t ebp_2 = 0
0041a117          
0041a11b          if (eax_17 s> 0)
0041a11d              int32_t* edx_18 = *(eax * 0x34 + &data_4b6030)
0041a11d              
0041a139              do
0041a120                  int32_t ecx_17 = *edx_18
0041a120                  
0041a124                  if (ecx_17 == eax_16)
0041a142                      int32_t var_1c_2 = *(eax * 0x34 + 0x4b6004)
0041a143                      int32_t var_20_2 = *(eax * 0x34 + &data_4b6000)
0041a149                      sub_410030("Entity %i, Brush %i: duplicate p…")
0041a151                      break
0041a151                  
0041a12d                  if (ecx_17 == (eax_16 ^ 1))
0041a158                      int32_t var_1c_3 = *(eax * 0x34 + 0x4b6004)
0041a159                      int32_t var_20_3 = *(eax * 0x34 + &data_4b6000)
0041a15f                      sub_410030("Entity %i, Brush %i: mirrored pl…")
0041a164                      ebx = arg1
0041a168                      break
0041a168                  
0041a12f                  ebx = arg1
0041a133                  ebp_2 += 1
0041a134                  edx_18 = &edx_18[8]
0041a139              while (ebp_2 s< eax_17)
0041a139          
0041a16b          int32_t eax_20 = *(eax * 0x34 + &data_4b602c)
0041a16b          
0041a170          if (ebp_2 == eax_20)
0041a17c              int32_t* eax_22 = (eax_20 << 5) + *(eax * 0x34 + &data_4b6030)
0041a17e              *eax_22 = eax_16
0041a180              int16_t* ecx_19
0041a180              ecx_19.w = ebp_1[1]
0041a180              
0041a187              if (ecx_19.w s>= 0)
0041a195                  eax_22[1] = sx.d(ecx_19.w)
0041a187              else
0041a189                  eax_22[1] = 0
0041a189              
0041a19f              data_255e0c0 += 1
0041a1a9              *(eax * 0x34 + &data_4b602c) += 1
0041a1a9          
0041a1b4          bool cond:1_1 = var_8 + 1 s< ebx[1]
0041a1b6          var_8 += 1
0041a1b6          
0041a1ba          if (not(cond:1_1))
0041a1ba              break
0041a1ba          
0041a01a          edi_1 = var_8
0041a01a      
0041a1c0      ebp = arg2
0041a1c0  
0041a1c8  *(eax * 0x34 + 0x4b6008) = ebx[2]
0041a1cb  sub_4190f0(eax * 0x34 + &data_4b6000)
0041a1cb  
0041a1db  if (sub_4154c0(eax * 0x34 + &data_4b6000) != 0)
0041a1e3      int32_t eax_30 = data_255e0c8 + 1
0041a1e4      data_255e0c8 = eax_30
0041a1e9      *(eax * 0x34 + &data_4b602c) = 0
0041a1f6      return eax_30
0041a1f6  
0041a1f7  int32_t eax_31 = data_279c334
0041a1f7  
0041a200  if (eax_31 != 0)
0041a214      return sub_405050(eax * 0x34 + &data_4b6000, ebp, 0)
0041a214  
0041a224  if (data_279c328 != 0 && (*(eax * 0x34 + 0x4b6008) & 0x8000000) != 0)
0041a226      *(eax * 0x34 + &data_4b602c) = 0
0041a230      return eax_31
0041a230  
0041a23d  if (data_279babc != 0 && (*(eax * 0x34 + 0x4b6008) & 0x38) != 0)
0041a23f      *(eax * 0x34 + &data_4b602c) = 0
0041a249      return eax_31
0041a249  
0041a24b  sub_415210(eax * 0x34 + &data_4b6000)
0041a251  sub_4153c0(eax * 0x34 + &data_4b6000)
0041a251  
0041a261  if ((*(eax * 0x34 + 0x4b6008) & 0x30000) != 0)
0041a269      int32_t i = 0
0041a26c      data_255e0c4 += 1
0041a26c      
0041a277      if (*(eax * 0x34 + &data_4b602c) s> 0)
0041a279          int32_t ecx_24 = 0
0041a279          
0041a28e          do
0041a281              i += 1
0041a282              *(ecx_24 + *(eax * 0x34 + &data_4b6030) + 4) = 0xffffffff
0041a289              ecx_24 += 0x20
0041a28e          while (i s< *(eax * 0x34 + &data_4b602c))
0041a28e  
0041a299  data_dde044 += 1
0041a2a2  int32_t eax_35 = *(ebp i+ 0x10) + 1
0041a2a3  *(ebp i+ 0x10) = eax_35
0041a2ab  return eax_35

0041a2ac                                      90 90 90 90                                                              ....

0041a2b0    int32_t sub_41a2b0(float arg1)

0041a2b7  sub_419ec0(arg1)
0041a2bc  int32_t result = data_2584ec8
0041a2c4  int32_t edi = 0
0041a2c4  
0041a2c8  if (result s> 0)
0041a2cc      void* esi_1 = nullptr
0041a2ce      void* ebx_1 = &data_493fa0
0041a2ce      
0041a2fd      do
0041a2da          if (*ebx_1 == *(arg1 i+ 0x24))
0041a2e7              sub_419f70(esi_1 + data_261d000, arg1)
0041a2e7          
0041a2ef          result = data_2584ec8
0041a2f4          edi += 1
0041a2f5          ebx_1 += 4
0041a2f8          esi_1 += 0xc
0041a2fd      while (edi s< result)
0041a2fd  
0041a303  return result

0041a304              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0041a310    int32_t sub_41a310(int32_t arg1)

0041a32e  (&data_256ee8c)[arg1 * 0xb] = data_dde044
0041a331  (&data_256ee90)[arg1 * 0xb] = 0
0041a338  *(arg1 * 0x2c + 0x256eea4) = 0xffffffff
0041a33f  char* eax_1 = sub_40e6a0(arg1 * 0x2c + &data_256ee80, "model")
0041a33f  
0041a34b  if (eax_1 != 0)
0041a34e      char* edi_1 = eax_1
0041a350      int32_t i = 0xffffffff
0041a350      
0041a355      while (i != 0)
0041a355          bool cond:0_1 = 0 != *edi_1
0041a355          edi_1 = &edi_1[1]
0041a355          i -= 1
0041a355          
0041a355          if (not(cond:0_1))
0041a355              break
0041a355      
0041a35b      if (not.d(i) != 1)
0041a360          if (*eax_1 != 0x2a)
0041a367              sub_40f970("Q2_ParseBSPEntity: model number …")
0041a367          
0041a379          *(arg1 * 0x2c + 0x256eea4) = sub_41e293(&eax_1[1])
0041a379  
0041a383  sub_40e730(arg1 * 0x2c + &data_256ee80, "origin", arg1 * 0x2c + &data_256ee80)
0041a396  char* esi_2 = sub_40e6a0(arg1 * 0x2c + &data_256ee80, "classname")
0041a398  char* ecx_3 = "worldspawn"
0041a39d  int32_t eax_5
0041a39d  
0041a39d  while (true)
0041a39d      char edx_1 = *ecx_3
0041a39f      char* eax_3
0041a39f      eax_3.b = edx_1
0041a3a1      char temp0_1 = *esi_2
0041a3a1      bool c_1 = edx_1 u< temp0_1
0041a3a1      
0041a3a3      if (edx_1 == temp0_1)
0041a3a7          if (eax_3.b == 0)
0041a3bd              eax_5 = 0
0041a3bf              break
0041a3bf          
0041a3a9          edx_1 = ecx_3[1]
0041a3ac          eax_3.b = edx_1
0041a3ae          char temp4_1 = esi_2[1]
0041a3ae          c_1 = edx_1 u< temp4_1
0041a3ae          
0041a3b1          if (edx_1 == temp4_1)
0041a3b3              ecx_3 = &ecx_3[2]
0041a3b6              esi_2 = &esi_2[2]
0041a3b6              
0041a3bb              if (eax_3.b != 0)
0041a3bb                  continue
0041a3bb              
0041a3bd              eax_5 = 0
0041a3bf              break
0041a3bf      
0041a3c1      bool c_2 = unimplemented  {sbb eax, eax}
0041a3c3      eax_5 = sbb.d(sbb.d(eax_3, eax_3, c_1), 0xffffffff, c_2)
0041a3c3      break
0041a3c3  
0041a3c8  if (eax_5 == 0)
0041a3ca      *(arg1 * 0x2c + 0x256eea4) = eax_5
0041a3ca  
0041a3d2  if (*(arg1 * 0x2c + 0x256eea4) s>= 0)
0041a3d5      sub_41a2b0(arg1 * 0x2c + &data_256ee80)
0041a3d5  
0041a3eb  char* esi_3 = sub_40e6a0(arg1 * 0x2c + &data_256ee80, "classname")
0041a3ed  char* ecx_4 = "func_areaportal"
0041a3f2  int32_t eax_9
0041a3f2  
0041a3f2  while (true)
0041a3f2      char edx_2 = *ecx_4
0041a3f4      char* eax_7
0041a3f4      eax_7.b = edx_2
0041a3f6      char temp5_1 = *esi_3
0041a3f6      bool c_3 = edx_2 u< temp5_1
0041a3f6      
0041a3f8      if (edx_2 == temp5_1)
0041a3fc          if (eax_7.b == 0)
0041a412              eax_9 = 0
0041a414              break
0041a414          
0041a3fe          edx_2 = ecx_4[1]
0041a401          eax_7.b = edx_2
0041a403          char temp8_1 = esi_3[1]
0041a403          c_3 = edx_2 u< temp8_1
0041a403          
0041a406          if (edx_2 == temp8_1)
0041a408              ecx_4 = &ecx_4[2]
0041a40b              esi_3 = &esi_3[2]
0041a40b              
0041a410              if (eax_7.b != 0)
0041a410                  continue
0041a410              
0041a412              eax_9 = 0
0041a414              break
0041a414      
0041a416      bool c_4 = unimplemented  {sbb eax, eax}
0041a418      eax_9 = sbb.d(sbb.d(eax_7, eax_7, c_3), 0xffffffff, c_4)
0041a418      break
0041a418  
0041a41d  if (eax_9 == 0)
0041a424      int32_t eax_11 = data_255e0dc + 1
0041a425      data_255e0dc = eax_11
0041a42a      *(arg1 * 0x2c + &data_256ee98) = eax_11
0041a42a  
0041a434  return 1

0041a435                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0041a440    void sub_41a440(int32_t arg1, void* arg2, void* arg3)

0041a447  sub_410030("-- Q2_LoadMapFromBSP --\n")
0041a450  data_65e020 = 2
0041a45a  int32_t var_10 = arg1
0041a460  sub_410030("Loading map from %s...\n")
0041a470  sub_40dc30(arg1, arg2, arg3)
0041a485  __builtin_memset(s: &data_493fa0, c: 0xffffffff, n: 0x10000)
0041a487  int32_t i_1 = 0
0041a489  data_255e0c0 = 0
0041a48f  data_2584ecc = 0
0041a495  sub_40e3d0()
0041a49f  int32_t i = 0
0041a49f  
0041a4a3  if (data_2584ecc s> 0)
0041a4b6      do
0041a4a6          sub_41a310(i)
0041a4b3          i += 1
0041a4b6      while (i s< data_2584ecc)
0041a4b6  
0041a4c2  sub_4104f0(&data_255e0f0, &data_255e0d0)
0041a4c2  
0041a4d1  if (data_256ee90 s> 0)
0041a4d3      void* esi_1 = &data_4b6014
0041a4d3      
0041a518      do
0041a4d8          long double x87_r7_1 = fconvert.t(*esi_1)
0041a4da          long double temp0_1 = fconvert.t(4096f)
0041a4da          x87_r7_1 - temp0_1
0041a4e0          int32_t eax_3
0041a4e0          eax_3.w = (x87_r7_1 < temp0_1 ? 1 : 0) << 8
0041a4e0              | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
0041a4e0              | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe
0041a4e0          
0041a4e5          if ((eax_3:1.b & 0x41) != 0)
0041a4f2              sub_410520(esi_1, &data_255e0f0, &data_255e0d0)
0041a505              sub_410520(esi_1 + 0xc, &data_255e0f0, &data_255e0d0)
0041a505          
0041a512          i_1 += 1
0041a513          esi_1 += 0x34
0041a518      while (i_1 s< data_256ee90)
0041a518  
0041a51a  sub_4162b0()
0041a51f  sub_419080()

0041a527                       90 90 90 90 90 90 90 90 90                                                         .........

0041a530    int32_t sub_41a530()

0041a53d  __builtin_memset(s: 0x4b3fe0, c: 0, n: 0x1000)
0041a549  __builtin_memset(s: &data_493fa0, c: 0, n: 0x10000)
0041a54b  data_4a3fa0 = 0
0041a550  data_430b64 = 0
0041a556  return 0

0041a557                                                                       90 90 90 90 90 90 90 90 90                         .........

0041a560    int32_t sub_41a560(float arg1)

0041a560  int32_t* edx = arg1
0041a56c  void* eax = edx[0xc]
0041a56f  int32_t ebp = 1
0041a576  int32_t result = *(eax + 0x14)
0041a582  long double x87_r7 = fconvert.t(*(data_255edb0 + *(eax + 4) * 0xb4 + 0x7c))
0041a582  
0041a589  if (edx[0xb] s> 1)
0041a58f      void* edi_1 = 0x20
0041a58f      
0041a599      while (true)
0041a599          void* eax_5 = edi_1 + edx[0xc]
0041a5aa          x87_r7 = x87_r7 + fconvert.t(*(data_255edb0 + *(eax_5 + 4) * 0xb4 + 0x7c))
0041a5ae          int32_t ecx_5 = *(eax_5 + 0x14)
0041a5ae          
0041a5b3          if (ecx_5 != result)
0041a5b7              int32_t esi_3 = ecx_5 & 0x8000000
0041a5b7              
0041a5d1              if ((esi_3 == 0 || (result & 0x8000000) != 0)
0041a5d1                      && (esi_3 != 0 || (result & 0x8000000) == 0))
0041a5fc                  int32_t var_14_1 = edx[1]
0041a5fd                  int32_t var_18_1 = *edx
0041a603                  sub_41dc50("Entity %i, Brush %i: mixed face …")
0041a608                  x87_r7 = fconvert.t(fconvert.s(x87_r7))
0041a60c                  break
0041a60c              
0041a5d9              result |= 0x8000000
0041a5df              *(eax_5 + 0x14) = ecx_5 | 0x8000000
0041a5df          
0041a5e5          ebp += 1
0041a5e6          edi_1 += 0x20
0041a5e6          
0041a5eb          if (ebp s>= edx[0xb])
0041a5ed              arg1 = fconvert.s(x87_r7)
0041a5f1              break
0041a5f1  
0041a612  if ((result.b & 4) != 0)
0041a617      result = (result & 0xfffffffa) | 0x8001002
0041a617  
0041a61d  long double temp0 = fconvert.t(0f)
0041a61d  x87_r7 - temp0
0041a623  int32_t eax_3
0041a623  eax_3.w = (x87_r7 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7, temp0) ? 1 : 0) << 0xa
0041a623      | (x87_r7 == temp0 ? 1 : 0) << 0xe
0041a623  
0041a628  if ((eax_3:1.b & 0x41) == 0)
0041a62a      result |= 0x10000000
0041a62a      
0041a633      if ((result.b & 1) != 0)
0041a638          return (result & 0xfffffffe) | 2
0041a638  
0041a641  return result

0041a642        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0041a650    int32_t sub_41a650()

0041a66b  data_586024 = 0
0041a671  data_586034 = 0
0041a689  data_586028 = 0
0041a68f  data_586038 = 0
0041a69b  data_586048 = (*"generic/misc/red")[0].d
0041a6a8  int32_t ebp = data_255ee1c
0041a6bb  data_586020 = 0x3f800000
0041a6c0  data_586030 = 0x3f800000
0041a6c5  data_58604c = (*"ric/misc/red")[0].d
0041a6d1  data_586050 = (*"misc/red")[0].d
0041a6d7  int32_t ecx_1
0041a6d7  ecx_1.b = data_42e914[0x10][0]
0041a6dd  int32_t result = 0
0041a6e2  data_58602c = 0
0041a6e8  data_58603c = 0
0041a6ee  data_586040 = 0
0041a6f3  data_586044 = 0
0041a6f8  data_586054 = (*"/red")[0].d
0041a6fe  data_586058 = ecx_1.b
0041a704  data_586088 = 0xffffffff
0041a704  
0041a70e  if (ebp s> 1)
0041a718      void* edx_2 = &data_5860ac
0041a71d      void* ebx_1 = data_255edb0 + 0xd8
0041a723      int32_t i_1 = ebp - 1
0041a776      int32_t i
0041a776      
0041a776      do
0041a733          __builtin_memcpy(dest: edx_2 - 0x20, src: ebx_1 - 0x24, n: 0x20)
0041a738          void* edi_2 = ebx_1
0041a73a          *edx_2 = *(ebx_1 - 4)
0041a73c          *(edx_2 + 4) = 0
0041a73f          int32_t j = 0xffffffff
0041a73f          
0041a744          while (j != 0)
0041a744              bool cond:1_1 = 0 != *edi_2
0041a744              edi_2 += 1
0041a744              j -= 1
0041a744              
0041a744              if (not(cond:1_1))
0041a744                  break
0041a744          
0041a746          int32_t result_1 = not.d(j)
0041a74d          result = result_1
0041a75c          int32_t esi_4
0041a75c          int32_t edi_5
0041a75c          edi_5, esi_4 = __builtin_memcpy(dest: edx_2 + 8, src: edi_2 - result_1, 
0041a75c              n: result_1 u>> 2 << 2)
0041a760          ebx_1 += 0xb4
0041a769          edx_2 += 0x6c
0041a76c          __builtin_memcpy(dest: edi_5, src: esi_4, n: result & 3)
0041a76e          *(edx_2 - 0x24) = 0xffffffff
0041a775          i = i_1
0041a775          i_1 -= 1
0041a776      while (i != 1)
0041a776  
0041a77f  return result


0041a780    int32_t sub_41a780(int32_t arg1, int32_t arg2)

0041a792  int32_t result = arg1 * 7
0041a794  void* edx = data_255ee08 + (result << 2)
0041a797  int32_t ecx = 0
0041a797  
0041a79d  if (*(edx + 0x1a) u> 0)
0041a7a0      int32_t ebx_1 = data_255ee28
0041a7a0      
0041a7d3      do
0041a7ae          int32_t eax_1
0041a7ae          eax_1.w = *(edx + 0x18)
0041a7b6          int32_t ebp_2 = eax_1 + ecx
0041a7b8          ecx += 1
0041a7b9          int32_t eax_2
0041a7b9          eax_2.w = *(ebx_1 + (ebp_2 << 1))
0041a7bd          *((eax_2 << 2) + &data_493fa0) = arg2
0041a7c4          *((eax_2 << 2) + &data_4a3fc0) = arg1
0041a7cd          result.w = *(edx + 0x1a)
0041a7d3      while (ecx s< result)
0041a7d3  
0041a7d9  return result

0041a7da                                                                                90 90 90 90 90 90                            ......

0041a7e0    int32_t sub_41a7e0()

0041a7e0  data_4a3fa0 = 0x4b3fe0
0041a7ea  data_430b64 = 0

0041a7f5                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0041a800    int32_t sub_41a800(int32_t arg1)

0041a809  *data_4a3fa0 = arg1
0041a816  int32_t result = data_4a3fa0 + 4
0041a819  int32_t edx_1 = data_430b64 + 1
0041a81f  data_4a3fa0 = result
0041a824  data_430b64 = edx_1
0041a824  
0041a82a  if (result u>= &data_4b4fe0)
0041a831      result = sub_40f970("Sin_PushNodeStack: stack overflo…")
0041a831  
0041a837  return result

0041a838                                                                          90 90 90 90 90 90 90 90                          ........

0041a840    int32_t sub_41a840(void* arg1)

0041a843  sub_41a7e0()
0041a85b  int32_t i = 0
0041a85d  int32_t j = *(*(arg1 + 0x24) * 0x30 + data_255ee34 + 0x24)
0041a8e5  int32_t result
0041a8e5  
0041a8e5  do
0041a863      if (j s>= 0)
0041a8c9          sub_41a800(j)
0041a8ce          result = data_255ee2c
0041a8df          j = *(result + j * 0x1c + 4)
0041a863      else
0041a86f          sub_41a780(0xffffffff - j, *(arg1 + 0x24))
0041a877          result = sub_419e90()
0041a87c          i = result
0041a87c          
0041a880          if (i s< 0)
0041a880              break
0041a880          
0041a895          while (*(data_255ee2c + i * 0x1c + 4) != j)
0041a897              j = i
0041a899              result = sub_419e90()
0041a89e              i = result
0041a89e              
0041a8a2              if (i s< 0)
0041a8ee                  return result
0041a8ee          
0041a8a8          if (i s< 0)
0041a8a8              break
0041a8a8          
0041a8ab          sub_41a800(i)
0041a8c0          result = i * 7
0041a8c2          j = *(data_255ee2c + (result << 2) + 8)
0041a8e5  while (i s>= 0)
0041a8e5  
0041a8ee  return result

0041a8ef                                               90                                                                 .

0041a8f0    int32_t* sub_41a8f0(int32_t* arg1, float arg2)

0041a8f0  int32_t eax = data_dde044
0041a8f0  
0041a8fd  if (eax s>= 0x4000)
0041a904      sub_40f970("nummapbrushes >= MAX_MAPFILE_BRU…")
0041a909      eax = data_dde044
0041a909  
0041a916  float ebp = arg2
0041a93a  int32_t* ebx = arg1
0041a93e  *(eax * 0x34 + &data_4b6030) = (data_255e0c0 << 5) + 0x1f9e0a0
0041a955  *(eax * 0x34 + &data_4b6000) = (ebp i- &data_256ee80) s/ 0x2c
0041a967  int32_t edi_1 = 0
0041a969  *(eax * 0x34 + 0x4b6004) = data_dde044 - *(ebp i+ 0xc)
0041a974  int32_t var_8 = 0
0041a978  int32_t eax_5
0041a978  int32_t edx_7
0041a978  edx_7:eax_5 = muls.dp.d(0x2aaaaaab, ebx - data_261d000)
0041a97a  int32_t edx_8 = edx_7 s>> 1
0041a98a  *(eax * 0x34 + 0x4b6010) = *(((edx_8 + (edx_8 u>> 0x1f)) << 2) + &data_4a3fc0)
0041a98a  
0041a992  if (ebx[1] s> 0)
0041a9a7      while (true)
0041a9a7          int16_t* ebp_1 = data_255ee38 + ((*ebx + edi_1) << 3)
0041a9aa          int32_t eax_10 = data_255e0c0
0041a9aa          
0041a9b8          if (eax_10 s>= 0x20000)
0041a9bf              sub_40f970("MAX_MAPFILE_BRUSHSIDES")
0041a9c4              eax_10 = data_255e0c0
0041a9c4          
0041a9d1          int32_t edx_11
0041a9d1          edx_11.b = *(*ebx + edi_1 + 0x255ee60)
0041a9d1          
0041a9df          if (edx_11.b == 0)
0041a9e7              *((eax_10 << 5) + 0x1f9e0bc) &= 0xfff7
0041a9df          else
0041a9e1              *((eax_10 << 5) + 0x1f9e0bc) |= 8
0041a9e1          
0041a9f0          *((eax_10 << 5) + 0x1f9e0b4) = ebx[2]
0041a9f3          int32_t ecx_8
0041a9f3          ecx_8.w = ebp_1[1]
0041a9f3          
0041a9fa          if (ecx_8.w s>= 0)
0041aa18              *((eax_10 << 5) + 0x1f9e0b8) = *(data_255edb0 + sx.d(ecx_8.w) * 0xb4 + 0x20)
0041a9fa          else
0041a9fc              *((eax_10 << 5) + 0x1f9e0b8) = 0
0041a9fc          
0041aa1b          int32_t edx_14 = *((eax_10 << 5) + 0x1f9e0b8)
0041aa1b          
0041aa21          if ((edx_14.b & 0x30) != 0)
0041aa23              *((eax_10 << 5) + 0x1f9e0b4) |= 0x8000000
0041aa23          
0041aa2a          int32_t ecx_13 = *((eax_10 << 5) + 0x1f9e0b4)
0041aa2a          
0041aa33          if ((ecx_13 & 0x30000) != 0)
0041aa3b              *((eax_10 << 5) + 0x1f9e0b4) = ecx_13 | 0x8000000
0041aa3b          
0041aa46          if (data_279bacc != 0)
0041aa48              *((eax_10 << 5) + 0x1f9e0b4) &= 0xf7ffffff
0041aa48          
0041aa4f          int32_t ecx_16 = *((eax_10 << 5) + 0x1f9e0b4)
0041aa4f          
0041aa58          if ((ecx_16 & 0x3007f) == 0)
0041aa5d              *((eax_10 << 5) + 0x1f9e0b4) = ecx_16 | 1
0041aa5d          
0041aa63          if ((edx_14:1.b & 3) != 0)
0041aa6b              *((eax_10 << 5) + 0x1f9e0b4) = 0
0041aa72              *((eax_10 << 5) + 0x1f9e0b8) = edx_14 & 0xf7ffffff
0041aa72          
0041aa77          int32_t eax_13
0041aa77          eax_13.w = *ebp_1
0041aa7b          int32_t edx_16 = eax_13 * 5
0041aa7e          int32_t eax_14 = data_255edac
0041aa8a          int32_t var_1c_1 = *(eax_14 + (edx_16 << 2) + 0xc)
0041aa8c          int32_t eax_16 = sub_414ae0(eax_14 + (edx_16 << 2))
0041aa93          int32_t eax_17 = *(eax * 0x34 + &data_4b602c)
0041aa99          int32_t ebp_2 = 0
0041aa99          
0041aa9d          if (eax_17 s> 0)
0041aa9f              int32_t* edx_17 = *(eax * 0x34 + &data_4b6030)
0041aa9f              
0041aabb              do
0041aaa2                  int32_t ecx_19 = *edx_17
0041aaa2                  
0041aaa6                  if (ecx_19 == eax_16)
0041aac4                      int32_t var_1c_2 = *(eax * 0x34 + 0x4b6004)
0041aac5                      int32_t var_20_2 = *(eax * 0x34 + &data_4b6000)
0041aacb                      sub_410030("Entity %i, Brush %i: duplicate p…")
0041aad3                      break
0041aad3                  
0041aaaf                  if (ecx_19 == (eax_16 ^ 1))
0041aada                      int32_t var_1c_3 = *(eax * 0x34 + 0x4b6004)
0041aadb                      int32_t var_20_3 = *(eax * 0x34 + &data_4b6000)
0041aae1                      sub_410030("Entity %i, Brush %i: mirrored pl…")
0041aae6                      ebx = arg1
0041aaea                      break
0041aaea                  
0041aab1                  ebx = arg1
0041aab5                  ebp_2 += 1
0041aab6                  edx_17 = &edx_17[8]
0041aabb              while (ebp_2 s< eax_17)
0041aabb          
0041aaed          int32_t eax_19 = *(eax * 0x34 + &data_4b602c)
0041aaed          
0041aaf2          if (ebp_2 == eax_19)
0041aafe              int32_t* eax_21 = (eax_19 << 5) + *(eax * 0x34 + &data_4b6030)
0041ab00              *eax_21 = eax_16
0041ab02              int16_t* ecx_21
0041ab02              ecx_21.w = ebp_1[1]
0041ab02              
0041ab09              if (ecx_21.w s>= 0)
0041ab17                  eax_21[1] = sx.d(ecx_21.w)
0041ab09              else
0041ab0b                  eax_21[1] = 0
0041ab0b              
0041ab21              data_255e0c0 += 1
0041ab2b              *(eax * 0x34 + &data_4b602c) += 1
0041ab2b          
0041ab36          bool cond:1_1 = var_8 + 1 s< ebx[1]
0041ab38          var_8 += 1
0041ab38          
0041ab3c          if (not(cond:1_1))
0041ab3c              break
0041ab3c          
0041a99a          edi_1 = var_8
0041a99a      
0041ab42      ebp = arg2
0041ab42  
0041ab4a  *(eax * 0x34 + 0x4b6008) = ebx[2]
0041ab4d  sub_41a560(eax * 0x34 + &data_4b6000)
0041ab4d  
0041ab5d  if (sub_4154c0(eax * 0x34 + &data_4b6000) != 0)
0041ab65      int32_t eax_29 = data_255e0c8 + 1
0041ab66      data_255e0c8 = eax_29
0041ab6b      *(eax * 0x34 + &data_4b602c) = 0
0041ab78      return eax_29
0041ab78  
0041ab79  int32_t eax_30 = data_279c334
0041ab79  
0041ab82  if (eax_30 != 0)
0041ab96      return sub_405050(eax * 0x34 + &data_4b6000, ebp, 0)
0041ab96  
0041aba6  if (data_279c328 != 0 && (*(eax * 0x34 + 0x4b6008) & 0x8000000) != 0)
0041aba8      *(eax * 0x34 + &data_4b602c) = 0
0041abb2      return eax_30
0041abb2  
0041abbf  if (data_279babc != 0 && (*(eax * 0x34 + 0x4b6008) & 0x38) != 0)
0041abc1      *(eax * 0x34 + &data_4b602c) = 0
0041abcb      return eax_30
0041abcb  
0041abcd  sub_415210(eax * 0x34 + &data_4b6000)
0041abd3  sub_4153c0(eax * 0x34 + &data_4b6000)
0041abd3  
0041abe3  if ((*(eax * 0x34 + 0x4b6008) & 0x30000) != 0)
0041abeb      int32_t i = 0
0041abee      data_255e0c4 += 1
0041abee      
0041abf9      if (*(eax * 0x34 + &data_4b602c) s> 0)
0041abfb          int32_t ecx_26 = 0
0041abfb          
0041ac10          do
0041ac03              i += 1
0041ac04              *(ecx_26 + *(eax * 0x34 + &data_4b6030) + 4) = 0xffffffff
0041ac0b              ecx_26 += 0x20
0041ac10          while (i s< *(eax * 0x34 + &data_4b602c))
0041ac10  
0041ac1b  data_dde044 += 1
0041ac24  int32_t eax_34 = *(ebp i+ 0x10) + 1
0041ac25  *(ebp i+ 0x10) = eax_34
0041ac2d  return eax_34

0041ac2e                                            90 90                                                                ..

0041ac30    int32_t sub_41ac30(float arg1)

0041ac37  sub_41a840(arg1)
0041ac3c  int32_t result = data_255edd4
0041ac44  int32_t edi = 0
0041ac44  
0041ac48  if (result s> 0)
0041ac4c      void* esi_1 = nullptr
0041ac4e      void* ebx_1 = &data_493fa0
0041ac4e      
0041ac7d      do
0041ac5a          if (*ebx_1 == *(arg1 i+ 0x24))
0041ac67              sub_41a8f0(esi_1 + data_255ee0c, arg1)
0041ac67          
0041ac6f          result = data_255edd4
0041ac74          edi += 1
0041ac75          ebx_1 += 4
0041ac78          esi_1 += 0xc
0041ac7d      while (edi s< result)
0041ac7d  
0041ac83  return result

0041ac84              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0041ac90    int32_t sub_41ac90(int32_t arg1)

0041acad  (&data_256ee8c)[arg1 * 0xb] = data_dde044
0041acb0  (&data_256ee90)[arg1 * 0xb] = 0
0041acb7  *(arg1 * 0x2c + 0x256eea4) = 0xffffffff
0041acbe  char* eax_1 = sub_40e6a0(arg1 * 0x2c + &data_256ee80, "model")
0041acbe  
0041accd  if (eax_1 != 0 && *eax_1 == 0x2a)
0041acd9      *(arg1 * 0x2c + 0x256eea4) = sub_41e293(&eax_1[1])
0041acd9  
0041ace4  sub_40e730(arg1 * 0x2c + &data_256ee80, "origin", arg1 * 0x2c + &data_256ee80)
0041acf7  char* esi = sub_40e6a0(arg1 * 0x2c + &data_256ee80, "classname")
0041acf9  char* ecx_1 = "worldspawn"
0041acfe  int32_t eax_6
0041acfe  
0041acfe  while (true)
0041acfe      char edx_1 = *ecx_1
0041ad00      char* eax_4
0041ad00      eax_4.b = edx_1
0041ad02      char temp0_1 = *esi
0041ad02      bool c_1 = edx_1 u< temp0_1
0041ad02      
0041ad04      if (edx_1 == temp0_1)
0041ad08          if (eax_4.b == 0)
0041ad1e              eax_6 = 0
0041ad20              break
0041ad20          
0041ad0a          edx_1 = ecx_1[1]
0041ad0d          eax_4.b = edx_1
0041ad0f          char temp3_1 = esi[1]
0041ad0f          c_1 = edx_1 u< temp3_1
0041ad0f          
0041ad12          if (edx_1 == temp3_1)
0041ad14              ecx_1 = &ecx_1[2]
0041ad17              esi = &esi[2]
0041ad17              
0041ad1c              if (eax_4.b != 0)
0041ad1c                  continue
0041ad1c              
0041ad1e              eax_6 = 0
0041ad20              break
0041ad20      
0041ad22      bool c_2 = unimplemented  {sbb eax, eax}
0041ad24      eax_6 = sbb.d(sbb.d(eax_4, eax_4, c_1), 0xffffffff, c_2)
0041ad24      break
0041ad24  
0041ad29  if (eax_6 == 0)
0041ad2b      *(arg1 * 0x2c + 0x256eea4) = eax_6
0041ad2b  
0041ad33  if (*(arg1 * 0x2c + 0x256eea4) s>= 0)
0041ad36      sub_41ac30(arg1 * 0x2c + &data_256ee80)
0041ad36  
0041ad4c  char* esi_1 = sub_40e6a0(arg1 * 0x2c + &data_256ee80, "classname")
0041ad4e  char* ecx_2 = "func_areaportal"
0041ad53  int32_t eax_10
0041ad53  
0041ad53  while (true)
0041ad53      char edx_2 = *ecx_2
0041ad55      char* eax_8
0041ad55      eax_8.b = edx_2
0041ad57      char temp4_1 = *esi_1
0041ad57      bool c_3 = edx_2 u< temp4_1
0041ad57      
0041ad59      if (edx_2 == temp4_1)
0041ad5d          if (eax_8.b == 0)
0041ad73              eax_10 = 0
0041ad75              break
0041ad75          
0041ad5f          edx_2 = ecx_2[1]
0041ad62          eax_8.b = edx_2
0041ad64          char temp7_1 = esi_1[1]
0041ad64          c_3 = edx_2 u< temp7_1
0041ad64          
0041ad67          if (edx_2 == temp7_1)
0041ad69              ecx_2 = &ecx_2[2]
0041ad6c              esi_1 = &esi_1[2]
0041ad6c              
0041ad71              if (eax_8.b != 0)
0041ad71                  continue
0041ad71              
0041ad73              eax_10 = 0
0041ad75              break
0041ad75      
0041ad77      bool c_4 = unimplemented  {sbb eax, eax}
0041ad79      eax_10 = sbb.d(sbb.d(eax_8, eax_8, c_3), 0xffffffff, c_4)
0041ad79      break
0041ad79  
0041ad7f  if (eax_10 == 0)
0041ad86      int32_t eax_12 = data_255e0dc + 1
0041ad87      data_255e0dc = eax_12
0041ad8c      *(arg1 * 0x2c + &data_256ee98) = eax_12
0041ad8c  
0041ad95  return 1

0041ad96                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0041ada0    void sub_41ada0(int32_t arg1, void* arg2, void* arg3)

0041ada7  sub_410030("-- Sin_LoadMapFromBSP --\n")
0041adb0  data_65e020 = 4
0041adba  int32_t var_10 = arg1
0041adc0  sub_410030("Loading map from %s...\n")
0041add0  sub_40f650(arg1, arg2, arg3)
0041ade5  __builtin_memset(s: &data_493fa0, c: 0xffffffff, n: 0x10000)
0041ade7  int32_t i_1 = 0
0041ade9  data_255e0c0 = 0
0041adef  data_2584ecc = 0
0041adf5  sub_40f910()
0041adff  int32_t i = 0
0041adff  
0041ae03  if (data_2584ecc s> 0)
0041ae16      do
0041ae06          sub_41ac90(i)
0041ae13          i += 1
0041ae16      while (i s< data_2584ecc)
0041ae16  
0041ae22  sub_4104f0(&data_255e0f0, &data_255e0d0)
0041ae22  
0041ae31  if (data_256ee90 s> 0)
0041ae33      void* esi_1 = &data_4b6014
0041ae33      
0041ae78      do
0041ae38          long double x87_r7_1 = fconvert.t(*esi_1)
0041ae3a          long double temp0_1 = fconvert.t(4096f)
0041ae3a          x87_r7_1 - temp0_1
0041ae40          int32_t eax_3
0041ae40          eax_3.w = (x87_r7_1 < temp0_1 ? 1 : 0) << 8
0041ae40              | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
0041ae40              | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe
0041ae40          
0041ae45          if ((eax_3:1.b & 0x41) != 0)
0041ae52              sub_410520(esi_1, &data_255e0f0, &data_255e0d0)
0041ae65              sub_410520(esi_1 + 0xc, &data_255e0f0, &data_255e0d0)
0041ae65          
0041ae72          i_1 += 1
0041ae73          esi_1 += 0x34
0041ae78      while (i_1 s< data_256ee90)
0041ae78  
0041ae7a  sub_41a650()

0041ae82        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0041ae90    int32_t sub_41ae90() __pure

0041ae90  return 

0041ae91                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

0041aea0    void* sub_41aea0()

0041aea4  void* s = sub_4105b0(0x4c)
0041aeb4  __builtin_memset(s, c: 0, n: 0x4c)
0041aeb4  
0041aec1  if (data_42db3c == 1)
0041aece      int32_t eax_2 = data_493f64 + 1
0041aecf      bool cond:0_1 = eax_2 s<= data_493f7c
0041aed1      data_493f64 = eax_2
0041aed1      
0041aed6      if (not(cond:0_1))
0041aed8          data_493f7c = eax_2
0041aed8      
0041aede      uint32_t eax_3 = sub_410560(s)
0041aeee      data_493f58 += eax_3
0041aeee  
0041aef8  return s

0041aef9                                                                             90 90 90 90 90 90 90                           .......

0041af00    int32_t sub_41af00(void* arg1)

0041af05  int32_t* eax = *(arg1 + 0x30)
0041af05  
0041af0a  if (eax != 0)
0041af0d      sub_410740(eax)
0041af0d  
0041af1c  if (data_42db3c == 1)
0041af26      data_493f64 -= 1
0041af2c      uint32_t eax_1 = sub_410560(arg1)
0041af3c      data_493f58 -= eax_1
0041af3c  
0041af4c  return sub_41e29e(arg1)

0041af4d                                         90 90 90                                                               ...

0041af50    int32_t sub_41af50(int32_t arg1) __pure

0041af62  for (int32_t i = 1; i s<= 0x40; i <<= 1)
0041af5b      if ((arg1 & i) != 0)
0041af66          return i
0041af66  
0041af64  return 0

0041af67                       90 90 90 90 90 90 90 90 90                                                         .........

0041af70    int32_t sub_41af70(int32_t* arg1)

0041af78  if (*arg1 == 0xffffffff)
0041af7e      return arg1[0xf]
0041af7e  
0041af84  char eax_2 = sub_41af70(arg1[0xb])
0041af8f  char eax_3 = sub_41af70(arg1[0xc])
0041af99  char result = eax_3 | eax_2
0041af99  
0041afa4  if ((eax_2 & 1) != 0 && (eax_3 & 1) != 0)
0041afa9      return result
0041afa9  
0041afa6  return result & 0xfe

0041afaa                                90 90 90 90 90 90                                                            ......

0041afb0    int32_t sub_41afb0(void* arg1)

0041afbb  if (*(arg1 + 0x1c) == 0)
0041afc1      return 0
0041afc1  
0041afce  int32_t edi = sub_41af70(*(arg1 + 0x20))
0041afd6  int32_t esi_1 = sub_41af70(*(arg1 + 0x24))
0041afd6  
0041afe7  if (sub_41af50(esi_1 ^ edi) == 0)
0041aff0      return 1
0041aff0  
0041aff7  if ((edi & 0x18000000) != 0)
0041aff9      edi = 0
0041aff9  
0041b001  if ((esi_1 & 0x18000000) != 0)
0041b003      esi_1 = 0
0041b003  
0041b00b  if (((esi_1.b | edi.b) & 1) != 0)
0041b011      return 0
0041b011  
0041b012  int32_t esi_2 = esi_1 ^ edi
0041b012  
0041b014  if (esi_2 == 0)
0041b01d      return 1
0041b01d  
0041b01f  int32_t eax_11 = sub_41af50(esi_2)
0041b027  int32_t eax_12 = neg.d(eax_11)
0041b02e  return sbb.d(eax_12, eax_12, eax_11 != 0) + 1

0041b02f                                               90                                                                 .

0041b030    int32_t sub_41b030(void* arg1)

0041b043  if (**(arg1 + 0x20) != 0xffffffff || **(arg1 + 0x24) != 0xffffffff)
0041b04a      sub_40f970("Portal_EntityFlood: not a leaf")
0041b04a  
0041b065  if ((*(*(arg1 + 0x20) + 0x3c) & 1) == 0 && (*(*(arg1 + 0x24) + 0x3c) & 1) == 0)
0041b06a      return 1
0041b06a  
0041b067  return 0

0041b06b                                   90 90 90 90 90                                                             .....

0041b070    void* sub_41b070(void* arg1, void* arg2, void* arg3)

0041b081  if (*(arg1 + 0x20) != 0 || *(arg1 + 0x24) != 0)
0041b088      sub_40f970("AddPortalToNode: allready includ…")
0041b088  
0041b094  *(arg1 + 0x20) = arg2
0041b09a  *(arg1 + 0x28) = *(arg2 + 0x50)
0041b09d  *(arg2 + 0x50) = arg1
0041b0a4  *(arg1 + 0x24) = arg3
0041b0aa  *(arg1 + 0x2c) = *(arg3 + 0x50)
0041b0ad  *(arg3 + 0x50) = arg1
0041b0b1  return arg3

0041b0b2                                                        90 90 90 90 90 90 90 90 90 90 90 90 90 90                    ..............

0041b0c0    void* __stdcall sub_41b0c0(void* arg1, void* arg2)

0041b0c5  void* result = sub_41e520(0x4004)
0041b0d3  void* ebp = arg2
0041b0dc  void** edi = ebp + 0x50
0041b0dc  
0041b0df  while (true)
0041b0df      void* esi_1 = *edi
0041b0df      
0041b0e3      if (esi_1 == 0)
0041b0ea          result = sub_40f970("RemovePortalFromNode: portal not…")
0041b0ea      
0041b0f4      if (esi_1 == arg1)
0041b0f4          break
0041b0f4      
0041b0f9      if (*(esi_1 + 0x20) == ebp)
0041b0fb          edi = esi_1 + 0x28
0041b0f9      else if (*(esi_1 + 0x24) != ebp)
0041b10f          result = sub_40f970("RemovePortalFromNode: portal not…")
0041b103      else
0041b105          edi = esi_1 + 0x2c
0041b105  
0041b11c  if (*(arg1 + 0x20) == ebp)
0041b11e      result = *(arg1 + 0x28)
0041b121      *edi = result
0041b123      *(arg1 + 0x20) = 0
0041b11c  else if (*(arg1 + 0x24) != ebp)
0041b144      result = sub_40f970("RemovePortalFromNode: mislinked …")
0041b12f  else
0041b134      *edi = *(arg1 + 0x2c)
0041b136      *(arg1 + 0x24) = 0
0041b136  
0041b14c  void* i = *(ebp + 0x50)
0041b14f  int32_t j_2 = 0
0041b14f  
0041b153  if (i != 0)
0041b159      void arg_4
0041b159      __return_addr = &arg_4
0041b159      
0041b1d1      do
0041b15f          if (j_2 s> 0)
0041b161              void* edi_1 = &arg_4
0041b165              int32_t j_1 = j_2
0041b17c              int32_t j
0041b17c              
0041b17c              do
0041b169                  if (i == *edi_1)
0041b170                      sub_40f970("RemovePortalFromNode: circular l…")
0041b170                  
0041b178                  edi_1 += 4
0041b17b                  j = j_1
0041b17b                  j_1 -= 1
0041b17c              while (j != 1)
0041b17e              ebp = arg2
0041b17e          
0041b18d          if (*(i + 0x20) != ebp && *(i + 0x24) != ebp)
0041b194              sub_40f970("RemovePortalFromNodes: portal do…")
0041b194          
0041b19f          void** __return_addr_1 = __return_addr
0041b1a7          int32_t ecx_2
0041b1a7          ecx_2.b = *(i + 0x24) == ebp
0041b1aa          *__return_addr_1 = i
0041b1ac          j_2 += 1
0041b1ad          result = &__return_addr_1[1]
0041b1b8          __return_addr = result
0041b1b8          
0041b1bc          if (j_2 s>= 0x1000)
0041b1c3              result = sub_40f970("RemovePortalFromNode: more than …")
0041b1c3          
0041b1cb          i = *(i + (ecx_2 << 2) + 0x28)
0041b1d1      while (i != 0)
0041b1d1  
0041b1dd  return result

0041b1de                                                                                            90 90                                ..

0041b1e0    int32_t sub_41b1e0(int32_t* arg1)

0041b1f0  void* eax = *arg1
0041b1f7  void var_cc
0041b1f7  void* ecx = &var_cc
0041b1fb  void* eax_1 = &arg1[0x1b]
0041b1fe  int32_t i_2 = 3
0041b222  int16_t top_1
0041b222  int32_t i
0041b222  
0041b222  do
0041b206      long double x87_r7_2 = fconvert.t(*(eax_1 - 0xc)) - fconvert.t(8f)
0041b20c      eax_1 += 4
0041b20f      ecx += 4
0041b212      i = i_2
0041b212      i_2 -= 1
0041b213      *(ecx - 0x10) = fconvert.s(x87_r7_2)
0041b21f      *(ecx - 4) = fconvert.s(fconvert.t(*(eax_1 - 4)) + fconvert.t(8f))
0041b21f      top_1 = 0
0041b222  while (i != 1)
0041b227  int32_t ebx = 0
0041b22d  arg1[0xf] = 0
0041b230  arg1[1] = 0xffffffff
0041b236  arg1[0x15] = 0
0041b239  arg1[0x10] = 0
0041b23c  int32_t result_1 = 0
0041b24b  int32_t var_c0[0x6]
0041b24b  int32_t result
0041b24b  
0041b24b  while (true)
0041b24b      int32_t esi = ebx * 3 + result_1
0041b24e      void* eax_3 = sub_41aea0()
0041b263      var_c0[esi] = eax_3
0041b271      int32_t __saved_edi
0041b271      __builtin_memset(s: &(&__saved_edi)[esi * 7 + 0x13], c: 0, n: 0x1c)
0041b271      
0041b273      if (ebx == 0)
0041b28f          (&__saved_edi)[esi * 7 + 0x13 + result_1] = 0x3f800000
0041b29a          int32_t var_d8[0x3]
0041b29a          (&__saved_edi)[esi * 7 + 0x16] = var_d8[result_1]
0041b273      else
0041b279          unimplemented  {fld st0, dword [esp+esi*4+0x1c]}
0041b27d          unimplemented  {fchs }
0041b27f          (&__saved_edi)[esi * 7 + 0x13 + result_1] = 0xbf800000
0041b286          (&__saved_edi)[esi * 7 + 0x16] =
0041b286              fconvert.s(unimplemented  {fstp dword [edx+0xc], st0})
0041b286          unimplemented  {fstp dword [edx+0xc], st0}
0041b286      
0041b2a6      __builtin_memcpy(dest: eax_3, src: &(&__saved_edi)[esi * 7 + 0x13], n: 0x1c)
0041b2ad      int32_t eax_8 =
0041b2ad          sub_410b70(&(&__saved_edi)[esi * 7 + 0x13], (&__saved_edi)[esi * 7 + 0x16])
0041b2ad      top_1 -= 1
0041b2ad      unimplemented  {call sub_410b70}
0041b2b6      *(eax_3 + 0x30) = eax_8
0041b2c0      sub_41b070(eax_3, eax, &arg1[1])
0041b2c8      ebx += 1
0041b2c8      
0041b2cc      if (ebx s>= 2)
0041b2d6          result = result_1 + 1
0041b2da          result_1 = result
0041b2da          
0041b2de          if (result s>= 3)
0041b2de              break
0041b2de          
0041b242          ebx = 0
0041b242  
0041b2e4  int32_t i_1 = 0
0041b2e6  int32_t (* ebx_1)[0x6] = &var_c0
0041b2e6  
0041b31c  do
0041b2ea      int32_t j = 0
0041b2ec      void var_a8
0041b2ec      void* esi_2 = &var_a8
0041b2ec      
0041b313      do
0041b2f2          if (j != i_1)
0041b304              result = sub_4111c0(*ebx_1 + 0x30, esi_2, *(esi_2 + 0xc), 0.100000001f)
0041b304              top_1 -= 1
0041b304              unimplemented  {call sub_4111c0}
0041b304          
0041b30c          j += 1
0041b30d          esi_2 += 0x1c
0041b313      while (j s< 6)
0041b313      
0041b315      i_1 += 1
0041b316      ebx_1 = &(*ebx_1)[1]
0041b31c  while (i_1 s< 6)
0041b31c  
0041b328  return result

0041b329                             90 90 90 90 90 90 90                                                           .......

0041b330    void* sub_41b330(void* arg1)

0041b335  int32_t* edi = arg1
0041b344  int32_t eax_2 = *edi * 0x1c
0041b355  void* i
0041b355  int80_t st0
0041b355  st0, i = sub_410b70(eax_2 + &data_239e0c0, *(eax_2 + &data_239e0cc))
0041b355  int16_t top = 0xffff
0041b35a  int32_t* esi = edi[1]
0041b362  arg1 = i
0041b362  
0041b366  if (esi != 0)
0041b36e      while (i != 0)
0041b374          int32_t eax_3 = *esi
0041b386          int32_t ecx_4 = esi[0xb]
0041b38b          void** var_24_1
0041b38b          void* var_20_1
0041b38b          float var_1c_1
0041b38b          
0041b38b          if (ecx_4 != edi)
0041b39e              unimplemented  {fld st0, dword [&data_430b50]}
0041b3a4              unimplemented  {fsub st0, dword [eax]}
0041b3a6              int32_t var_18_2 = 0x3a83126f
0041b3ab              int32_t var_1c_2 = ecx_4
0041b3b4              float var_c = fconvert.s(unimplemented  {fstp dword [esp+0x10], st0})
0041b3b4              unimplemented  {fstp dword [esp+0x10], st0}
0041b3b8              unimplemented  {fld st0, dword [&data_430b54]}
0041b3be              unimplemented  {fsub st0, dword [eax+0x4]}
0041b3c1              float var_8_1 = fconvert.s(unimplemented  {fstp dword [esp+0x14], st0})
0041b3c1              unimplemented  {fstp dword [esp+0x14], st0}
0041b3c5              unimplemented  {fld st0, dword [&data_430b58]}
0041b3cb              unimplemented  {fsub st0, dword [eax+0x8]}
0041b3ce              float var_4_1 = fconvert.s(unimplemented  {fstp dword [esp+0x18], st0})
0041b3ce              unimplemented  {fstp dword [esp+0x18], st0}
0041b3d2              unimplemented  {fld st0, dword [eax+0xc]}
0041b3d5              unimplemented  {fchs }
0041b3d7              var_1c_1 = fconvert.s(unimplemented  {fstp dword [esp], st0})
0041b3d7              unimplemented  {fstp dword [esp], st0}
0041b3da              var_20_1 = &var_c
0041b3db              var_24_1 = &arg1
0041b38b          else
0041b390              int32_t var_18_1 = 0x3a83126f
0041b395              var_1c_1 = *(eax_3 * 0x1c + &data_239e0cc)
0041b396              var_20_1 = eax_3 * 0x1c + &data_239e0c0
0041b39b              var_24_1 = &arg1
0041b39b          
0041b3dc          sub_4111c0(var_24_1, var_20_1, var_1c_1, 0.00100000005f)
0041b3dc          top -= 1
0041b3dc          unimplemented  {call sub_4111c0}
0041b3e1          i = arg1
0041b3e5          edi = esi
0041b3e7          esi = esi[1]
0041b3e7          
0041b3ef          if (esi == 0)
0041b3ef              break
0041b3ef  
0041b3fa  return i

0041b3fb                                                                                   90 90 90 90 90                             .....

0041b400    void* sub_41b400(void* arg1)

0041b404  int32_t* ebx = arg1
0041b40b  void* result = sub_41b330(ebx)
0041b410  int32_t* i = ebx[0x14]
0041b418  arg1 = result
0041b418  
0041b41c  if (i != 0)
0041b422      void* edi_1 = arg1
0041b422      
0041b4c0      do
0041b428          if (result == 0)
0041b53e              return result
0041b53e          
0041b431          float var_10
0041b431          float var_c
0041b431          
0041b431          if (i[8] == ebx)
0041b435              edi_1 = nullptr
0041b437              var_c = *i
0041b43e              int32_t var_8_1 = i[1]
0041b445              int32_t var_4_1 = i[2]
0041b44c              var_10 = i[3]
0041b431          else if (i[9] != ebx)
0041b492              sub_40f970("MakeNodePortal: mislinked portal")
0041b455          else
0041b457              unimplemented  {fld st0, dword [&data_430b50]}
0041b45d              unimplemented  {fsub st0, dword [esi]}
0041b45f              edi_1 = 1
0041b464              var_c = fconvert.s(unimplemented  {fstp dword [esp+0x10], st0})
0041b464              unimplemented  {fstp dword [esp+0x10], st0}
0041b468              unimplemented  {fld st0, dword [&data_430b54]}
0041b46e              unimplemented  {fsub st0, dword [esi+0x4]}
0041b471              float var_8_2 = fconvert.s(unimplemented  {fstp dword [esp+0x14], st0})
0041b471              unimplemented  {fstp dword [esp+0x14], st0}
0041b475              unimplemented  {fld st0, dword [&data_430b58]}
0041b47b              unimplemented  {fsub st0, dword [esi+0x8]}
0041b47e              float var_4_2 = fconvert.s(unimplemented  {fstp dword [esp+0x18], st0})
0041b47e              unimplemented  {fstp dword [esp+0x18], st0}
0041b482              unimplemented  {fld st0, dword [esi+0xc]}
0041b485              unimplemented  {fchs }
0041b487              var_10 = fconvert.s(unimplemented  {fstp dword [esp+0xc], st0})
0041b487              unimplemented  {fstp dword [esp+0xc], st0}
0041b487          
0041b4ae          sub_4111c0(&arg1, &var_c, var_10, 0.100000001f)
0041b4ae          int16_t top = top - 1
0041b4ae          unimplemented  {call sub_4111c0}
0041b4b3          i = i[edi_1 + 0xa]
0041b4b7          result = arg1
0041b4c0      while (i != 0)
0041b4c0  
0041b4c8  if (result == 0)
0041b53e      return result
0041b53e  
0041b4d5  if (sub_406f30(result) != 0)
0041b4dd      void* ecx_3 = arg1
0041b4e3      data_493f70 += 1
0041b4f7      return sub_410740(ecx_3)
0041b4f7  
0041b4f8  void* eax_4 = sub_41aea0()
0041b516  __builtin_memcpy(dest: eax_4, src: *ebx * 0x1c + &data_239e0c0, n: 0x1c)
0041b518  int32_t ecx_5 = *ebx
0041b51a  *(eax_4 + 0x1c) = ebx
0041b51d  *(eax_4 + 0x48) = ecx_5
0041b524  *(eax_4 + 0x30) = arg1
0041b530  return sub_41b070(eax_4, ebx[0xb], ebx[0xc])

0041b53f                                                                                               90                                 .

0041b540    int32_t* sub_41b540(int32_t* arg1)

0041b545  int32_t* ebp = arg1
0041b549  int32_t eax = *ebp
0041b54c  void* i = ebp[0x14]
0041b558  void* eax_1 = ebp[0xb]
0041b564  void* ecx_2 = ebp[0xc]
0041b564  
0041b573  if (i == 0)
0041b768      ebp[0x14] = 0
0041b774      return eax_1
0041b774  
0041b757  int32_t* eax_10
0041b757  
0041b757  do
0041b57e      int32_t var_18
0041b57e      int32_t esi_1
0041b57e      
0041b57e      if (*(i + 0x20) != ebp)
0041b58b          if (*(i + 0x24) != ebp)
0041b59c              sub_40f970("SplitNodePortals: mislinked port…")
0041b58b          else
0041b58d              var_18 = 1
0041b58d          
0041b5a4          esi_1 = var_18
0041b57e      else
0041b580          esi_1 = 0
0041b582          var_18 = 0
0041b582      
0041b5ab      void* i_1 = *(i + (esi_1 << 2) + 0x28)
0041b5b4      int32_t eax_2
0041b5b4      eax_2.b = esi_1 == 0
0041b5bc      void* edi_1 = *(i + (eax_2 << 2) + 0x20)
0041b5c4      sub_41b0c0(i, *(i + 0x20))
0041b5ce      sub_41b0c0(i, *(i + 0x24))
0041b5ef      int32_t* var_20
0041b5ef      int32_t* var_1c
0041b5ef      sub_410e60(*(i + 0x30), eax * 0x1c + &data_239e0c0, *(eax * 0x1c + &data_239e0cc), 
0041b5ef          0.00100000005f, &var_1c, &var_20)
0041b5ef      int16_t top = top - 1
0041b5ef      unimplemented  {call sub_410e60}
0041b5f4      int32_t* eax_5 = var_1c
0041b5f4      
0041b5fd      if (eax_5 != 0 && sub_406f30(eax_5) != 0)
0041b611          sub_410740(var_1c)
0041b61e          int32_t eax_8 = data_493f70 + 1
0041b61f          var_1c = nullptr
0041b627          data_493f70 = eax_8
0041b627      
0041b62c      eax_10 = var_20
0041b62c      
0041b632      if (eax_10 != 0)
0041b63f          if (sub_406f30(eax_10) == 0)
0041b663              eax_10 = var_20
0041b63f          else
0041b646              sub_410740(var_20)
0041b654              eax_10 = nullptr
0041b656              int32_t ecx_6 = data_493f70 + 1
0041b657              var_20 = nullptr
0041b65b              data_493f70 = ecx_6
0041b65b      
0041b667      int32_t* ecx_7 = var_1c
0041b667      
0041b66d      if (ecx_7 != 0)
0041b6ae          if (eax_10 != 0)
0041b6e2              void* eax_13 = sub_41aea0()
0041b6f2              __builtin_memcpy(dest: eax_13, src: i, n: 0x4c)
0041b6f8              *(eax_13 + 0x30) = var_20
0041b6ff              sub_410740(*(i + 0x30))
0041b70b              *(i + 0x30) = var_1c
0041b714              void* var_44_2
0041b714              void* var_40_2
0041b714              
0041b714              if (var_18 != 0)
0041b739                  sub_41b070(i, edi_1, eax_1)
0041b742                  var_40_2 = ecx_2
0041b743                  var_44_2 = edi_1
0041b714              else
0041b721                  sub_41b070(i, eax_1, edi_1)
0041b72a                  var_40_2 = edi_1
0041b72b                  var_44_2 = ecx_2
0041b72b              
0041b745              eax_10 = sub_41b070(eax_13, var_44_2, var_40_2)
0041b74a              ebp = arg1
0041b6ae          else
0041b6b1              sub_410740(ecx_7)
0041b6b1              
0041b6bb              if (esi_1 != 0)
0041b6d8                  eax_10 = sub_41b070(i, edi_1, eax_1)
0041b6bb              else
0041b6c4                  eax_10 = sub_41b070(i, eax_1, edi_1)
0041b66d      else if (eax_10 != 0)
0041b678          sub_410740(eax_10)
0041b678          
0041b682          if (esi_1 != 0)
0041b69f              eax_10 = sub_41b070(i, edi_1, ecx_2)
0041b682          else
0041b68b              eax_10 = sub_41b070(i, ecx_2, edi_1)
0041b68b      
0041b751      i = i_1
0041b757  while (i != 0)
0041b757  
0041b75e  ebp[0x14] = i
0041b767  return eax_10

0041b775                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0041b780    void sub_41b780(void* arg1)

0041b780  int32_t ecx
0041b780  int32_t var_4 = ecx
0041b782  void* ebx = arg1
0041b788  void* ebp = ebx + 0x14
0041b790  sub_4104f0(ebx + 8, ebp)
0041b79d  int32_t eax_1
0041b79d  
0041b79d  for (void* i = *(ebx + 0x50); i != 0; i = *(i + (eax_1 << 2) + 0x28))
0041b7a7      eax_1.b = *(i + 0x24) == ebx
0041b7ae      int32_t* eax_2 = *(i + 0x30)
0041b7b1      int32_t j = 0
0041b7b1      
0041b7b6      if (*eax_2 s> 0)
0041b7b8          int32_t ebx_1 = 0
0041b7b8          
0041b7d9          do
0041b7c8              sub_410520(ebx_1 + eax_2 + 4, arg1 + 8, ebp)
0041b7cd              eax_2 = *(i + 0x30)
0041b7d3              j += 1
0041b7d4              ebx_1 += 0xc
0041b7d9          while (j s< *eax_2)
0041b7d9          
0041b7db          ebx = arg1

0041b7f1                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

0041b800    void sub_41b800(int32_t* arg1)

0041b806  int32_t eax = data_493f78 + 1
0041b808  int32_t var_c = eax
0041b80e  data_493f78 = eax
0041b813  sub_40fa00("\r%6d")
0041b813  
0041b822  if (data_279bf00 == 0)
0041b828      int32_t* esi_1 = arg1
0041b828      
0041b82d      while (true)
0041b82d          sub_41b780(esi_1)
0041b832          long double x87_r7_1 = fconvert.t(esi_1[2])
0041b835          long double temp0_1 = fconvert.t(esi_1[5])
0041b835          x87_r7_1 - temp0_1
0041b835          
0041b843          if ((((x87_r7_1 < temp0_1 ? 1 : 0) << 8
0041b843                  | (is_unordered.t(x87_r7_1, temp0_1) ? 1 : 0) << 0xa
0041b843                  | (x87_r7_1 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
0041b84a              sub_410030("WARNING: node without a volume\n")
0041b84a          
0041b852          int32_t ecx_1 = 0
0041b854          void* edx_1 = &esi_1[5]
0041b854          
0041b856          while (true)
0041b856              long double x87_r7_2 = fconvert.t(*(edx_1 - 0xc))
0041b859              long double temp1_1 = fconvert.t(-8000f)
0041b859              x87_r7_2 - temp1_1
0041b859              
0041b864              if ((((x87_r7_2 < temp1_1 ? 1 : 0) << 8
0041b864                      | (is_unordered.t(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
0041b864                      | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
0041b866                  long double x87_r7_3 = fconvert.t(*edx_1)
0041b868                  long double temp2_1 = fconvert.t(8000f)
0041b868                  x87_r7_3 - temp2_1
0041b868                  
0041b873                  if ((((x87_r7_3 < temp2_1 ? 1 : 0) << 8
0041b873                          | (is_unordered.t(x87_r7_3, temp2_1) ? 1 : 0) << 0xa
0041b873                          | (x87_r7_3 == temp2_1 ? 1 : 0) << 0xe):1.b & 0x41) != 0)
0041b875                      ecx_1 += 1
0041b876                      edx_1 += 4
0041b876                      
0041b87c                      if (ecx_1 s>= 3)
0041b87c                          break
0041b87c                      
0041b87c                      continue
0041b87c              
0041b885              sub_410030("WARNING: node with unbounded vol…")
0041b88a              break
0041b88a          
0041b890          if (*esi_1 == 0xffffffff)
0041b890              break
0041b890          
0041b893          sub_41b400(esi_1)
0041b899          sub_41b540(esi_1)
0041b8a2          sub_41b800(esi_1[0xb])
0041b8ac          esi_1 = esi_1[0xc]
0041b8af          int32_t eax_5 = data_493f78 + 1
0041b8b0          int32_t var_18_1 = eax_5
0041b8b6          data_493f78 = eax_5
0041b8bb          sub_40fa00("\r%6d")
0041b8bb          
0041b8ca          if (data_279bf00 != 0)
0041b8ca              break

0041b8d3                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0041b8e0    int80_t sub_41b8e0(int32_t* arg1)

0041b8e6  sub_410030("---- Node Portalization ----\n")
0041b8ed  int32_t var_c = 0
0041b8f3  data_493f78 = 0
0041b8f8  data_493f58 = 0
0041b8fd  sub_40fa00("%6d nodes portalized")
0041b907  sub_41b1e0(arg1)
0041b90f  int80_t result = sub_41b800(*arg1)
0041b91a  int32_t var_1c = data_493f78
0041b920  sub_410030("\r%6d nodes portalized\n")
0041b92b  int32_t var_24 = data_493f70
0041b931  sub_410030("%6d tiny portals\n")
0041b93e  int32_t var_2c = data_493f58 s>> 0xa
0041b944  sub_410030("%6d KB of portal memory\n")
0041b951  int32_t var_34 = sub_4107a0() s>> 0xa
0041b957  sub_410030("%6i KB of winding memory\n")
0041b960  return result

0041b961     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0041b970    void* sub_41b970(void* arg1)

0041b974  *(arg1 + 0x54) = 0
0041b97b  void* ecx = data_493f5c
0041b97b  
0041b983  if (ecx != 0)
0041b985      *(ecx + 0x54) = arg1
0041b988      data_493f5c = arg1
0041b98d      return arg1
0041b98d  
0041b98e  data_493f6c = arg1
0041b993  data_493f5c = arg1
0041b998  return arg1

0041b999                                                                             90 90 90 90 90 90 90                           .......

0041b9a0    void* sub_41b9a0()

0041b9a0  void* result = data_493f6c
0041b9a7  int32_t ecx_1
0041b9a7  
0041b9a7  if (result != 0)
0041b9a9      ecx_1 = *(result + 0x54)
0041b9ae      data_493f6c = ecx_1
0041b9ae  
0041b9b4  if (result == 0 || ecx_1 == 0)
0041b9b6      data_493f5c = 0
0041b9b6  
0041b9c0  return result

0041b9c1     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                   ...............

0041b9d0    void* sub_41b9d0(void* arg1)

0041b9d6  *(arg1 + 0x40) = 1
0041b9dd  sub_41b970(arg1)
0041b9e5  void* result = sub_41b9a0()
0041b9e5  
0041b9ee  for (void* i = result; i != 0; i = result)
0041b9f8      int32_t eax
0041b9f8      
0041b9f8      for (void* j = *(i + 0x50); j != 0; j = *(j + (eax << 2) + 0x28))
0041ba01          eax.b = *(j + 0x24) == i
0041ba0a          int32_t ecx_1
0041ba0a          ecx_1.b = eax == 0
0041ba0a          
0041ba1a          if (*(*(j + (ecx_1 << 2) + 0x20) + 0x40) == 0)
0041ba1c              int32_t var_14_1 = eax
0041ba1c              
0041ba28              if (sub_41b030(j) != 0)
0041ba30                  *(*(j + (ecx_1 << 2) + 0x20) + 0x40) = *(i + 0x40) + 1
0041ba36                  sub_41b970(*(j + (ecx_1 << 2) + 0x20))
0041ba36      
0041ba46      result = sub_41b9a0()
0041ba46  
0041ba55  return result

0041ba56                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0041ba60    void sub_41ba60(int32_t* arg1, float* arg2, int32_t arg3)

0041ba61  int32_t* esi = arg1
0041ba61  
0041ba68  while (*esi != 0xffffffff)
0041ba73      int32_t eax_1 = *esi
0041ba73      
0041ba7f      if (eax_1 s< 0 || eax_1 s> data_255e0e8)
0041ba86          sub_40f970("PlaceOccupant: invalid node->pla…")
0041ba86      
0041ba97      int32_t ecx_2 = *esi * 7
0041baba      long double x87_r7_4 =
0041baba          fconvert.t(*((ecx_2 << 2) + &data_239e0c4)) * fconvert.t(arg2[1])
0041baba          + fconvert.t(*((ecx_2 << 2) + &data_239e0c8)) * fconvert.t(arg2[2])
0041baba          + fconvert.t(*((ecx_2 << 2) + &data_239e0c0)) * fconvert.t(*arg2)
0041babc      long double x87_r7_5 = x87_r7_4 - fconvert.t(*((ecx_2 << 2) + &data_239e0cc))
0041babf      long double temp0_1 = fconvert.t(0f)
0041babf      x87_r7_5 - temp0_1
0041bac5      void* eax_3
0041bac5      eax_3.w = (x87_r7_5 < temp0_1 ? 1 : 0) << 8
0041bac5          | (is_unordered.t(x87_r7_5, temp0_1) ? 1 : 0) << 0xa
0041bac5          | (x87_r7_5 == temp0_1 ? 1 : 0) << 0xe | 0x3800
0041bac5      
0041baca      if ((eax_3:1.b & 1) != 0)
0041bad1          esi = esi[0xc]
0041baca      else
0041bacc          esi = esi[0xb]
0041bacc      
0041bad6      if (esi == 0)
0041bad8          long double temp1_1 = fconvert.t(0f)
0041bad8          x87_r7_5 - temp1_1
0041bade          eax_3.w = (x87_r7_5 < temp1_1 ? 1 : 0) << 8
0041bade              | (is_unordered.t(x87_r7_5, temp1_1) ? 1 : 0) << 0xa
0041bade              | (x87_r7_5 == temp1_1 ? 1 : 0) << 0xe
0041bade          
0041bae3          if ((eax_3:1.b & 1) == 0)
0041bafc              int32_t var_c_2 = 0
0041bb02              sub_40f970("PlaceOccupant: invalid child %d\n")
0041bae3          else
0041baea              int32_t var_c_1 = 1
0041baf0              sub_40f970("PlaceOccupant: invalid child %d\n")
0041baf0  
0041bb1c  if ((esi[0xf].b & 1) != 0)
0041bb21      return 
0041bb21  
0041bb27  if (esi[0x10] != 0)
0041bb2c      return 
0041bb2c  
0041bb32  esi[0x11] = arg3
0041bb35  data_493f60 = 0
0041bb3f  sub_41b9d0(esi)

0041bb4e                                            90 90                                                                ..

0041bb50    int32_t sub_41bb50(int32_t* arg1)

0041bb5e  int32_t* eax = *arg1
0041bb64  sub_410030("------ FloodEntities -------\n")
0041bb69  int32_t ebx = 0
0041bb70  arg1[0x11] = 0
0041bb7e  int32_t var_10 = 1
0041bb7e  
0041bb82  if (data_2584ecc s> 1)
0041bb8a      void* ebp_1 = &data_256eeac
0041bb8a      
0041bb9a      while (true)
0041bb9a          float var_c
0041bb9a          sub_40e730(ebp_1, "origin", &var_c)
0041bb9a          
0041bbb3          if (sub_410380(&var_c, &data_430b50) == 0)
0041bbbf              char* eax_2 = sub_40e6a0(ebp_1, "classname")
0041bbc4              unimplemented  {fld st0, dword [esp+0x30]}
0041bbc8              unimplemented  {fadd dword [&data_42914c]}
0041bbd1              char* esi_1 = "info_player_start"
0041bbd6              float var_4_1 = fconvert.s(unimplemented  {fstp dword [esp+0x28], st0})
0041bbd6              unimplemented  {fstp dword [esp+0x28], st0}
0041bbda              int32_t eax_4
0041bbda              
0041bbda              while (true)
0041bbda                  char edx_1 = *eax_2
0041bbde                  char temp0_1 = *esi_1
0041bbde                  bool c_1 = edx_1 u< temp0_1
0041bbde                  
0041bbe0                  if (edx_1 == temp0_1)
0041bbe4                      if (edx_1 == 0)
0041bbfa                          eax_4 = 0
0041bbfc                          break
0041bbfc                      
0041bbe6                      edx_1 = eax_2[1]
0041bbeb                      char temp3_1 = esi_1[1]
0041bbeb                      c_1 = edx_1 u< temp3_1
0041bbeb                      
0041bbee                      if (edx_1 == temp3_1)
0041bbf0                          eax_2 = &eax_2[2]
0041bbf3                          esi_1 = &esi_1[2]
0041bbf3                          
0041bbf8                          if (edx_1 != 0)
0041bbf8                              continue
0041bbf8                          
0041bbfa                          eax_4 = 0
0041bbfc                          break
0041bbfc                  
0041bbfe                  bool c_2 = unimplemented  {sbb eax, eax}
0041bc00                  eax_4 = sbb.d(sbb.d(eax_2, eax_2, c_1), 0xffffffff, c_2)
0041bc00                  break
0041bc00              
0041bc05              int16_t top
0041bc05              
0041bc05              if (eax_4 != 0)
0041bca1                  int32_t eax_7 = sub_41ba60(eax, &var_c, ebp_1)
0041bca1                  top -= 1
0041bca1                  unimplemented  {call sub_41ba60}
0041bca1                  
0041bcab                  if (eax_7 != 0)
0041bcad                      ebx = 1
0041bc05              else
0041bc0b                  int32_t i = 0xfffffff0
0041bc10                  int32_t var_1c_1 = 0xfffffff0
0041bc10                  
0041bc92                  do
0041bc14                      unimplemented  {fild st0, dword [esp+0x10]}
0041bc18                      int32_t j = 0xfffffff0
0041bc1d                      int32_t var_18_1 = 0xfffffff0
0041bc21                      float var_1c_2 =
0041bc21                          fconvert.s(unimplemented  {fstp dword [esp+0x10], st0})
0041bc21                      unimplemented  {fstp dword [esp+0x10], st0}
0041bc21                      
0041bc7a                      do
0041bc25                          unimplemented  {fld st0, dword [esp+0x10]}
0041bc29                          unimplemented  {fadd dword [esp+0x20]}
0041bc38                          var_c = fconvert.s(unimplemented  {fstp dword [esp+0x2c], st0})
0041bc38                          unimplemented  {fstp dword [esp+0x2c], st0}
0041bc3c                          unimplemented  {fild st0, dword [esp+0x20]}
0041bc40                          float var_18_2 =
0041bc40                              fconvert.s(unimplemented  {fst dword [esp+0x20], st0})
0041bc44                          unimplemented  {fadd dword [esp+0x30]}
0041bc48                          float var_8_1 =
0041bc48                              fconvert.s(unimplemented  {fstp dword [esp+0x30], st0})
0041bc48                          unimplemented  {fstp dword [esp+0x30], st0}
0041bc4c                          int32_t eax_5 = sub_41ba60(eax, &var_c, ebp_1)
0041bc4c                          top -= 1
0041bc4c                          unimplemented  {call sub_41ba60}
0041bc4c                          
0041bc56                          if (eax_5 != 0)
0041bc7e                              ebx = 1
0041bc83                              i = 0x3e7
0041bc83                              break
0041bc83                          
0041bc58                          unimplemented  {fld st0, dword [esp+0x20]}
0041bc5c                          unimplemented  {fsub st0, dword [esp+0x10]}
0041bc60                          j += 0x10
0041bc66                          var_c = fconvert.s(unimplemented  {fstp dword [esp+0x20], st0})
0041bc66                          unimplemented  {fstp dword [esp+0x20], st0}
0041bc6a                          unimplemented  {fld st0, dword [esp+0x24]}
0041bc6e                          unimplemented  {fsub st0, dword [esp+0x14]}
0041bc72                          int32_t j_1 = j
0041bc76                          float var_8_2 =
0041bc76                              fconvert.s(unimplemented  {fstp dword [esp+0x24], st0})
0041bc76                          unimplemented  {fstp dword [esp+0x24], st0}
0041bc7a                      while (j s<= 0x10)
0041bc7a                      
0041bc88                      i += 0x10
0041bc8e                      int32_t i_1 = i
0041bc92                  while (i s<= 0x10)
0041bc92          
0041bcbd          ebp_1 += 0x2c
0041bcc0          bool cond:1_1 = var_10 + 1 s< data_2584ecc
0041bcc2          var_10 += 1
0041bcc2          
0041bcc6          if (not(cond:1_1))
0041bcc6              break
0041bcc6  
0041bcd0  if (data_2584ecc s> 1 && ebx != 0)
0041bcf0      if (arg1[0x11] == 0)
0041bd10          return 1
0041bd10      
0041bcf7      sub_410030("WARNING: entity reached from out…")
0041bcf7      
0041bd04      if (arg1[0x11] == 0)
0041bd10          return 1
0041bcd0  else
0041bcd7      sub_410030("WARNING: no entities inside\n")
0041bcd7  
0041bce6  return 0

0041bd11                                                     90 90 90 90 90 90 90 90 90 90 90 90 90 90 90                   ...............

0041bd20    int32_t sub_41bd20(int32_t* arg1)

0041bd21  int32_t* esi = arg1
0041bd21  
0041bd28  while (*esi != 0xffffffff)
0041bd2e      sub_41bd20(esi[0xb])
0041bd33      esi = esi[0xc]
0041bd33  
0041bd43  if (esi[0x10] != 0)
0041bd7b      int32_t eax_6 = data_493f80 + 1
0041bd7c      data_493f80 = eax_6
0041bd81      return eax_6
0041bd81  
0041bd4f  if ((1 & esi[0xf].b) == 0)
0041bd58      data_493f68 += 1
0041bd63      esi[0xf] |= 1
0041bd67      return 1
0041bd67  
0041bd6e  int32_t eax_4 = data_493f54 + 1
0041bd6f  data_493f54 = eax_4
0041bd74  return eax_4

0041bd82        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0041bd90    int32_t* sub_41bd90(int32_t* arg1)

0041bd97  data_493f68 = 0
0041bd9c  data_493f80 = 0
0041bda1  data_493f54 = 0
0041bda6  sub_410030("------- FillOutside --------\n")
0041bdb0  sub_41bd20(arg1)
0041bdbb  int32_t var_c = data_493f54
0041bdc1  sub_410030("%5i solid leaves\n")
0041bdcc  int32_t var_14 = data_493f68
0041bdd2  sub_410030("%5i leaves filled\n")
0041bddc  int32_t var_1c = data_493f80
0041bdea  return sub_410030("%5i inside leaves\n")

0041bdeb                                   90 90 90 90 90                                                             .....

0041bdf0    int32_t* sub_41bdf0(void* arg1)

0041bdfe  int32_t result
0041bdfe  
0041bdfe  if (*(arg1 + 0x3c) != 0x8000)
0041be55      result = *(arg1 + 0x4c)
0041be55      
0041be5a      if (result == 0)
0041be5c          void* i = *(arg1 + 0x50)
0041be5f          result = data_493f74
0041be66          *(arg1 + 0x4c) = result
0041be69          int32_t ecx_3
0041be69          
0041be69          for (; i != 0; i = *(i + (ecx_3 << 2) + 0x28))
0041be72              ecx_3.b = *(i + 0x24) == arg1
0041be77              int32_t var_10_1 = ecx_3
0041be79              result = sub_41b030(i)
0041be79              
0041be83              if (result != 0)
0041be89                  int32_t edx_4
0041be89                  edx_4.b = ecx_3 == 0
0041be91                  result = sub_41bdf0(*(i + (edx_4 << 2) + 0x20))
0041bdfe  else
0041be03      int32_t esi_1 = data_493f74
0041be0c      result = **(*(arg1 + 0x38) + 0x24)
0041be11      int32_t edx_1 = result * 0xb
0041be1b      int32_t edx_2 = *((edx_1 << 2) + &data_256ee9c)
0041be1b      
0041be24      if (edx_2 != esi_1)
0041be26          int32_t edi_1 = *((edx_1 << 2) + &data_256eea0)
0041be26          
0041be2b          if (edi_1 != esi_1)
0041be2f              if (edi_1 != 0)
0041be31                  int32_t result_1 = result
0041be42                  return sub_410030("WARNING: areaportal entity %i to…")
0041be42              
0041be45              if (edx_2 == 0)
0041be4e                  *((edx_1 << 2) + &data_256ee9c) = esi_1
0041be54                  return result
0041be54              
0041be47              *((edx_1 << 2) + &data_256eea0) = esi_1
0041be47  
0041bea4  return result

0041bea5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0041beb0    int32_t* sub_41beb0(int32_t* arg1)

0041beb1  int32_t* esi = arg1
0041beb1  
0041beb8  while (*esi != 0xffffffff)
0041bebe      sub_41beb0(esi[0xb])
0041bec3      esi = esi[0xc]
0041bec3  
0041bece  int32_t* result = esi[0x13]
0041bece  
0041bed3  if (result == 0)
0041bed5      result = esi[0xf]
0041bed5      
0041bee8      if ((result.b & 1) == 0 && esi[0x10] != 0 && result != 0x8000)
0041bef2          data_493f74 += 1
0041bef8          return sub_41bdf0(esi)
0041bef8  
0041bf01  return result

0041bf02        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0041bf10    void sub_41bf10(int32_t* arg1)

0041bf11  int32_t* esi = arg1
0041bf11  
0041bf18  while (*esi != 0xffffffff)
0041bf1e      sub_41bf10(esi[0xb])
0041bf23      esi = esi[0xc]
0041bf23  
0041bf3c  if (esi[0xf] == 0x8000 && esi[0x13] == 0)
0041bf3e      void* ecx_1 = esi[0xe]
0041bf49      int32_t eax_3 = **(ecx_1 + 0x24) * 0xb
0041bf53      esi[0x13] = *((eax_3 << 2) + &data_256ee9c)
0041bf53      
0041bf66      if (*((eax_3 << 2) + &data_256eea0) == 0)
0041bf6d          int32_t var_8_2 = **(ecx_1 + 0x24)
0041bf73          sub_410030("WARNING: areaportal entity %i do…")

0041bf7d                                                                                         90 90 90                               ...

0041bf80    int32_t* sub_41bf80()

0041bf80  int32_t eax = data_493f74
0041bf80  
0041bf8a  if (eax s> 0x100)
0041bf91      sub_40f970("MAX_MAP_AREAS")
0041bf96      eax = data_493f74
0041bf96  
0041bf9f  int32_t i = 1
0041bfa9  data_2584e80 = eax + 1
0041bfaf  data_2584ea0 = 1
0041bfaf  
0041bfb5  if (eax s>= 1)
0041c03d      do
0041bfc8          int32_t j = 0
0041bfca          *(data_2584e8c + (i << 3) + 4) = data_2584ea0
0041bfca          
0041bfd5          if (data_2584ecc s> 0)
0041bfd7              void* ecx_1 = &data_256ee98
0041bfd7              
0041c021              do
0041bfdc                  int32_t edx_2 = *ecx_1
0041bfdc                  
0041bfe0                  if (edx_2 != 0)
0041bfed                      int32_t* eax_4 = data_2584ea4 + (data_2584ea0 << 3)
0041bfed                      
0041bff5                      if (*(ecx_1 + 4) == i)
0041bff7                          *eax_4 = edx_2
0041c008                          eax_4[1] = *(ecx_1 + 8)
0041c011                          data_2584ea0 += 1
0041bff5                      else if (*(ecx_1 + 8) == i)
0041c003                          *eax_4 = edx_2
0041c008                          eax_4[1] = *(ecx_1 + 4)
0041c011                          data_2584ea0 += 1
0041c011                  
0041c01b                  j += 1
0041c01c                  ecx_1 += 0x2c
0041c021              while (j s< data_2584ecc)
0041c021          
0041c023          int32_t eax_8 = data_2584e8c
0041c032          *(eax_8 + (i << 3)) = data_2584ea0 - *(eax_8 + (i << 3) + 4)
0041c03a          i += 1
0041c03d      while (i s<= data_493f74)
0041c03d  
0041c04a  int32_t __saved_ebx = data_2584e80
0041c050  sub_410030("%5i numareas\n")
0041c05b  int32_t var_10 = data_2584ea0
0041c06a  return sub_410030("%5i numareaportals\n")

0041c06b                                   90 90 90 90 90                                                             .....

0041c070    int32_t* sub_41c070(int32_t* arg1)

0041c076  sub_410030("--- FloodAreas ---\n")
0041c082  sub_41beb0(*arg1)
0041c08a  sub_41bf10(*arg1)
0041c095  int32_t var_14 = data_493f74
0041c0a4  return sub_410030("%5i areas\n")

0041c0a5                 90 90 90 90 90 90 90 90 90 90 90                                                       ...........

0041c0b0    void sub_41c0b0(void* arg1)

0041c0c0  void* esi = arg1 + 0x20
0041c0cc  int32_t eax_1 = sub_41af50(*(*(arg1 + 0x24) + 0x3c) ^ *(*(arg1 + 0x20) + 0x3c))
0041c0d4  int32_t var_4 = eax_1
0041c0d4  
0041c0da  if (eax_1 != 0)
0041c0e3      int32_t* edi_1 = nullptr
0041c0e6      int32_t* var_14_1 = nullptr
0041c0ea      int32_t ecx_2 = **(arg1 + 0x1c)
0041c0ec      float var_1c_1 = 0f
0041c0f4      int32_t var_10_1 = 0
0041c0ff      void* var_c_1 = esi
0041c1ca      bool cond:0_1
0041c1ca      
0041c1ca      do
0041c10e          void** ecx_4 = *(*esi + 0x38)
0041c113          void** var_18_1 = ecx_4
0041c113          
0041c117          if (ecx_4 != 0)
0041c11d              while (true)
0041c11d                  void* esi_1 = ecx_4[9]
0041c11d                  
0041c123                  if ((*(esi_1 + 8) & eax_1) != 0)
0041c125                      int32_t edi_2 = *(esi_1 + 0x2c)
0041c128                      int32_t edx_4 = 0
0041c128                      
0041c12c                      if (edi_2 s> 0)
0041c12e                          int32_t* ecx_5 = *(esi_1 + 0x30)
0041c12e                          
0041c13b                          while (true)
0041c13b                              if ((ecx_5[7].b & 4) == 0 && ecx_5[1] != 0xffffffff)
0041c143                                  int32_t eax_2
0041c143                                  eax_2.b = (*ecx_5).b & 0xfe
0041c143                                  
0041c147                                  if (eax_2 == ecx_2)
0041c1da                                      edi_1 = (edx_4 << 5) + *(esi_1 + 0x30)
0041c1da                                      break
0041c1da                                  
0041c154                                  int32_t ebx_3 = eax_2 * 7
0041c178                                  long double x87_r7_4 =
0041c178                                      fconvert.t(*((ebx_3 << 2) + &data_239e0c8))
0041c178                                      * fconvert.t(*(ecx_2 * 0x1c + &data_239e0c8))
0041c178                                      + fconvert.t(*((ebx_3 << 2) + &data_239e0c4))
0041c178                                      * fconvert.t(*(ecx_2 * 0x1c + &data_239e0c4))
0041c178                                      + fconvert.t(*((ebx_3 << 2) + &data_239e0c0))
0041c178                                      * fconvert.t(*(ecx_2 * 0x1c + &data_239e0c0))
0041c17a                                  long double temp0_1 = fconvert.t(var_1c_1)
0041c17a                                  x87_r7_4 - temp0_1
0041c17e                                  float* eax_3
0041c17e                                  eax_3.w = (x87_r7_4 < temp0_1 ? 1 : 0) << 8
0041c17e                                      | (is_unordered.t(x87_r7_4, temp0_1) ? 1 : 0) << 0xa
0041c17e                                      | (x87_r7_4 == temp0_1 ? 1 : 0) << 0xe | 0x3800
0041c17e                                  
0041c183                                  if ((eax_3:1.b & 0x41) == 0)
0041c185                                      var_1c_1 = fconvert.s(x87_r7_4)
0041c189                                      var_14_1 = ecx_5
0041c189                              
0041c191                              edx_4 += 1
0041c192                              ecx_5 = &ecx_5[8]
0041c192                              
0041c197                              if (edx_4 s>= edi_2)
0041c199                                  eax_1 = var_4
0041c19d                                  ecx_4 = var_18_1
0041c19d                                  goto label_41c1a1
0041c19d                          
0041c197                          break
0041c197                  
0041c1a1                  label_41c1a1:
0041c1a1                  ecx_4 = *ecx_4
0041c1a5                  var_18_1 = ecx_4
0041c1a5                  
0041c1a9                  if (ecx_4 == 0)
0041c1af                      edi_1 = var_14_1
0041c1af                      goto label_41c1bc
0041c1af              
0041c1a9              break
0041c1a9          
0041c1bc          label_41c1bc:
0041c1bc          esi = var_c_1 + 4
0041c1bf          cond:0_1 = var_10_1 + 1 s< 2
0041c1c2          var_10_1 += 1
0041c1c6          var_c_1 = esi
0041c1ca      while (cond:0_1)
0041c1ca      
0041c1df      if (edi_1 == 0)
0041c1e6          sub_410030("WARNING: side not found for port…")
0041c1e6      
0041c1f2      *(arg1 + 0x34) = 1
0041c1f9      *(arg1 + 0x38) = edi_1

0041c203           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0041c210    void* sub_41c210(int32_t* arg1)

0041c212  int32_t* edi = arg1
0041c212  
0041c219  while (*edi != 0xffffffff)
0041c21f      sub_41c210(edi[0xb])
0041c224      edi = edi[0xc]
0041c224  
0041c22f  void* result = edi[0xf]
0041c22f  
0041c234  if (result != 0)
0041c23b      int32_t ecx_2
0041c23b      
0041c23b      for (void* i = edi[0x14]; i != 0; i = *(i + (ecx_2 << 2) + 0x28))
0041c241          result = *(i + 0x1c)
0041c248          int32_t ebx_1
0041c248          ebx_1.b = *(i + 0x20) == edi
0041c248          
0041c24d          if (result != 0)
0041c254              if (*(i + 0x34) == 0)
0041c257                  sub_41c0b0(i)
0041c257                  int16_t top = top - 1
0041c257                  unimplemented  {call sub_41c0b0}
0041c257              
0041c25f              result = *(i + 0x38)
0041c25f              
0041c264              if (result != 0)
0041c266                  *(result + 0x1c) |= 2
0041c266          
0041c26e          ecx_2.b = ebx_1 == 0
0041c26e  
0041c27c  return result

0041c27d                                                                                         90 90 90                               ...

0041c280    void* sub_41c280(int32_t* arg1, int32_t arg2, int32_t arg3)

0041c285  sub_410030("--- MarkVisibleSides ---\n")
0041c285  
0041c297  if (arg2 s< arg3)
0041c2a3      int32_t i_1 = arg3 - arg2
0041c2a5      void* edx_3 = arg2 * 0x34 + &data_4b6030
0041c2cc      int32_t i
0041c2cc      
0041c2cc      do
0041c2ac          int32_t j_1 = *(edx_3 - 4)
0041c2ac          
0041c2b1          if (j_1 s> 0)
0041c2b3              int32_t ecx_2 = 0
0041c2c6              int32_t j
0041c2c6              
0041c2c6              do
0041c2b5                  int32_t eax_1 = *edx_3
0041c2b7                  *(eax_1 + ecx_2 + 0x1c) &= 0xfffd
0041c2c2                  ecx_2 += 0x20
0041c2c5                  j = j_1
0041c2c5                  j_1 -= 1
0041c2c6              while (j != 1)
0041c2c6          
0041c2c8          edx_3 += 0x34
0041c2cb          i = i_1
0041c2cb          i_1 -= 1
0041c2cc      while (i != 1)
0041c2cc  
0041c2dd  return sub_41c210(*arg1)

0041c2de                                                                                            90 90                                ..

0041c2e0    int32_t sub_41c2e0(int32_t* arg1, float arg2)

0041c2e0  int32_t __saved_esi_1
0041c2e0  int32_t __saved_esi = __saved_esi_1
0041c2e5  float var_8 = arg2
0041c2f2  long double x87_r7_2 = fabs(fconvert.t(arg2) - sub_4103c0())
0041c2f4  long double temp0 = fconvert.t(0.001)
0041c2f4  x87_r7_2 - temp0
0041c2f4  
0041c2ff  if ((((x87_r7_2 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7_2, temp0) ? 1 : 0) << 0xa
0041c2ff          | (x87_r7_2 == temp0 ? 1 : 0) << 0xe):1.b & 1) == 0)
0041c32c      double var_c_1 = fconvert.d(fconvert.t(arg2))
0041c32f      void* var_10_1 = &data_42ee10
0041c33e      return sub_41e4d9(arg1, &data_42ee10)
0041c33e  
0041c301  float var_8_1 = arg2
0041c302  int16_t x87control
0041c302  long double st0_1
0041c302  st0_1, x87control = sub_4103c0()
0041c30c  int64_t var_c
0041c30c  var_c.d = __ftol(x87control, st0_1)
0041c311  void* var_10 = &data_42ee14
0041c320  return sub_41e4d9(arg1, &data_42ee14)

0041c33f                                                                                               90                                 .

0041c340    void sub_41c340(int32_t* arg1)

0041c345  int32_t* esi = arg1
0041c345  
0041c353  if (*esi != 0xffffffff && esi[9] == 0)
0041c359      sub_41c340(esi[0xb])
0041c362      sub_41c340(esi[0xc])
0041c36f      return 
0041c36f  
0041c374  if ((esi[0xf].b & 1) == 0)
0041c37f      int32_t edx_1
0041c37f      
0041c37f      for (float* i = esi[0x14]; i != 0; i = i[edx_1 + 0xa])
0041c38a          int32_t* edi_1 = i[0xc]
0041c391          edx_1.b = i[9] == esi
0041c391          
0041c3a3          if (edi_1 != 0 && i[8] == esi && sub_41afb0(i) != 0)
0041c3c5              float var_10
0041c3c5              float var_c
0041c3c5              sub_410940(edi_1, &var_c, &var_10)
0041c3e3              float var_8
0041c3e3              float var_4
0041c3e3              long double x87_r7_4 = fconvert.t(var_4) * fconvert.t(i[2])
0041c3e3                  + fconvert.t(var_8) * fconvert.t(i[1])
0041c3e3                  + fconvert.t(var_c) * fconvert.t(*i)
0041c3e5              long double temp0_1 = fconvert.t(0.98999999999999999)
0041c3e5              x87_r7_4 - temp0_1
0041c3f0              void* ecx_3
0041c3f0              
0041c3f0              if ((((x87_r7_4 < temp0_1 ? 1 : 0) << 8
0041c3f0                      | (is_unordered.t(x87_r7_4, temp0_1) ? 1 : 0) << 0xa
0041c3f0                      | (x87_r7_4 == temp0_1 ? 1 : 0) << 0xe):1.b & 1) == 0)
0041c401                  ecx_3 = i[8]
0041c407                  int32_t var_28_4 = *(i[9] i+ 0x48)
0041c3f0              else
0041c3f5                  ecx_3 = i[9]
0041c3fb                  int32_t var_28_3 = *(i[8] i+ 0x48)
0041c3fb              
0041c413              int32_t var_2c_2 = *(ecx_3 + 0x48)
0041c414              int32_t var_30_2 = *edi_1
0041c41b              sub_41e4d9(data_493f4c, "%i %i %i ")
0041c425              int32_t j = 0
0041c425              
0041c429              if (*edi_1 s> 0)
0041c42b                  void* esi_1 = &edi_1[2]
0041c42b                  
0041c488                  do
0041c43a                      sub_41e4d9(data_493f4c, &data_42b17c)
0041c44a                      sub_41c2e0(data_493f4c, *(esi_1 - 4))
0041c458                      sub_41c2e0(data_493f4c, *esi_1)
0041c468                      sub_41c2e0(data_493f4c, *(esi_1 + 4))
0041c478                      sub_41e4d9(data_493f4c, &data_42ee18)
0041c482                      j += 1
0041c483                      esi_1 += 0xc
0041c488                  while (j s< *edi_1)
0041c488                  
0041c48a                  esi = arg1
0041c48a              
0041c49a              sub_41e4d9(data_493f4c, &data_42b33c)

0041c4ba                                                                                90 90 90 90 90 90                            ......

0041c4c0    void sub_41c4c0(int32_t* arg1, int32_t arg2)

0041c4c1  int32_t* esi = arg1
0041c4c1  
0041c4cd  while (*esi != 0xffffffff)
0041c4cf      int32_t eax_1 = esi[0xb]
0041c4d4      esi[0x12] = arg2
0041c4d7      sub_41c4c0(eax_1, arg2)
0041c4dc      esi = esi[0xc]
0041c4dc  
0041c4eb  if ((esi[0xf].b & 1) != 0)
0041c4ed      esi[0x12] = 0xffffffff
0041c4f6      return 
0041c4f6  
0041c4f7  esi[0x12] = arg2

0041c4fd                                                                                         90 90 90                               ...

0041c500    void sub_41c500(int32_t* arg1)

0041c501  int32_t* esi = arg1
0041c501  
0041c509  if (*esi != 0xffffffff)
0041c515      while (esi[9] == 0)
0041c517          int32_t eax_1 = esi[0xb]
0041c51a          esi[0x12] = 0xffffff9d
0041c51e          sub_41c500(eax_1)
0041c523          esi = esi[0xc]
0041c523          
0041c52c          if (*esi == 0xffffffff)
0041c52c              break
0041c52c  
0041c532  if ((esi[0xf].b & 1) != 0)
0041c534      esi[0x12] = 0xffffffff
0041c53d      return 
0041c53d  
0041c546  sub_41c4c0(esi, data_493f50)
0041c555  data_493f50 += 1
0041c55b  void* i = esi[0x14]
0041c55b  
0041c560  while (i != 0)
0041c565      if (*(i + 0x20) != esi)
0041c57f          i = *(i + 0x2c)
0041c565      else
0041c572          if (sub_41afb0(i) != 0)
0041c574              data_493f44 += 1
0041c574          
0041c57a          i = *(i + 0x28)

0041c589                             90 90 90 90 90 90 90                                                           .......

0041c590    void sub_41c590(int32_t* arg1)

0041c591  int32_t* esi = arg1
0041c591  
0041c598  if (*esi != 0xffffffff)
0041c59f      while (esi[9] == 0)
0041c5a2          sub_41b400(esi)
0041c5a8          sub_41b540(esi)
0041c5b1          sub_41c590(esi[0xb])
0041c5b6          esi = esi[0xc]
0041c5b6          
0041c5bf          if (*esi == 0xffffffff)
0041c5bf              break

0041c5c3           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0041c5d0    int32_t sub_41c5d0(int32_t* arg1)

0041c5d1  int32_t* esi = arg1
0041c5d1  
0041c5d8  while (*esi != 0xffffffff)
0041c5de      sub_41c5d0(esi[0xb])
0041c5e3      esi = esi[0xc]
0041c5e3  
0041c606  *(data_2584e94 + data_493f48 * 0x1c + 4) = esi[0x12].w
0041c610  int32_t result = data_493f48 + 1
0041c611  data_493f48 = result
0041c616  return result

0041c617                                                                       90 90 90 90 90 90 90 90 90                         .........

0041c620    int32_t sub_41c620(int32_t* arg1)

0041c62d  sub_40fa00("--- WritePortalFile ---\n")
0041c639  int32_t* esi = *arg1
0041c63b  data_493f50 = 0
0041c646  data_493f44 = 0
0041c650  sub_41cd50(esi)
0041c656  sub_41b1e0(arg1)
0041c65c  sub_41c590(esi)
0041c662  sub_41c500(esi)
0041c667  int32_t var_420 = 0x279bf20
0041c676  void var_400
0041c676  sub_41e430(&var_400, "%s.prt")
0041c67f  void* var_42c = &var_400
0041c685  sub_41dc50("writing %s\n")
0041c694  int32_t* eax = sub_41df39(&var_400, U"w")
0041c69c  data_493f4c = eax
0041c69c  
0041c6a3  if (eax == 0)
0041c6a9      void* var_40c_1 = &var_400
0041c6af      sub_40f970("Error opening %s")
0041c6b4      eax = data_493f4c
0041c6b4  
0041c6bc  char* var_40c_2 = "PRT1"
0041c6c7  sub_41e4d9(eax, &data_42ee4c)
0041c6d8  int32_t var_418_1 = data_493f50
0041c6df  sub_41e4d9(data_493f4c, &data_42cc00)
0041c6ef  int32_t var_424 = data_493f44
0041c6f6  sub_41e4d9(data_493f4c, &data_42cc00)
0041c701  int32_t var_430 = data_493f50
0041c707  sub_40fa00("%5i visclusters\n")
0041c711  int32_t var_438_1 = data_493f44
0041c717  sub_40fa00("%5i visportals\n")
0041c71d  sub_41c340(esi)
0041c729  sub_41ddd2(data_493f4c)
0041c72f  data_493f48 = 1
0041c749  return sub_41c5d0(esi)

0041c74a                                90 90 90 90 90 90                                                            ......

0041c750    int32_t sub_41c750(char* arg1)

0041c750  int32_t edx_6 = data_493f40
0041c75c  int32_t ebx
0041c75c  int32_t var_40c = ebx
0041c75e  int32_t result = 0
0041c75e  
0041c764  if (edx_6 s> 0)
0041c766      void* edi_1 = &data_470f40
0041c766      
0041c76b      while (true)
0041c76b          char* eax_1 = arg1
0041c772          void* esi_1 = edi_1
0041c774          int32_t eax_3
0041c774          
0041c774          while (true)
0041c774              ebx.b = *eax_1
0041c778              char temp0_1 = *esi_1
0041c778              bool c_1 = ebx.b u< temp0_1
0041c778              
0041c77a              if (ebx.b == temp0_1)
0041c77e                  if (ebx.b == 0)
0041c794                      eax_3 = 0
0041c796                      break
0041c796                  
0041c780                  ebx.b = eax_1[1]
0041c785                  char temp3_1 = *(esi_1 + 1)
0041c785                  c_1 = ebx.b u< temp3_1
0041c785                  
0041c788                  if (ebx.b == temp3_1)
0041c78a                      eax_1 = &eax_1[2]
0041c78d                      esi_1 += 2
0041c78d                      
0041c792                      if (ebx.b != 0)
0041c792                          continue
0041c792                      
0041c794                      eax_3 = 0
0041c796                      break
0041c796              
0041c798              bool c_2 = unimplemented  {sbb eax, eax}
0041c79a              eax_3 = sbb.d(sbb.d(eax_1, eax_1, c_1), 0xffffffff, c_2)
0041c79a              break
0041c79a          
0041c79f          if (eax_3 == 0)
0041c8d5              return result
0041c8d5          
0041c7a5          result += 1
0041c7a6          edi_1 += 0x8c
0041c7a6          
0041c7ae          if (result s>= edx_6)
0041c7ae              break
0041c7ae  
0041c7b6  if (edx_6 == 0x400)
0041c7bd      sub_40f970("MAX_MAP_TEXTURES")
0041c7bd  
0041c7c5  char* edi_2 = arg1
0041c7d5  int32_t i = 0xffffffff
0041c7dd  int32_t ebx_2 = result * 0x8c
0041c7dd  
0041c7e0  while (i != 0)
0041c7e0      bool cond:1_1 = 0 != *edi_2
0041c7e0      edi_2 = &edi_2[1]
0041c7e0      i -= 1
0041c7e0      
0041c7e0      if (not(cond:1_1))
0041c7e0          break
0041c7e0  
0041c7e2  int32_t ecx_1 = not.d(i)
0041c7f9  int32_t esi_3
0041c7f9  int32_t edi_5
0041c7f9  edi_5, esi_3 =
0041c7f9      __builtin_memcpy(dest: ebx_2 + &data_470f40, src: edi_2 - ecx_1, n: ecx_1 u>> 2 << 2)
0041c800  __builtin_memcpy(dest: edi_5, src: esi_3, n: ecx_1 & 3)
0041c809  char* var_41c_1 = arg1
0041c80a  int32_t var_420_1 = 0x255e9a0
0041c815  void var_400
0041c815  sub_41e430(&var_400, "%stextures/%s.wal")
0041c82f  void* var_408
0041c82f  
0041c82f  if (sub_40fd50(&var_400, &var_408) != 0xffffffff)
0041c839      int32_t eax_9 = sub_40ff30(*(var_408 + 0x60))
0041c83e      void* ecx_7 = var_408
0041c842      *(ebx_2 + 0x470f84) = eax_9
0041c851      *(ebx_2 + 0x470f80) = sub_40ff30(*(ecx_7 + 0x58))
0041c85f      int32_t eax_12 = sub_40ff30(*(var_408 + 0x5c))
0041c864      void* edx_3 = var_408
0041c868      *(ebx_2 + 0x470f88) = eax_12
0041c86e      int32_t i_1 = 0xffffffff
0041c873      void* edi_6 = edx_3 + 0x38
0041c873      
0041c87c      while (i_1 != 0)
0041c87c          bool cond:3_1 = 0 != *edi_6
0041c87c          edi_6 += 1
0041c87c          i_1 -= 1
0041c87c          
0041c87c          if (not(cond:3_1))
0041c87c              break
0041c87c      
0041c87e      int32_t ecx_9 = not.d(i_1)
0041c892      int32_t esi_6
0041c892      int32_t edi_9
0041c892      edi_9, esi_6 = __builtin_memcpy(dest: ebx_2 + &data_470f8c, src: edi_6 - ecx_9, 
0041c892          n: ecx_9 u>> 2 << 2)
0041c899      __builtin_memcpy(dest: edi_9, src: esi_6, n: ecx_9 & 3)
0041c89b      sub_41e29e(edx_3)
0041c89b  
0041c8b6  bool cond:2_1 = *(ebx_2 + &data_470f8c) == 0
0041c8b8  data_493f40 += 1
0041c8b8  
0041c8be  if (not(cond:2_1))
0041c8c1      sub_41c750(ebx_2 + &data_470f8c)
0041c8c1  
0041c8d5  return result

0041c8d6                                                                    90 90 90 90 90 90 90 90 90 90                        ..........

0041c8e0    void sub_41c8e0(float* arg1, int32_t* arg2, int32_t* arg3)

0041c8e0  int32_t ecx
0041c8e0  int32_t var_4_1 = ecx
0041c8e7  int32_t esi = 0
0041c8e9  float var_4 = 0f
0041c8f1  int32_t edx = 0
0041c8f1  
0041c92b  for (void* i = &data_42ee8c; i s< "xtures/%s.wal"; )
0041c90a      long double x87_r7_4 = fconvert.t(*(i + 4)) * fconvert.t(arg1[2])
0041c90a          + fconvert.t(*(i - 4)) * fconvert.t(*arg1) + fconvert.t(*i) * fconvert.t(arg1[1])
0041c90c      long double temp0_1 = fconvert.t(var_4)
0041c90c      x87_r7_4 - temp0_1
0041c90c      
0041c915      if ((((x87_r7_4 < temp0_1 ? 1 : 0) << 8
0041c915              | (is_unordered.t(x87_r7_4, temp0_1) ? 1 : 0) << 0xa
0041c915              | (x87_r7_4 == temp0_1 ? 1 : 0) << 0xe | 0x3800):1.b & 0x41) == 0)
0041c917          var_4 = fconvert.s(x87_r7_4)
0041c91b          esi = edx
0041c91b      
0041c921      i += 0x24
0041c924      edx += 1
0041c924  
0041c934  int32_t eax_2 = esi * 0x24
0041c93f  *arg2 = *(eax_2 + 0x42ee94)
0041c947  arg2[1] = *(eax_2 + 0x42ee98)
0041c950  arg2[2] = *(eax_2 + 0x42ee9c)
0041c95d  *arg3 = *(eax_2 + 0x42eea0)
0041c965  arg3[1] = *(eax_2 + 0x42eea4)
0041c96e  arg3[2] = *(eax_2 + 0x42eea8)

0041c973                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0041c980    int32_t sub_41c980(float* arg1, float* arg2, float* arg3)

0041c999  if (arg2[5].b == 0)
0041c9a7      return 0
0041c9a7  
0041c9b7  void s
0041c9b7  __builtin_memset(&s, c: 0, n: 0x4c)
0041c9b9  void* edi = &arg2[5]
0041c9bb  int32_t i = 0xffffffff
0041c9bb  
0041c9be  while (i != 0)
0041c9be      bool cond:0_1 = 0 != *edi
0041c9be      edi += 1
0041c9be      i -= 1
0041c9be      
0041c9be      if (not(cond:0_1))
0041c9be          break
0041c9be  
0041c9c0  int32_t ecx = not.d(i)
0041c9d1  void var_60
0041c9d1  int32_t esi_1
0041c9d1  int32_t edi_2
0041c9d1  edi_2, esi_1 = __builtin_memcpy(dest: &var_60, src: edi - ecx, n: ecx u>> 2 << 2)
0041c9df  __builtin_memcpy(dest: edi_2, src: esi_1, n: ecx & 3)
0041c9e8  float var_a8
0041c9e8  float var_9c
0041c9e8  sub_41c8e0(arg1, &var_a8, &var_9c)
0041c9f4  void* edx_1 = &arg2[3]
0041ca07  float var_a0
0041ca07  fconvert.t(var_a8) * fconvert.t(*arg3) + fconvert.t(var_a0) * fconvert.t(arg3[2])
0041ca0d  arg3[1]
0041ca2a  float var_98
0041ca2a  float var_94
0041ca2a  float var_8c = fconvert.s(fconvert.t(var_9c) * fconvert.t(*arg3)
0041ca2a      + fconvert.t(var_94) * fconvert.t(arg3[2])
0041ca2a      + fconvert.t(var_98) * fconvert.t(arg3[1]))
0041ca2e  long double x87_r6_8 = fconvert.t(*edx_1)
0041ca30  long double temp0 = fconvert.t(0f)
0041ca30  x87_r6_8 - temp0
0041ca36  float* eax_4
0041ca36  eax_4.w = (x87_r6_8 < temp0 ? 1 : 0) << 8
0041ca36      | (is_unordered.t(x87_r6_8, temp0) ? 1 : 0) << 0xa
0041ca36      | (x87_r6_8 == temp0 ? 1 : 0) << 0xe | 0x3800
0041ca36  
0041ca3b  if ((eax_4:1.b & 0x40) != 0)
0041ca3d      *edx_1 = 0x3f800000
0041ca3d  
0041ca43  long double x87_r6_9 = fconvert.t(arg2[4])
0041ca46  long double temp1 = fconvert.t(0f)
0041ca46  x87_r6_9 - temp1
0041ca4c  eax_4.w = (x87_r6_9 < temp1 ? 1 : 0) << 8
0041ca4c      | (is_unordered.t(x87_r6_9, temp1) ? 1 : 0) << 0xa
0041ca4c      | (x87_r6_9 == temp1 ? 1 : 0) << 0xe | 0x3800
0041ca4c  
0041ca51  if ((eax_4:1.b & 0x40) != 0)
0041ca53      arg2[4] = 0x3f800000
0041ca53  
0041ca5a  long double x87_r6_10 = fconvert.t(arg2[2])
0041ca5d  long double temp2 = fconvert.t(0f)
0041ca5d  x87_r6_10 - temp2
0041ca63  eax_4.w = (x87_r6_10 < temp2 ? 1 : 0) << 8
0041ca63      | (is_unordered.t(x87_r6_10, temp2) ? 1 : 0) << 0xa
0041ca63      | (x87_r6_10 == temp2 ? 1 : 0) << 0xe | 0x3800
0041ca68  long double x87_r5_4
0041ca68  long double x87_r6_11
0041ca68  
0041ca68  if ((eax_4:1.b & 0x40) != 0)
0041ca6a      x87_r6_11 = fconvert.t(0f)
0041ca70      x87_r5_4 = fconvert.t(1f)
0041ca68  else if (arg2[2] == 0x42b40000)
0041ca81      x87_r6_11 = fconvert.t(1f)
0041ca87      x87_r5_4 = fconvert.t(0f)
0041ca7f  else if (arg2[2] == 0x43340000)
0041ca98      x87_r6_11 = fconvert.t(0f)
0041ca9e      x87_r5_4 = fconvert.t(-1f)
0041ca96  else if (arg2[2] != 0x43870000)
0041cac6      long double x87_r6_14 =
0041cac6          fconvert.t(arg2[2]) * fconvert.t(0.00555555569f) * fconvert.t(3.1415926535897931)
0041cacc      float var_ac_1 = fconvert.s(x87_r6_14)
0041cad0      long double st0_1
0041cad0      bool c2_3
0041cad0      st0_1, c2_3 = __fsin(x87_r6_14)
0041cad0      x87_r6_11 = st0_1
0041cad6      long double st0_2
0041cad6      bool c2_4
0041cad6      st0_2, c2_4 = __fcos(fconvert.t(var_ac_1))
0041cad6      x87_r5_4 = st0_2
0041caad  else
0041caaf      x87_r6_11 = fconvert.t(-1f)
0041cab5      x87_r5_4 = fconvert.t(0f)
0041cab5  
0041cad8  long double x87_r4 = fconvert.t(var_a8)
0041cadc  long double temp3 = fconvert.t(0f)
0041cadc  x87_r4 - temp3
0041cae2  eax_4.w = (x87_r4 < temp3 ? 1 : 0) << 8 | (is_unordered.t(x87_r4, temp3) ? 1 : 0) << 0xa
0041cae2      | (x87_r4 == temp3 ? 1 : 0) << 0xe | 0x2800
0041cae7  int32_t esi_2
0041cae7  
0041cae7  if ((eax_4:1.b & 0x40) != 0)
0041caed      float var_a4
0041caed      long double x87_r4_1 = fconvert.t(var_a4)
0041caf1      long double temp4_1 = fconvert.t(0f)
0041caf1      x87_r4_1 - temp4_1
0041caf7      esi_2 = 1
0041cafc      eax_4.w = (x87_r4_1 < temp4_1 ? 1 : 0) << 8
0041cafc          | (is_unordered.t(x87_r4_1, temp4_1) ? 1 : 0) << 0xa
0041cafc          | (x87_r4_1 == temp4_1 ? 1 : 0) << 0xe | 0x2800
0041cafc      
0041cb01      if ((eax_4:1.b & 0x40) != 0)
0041cb03          esi_2 = 2
0041cae7  else
0041cae9      esi_2 = 0
0041cae9  
0041cb08  long double x87_r4_2 = fconvert.t(var_9c)
0041cb0c  long double temp5 = fconvert.t(0f)
0041cb0c  x87_r4_2 - temp5
0041cb12  eax_4.w = (x87_r4_2 < temp5 ? 1 : 0) << 8
0041cb12      | (is_unordered.t(x87_r4_2, temp5) ? 1 : 0) << 0xa
0041cb12      | (x87_r4_2 == temp5 ? 1 : 0) << 0xe | 0x2800
0041cb17  int32_t eax_5
0041cb17  
0041cb17  if ((eax_4:1.b & 0x40) != 0)
0041cb1d      long double x87_r4_3 = fconvert.t(var_98)
0041cb21      long double temp6_1 = fconvert.t(0f)
0041cb21      x87_r4_3 - temp6_1
0041cb27      eax_4.w = (x87_r4_3 < temp6_1 ? 1 : 0) << 8
0041cb27          | (is_unordered.t(x87_r4_3, temp6_1) ? 1 : 0) << 0xa
0041cb27          | (x87_r4_3 == temp6_1 ? 1 : 0) << 0xe | 0x2800
0041cb2c      eax_5 = 1
0041cb2c      
0041cb31      if ((eax_4:1.b & 0x40) != 0)
0041cb33          eax_5 = 2
0041cb17  else
0041cb19      eax_5 = 0
0041cb19  
0041cb38  int32_t __saved_edi
0041cb38  void* ecx_4 = &(&__saved_edi)[eax_5 + 5]
0041cb3c  void* eax_6 = &(&__saved_edi)[esi_2 + 5]
0041cb40  int32_t i_6 = 2
0041cb68  int32_t i_1
0041cb68  
0041cb68  do
0041cb47      long double x87_r4_5 = x87_r6_11 * fconvert.t(*eax_6)
0041cb4b      long double x87_r3_2 = x87_r5_4 * fconvert.t(*ecx_4)
0041cb4d      eax_6 += 0xc
0041cb50      ecx_4 += 0xc
0041cb53      i_1 = i_6
0041cb53      i_6 -= 1
0041cb62      *(eax_6 - 0xc) = fconvert.s(x87_r5_4 * fconvert.t(*(eax_6 - 0xc))
0041cb62          - x87_r6_11 * fconvert.t(*(ecx_4 - 0xc)))
0041cb65      *(ecx_4 - 0xc) = fconvert.s(x87_r4_5 + x87_r3_2)
0041cb68  while (i_1 != 1)
0041cb6e  float* eax_7 = &var_a8
0041cb72  void* edi_3 = &s
0041cb76  int32_t i_5 = 2
0041cb99  int32_t i_2
0041cb99  
0041cb99  do
0041cb7b      void* ecx_5 = edi_3
0041cb7d      int32_t j_1 = 3
0041cb90      int32_t j
0041cb90      
0041cb90      do
0041cb84          long double x87_r6_17 = fconvert.t(*eax_7) / fconvert.t(*edx_1)
0041cb86          eax_7 = &eax_7[1]
0041cb89          ecx_5 += 4
0041cb8c          j = j_1
0041cb8c          j_1 -= 1
0041cb8d          *(ecx_5 - 4) = fconvert.s(x87_r6_17)
0041cb90      while (j != 1)
0041cb92      edx_1 += 4
0041cb95      edi_3 += 0x10
0041cb98      i_2 = i_5
0041cb98      i_5 -= 1
0041cb99  while (i_2 != 1)
0041cba9  int32_t ebx = 0
0041cbad  float var_7c = fconvert.s(x87_r5_4 + fconvert.t(*arg2))
0041cbc0  void* ebp_1 = &data_2585000
0041cbc5  int32_t var_ac_2 = 0
0041cbc9  float var_6c = fconvert.s(fconvert.t(var_8c) + fconvert.t(arg2[1]))
0041cbc9  
0041cbcd  if (data_2584ef0 s> 0)
0041cbe7      while (true)
0041cbe7          if (*(ebp_1 + 0x20) == arg2[0xd] && *(ebp_1 + 0x24) == arg2[0xe])
0041cbe9              int32_t ebx_1 = 0
0041cbeb              void* edi_4 = &s
0041cbeb              
0041cbf2              while (true)
0041cbf2                  if (ebx_1 s>= 2)
0041cd2e                      return var_ac_2
0041cd2e                  
0041cbf8                  void* esi_3 = &var_60
0041cbfc                  void* eax_11 = ebp_1 + 0x28
0041cbff                  int32_t eax_13
0041cbff                  float* ecx_8
0041cbff                  float* i_3
0041cbff                  
0041cbff                  while (true)
0041cbff                      i_3.b = *eax_11
0041cc01                      ecx_8.b = i_3.b
0041cc03                      char temp10_1 = *esi_3
0041cc03                      bool c_1 = i_3.b u< temp10_1
0041cc03                      
0041cc05                      if (i_3.b == temp10_1)
0041cc09                          if (ecx_8.b == 0)
0041cc1f                              eax_13 = 0
0041cc21                              break
0041cc21                          
0041cc0b                          i_3.b = *(eax_11 + 1)
0041cc0e                          ecx_8.b = i_3.b
0041cc10                          char temp13_1 = *(esi_3 + 1)
0041cc10                          c_1 = i_3.b u< temp13_1
0041cc10                          
0041cc13                          if (i_3.b == temp13_1)
0041cc15                              eax_11 += 2
0041cc18                              esi_3 += 2
0041cc18                              
0041cc1d                              if (ecx_8.b != 0)
0041cc1d                                  continue
0041cc1d                              
0041cc1f                              eax_13 = 0
0041cc21                              break
0041cc21                      
0041cc23                      bool c_2 = unimplemented  {sbb eax, eax}
0041cc25                      eax_13 = sbb.d(sbb.d(eax_11, eax_11, c_1), 0xffffffff, c_2)
0041cc25                      break
0041cc25                  
0041cc2a                  if (eax_13 != 0)
0041cc2a                      break
0041cc2a                  
0041cc32                  i_3 = nullptr
0041cc34                  ecx_8 = edi_4
0041cc34                  
0041cc4b                  do
0041cc38                      long double x87_r7_8 = fconvert.t(*(ebp_1 - &s + ecx_8))
0041cc3b                      long double temp14_1 = fconvert.t(*ecx_8)
0041cc3b                      x87_r7_8 - temp14_1
0041cc3b                      
0041cc42                      if ((((x87_r7_8 < temp14_1 ? 1 : 0) << 8
0041cc42                              | (is_unordered.t(x87_r7_8, temp14_1) ? 1 : 0) << 0xa
0041cc42                              | (x87_r7_8 == temp14_1 ? 1 : 0) << 0xe):1.b & 0x40) == 0)
0041cc42                          goto label_41cc53
0041cc42                      
0041cc44                      i_3 += 1
0041cc45                      ecx_8 = &ecx_8[1]
0041cc4b                  while (i_3 s< 4)
0041cc4b                  
0041cc4d                  ebx_1 += 1
0041cc4e                  edi_4 += 0x10
0041cc4e              
0041cc53              label_41cc53:
0041cc53              ebx = var_ac_2
0041cc53          
0041cc5c          ebx += 1
0041cc5d          ebp_1 += 0x4c
0041cc62          var_ac_2 = ebx
0041cc62          
0041cc66          if (ebx s>= data_2584ef0)
0041cc66              break
0041cc66  
0041cc6c  int32_t eax_16 = data_2584ef0
0041cc7c  __builtin_memcpy(dest: ebp_1, src: &s, n: 0x4c)
0041cc86  data_2584ef0 = eax_16 + 1
0041cca0  int32_t eax_20 = sub_41c750(&arg2[5]) * 0x23
0041cca3  int32_t ecx_11
0041cca3  ecx_11.b = *((eax_20 << 2) + &data_470f8c)
0041cca3  
0041ccb3  if (ecx_11.b == 0)
0041cd30      *(ebp_1 + 0x48) = 0xffffffff
0041cd42      return ebx
0041cd42  
0041cccf  void var_3c
0041cccf  __builtin_memcpy(dest: &var_3c, src: arg2, n: 0x3c)
0041ccd1  void* edi_6 = (eax_20 << 2) + &data_470f8c
0041ccd3  int32_t i_4 = 0xffffffff
0041ccd3  
0041ccd8  while (i_4 != 0)
0041ccd8      bool cond:6_1 = 0 != *edi_6
0041ccd8      edi_6 += 1
0041ccd8      i_4 -= 1
0041ccd8      
0041ccd8      if (not(cond:6_1))
0041ccd8          break
0041ccd8  
0041ccda  int32_t ecx_12 = not.d(i_4)
0041ccee  void var_28
0041ccee  int32_t esi_8
0041ccee  int32_t edi_8
0041ccee  edi_8, esi_8 = __builtin_memcpy(dest: &var_28, src: edi_6 - ecx_12, n: ecx_12 u>> 2 << 2)
0041ccfc  __builtin_memcpy(dest: edi_8, src: esi_8, n: ecx_12 & 3)
0041cd10  *(ebp_1 + 0x48) = sub_41c980(arg1, &var_3c, arg3)
0041cd1f  return ebx

0041cd43           90 90 90 90 90 90 90 90 90 90 90 90 90                                                     .............

0041cd50    void sub_41cd50(int32_t* arg1)

0041cd59  if (*arg1 != 0xffffffff)
0041cd5f      sub_41cd50(arg1[0xb])
0041cd68      sub_41cd50(arg1[0xc])
0041cd68  
0041cd70  void* i_1 = arg1[0x14]
0041cd70  
0041cd75  if (i_1 == 0)
0041cde3      arg1[0x14] = 0
0041cdec      return 
0041cdec  
0041cdda  void* i
0041cdda  
0041cdda  do
0041cd7f      int32_t eax_2
0041cd7f      eax_2.b = *(i_1 + 0x24) == arg1
0041cd84      i = *(i_1 + (eax_2 << 2) + 0x28)
0041cd8a      int32_t edx_2
0041cd8a      edx_2.b = eax_2 == 0
0041cd93      sub_41b0c0(i_1, *(i_1 + (edx_2 << 2) + 0x20))
0041cd98      void* eax_4 = *(i_1 + 0x30)
0041cd98      
0041cda0      if (eax_4 != 0)
0041cda3          uint32_t eax_5 = sub_410560(eax_4)
0041cdb3          data_430b68 += eax_5
0041cdb3      
0041cdba      uint32_t eax_6 = sub_410560(i_1)
0041cdc8      data_430b68 += eax_6
0041cdce      sub_41af00(i_1)
0041cdd6      i_1 = i
0041cdda  while (i != 0)
0041cdda  
0041cddc  arg1[0x14] = i

0041cded                                         90 90 90                                                               ...

0041cdf0    int32_t sub_41cdf0(int32_t* arg1)

0041cdf8  if (*arg1 != 0xffffffff)
0041cdfe      sub_41cdf0(arg1[0xb])
0041ce07      sub_41cdf0(arg1[0xc])
0041ce07  
0041ce10  int32_t* i_2 = arg1[0xe]
0041ce10  
0041ce16  if (i_2 != 0)
0041ce3b      int32_t* i
0041ce3b      
0041ce3b      do
0041ce18          i = *i_2
0041ce1b          uint32_t eax_2 = sub_410560(i_2)
0041ce29          data_430b68 += eax_2
0041ce2f          sub_406960(i_2)
0041ce37          i_2 = i
0041ce3b      while (i != 0)
0041ce3b  
0041ce3d  int32_t* i_3 = arg1[0xd]
0041ce3d  
0041ce42  if (i_3 != 0)
0041ce80      int32_t* i_1
0041ce80      
0041ce80      do
0041ce44          void* eax_3 = i_3[0xa]
0041ce47          i_1 = *i_3
0041ce47          
0041ce4b          if (eax_3 != 0)
0041ce4e              uint32_t eax_4 = sub_410560(eax_3)
0041ce5e              data_430b68 += eax_4
0041ce5e          
0041ce6f          data_430b68 += 0x84
0041ce74          sub_40ab10(i_3)
0041ce7c          i_3 = i_1
0041ce80      while (i_1 != 0)
0041ce80  
0041ce82  void* eax_7 = arg1[8]
0041ce82  
0041ce89  if (eax_7 != 0)
0041ce8c      uint32_t eax_8 = sub_410560(eax_7)
0041ce99      data_430b68 += eax_8
0041cea3      sub_406960(arg1[8])
0041cea3  
0041ceb2  if (data_42db3c == 1)
0041ceb4      data_279c380 -= 1
0041ceb4  
0041cebb  uint32_t eax_9 = sub_410560(arg1)
0041cec9  data_430b68 += eax_9
0041ced8  return sub_41e29e(arg1)

0041ced9                                                                             90 90 90 90 90 90 90                           .......

0041cee0    void sub_41cee0(int32_t* arg1)

0041cee7  if (arg1 != 0)
0041cee9      data_430b68 = 0
0041cef6      sub_41cd50(*arg1)
0041cefe      sub_41cdf0(*arg1)
0041cf04      uint32_t eax_2 = sub_410560(arg1)
0041cf12      data_430b68 += eax_2
0041cf18      sub_41e29e(arg1)
0041cf22      sub_410030("\nfreed ")
0041cf2e      sub_4105f0(data_430b68)
0041cf38      sub_410030(" of tree memory\n")

0041cf42        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0041cf50    void sub_41cf50(int32_t* arg1)

0041cf58  if (*arg1 != 0xffffffff)
0041cf62      sub_41cf50(arg1[0xb])
0041cf6b      sub_41cf50(arg1[0xc])
0041cf6b      
0041cf7a      if (data_279c334 == 0)
0041cf9c          label_41cf9c:
0041cf9c          
0041cfad          if ((*(arg1[0xb] + 0x3c) & 1) != 0 && (*(arg1[0xc] + 0x3c) & 1) != 0)
0041cfb8              if (arg1[0xd] != 0)
0041cfbf                  sub_40f970("node->faces seperating CONTENTS_…")
0041cfbf              
0041cfd9              if (*(arg1[0xb] + 0x34) != 0 || *(arg1[0xc] + 0x34) != 0)
0041cfe0                  sub_40f970("!node->faces with children")
0041cfe0              
0041cfe8              int32_t eax_5 = arg1[0xe]
0041cfeb              *arg1 = 0xffffffff
0041cff3              arg1[0xf] = 1
0041cffa              arg1[9] = 0
0041cffa              
0041d001              if (eax_5 != 0)
0041d008                  sub_40f970("PruneNodes: node->brushlist")
0041d008              
0041d013              void* edx_4 = arg1[0xb]
0041d019              arg1[0xe] = *(arg1[0xc] + 0x38)
0041d01c              int32_t* i_1 = *(edx_4 + 0x38)
0041d01c              
0041d021              if (i_1 != 0)
0041d031                  int32_t* i
0041d031                  
0041d031                  do
0041d026                      i = *i_1
0041d028                      *i_1 = arg1[0xe]
0041d02a                      arg1[0xe] = i_1
0041d02f                      i_1 = i
0041d031                  while (i != 0)
0041d031              
0041d037              sub_41e29e(arg1[0xb])
0041d040              sub_41e29e(arg1[0xc])
0041d050              data_470f2c += 2
0041cf7a      else if ((*(arg1[0xb] + 0x3c) & 0x20000000) == 0
0041cf7a              && (*(arg1[0xc] + 0x3c) & 0x20000000) == 0)
0041cf93          goto label_41cf9c

0041d057                                                                       90 90 90 90 90 90 90 90 90                         .........

0041d060    int32_t* sub_41d060(int32_t* arg1)

0041d065  sub_410030("------- Prune Nodes --------\n")
0041d06e  data_470f2c = 0
0041d079  sub_41cf50(arg1)
0041d084  int32_t var_c = data_470f2c
0041d092  return sub_410030("%5i pruned nodes\n")

0041d093                                                           90 90 90 90 90 90 90 90 90 90 90 90 90                     .............

0041d0a0    int32_t sub_41d0a0()

0041d0a0  int32_t result = data_255e0e8
0041d0a6  int32_t i = 0
0041d0a6  
0041d0aa  if (result s> 0)
0041d0ac      result = data_2584ef4
0041d0b2      void* esi_1 = &data_239e0c8
0041d0b2      
0041d10f      do
0041d0c3          int32_t* eax_1 = data_261d008 + result * 0x14
0041d0c6          *eax_1 = *(esi_1 - 8)
0041d0cb          eax_1[1] = *(esi_1 - 4)
0041d0d0          eax_1[2] = *esi_1
0041d0d6          eax_1[3] = *(esi_1 + 4)
0041d0dc          eax_1[4] = *(esi_1 + 8)
0041d0e4          result = data_2584ef4 + 1
0041d0ea          data_2584ef4 = result
0041d0ea          
0041d0ef          if (result s>= 0x10000)
0041d0f6              sub_40f970("MAX_MAP_PLANES")
0041d0fb              result = data_2584ef4
0041d0fb          
0041d109          i += 1
0041d10a          esi_1 += 0x1c
0041d10f      while (i s< data_255e0e8)
0041d10f  
0041d113  return result

0041d114                                                              90 90 90 90 90 90 90 90 90 90 90 90                      ............

0041d120    int32_t sub_41d120(void* arg1, void* arg2)

0041d121  void* esi = arg2
0041d12a  int32_t result
0041d12a  
0041d12a  while (true)
0041d12a      void* eax_1 = *(esi + 4)
0041d12a      
0041d12f      if (eax_1 == 0)
0041d135          result = *(esi + 8)
0041d135          
0041d13a          if (result == 0)
0041d13a              break
0041d13a          
0041d13e          sub_41d120(arg1, result)
0041d143          esi = *(esi + 0xc)
0041d12f      else
0041d131          esi = eax_1
0041d131  
0041d14b  int32_t esi_1 = *(esi + 0x24)
0041d14b  
0041d151  if (esi_1 != 0xffffffff)
0041d15d      if (esi_1 s< 0 || esi_1 s>= data_2584e9c)
0041d164          sub_40f970("Bad leafface")
0041d164      
0041d16c      int32_t ecx_1 = data_2584e84
0041d174      result.w = *(arg1 + 0x14)
0041d178      bool cond:0_1 = result != ecx_1
0041d178      
0041d17a      if (result s< ecx_1)
0041d182          int16_t* edx_2 = data_2584eb4 + (result << 1)
0041d182          
0041d194          do
0041d187              int32_t edi_1
0041d187              edi_1.w = *edx_2
0041d187              
0041d18c              if (edi_1 == esi_1)
0041d18c                  break
0041d18c              
0041d18e              result += 1
0041d18f              edx_2 = &edx_2[1]
0041d194          while (result s< ecx_1)
0041d194          
0041d196          cond:0_1 = result != ecx_1
0041d196      
0041d198      if (not(cond:0_1))
0041d1a0          if (ecx_1 s>= 0x10000)
0041d1a7              sub_40f970("MAX_MAP_LEAFFACES")
0041d1ac              ecx_1 = data_2584e84
0041d1ac          
0041d1ba          *(data_2584eb4 + (ecx_1 << 1)) = esi_1.w
0041d1c3          result = data_2584e84 + 1
0041d1c4          data_2584e84 = result
0041d1c4  
0041d1cb  return result

0041d1cc                                      90 90 90 90                                                              ....

0041d1d0    void* sub_41d1d0(int32_t arg1)

0041d1d0  int32_t eax = data_2584e88
0041d1d0  
0041d1da  if (eax s>= 0x10000)
0041d1e1      sub_40f970("MAX_MAP_LEAFS")
0041d1e6      eax = data_2584e88
0041d1e6  
0041d1fc  int32_t ebx = arg1
0041d205  int32_t* esi = data_2584e94 + eax * 0x1c
0041d208  data_2584e88 = eax + 1
0041d211  *esi = *(ebx + 0x3c)
0041d213  uint32_t ecx_1
0041d213  ecx_1.w = *(ebx + 0x48)
0041d217  esi[1].w = ecx_1.w
0041d21b  int32_t edx
0041d21b  edx.w = *(ebx + 0x4c)
0041d21f  *(esi + 6) = edx.w
0041d226  int16_t eax_3
0041d226  int16_t x87control
0041d226  int16_t x87control_1
0041d226  eax_3, x87control_1 = __ftol(x87control, fconvert.t(*(ebx + 8)))
0041d22b  esi[2].w = eax_3
0041d232  int16_t eax_4
0041d232  int16_t x87control_2
0041d232  eax_4, x87control_2 = __ftol(x87control_1, fconvert.t(*(ebx + 0xc)))
0041d237  *(esi + 0xa) = eax_4
0041d23e  int16_t eax_5
0041d23e  int16_t x87control_3
0041d23e  eax_5, x87control_3 = __ftol(x87control_2, fconvert.t(*(ebx + 0x10)))
0041d243  esi[3].w = eax_5
0041d24a  int16_t eax_6
0041d24a  int16_t x87control_4
0041d24a  eax_6, x87control_4 = __ftol(x87control_3, fconvert.t(*(ebx + 0x14)))
0041d24f  *(esi + 0xe) = eax_6
0041d256  int16_t eax_7
0041d256  int16_t x87control_5
0041d256  eax_7, x87control_5 = __ftol(x87control_4, fconvert.t(*(ebx + 0x18)))
0041d25b  esi[4].w = eax_7
0041d262  void* result
0041d262  int32_t edx_1
0041d262  result, edx_1 = __ftol(x87control_5, fconvert.t(*(ebx + 0x1c)))
0041d267  *(esi + 0x12) = result.w
0041d26b  result.w = data_2584ee4.w
0041d271  esi[6].w = result.w
0041d275  void** i = *(ebx + 0x38)
0041d278  int32_t edi = data_2584ee4
0041d278  
0041d280  for (; i != 0; i = *i)
0041d28c      if (edi s>= 0x10000)
0041d293          sub_40f970("MAX_MAP_LEAFBRUSHES")
0041d298          edi = data_2584ee4
0041d298      
0041d2af      int32_t eax_8
0041d2af      int32_t edx_2
0041d2af      edx_2:eax_8 = muls.dp.d(0x4ec4ec4f, i[9] - &data_4b6000)
0041d2b1      int32_t edx_3 = edx_2 s>> 4
0041d2b8      result.w = esi[6].w
0041d2c1      bool cond:2_1 = result != edi
0041d2c3      arg1 = edx_3 + (edx_3 u>> 0x1f)
0041d2c3      
0041d2c7      if (result s< edi)
0041d2cf          ecx_1 = data_255ee4c + (result << 1)
0041d2cf          
0041d2e3          do
0041d2d4              edx_1.w = *ecx_1
0041d2d4              
0041d2db              if (edx_1 == arg1)
0041d2db                  break
0041d2db              
0041d2dd              result += 1
0041d2de              ecx_1 += 2
0041d2e3          while (result s< edi)
0041d2e3          
0041d2e5          cond:2_1 = result != edi
0041d2e5      
0041d2e7      if (not(cond:2_1))
0041d2ee          ecx_1.w = arg1.w
0041d2f3          *(data_255ee4c + (edi << 1)) = ecx_1.w
0041d2fd          edi = data_2584ee4 + 1
0041d2fe          data_2584ee4 = edi
0041d2fe  
0041d30f  edi.w -= esi[6].w
0041d313  result.b = *esi
0041d317  *(esi + 0x1a) = edi.w
0041d317  
0041d31b  if ((result.b & 1) == 0)
0041d31d      edx_1.w = data_2584e84.w
0041d324      esi[5].w = edx_1.w
0041d32d      int32_t eax_9
0041d32d      
0041d32d      for (void* i_1 = *(ebx + 0x50); i_1 != 0; i_1 = *(i_1 + (eax_9 << 2) + 0x28))
0041d336          eax_9.b = *(i_1 + 0x24) == ebx
0041d33b          result = *(i_1 + (eax_9 << 2) + 0x3c)
0041d33b          
0041d341          if (result != 0)
0041d345              result, ecx_1 = sub_41d120(esi, result)
0041d345      
0041d355      ecx_1.w = data_2584e84.w
0041d35c      ecx_1.w -= esi[5].w
0041d360      *(esi + 0x16) = ecx_1.w
0041d360  
0041d368  return result

0041d369                             90 90 90 90 90 90 90                                                           .......

0041d370    int32_t sub_41d370(void* arg1)

0041d375  int32_t result = *(arg1 + 0x2c)
0041d378  *(arg1 + 0x24) = 0xffffffff
0041d378  
0041d382  if (result s>= 3)
0041d388      result = *(arg1 + 4)
0041d388      
0041d38d      if (result == 0)
0041d393          result = *(arg1 + 8)
0041d393          
0041d398          if (result == 0)
0041d39e              result = *(arg1 + 0xc)
0041d39e              
0041d3a3              if (result == 0)
0041d3ae                  *(arg1 + 0x24) = data_2584e9c
0041d3b1                  int32_t ecx_1 = data_2584e9c
0041d3b1                  
0041d3bd                  if (ecx_1 s>= 0x10000)
0041d3c4                      sub_40f970("numfaces == MAX_MAP_FACES")
0041d3c9                      ecx_1 = data_2584e9c
0041d3c9                  
0041d3d2                  int32_t eax_1 = data_2584eac
0041d3db                  data_2584e9c = ecx_1 + 1
0041d3e1                  int32_t ecx_2
0041d3e1                  ecx_2.w = *(arg1 + 0x1c)
0041d3e5                  int16_t* eax_2 = eax_1 + ecx_1 * 0x14
0041d3ee                  *eax_2 = ecx_2.w & 0xfffe
0041d3f1                  int32_t edx_1
0041d3f1                  edx_1.b = *(arg1 + 0x1c)
0041d3f7                  eax_2[1] = edx_1.w & 1
0041d401                  *(eax_2 + 4) = data_2584ed0
0041d408                  eax_2[4] = *(arg1 + 0x2c)
0041d40c                  int32_t ecx_4
0041d40c                  ecx_4.w = *(arg1 + 0x14)
0041d410                  eax_2[5] = ecx_4.w
0041d414                  int32_t ecx_5 = *(arg1 + 0x2c)
0041d417                  result = 0
0041d417                  
0041d41b                  if (ecx_5 s> 0)
0041d420                      void* ebx_1 = arg1 + 0x34
0041d420                      
0041d47d                      do
0041d434                          int32_t eax_6 = sub_40ab40((*ebx_1).w, 
0041d434                              (*(arg1 + (mods.dp.d(sx.q(result + 1), ecx_5) << 2) + 0x34))
0041d434                                  .w, 
0041d434                              arg1)
0041d434                          
0041d448                          if (data_2584ed0 s>= 0x3e800)
0041d44f                              sub_40f970("numsurfedges == MAX_MAP_SURFEDGE…")
0041d44f                          
0041d463                          result += 1
0041d465                          ebx_1 += 4
0041d468                          *(data_2584ed8 + (data_2584ed0 << 2)) = eax_6
0041d472                          data_2584ed0 += 1
0041d478                          ecx_5 = *(arg1 + 0x2c)
0041d47d                      while (result s< ecx_5)
0041d47d  
0041d483  return result

0041d484              90 90 90 90 90 90 90 90 90 90 90 90                                                      ............

0041d490    int32_t sub_41d490(int32_t* arg1)

0041d490  int32_t __saved_esi_1
0041d490  int32_t __saved_esi = __saved_esi_1
0041d490  
0041d498  if (*arg1 == 0xffffffff)
0041d49b      sub_41d1d0(arg1)
0041d4ab      return neg.d(data_2584e88)
0041d4ab  
0041d4ac  int32_t eax_2 = data_2584eb8
0041d4ac  
0041d4b6  if (eax_2 == 0x10000)
0041d4bd      sub_40f970("MAX_MAP_NODES")
0041d4c2      eax_2 = data_2584eb8
0041d4c2  
0041d4ca  int32_t edx = data_2584ebc
0041d4da  int32_t ebx
0041d4da  int32_t var_8_3 = ebx
0041d4db  int32_t ebp
0041d4db  int32_t var_c = ebp
0041d4dc  data_2584eb8 = eax_2 + 1
0041d4e1  int32_t edi
0041d4e1  int32_t var_10 = edi
0041d4e1  int32_t* esp_1 = &var_10
0041d4e5  int32_t* edi_1 = edx + eax_2 * 0x1c
0041d4e8  int16_t eax_4
0041d4e8  int16_t x87control
0041d4e8  int16_t x87control_1
0041d4e8  eax_4, x87control_1 = __ftol(x87control, fconvert.t(arg1[2]))
0041d4ed  edi_1[3].w = eax_4
0041d4f4  int16_t eax_5
0041d4f4  int16_t x87control_2
0041d4f4  eax_5, x87control_2 = __ftol(x87control_1, fconvert.t(arg1[3]))
0041d4f9  *(edi_1 + 0xe) = eax_5
0041d500  int16_t eax_6
0041d500  int16_t x87control_3
0041d500  eax_6, x87control_3 = __ftol(x87control_2, fconvert.t(arg1[4]))
0041d505  edi_1[4].w = eax_6
0041d50c  int16_t eax_7
0041d50c  int16_t x87control_4
0041d50c  eax_7, x87control_4 = __ftol(x87control_3, fconvert.t(arg1[5]))
0041d511  *(edi_1 + 0x12) = eax_7
0041d518  int16_t eax_8
0041d518  int16_t x87control_5
0041d518  eax_8, x87control_5 = __ftol(x87control_4, fconvert.t(arg1[6]))
0041d51d  edi_1[5].w = eax_8
0041d529  *(edi_1 + 0x16) = __ftol(x87control_5, fconvert.t(arg1[7]))
0041d52d  int32_t eax_10 = *arg1
0041d537  *((eax_10 << 2) + &data_430f20) += 1
0041d540  int32_t eax_12 = *arg1 ^ 1
0041d552  *((eax_12 << 2) + &data_430f20) += 1
0041d554  void* eax_13
0041d554  eax_13.b = *arg1
0041d554  
0041d558  if ((eax_13.b & 1) != 0)
0041d55a      char* var_14_1 = "WriteDrawNodes_r: odd planenum"
0041d55f      sub_40f970("WriteDrawNodes_r: odd planenum")
0041d564      esp_1 = &var_10
0041d564  
0041d569  *edi_1 = *arg1
0041d572  edi_1[6].w = data_2584e9c.w
0041d572  
0041d57b  if (arg1[0xd] != 0)
0041d585      data_470f24 += 1
0041d57b  else
0041d57d      data_470f20 += 1
0041d57d  
0041d58b  int32_t* i = arg1[0xd]
0041d58b  
0041d590  while (i != 0)
0041d593      sub_41d370(i)
0041d598      i = *i
0041d59a      esp_1 = &var_10
0041d59a  
0041d5a1  int32_t eax_14
0041d5a1  eax_14.w = data_2584e9c.w
0041d5a7  void* ebx_3 = &edi_1[1]
0041d5aa  eax_14.w -= edi_1[6].w
0041d5ae  void* esi_1 = &arg1[0xb]
0041d5b1  int32_t i_2 = 2
0041d5b6  *(edi_1 + 0x1a) = eax_14.w
0041d5f1  int32_t i_1
0041d5f1  
0041d5f1  do
0041d5bf      void* esp_2
0041d5bf      
0041d5bf      if (**esi_1 != 0xffffffff)
0041d5dd          *ebx_3 = data_2584eb8
0041d5e1          *(esp_1 - 4) = *esi_1
0041d5e2          sub_41d490()
0041d5e2          esp_2 = esp_1
0041d5bf      else
0041d5cb          *ebx_3 = 0xffffffff - data_2584e88
0041d5cf          *(esp_1 - 4) = *esi_1
0041d5cf          esp_2 = esp_1 - 4
0041d5d0          sub_41d1d0()
0041d5d0      
0041d5e7      esp_1 = esp_2 + 4
0041d5ea      ebx_3 += 4
0041d5ed      esi_1 += 4
0041d5f0      i_1 = i_2
0041d5f0      i_2 -= 1
0041d5f1  while (i_1 != 1)
0041d606  *esp_1
0041d606  esp_1[1]
0041d60c  esp_1[2]
0041d610  esp_1[3]
0041d614  return (edi_1 - data_2584ebc) s/ 0x1c

0041d615                                                                 90 90 90 90 90 90 90 90 90 90 90                       ...........

0041d620    int32_t sub_41d620(int32_t* arg1)

0041d629  data_470f20 = 0
0041d62e  data_470f24 = 0
0041d633  sub_40fa00("--- WriteBSP ---\n")
0041d63c  int32_t esi = data_2584e9c
0041d654  int32_t* var_14 = arg1
0041d65b  *(data_2584e90 * 0x30 + data_2584ec0 + 0x24) = sub_41d490(arg1)
0041d65f  sub_41bf80()
0041d669  int32_t var_18 = data_470f24
0041d66f  sub_40fa00("%5i nodes with faces\n")
0041d67a  int32_t var_20 = data_470f20
0041d680  sub_40fa00("%5i nodes without faces\n")
0041d68d  int32_t var_28 = data_2584e9c - esi
0041d69d  return sub_40fa00("%5i faces\n")

0041d69e                                                                                            90 90                                ..

0041d6a0    int32_t sub_41d6a0()

0041d6a0  int32_t result = data_2584ecc
0041d6a9  int32_t ebx = 1
0041d6b1  int32_t edi = 1
0041d6b1  
0041d6b3  if (result s> 1)
0041d6b6      void* esi_1 = &data_256eeac
0041d6b6      
0041d6f1      do
0041d6c0          if (*(esi_1 + 0x10) != 0)
0041d6c2              int32_t var_1c_1 = edi
0041d6cd              void var_c
0041d6cd              sub_41e430(&var_c, &data_42f154)
0041d6d6              edi += 1
0041d6de              sub_40e600(esi_1, "model", &var_c)
0041d6de          
0041d6e6          result = data_2584ecc
0041d6eb          ebx += 1
0041d6ec          esi_1 += 0x2c
0041d6f1      while (ebx s< result)
0041d6f1  
0041d6f9  return result

0041d6fa                                                                                90 90 90 90 90 90                            ......

0041d700    int32_t sub_41d700()

0041d70c  int32_t result = 1
0041d713  int32_t var_818 = 0
0041d71b  int32_t result_1 = 1
0041d71b  
0041d71f  if (data_2584ecc s> 1)
0041d728      void* esi_1 = &data_256eeac
0041d72e      void* var_814_1 = &data_256eeac
0041d72e      
0041d745      while (true)
0041d74f          if (sub_40fb50(sub_40e6a0(esi_1, "classname"), "light", 5) == 0)
0041d75b              char* eax_2 = sub_40e6a0(esi_1, "targetname")
0041d75b              
0041d768              if (*eax_2 != 0)
0041d772                  int32_t ebp_1 = 0
0041d772                  
0041d776                  if (var_818 s> 0)
0041d778                      void var_800
0041d778                      void* edi_1 = &var_800
0041d778                      
0041d77c                      while (true)
0041d77c                          char* esi_2 = eax_2
0041d77e                          void* eax_4 = edi_1
0041d780                          int32_t eax_6
0041d780                          
0041d780                          while (true)
0041d780                              char edx_1 = *eax_4
0041d784                              char temp0_1 = *esi_2
0041d784                              bool c_1 = edx_1 u< temp0_1
0041d784                              
0041d786                              if (edx_1 == temp0_1)
0041d78a                                  if (edx_1 == 0)
0041d7a0                                      eax_6 = 0
0041d7a2                                      break
0041d7a2                                  
0041d78c                                  edx_1 = *(eax_4 + 1)
0041d791                                  char temp3_1 = esi_2[1]
0041d791                                  c_1 = edx_1 u< temp3_1
0041d791                                  
0041d794                                  if (edx_1 == temp3_1)
0041d796                                      eax_4 += 2
0041d799                                      esi_2 = &esi_2[2]
0041d799                                      
0041d79e                                      if (edx_1 != 0)
0041d79e                                          continue
0041d79e                                      
0041d7a0                                      eax_6 = 0
0041d7a2                                      break
0041d7a2                              
0041d7a4                              bool c_2 = unimplemented  {sbb eax, eax}
0041d7a6                              eax_6 = sbb.d(sbb.d(eax_4, eax_4, c_1), 0xffffffff, c_2)
0041d7a6                              break
0041d7a6                          
0041d7ab                          if (eax_6 == 0)
0041d7ab                              break
0041d7ab                          
0041d7b1                          ebp_1 += 1
0041d7b2                          edi_1 += 0x40
0041d7b2                          
0041d7b7                          if (ebp_1 s>= var_818)
0041d7b7                              break
0041d7b7                  
0041d7bf                  if (ebp_1 == var_818)
0041d7c4                      if (var_818 == 0x20)
0041d7cb                          sub_40f970("stylenum == MAX_SWITCHED_LIGHTS")
0041d7cb                      
0041d7d5                      char* edi_2 = eax_2
0041d7da                      int32_t i = 0xffffffff
0041d7da                      
0041d7e3                      while (i != 0)
0041d7e3                          bool cond:2_1 = 0 != *edi_2
0041d7e3                          edi_2 = &edi_2[1]
0041d7e3                          i -= 1
0041d7e3                          
0041d7e3                          if (not(cond:2_1))
0041d7e3                              break
0041d7e3                      
0041d7e5                      int32_t ecx_2 = not.d(i)
0041d7f2                      int32_t __saved_edi
0041d7f2                      int32_t esi_4
0041d7f2                      int32_t edi_5
0041d7f2                      edi_5, esi_4 = __builtin_memcpy(
0041d7f2                          dest: &(&__saved_edi)[ebp_1 * 0x10 + 0xa], src: edi_2 - ecx_2, 
0041d7f2                          n: ecx_2 u>> 2 << 2)
0041d7fe                      __builtin_memcpy(dest: edi_5, src: esi_4, n: ecx_2 & 3)
0041d800                      var_818 += 1
0041d800                  
0041d80b                  int32_t var_82c_1 = ebp_1 + 0x20
0041d812                  void var_80c
0041d812                  sub_41e430(&var_80c, &data_42e7ec)
0041d817                  esi_1 = var_814_1
0041d826                  sub_40e600(esi_1, "style", &var_80c)
0041d826          
0041d838          result = result_1 + 1
0041d839          esi_1 += 0x2c
0041d83e          result_1 = result
0041d842          var_814_1 = esi_1
0041d842          
0041d846          if (result s>= data_2584ecc)
0041d846              break
0041d846  
0041d856  return result

0041d857                                                                       90 90 90 90 90 90 90 90 90                         .........

0041d860    int32_t sub_41d860()

0041d863  int32_t i = data_dde044
0041d86c  data_255ee48 = 0
0041d872  data_2584ec8 = i
0041d877  int32_t i_1 = 0
0041d877  
0041d87b  if (i s> 0)
0041d885      void* var_20_1 = nullptr
0041d889      void* ebx_1 = &data_4b602c
0041d889      
0041da4d      do
0041d89a          int32_t j = 0
0041d89c          int32_t* ebp_1 = var_20_1 + data_261d000
0041d89f          ebp_1[2] = *(ebx_1 - 0x24)
0041d8a7          *ebp_1 = data_255ee48
0041d8ac          ebp_1[1] = *ebx_1
0041d8ac          
0041d8b3          if (*ebx_1 s> 0)
0041d8b5              int32_t esi_1 = 0
0041d8b5              
0041d905              do
0041d8c1                  if (data_255ee48 == 0x10000)
0041d8c8                      sub_40f970("MAX_MAP_BRUSHSIDES")
0041d8c8                  
0041d8d6                  int32_t ecx_3 = data_255ee48
0041d8dc                  esi_1 += 0x20
0041d8df                  int16_t* eax_3 = data_2584ee0 + (ecx_3 << 2)
0041d8e3                  data_255ee48 = ecx_3 + 1
0041d8ec                  j += 1
0041d8ed                  int32_t edx_2
0041d8ed                  edx_2.w = *(*(ebx_1 + 4) + esi_1 - 0x20)
0041d8f2                  *eax_3 = edx_2.w
0041d8f8                  edx_2.w = *(*(ebx_1 + 4) + esi_1 - 0x1c)
0041d8fd                  eax_3[1] = edx_2.w
0041d905              while (j s< *ebx_1)
0041d905          
0041d90b          int32_t edi_1 = 0xffffffff
0041d90e          float var_c
0041d90e          float* var_24_1 = &var_c
0041d912          void* eax_5 = ebx_1 - 0xc
0041d915          void* var_28_1 = eax_5
0041d919          int32_t var_14_1 = 3
0041d921          int32_t var_18_1 = 0xffffffff
0041d921          
0041d93e          while (true)
0041d93e              int32_t edx_3 = data_430b54
0041d948              var_c = data_430b50
0041d952              int32_t var_8_1 = edx_3
0041d95a              int32_t var_4_1 = data_430b58
0041d961              *var_24_1 = fconvert.s(float.t(var_18_1))
0041d963              float var_1c_1
0041d963              
0041d963              if (edi_1 != 0xffffffff)
0041d972                  var_1c_1 = *eax_5
0041d963              else
0041d96a                  var_1c_1 = fconvert.s(fneg(fconvert.t(*(eax_5 - 0xc))))
0041d96a              
0041d97e              float var_3c_1 = var_1c_1
0041d980              int32_t j_1
0041d980              int32_t* edx_5
0041d980              j_1, edx_5 = sub_414ae0(&var_c)
0041d985              int32_t ecx_10 = *ebx_1
0041d98c              int32_t eax_7 = 0
0041d98c              
0041d990              if (ecx_10 s> 0)
0041d992                  edx_5 = *(ebx_1 + 4)
0041d992                  
0041d997                  while (*edx_5 != j_1)
0041d999                      eax_7 += 1
0041d99a                      edx_5 = &edx_5[8]
0041d99a                      
0041d99f                      if (eax_7 s>= ecx_10)
0041d99f                          break
0041d99f              
0041d9a3              if (eax_7 == ecx_10)
0041d9af                  if (data_255ee48 s>= 0x10000)
0041d9b6                      sub_40f970("MAX_MAP_BRUSHSIDES")
0041d9b6                  
0041d9c9                  *(data_2584ee0 + (data_255ee48 << 2)) = j_1.w
0041d9cd                  int32_t eax_9 = data_2584ee0
0041d9d2                  int32_t ecx_12 = data_255ee48
0041d9d8                  edx_5.w = *(eax_9 + (ecx_12 << 2) - 2)
0041d9dd                  *(eax_9 + (ecx_12 << 2) + 2) = edx_5.w
0041d9e9                  data_255ee48 += 1
0041d9f3                  ebp_1[1] += 1
0041d9f3              
0041d9f6              edi_1 += 2
0041d9fc              var_18_1 = edi_1
0041d9fc              
0041da00              if (edi_1 s<= 1)
0041d934                  eax_5 = var_28_1
0041da00              else
0041da1b                  var_24_1 = &var_24_1[1]
0041da1f                  bool cond:3_1 = var_14_1 != 1
0041da20                  var_28_1 += 4
0041da24                  var_14_1 -= 1
0041da24                  
0041da28                  if (not(cond:3_1))
0041da28                      break
0041da28                  
0041d927                  eax_5 = var_28_1
0041d92b                  edi_1 = 0xffffffff
0041d92e                  var_18_1 = 0xffffffff
0041d92e          
0041da3c          i = i_1 + 1
0041da3d          ebx_1 += 0x34
0041da45          i_1 = i
0041da49          var_20_1 += 0xc
0041da4d      while (i s< data_dde044)
0041da4d  
0041da5a  return i

0041da5b                                                                                   90 90 90 90 90                             .....

0041da60    int32_t sub_41da60()

0041da60  int32_t* ecx = data_2584e94
0041da68  data_2584e90 = 0
0041da6d  data_2584e9c = 0
0041da72  data_2584eb8 = 0
0041da77  data_255ee48 = 0
0041da7c  data_2584e84 = 0
0041da81  data_2584ee4 = 0
0041da86  data_2584ed0 = 0
0041da90  data_2584e98 = 1
0041da95  data_2584ee8 = 1
0041da9a  data_2584e88 = 1
0041da9f  *ecx = 1
0041daa1  return 1

0041daa2        90 90 90 90 90 90 90 90 90 90 90 90 90 90                                                    ..............

0041dab0    int32_t sub_41dab0()

0041dab0  sub_41d860()
0041dab5  sub_41d0a0()
0041daba  return sub_40e430() __tailcall

0041dabf                                                                                               90                                 .

0041dac0    void sub_41dac0()

0041dac0  int32_t eax = data_2584e90
0041dac0  
0041dacd  if (eax == 0x400)
0041dad4      sub_40f970("MAX_MAP_MODELS")
0041dad9      eax = data_2584e90
0041dad9  
0041daf3  int32_t* ebx_2 = eax * 0x30 + data_2584ec0
0041daf7  ebx_2[0xa] = data_2584e9c
0041daff  int32_t ecx_1 = data_2584e88
0041db05  int32_t edx = data_2584e98
0041db0b  data_279ba88 = data_2584e9c
0041db10  int32_t eax_3 = data_279befc
0041db15  data_470f28 = ecx_1
0041db1b  data_42ca44 = edx
0041db24  int32_t edx_1 = eax_3 * 0xb
0041db2b  int32_t edi = (&data_256ee8c)[edx_1]
0041db40  int32_t esi_1 = (&data_256ee90)[edx_1] + edi
0041db48  float var_18
0041db48  int32_t var_c
0041db48  sub_4104f0(&var_18, &var_c)
0041db48  
0041db52  if (edi s< esi_1)
0041db58      int32_t i_1 = esi_1 - edi
0041db5d      void* ebp_1 = edi * 0x34 + &data_4b6014
0041db95      int32_t i
0041db95      
0041db95      do
0041db69          if (*(ebp_1 + 0x18) != 0)
0041db76              sub_410520(ebp_1, &var_18, &var_c)
0041db89              sub_410520(ebp_1 + 0xc, &var_18, &var_c)
0041db89          
0041db91          ebp_1 += 0x34
0041db94          i = i_1
0041db94          i_1 -= 1
0041db95      while (i != 1)
0041db95  
0041db9d  *ebx_2 = var_18
0041dba3  int32_t var_14
0041dba3  ebx_2[1] = var_14
0041dbaa  int32_t var_10
0041dbaa  ebx_2[2] = var_10
0041dbb1  ebx_2[3] = var_c
0041dbb8  int32_t var_8
0041dbb8  ebx_2[4] = var_8
0041dbbf  int32_t var_4
0041dbbf  ebx_2[5] = var_4

0041dbc8                          90 90 90 90 90 90 90 90                                                          ........

0041dbd0    int32_t sub_41dbd0()

0041dbe1  void* eax_2 = data_2584e90 * 0x30 + data_2584ec0
0041dbec  *(eax_2 + 0x2c) = data_2584e9c - *(eax_2 + 0x28)
0041dbf4  int32_t result = data_2584e90 + 1
0041dbf5  data_2584e90 = result
0041dbfa  return result

0041dbfb                                                                                   90 90 90 90 90                             .....

0041dc00    int32_t sub_41dc00()

0041dc00  sub_41dc18()
0041dc0a  data_430b70 = sub_41fa5e()
0041dc0f  int32_t result = sub_41fa0e()
0041dc14  __fnclex()
0041dc16  return result


0041dc17    int32_t sub_41dc17() __pure

0041dc17  return 


0041dc18    int32_t sub_41dc18()

0041dc1d  data_42f32c = sub_41fae1
0041dc27  data_42f328 = sub_41fe37
0041dc2c  data_42f330 = sub_41fb47
0041dc36  data_42f334 = sub_41fa87
0041dc40  data_42f338 = sub_41fb2f
0041dc4a  data_42f33c = sub_41fe37
0041dc4f  return sub_41fe37


0041dc50    int32_t sub_41dc50(void* arg1)

0041dc5b  sub_41ff98(1, &data_42f360)
0041dc61  int32_t eax = sub_42000d(&data_42f360)
0041dc6c  void arg_8
0041dc6c  void* var_1c = &arg_8
0041dc72  int32_t result = sub_4200c4(&data_42f360, arg1)
0041dc7b  sub_42009a(eax, &data_42f360)
0041dc83  sub_41ffea(1, &data_42f360)
0041dc90  return result

0041dc91                                                     cc cc cc                                                       ...

0041dc94    int32_t __ftol(int16_t arg1 @ x87control, long double arg2 @ st0)

0041dc9b  int16_t x87status
0041dc9b  int16_t temp0
0041dc9b  temp0, x87status = __fnstcw_memmem16(arg1)
0041dca3  int16_t eax
0041dca3  eax:1.b = temp0:1.b | 0xc
0041dcaa  int16_t x87control
0041dcaa  int16_t x87status_1
0041dcaa  x87control, x87status_1 = __fldcw_memmem16(eax)
0041dcb0  int16_t x87control_1
0041dcb0  int16_t x87status_2
0041dcb0  x87control_1, x87status_2 = __fldcw_memmem16(temp0)
0041dcba  return int.q(arg2).d


0041dcbb    uint32_t sub_41dcbb(void* arg1, int32_t arg2, uint32_t arg3, int32_t* arg4)

0041dcc2  sub_41ff69(arg4)
0041dcd3  uint32_t result = sub_41dcea(arg1, arg2, arg3, arg4)
0041dcdd  sub_41ffbb(arg4)
0041dce9  return result


0041dcea    uint32_t sub_41dcea(void* arg1, int32_t arg2, uint32_t arg3, int32_t* arg4)

0041dced  int32_t ecx
0041dced  int32_t var_8 = ecx
0041dcf4  void* edi_1 = arg2 * arg3
0041dcf8  char* ebx = arg1
0041dcfb  void* ecx_1 = edi_1
0041dcff  void* var_8_1 = edi_1
0041dd02  arg1 = ecx_1
0041dd02  
0041dd05  if (edi_1 == 0)
0041dd07      return 0
0041dd07  
0041dd0e  int32_t* esi_1 = arg4
0041dd0e  
0041dd17  if ((esi_1[3].w & 0x10c) == 0)
0041dd21      arg4 = 0x1000
0041dd17  else
0041dd1c      arg4 = esi_1[6]
0041dd1c  
0041dd33  while (true)
0041dd33      void* eax_3
0041dd33      
0041dd33      if ((esi_1[3].w & 0x10c) != 0)
0041dd35          eax_3 = esi_1[1]
0041dd35      
0041dd3a      if ((esi_1[3].w & 0x10c) != 0 && eax_3 != 0)
0041dd3e          void* edi_2 = ecx_1
0041dd3e          
0041dd40          if (ecx_1 u>= eax_3)
0041dd42              edi_2 = eax_3
0041dd42          
0041dd48          sub_420bf0(ebx, *esi_1, edi_2)
0041dd4d          arg1 -= edi_2
0041dd50          esi_1[1] -= edi_2
0041dd53          *esi_1 += edi_2
0041dd58          ebx += edi_2
0041dd5a          edi_1 = var_8_1
0041dd3a      else if (ecx_1 u< arg4)
0041dd93          uint32_t eax_7 = sub_4208ce(esi_1)
0041dd93          
0041dd9c          if (eax_7 == 0xffffffff)
0041dd9c              break
0041dd9c          
0041dd9e          *ebx = eax_7.b
0041dda3          ebx = &ebx[1]
0041dda4          arg1 -= 1
0041dda7          arg4 = esi_1[6]
0041dd62      else
0041dd68          void* eax_4 = ecx_1
0041dd68          
0041dd6a          if (arg4 != 0)
0041dd73              eax_4 = ecx_1 - modu.dp.d(0:eax_4, arg4)
0041dd73          
0041dd7a          void* eax_6 = sub_4209aa(esi_1[4], ebx, eax_4)
0041dd7a          
0041dd84          if (eax_6 == 0)
0041ddbc              esi_1[3] |= 0x10
0041ddc0              break
0041ddc0          
0041dd89          if (eax_6 == 0xffffffff)
0041ddc2              esi_1[3] |= 0x20
0041ddc2              break
0041ddc2          
0041dd8b          arg1 -= eax_6
0041dd8e          ebx += eax_6
0041dd8e      
0041ddae      if (arg1 == 0)
0041ddb4          return arg3
0041ddb4      
0041dd2a      ecx_1 = arg1
0041dd2a  
0041ddbb  return divu.dp.d(0:(edi_1 - arg1), arg2)


0041ddd2    int32_t sub_41ddd2(int32_t* arg1)

0041ddd8  int32_t result = 0xffffffff
0041ddd8  
0041dddf  if ((arg1[3].b & 0x40) == 0)
0041dde8      sub_41ff69(arg1)
0041ddf4      result = sub_41de03(arg1)
0041ddf6      sub_41ffbb(arg1)
0041dddf  else
0041dde1      arg1[3] = 0
0041dde1  
0041de02  return result


0041de03    int32_t sub_41de03(int32_t* arg1)

0041de09  int32_t result = 0xffffffff
0041de09  
0041de10  if ((arg1[3].b & 0x83) != 0)
0041de19      result = sub_41eca1(arg1)
0041de1b      sub_421005(arg1)
0041de1b      
0041de2d      if (sub_420f25(arg1[4]) s>= 0)
0041de34          void* eax_3 = arg1[7]
0041de34          
0041de39          if (eax_3 != 0)
0041de3c              sub_41e29e(eax_3)
0041de41              arg1[7] = 0
0041de2d      else
0041de2f          result = 0xffffffff
0041de2f  
0041de46  arg1[3] = 0
0041de4e  return result


0041de4f    int32_t sub_41de4f(int32_t* arg1, void* arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)

0041de56  sub_41ff69(arg1)
0041de64  int32_t result = sub_41de7b(arg1, arg2, arg3)
0041de6e  sub_41ffbb(arg1)
0041de7a  return result


0041de7b    int32_t sub_41de7b(int32_t* arg1, void* arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)

0041de81  int32_t eax = arg1[3]
0041de81  
0041de86  if ((eax.b & 0x83) != 0)
0041de88      enum SET_FILE_POINTER_MOVE_METHOD edi_1 = arg3
0041de88      
0041de98      if (edi_1 == FILE_BEGIN || edi_1 == FILE_CURRENT || edi_1 == FILE_END)
0041de9a          eax.b &= 0xef
0041de9f          arg1[3] = eax
0041de9f          
0041dea2          if (edi_1 == FILE_CURRENT)
0041deaa              arg2 += sub_41e0a7(arg1)
0041deaf              edi_1 = FILE_BEGIN
0041deaf          
0041deb2          sub_41eca1(arg1)
0041deb7          int32_t eax_2 = arg1[3]
0041deb7          
0041debd          if ((eax_2.b & 0x80) != 0)
0041debf              eax_2.b &= 0xfc
0041dec1              arg1[3] = eax_2
0041debd          else if ((eax_2.b & 1) != 0 && (eax_2.b & 8) != 0 && (eax_2:1.b & 4) == 0)
0041ded3              arg1[6] = 0x200
0041ded3          
0041deef          int32_t ecx_3
0041deef          ecx_3.b = sub_421030(arg1[4], arg2, edi_1) != 0xffffffff
0041def3          return ecx_3 - 1
0041def3  
0041defc  *sub_41e9bd() = 0x16
0041df02  return 0xffffffff


0041df08    int32_t* sub_41df08(PSTR arg1, char* arg2, char arg3)

0041df09  int32_t* eax = sub_421278()
0041df09  
0041df12  if (eax == 0)
0041df15      return eax
0041df15  
0041df24  int32_t* eax_1 = sub_421108(arg1, arg2, arg3, eax)
0041df2c  sub_41ffbb(eax)
0041df38  return eax_1


0041df39    int32_t* sub_41df39(PSTR arg1, char* arg2)

0041df4b  return sub_41df08(arg1, arg2, 0x40)


0041df4c    uint32_t sub_41df4c(char* arg1, int32_t arg2, uint32_t arg3, int32_t* arg4)

0041df53  sub_41ff69(arg4)
0041df64  uint32_t result = sub_41df7b(arg1, arg2, arg3, arg4)
0041df6e  sub_41ffbb(arg4)
0041df7a  return result


0041df7b    uint32_t sub_41df7b(char* arg1, int32_t arg2, uint32_t arg3, int32_t* arg4)

0041df7e  int32_t ecx
0041df7e  int32_t var_8 = ecx
0041df85  uint32_t edi_1 = arg2 * arg3
0041df8c  uint32_t var_8_1 = edi_1
0041df94  uint32_t ebx = edi_1
0041df94  
0041df96  if (edi_1 == 0)
0041df98      return 0
0041df98  
0041df9f  int32_t* esi_1 = arg4
0041df9f  
0041dfa8  if ((esi_1[3].w & 0x10c) == 0)
0041dfb2      arg4 = 0x1000
0041dfa8  else
0041dfad      arg4 = esi_1[6]
0041dfad  
0041dfbc  uint32_t eax_12
0041dfbc  
0041dfbc  while (true)
0041dfbc      int32_t ecx_2 = esi_1[3] & 0x108
0041dfc2      uint32_t eax_3
0041dfc2      
0041dfc2      if (ecx_2 != 0)
0041dfc4          eax_3 = esi_1[1]
0041dfc4      
0041dfc9      if (ecx_2 != 0 && eax_3 != 0)
0041dfcd          uint32_t edi_2 = ebx
0041dfcd          
0041dfcf          if (ebx u>= eax_3)
0041dfd1              edi_2 = eax_3
0041dfd1          
0041dfd9          sub_420bf0(*esi_1, arg1, edi_2)
0041dfde          esi_1[1] -= edi_2
0041dfe1          *esi_1 += edi_2
0041dfe6          ebx -= edi_2
0041dfe8          arg1 = &arg1[edi_2]
0041e033          edi_1 = var_8_1
0041dfc9      else if (ebx u< arg4)
0041e03b          int32_t* var_18_4 = esi_1
0041e03b          
0041e04a          if (sub_421340(sx.d(*arg1)) == 0xffffffff)
0041e07a              eax_12 = edi_1
0041e07a              break
0041e07a          
0041e04c          arg1 = &arg1[1]
0041e04f          int32_t* eax_11 = esi_1[6]
0041e052          ebx -= 1
0041e053          arg4 = eax_11
0041e053          
0041e058          if (eax_11 s<= 0)
0041e05a              arg4 = 1
0041dff0      else
0041dff4          bool cond:3_1
0041dff4          
0041dff4          if (ecx_2 != 0)
0041dffc              cond:3_1 = sub_41eca1(esi_1) != 0
0041dffc          
0041dfff          if (ecx_2 != 0 && cond:3_1)
0041e07a              eax_12 = edi_1
0041e07a              break
0041e07a          
0041e005          uint32_t edi_4
0041e005          
0041e005          if (arg4 == 0)
0041e014              edi_4 = ebx
0041e005          else
0041e010              edi_4 = ebx - modu.dp.d(0:ebx, arg4)
0041e010          
0041e01d          int32_t eax_7 = sub_421458(esi_1[4], arg1, edi_4)
0041e01d          
0041e028          if (eax_7 != 0xffffffff)
0041e02a              arg1 = &arg1[eax_7]
0041e02d              ebx -= eax_7
0041e02d          
0041e031          if (eax_7 == 0xffffffff || eax_7 u< edi_4)
0041e071              esi_1[3] |= 0x20
0041e075              eax_12 = var_8_1
0041e078              break
0041e078          
0041e033          edi_1 = var_8_1
0041e033      
0041e063      if (ebx == 0)
0041e069          return arg3
0041e069  
0041e070  return divu.dp.d(0:(eax_12 - ebx), arg2)


0041e085    void* sub_41e085(int32_t* arg1)

0041e08c  sub_41ff69(arg1)
0041e092  void* result = sub_41e0a7(arg1)
0041e09a  sub_41ffbb(arg1)
0041e0a6  return result


0041e0a7    void* sub_41e0a7(int32_t* arg1)

0041e0b0  int32_t* edi = arg1
0041e0b5  int32_t esi = edi[4]
0041e0b5  
0041e0be  if (edi[1] s< 0)
0041e0c0      edi[1] = 0
0041e0c0  
0041e0c7  uint32_t eax = sub_421030(esi, 0, FILE_CURRENT)
0041e0d1  uint32_t var_8 = eax
0041e0d1  
0041e0d4  if (eax s>= 0)
0041e0d6      int16_t ecx_1 = (edi[3]).w
0041e0d6      
0041e0de      if ((ecx_1 & 0x108) == 0)
0041e0e0          return eax - edi[1]
0041e0e0      
0041e0e8      int32_t eax_2 = *edi
0041e0ea      char* i_2 = edi[2]
0041e0f4      void* result = eax_2 - i_2
0041e0f4      
0041e0f7      if ((ecx_1.b & 3) != 0)
0041e112          if ((*((&data_2823880)[esi s>> 5] + (esi & 0x1f) * 0x24 + 4) & 0x80) != 0)
0041e118              for (char* i = i_2; i u< eax_2; i = &i[1])
0041e11d                  if (*i == 0xa)
0041e11f                      result += 1
0041e11f          
0041e112          goto label_41e13d
0041e112      
0041e128      if ((ecx_1.b & 0x80) != 0)
0041e13d          label_41e13d:
0041e13d          
0041e141          if (var_8 == 0)
0041e143              return result
0041e143          
0041e14f          if ((edi[3].b & 1) != 0)
0041e155              int32_t ecx_5 = edi[1]
0041e155              
0041e15a              if (ecx_5 != 0)
0041e168                  arg1 = eax_2 - i_2 + ecx_5
0041e181                  int32_t esi_2 = (esi & 0x1f) * 0x24
0041e181                  
0041e189                  if ((*(esi_2 + (&data_2823880)[esi s>> 5] + 4) & 0x80) != 0)
0041e19d                      bool cond:3_1
0041e19d                      
0041e19d                      if (sub_421030(esi, 0, FILE_END) != var_8)
0041e1c4                          sub_421030(esi, var_8, FILE_BEGIN)
0041e1c9                          int32_t* eax_12 = 0x200
0041e1d4                          int16_t ecx_8
0041e1d4                          
0041e1d4                          if (arg1 u<= 0x200)
0041e1d6                              ecx_8 = (edi[3]).w
0041e1d6                          
0041e1e1                          if (arg1 u> 0x200 || (ecx_8.b & 8) == 0 || (ecx_8:1.b & 4) != 0)
0041e1e3                              eax_12 = edi[6]
0041e1e3                          
0041e1e6                          arg1 = eax_12
0041e1eb                          cond:3_1 = (*(esi_2 + (&data_2823880)[esi s>> 5] + 4) & 4) == 0
0041e19d                      else
0041e19f                          char* i_1 = edi[2]
0041e19f                          
0041e1a9                          for (void* ecx_7 = arg1 + i_1; i_1 u< ecx_7; i_1 = &i_1[1])
0041e1ae                              if (*i_1 == 0xa)
0041e1b0                                  arg1 += 1
0041e1b0                          
0041e1b6                          cond:3_1 = (*(edi + 0xd) & 0x20) == 0
0041e1b6                      
0041e1f0                      if (not(cond:3_1))
0041e1f2                          arg1 += 1
0041e1f2                  
0041e1f8                  var_8 -= arg1
0041e15a              else
0041e15c                  result &= ecx_5
0041e15c          
0041e201          return result + var_8
0041e201      
0041e12f      *sub_41e9bd() = 0x16
0041e12f  
0041e135  return 0xffffffff


0041e208    int32_t sub_41e208(char* arg1)

0041e20c  char* edi = arg1
0041e217  BOOL eax_2
0041e217  wchar16 (* ecx)[0x21]
0041e217  int32_t edx
0041e217  
0041e217  while (true)
0041e217      if (data_42f800 s<= 1)
0041e22b          ecx = data_42f5f4
0041e231          uint32_t eax_3
0041e231          eax_3.b = (*ecx)[zx.d(*edi)].b
0041e234          eax_2 = eax_3 & 8
0041e217      else
0041e219          uint32_t eax_1 = zx.d(*edi)
0041e21f          eax_2, edx = sub_421804(eax_1, edx, ecx, eax_1)
0041e225          ecx = 8
0041e225      
0041e239      if (eax_2 == 0)
0041e239          break
0041e239      
0041e23b      edi = &edi[1]
0041e23b  
0041e23e  uint32_t esi = zx.d(*edi)
0041e241  void* edi_1 = &edi[1]
0041e245  uint32_t ebp = esi
0041e245  
0041e24c  if (esi == 0x2d || esi == 0x2b)
0041e24e      esi = zx.d(*edi_1)
0041e251      edi_1 += 1
0041e251  
0041e252  int32_t result = 0
0041e252  
0041e25b  while (true)
0041e25b      BOOL eax_4
0041e25b      
0041e25b      if (data_42f800 s<= 1)
0041e26e          wchar16 (* eax_5)[0x21]
0041e26e          eax_5.b = (*data_42f5f4)[esi].b
0041e271          eax_4 = eax_5 & 4
0041e25b      else
0041e260          eax_4, edx = sub_421804(eax_2, edx, ecx, esi)
0041e266          ecx = 4
0041e266      
0041e276      if (eax_4 == 0)
0041e276          break
0041e276      
0041e278      eax_2 = result * 5
0041e27b      result = esi + (eax_2 << 1) - 0x30
0041e27f      esi = zx.d(*edi_1)
0041e282      edi_1 += 1
0041e282  
0041e28a  if (ebp != 0x2d)
0041e292      return result
0041e292  
0041e28c  return neg.d(result)


0041e293    int32_t sub_41e293(char* arg1)

0041e29d  return sub_41e208(arg1)


0041e29e    void sub_41e29e(void* arg1)

0041e2a5  if (arg1 != 0)
0041e2a9      sub_421919(9)
0041e2af      void* eax_1 = sub_4219cd(arg1)
0041e2af      
0041e2b8      if (eax_1 != 0)
0041e2bc          sub_4219f8(eax_1, arg1)
0041e2c3          sub_42197a(9)
0041e2cc          return 
0041e2cc      
0041e2cf      sub_42197a(9)
0041e2de      HeapFree(hHeap: data_2823868, dwFlags: HEAP_NONE, lpMem: arg1)


0041e2e6    int32_t sub_41e2e6()

0041e2e6  void* eax_1 = data_42f198
0041e2e6  
0041e2ed  if (eax_1 != 0)
0041e2ef      eax_1()
0041e2ef  
0041e2fb  sub_41e3ec(&data_42b008, 0x42b014)
0041e312  return sub_41e3ec(&data_42b000, 0x42b004)


0041e313    int32_t sub_41e313(uint32_t arg1)

0041e323  return sub_41e335(arg1, 0, 0)


0041e324    int32_t sub_41e324(uint32_t arg1)

0041e334  return sub_41e335(arg1, 1, 0)


0041e335    int32_t sub_41e335(uint32_t arg1, int32_t arg2, int32_t arg3)

0041e336  sub_41e3da()
0041e336  
0041e344  if (data_430bb4 == 1)
0041e351      TerminateProcess(hProcess: GetCurrentProcess(), uExitCode: arg1)
0041e351      noreturn
0041e351  
0041e361  data_430bb0 = 1
0041e367  data_430bac = arg3.b
0041e367  
0041e36d  if (arg2 == 0)
0041e36f      int32_t eax_2 = data_28249b4
0041e36f      
0041e376      if (eax_2 != 0)
0041e37f          int32_t* i = data_28249b0 - 4
0041e37f          
0041e384          if (i u>= eax_2)
0041e397              do
0041e386                  int32_t eax_3 = *i
0041e386                  
0041e38a                  if (eax_3 != 0)
0041e38c                      eax_3()
0041e38c                  
0041e38e                  i -= 4
0041e397              while (i u>= data_28249b4)
0041e397      
0041e3a4      sub_41e3ec(&data_42b018, 0x42b020)
0041e3a4  
0041e3b5  sub_41e3ec(&data_42b024, 0x42b028)
0041e3b5  
0041e3bf  if (arg3 != 0)
0041e3c7      return sub_41e3e3()
0041e3c7  
0041e3cc  data_430bb4 = 1
0041e3d2  ExitProcess(uExitCode: arg1)
0041e3d2  noreturn

0041e3d8                                                                          5f c3                                            _.

0041e3da    int32_t sub_41e3da()

0041e3e2  return sub_421919(0xd)


0041e3e3    int32_t sub_41e3e3()

0041e3eb  return sub_42197a(0xd)


0041e3ec    void sub_41e3ec(int32_t* arg1, int32_t arg2)

0041e3f5  for (int32_t* i = arg1; i u< arg2; i = &i[1])
0041e3f7      int32_t eax = *i
0041e3f7      
0041e3fb      if (eax != 0)
0041e3fd          eax()


0041e406    int32_t sub_41e406(PSTR arg1)

0041e412  enum WIN32_ERROR eax_1
0041e412  
0041e412  if (DeleteFileA(lpFileName: arg1) != 0)
0041e41c      eax_1 = NO_ERROR
0041e412  else
0041e414      eax_1 = GetLastError()
0041e414  
0041e420  if (eax_1 == NO_ERROR)
0041e42f      return 0
0041e42f  
0041e423  sub_41e94a(eax_1)
0041e42c  return 0xffffffff


0041e430    int32_t sub_41e430(char* arg1, void* arg2)

0041e43a  char* var_1c = arg1
0041e43d  char* var_24 = arg1
0041e443  int32_t var_18 = 0x42
0041e44a  void arg_c
0041e44a  void* var_2c = &arg_c
0041e451  int32_t var_20 = 0x7fffffff
0041e459  int32_t result = sub_4200c4(&var_24, arg2)
0041e461  int32_t var_20_1 = var_20 - 1
0041e461  
0041e466  if (var_20 - 1 s< 0)
0041e473      char** var_2c_1 = &var_24
0041e476      sub_421340(nullptr)
0041e466  else
0041e46b      *var_24 = 0
0041e46b  
0041e481  return result


0041e482    long double sub_41e482(char* arg1)

0041e489  char* esi = arg1
0041e489  
0041e493  while (true)
0041e493      BOOL eax_2
0041e493      wchar16 (* ecx)[0x21]
0041e493      
0041e493      if (data_42f800 s<= 1)
0041e4a7          ecx = data_42f5f4
0041e4ad          uint32_t eax_3
0041e4ad          eax_3.b = (*ecx)[zx.d(*esi)].b
0041e4b0          eax_2 = eax_3 & 8
0041e493      else
0041e495          uint32_t eax_1 = zx.d(*esi)
0041e49b          int32_t edx
0041e49b          eax_2, edx = sub_421804(eax_1, edx, ecx, eax_1)
0041e4a1          ecx = 8
0041e4a1      
0041e4b5      if (eax_2 == 0)
0041e4b5          break
0041e4b5      
0041e4b7      esi = &esi[1]
0041e4b7  
0041e4ba  int32_t var_24 = 0
0041e4bc  int32_t var_28_2 = 0
0041e4c5  void* var_2c_1 = sub_422550(esi)
0041e4d8  void var_1c
0041e4d8  return fconvert.t(*(sub_4224ce(&var_1c, esi) + 0x10))


0041e4d9    int32_t sub_41e4d9(int32_t* arg1, void* arg2)

0041e4e1  sub_41ff69(arg1)
0041e4e7  int32_t eax = sub_42000d(arg1)
0041e4f2  void arg_c
0041e4f2  void* var_18 = &arg_c
0041e4f8  int32_t result = sub_4200c4(arg1, arg2)
0041e501  sub_42009a(eax, arg1)
0041e507  sub_41ffbb(arg1)
0041e514  return result

0041e515                                                                 cc cc cc cc cc cc cc cc cc cc cc                       ...........

0041e520    void* const __convention("regparm") sub_41e520(int32_t arg1)

0041e526  void arg_4
0041e526  void* ecx = &arg_4
0041e526  
0041e52a  while (arg1 u>= 0x1000)
0041e52c      ecx -= 0x1000
0041e532      arg1 -= 0x1000
0041e537      *ecx
0041e537  
0041e540  void* ecx_1 = ecx - arg1
0041e544  *ecx_1
0041e54d  *(ecx_1 - 4) = __return_addr
0041e54e  return __return_addr


0041e54f    int32_t sub_41e54f(char* arg1, char* arg2)

0041e558  int32_t var_18 = 0x49
0041e560  char* var_1c = arg1
0041e563  char* var_24 = arg1
0041e56b  void* var_20 = sub_422550(arg1)
0041e582  void arg_c
0041e582  return sub_4225cb(&var_24, arg2, &arg_c)


0041e583    void* sub_41e583(int32_t* arg1)

0041e594  return sub_41e595(arg1, data_430c70)


0041e595    void* sub_41e595(int32_t* arg1, int32_t arg2)

0041e59a  if (arg1 u<= 0xffffffe0)
0041e5bc      bool cond:1_1
0041e5bc      
0041e5bc      do
0041e5a0          void* result = sub_41e5c1(arg1)
0041e5a0          
0041e5ae          if (result != 0 || arg2 == result)
0041e5c0              return result
0041e5c0          
0041e5b9          cond:1_1 = sub_42307c(arg1) != 0
0041e5bc      while (cond:1_1)
0041e5bc  
0041e5be  return nullptr


0041e5c1    void* sub_41e5c1(int32_t* arg1)

0041e5c2  int32_t* esi = arg1
0041e5c2  
0041e5cd  if (esi u<= data_42f8d4)
0041e5d1      sub_421919(9)
0041e5d7      void* result = sub_421d23(esi)
0041e5e0      sub_42197a(9)
0041e5e0      
0041e5ea      if (result != 0)
0041e5ec          return result
0041e5ec  
0041e5f2  if (esi == 0)
0041e5f6      esi = 1
0041e5f6  
0041e606  return HeapAlloc(hHeap: data_2823868, dwFlags: HEAP_NONE, 
0041e606      dwBytes: (esi + 0xf) & 0xfffffff0)

0041e60f                                               cc                                                                 .

0041e610    char* sub_41e610(char* arg1, void* arg2)

0041e610  char* ecx_1 = arg2
0041e617  int16_t edx
0041e617  edx.b = *ecx_1
0041e619  char* result = arg1
0041e619  
0041e61f  if (edx.b == 0)
0041e68f      return result
0041e68f  
0041e621  edx:1.b = ecx_1[1]
0041e621  
0041e626  if (edx:1.b != 0)
0041e62a      while (true)
0041e62a          void* ecx = arg2
0041e62e          int16_t eax
0041e62e          eax.b = *result
0041e630          void* esi_2 = &result[1]
0041e630          
0041e633          if (eax.b != edx.b)
0041e637              if (eax.b == 0)
0041e649                  return 0
0041e649              
0041e639              while (true)
0041e639                  eax.b = *esi_2
0041e63b                  esi_2 += 1
0041e63c                  label_41e63c:
0041e63c                  
0041e63e                  if (eax.b == edx.b)
0041e63e                      break
0041e63e                  
0041e642                  if (eax.b == 0)
0041e649                      return 0
0041e649          
0041e64a          eax.b = *esi_2
0041e64c          esi_2 += 1
0041e64c          
0041e64f          if (eax.b != edx:1.b)
0041e64f              break
0041e64f          
0041e651          result = esi_2 - 1
0041e651          
0041e654          while (true)
0041e654              eax:1.b = *(ecx + 2)
0041e654              
0041e659              if (eax:1.b != 0)
0041e65b                  eax.b = *esi_2
0041e65d                  esi_2 += 2
0041e65d                  
0041e662                  if (eax.b != eax:1.b)
0041e662                      break
0041e662                  
0041e664                  eax.b = *(ecx + 3)
0041e664                  
0041e669                  if (eax.b != 0)
0041e66b                      eax:1.b = *(esi_2 - 1)
0041e66e                      ecx += 2
0041e66e                      
0041e673                      if (eax.b != eax:1.b)
0041e673                          break
0041e673                      
0041e673                      continue
0041e673              
0041e689              return &result[0xffffffff]
0041e689      
0041e64f      goto label_41e63c
0041e64f  
0041e67c  int32_t eax_2
0041e67c  eax_2.b = edx.b
00423276  int32_t ebx
00423276  int32_t var_4_1 = ebx
0042327c  char* edx_1 = arg1
0042327c  
00423286  while ((edx_1 & 3) != 0)
00423288      ecx_1.b = *edx_1
0042328a      edx_1 = &edx_1[1]
0042328a      
0042328d      if (ecx_1.b == eax_2.b)
00423264          return &edx_1[0xffffffff]
00423264      
00423291      if (ecx_1.b == 0)
004232e7          return 0
004232e7  
0042329b  int32_t ebx_7 = eax_2 | eax_2 << 8
0042329d  int32_t edi
0042329d  int32_t var_8_1 = edi
004232a3  int32_t esi
004232a3  int32_t var_c_1 = esi
004232a4  int32_t ebx_9 = ebx_7 << 0x10 | ebx_7
004232a4  
004232a6  while (true)
004232a6      int32_t ecx_2 = *edx_1
004232b1      int32_t ecx_3 = ecx_2 ^ ebx_9
004232c1      edx_1 = &edx_1[4]
004232c1      
004232ca      if (((ecx_3 ^ 0xffffffff ^ (0x7efefeff + ecx_3)) & 0x81010100) != 0)
004232e8          int32_t eax_14 = *(edx_1 - 4)
004232e8          
004232ed          if (eax_14.b == ebx_9.b)
0042332b              return &edx_1[0xfffffffc]
0042332b          
004232f1          if (eax_14.b == 0)
004232f1              break
004232f1          
004232f5          if (eax_14:1.b == ebx_9.b)
00423324              return &edx_1[0xfffffffd]
00423324          
004232f9          if (eax_14:1.b == 0)
004232f9              break
004232f9          
004232fb          uint16_t eax_15 = (eax_14 u>> 0x10).w
004232fb          
00423300          if (eax_15.b == ebx_9.b)
0042331d              return &edx_1[0xfffffffe]
0042331d          
00423304          if (eax_15.b == 0)
00423304              break
00423304          
00423308          if (eax_15:1.b == ebx_9.b)
00423316              return &edx_1[0xffffffff]
00423316          
0042330c          if (eax_15:1.b == 0)
0042330c              break
004232ca      else
004232cc          int32_t eax_11 = (ecx_2 ^ 0xffffffff ^ (0x7efefeff + ecx_2)) & 0x81010100
004232cc          
004232d1          if (eax_11 != 0)
004232d8              if ((eax_11 & 0x1010100) != 0)
004232d8                  break
004232d8              
004232e0              if (((0x7efefeff + ecx_2) & 0x80000000) == 0)
004232e0                  break
004232e0  
004232e7  return 0


0041e690    int32_t sub_41e690(char* arg1, void* arg2, int32_t arg3)

0041e69a  int32_t var_2c = arg3
0041e69d  char* var_1c = arg1
0041e6a0  char* var_24 = arg1
0041e6a9  int32_t var_18 = 0x42
0041e6b0  int32_t var_20 = 0x7fffffff
0041e6b8  int32_t result = sub_4200c4(&var_24, arg2)
0041e6c0  int32_t var_20_1 = var_20 - 1
0041e6c0  
0041e6c5  if (var_20 - 1 s< 0)
0041e6d2      char** var_2c_1 = &var_24
0041e6d5      sub_421340(nullptr)
0041e6c5  else
0041e6ca      *var_24 = 0
0041e6ca  
0041e6e0  return result


0041e6e1    int32_t sub_41e6e1(void* arg1, int32_t arg2)

0041e6ea  sub_41ff69(&data_42f360)
0041e6f0  int32_t eax = sub_42000d(&data_42f360)
0041e6f5  int32_t var_18 = arg2
0041e700  int32_t result = sub_4200c4(&data_42f360, arg1)
0041e709  sub_42009a(eax, &data_42f360)
0041e70f  sub_41ffbb(&data_42f360)
0041e71c  return result

0041e71d                                                                                         cc cc cc                               ...

0041e720    char* sub_41e720(char* arg1, char* arg2, int32_t arg3)

0041e720  int32_t ecx = arg3
0041e720  
0041e727  if (ecx == 0)
0041e7a8      return arg1
0041e7a8  
0041e72b  int32_t ebx_1 = ecx
0041e72d  char* esi_1 = arg2
0041e737  char* edi_1 = arg1
0041e73b  int32_t eax
0041e73b  uint32_t i_2
0041e73b  uint32_t i_3
0041e73b  
0041e73b  if ((esi_1 & 3) != 0)
0041e757      do
0041e744          eax.b = *esi_1
0041e746          esi_1 = &esi_1[1]
0041e747          *edi_1 = eax.b
0041e749          edi_1 = &edi_1[1]
0041e74a          int32_t temp0_1 = ecx
0041e74a          ecx -= 1
0041e74a          
0041e74b          if (temp0_1 == 1)
0041e779              return arg1
0041e779          
0041e74f          if (eax.b == 0)
0041e780              while ((edi_1 & 3) != 0)
0041e782                  *edi_1 = eax.b
0041e784                  edi_1 = &edi_1[1]
0041e785                  int32_t temp2_1 = ecx
0041e785                  ecx -= 1
0041e785                  
0041e786                  if (temp2_1 == 1)
0041e81d                      return arg1
0041e81d              
0041e794              ebx_1 = ecx
0041e796              i_3 = ecx u>> 2
0041e796              
0041e799              if (i_3 == 0)
0041e799                  goto label_41e79b
0041e799              
0041e807              label_41e807:
0041e807              eax = 0
0041e80f              uint32_t i
0041e80f              
0041e80f              do
0041e809                  *edi_1 = 0
0041e80b                  edi_1 = &edi_1[4]
0041e80e                  i = i_3
0041e80e                  i_3 -= 1
0041e80f              while (i != 1)
0041e811              label_41e811:
0041e811              ebx_1 &= 3
0041e811              
0041e814              if (ebx_1 != 0)
0041e814                  goto label_41e79b
0041e814              
0041e81d              return arg1
0041e757      while ((esi_1 & 3) != 0)
0041e757      
0041e759      ebx_1 = ecx
0041e75b      i_2 = ecx u>> 2
0041e75b      
0041e75e      if (i_2 != 0)
0041e75e          goto label_41e7af
0041e75e      
0041e760      label_41e760:
0041e760      ebx_1 &= 3
0041e760      
0041e763      if (ebx_1 != 0)
0041e763          goto label_41e765
0041e73b  else
0041e73d      i_2 = ecx u>> 2
0041e73d      
0041e740      if (i_2 != 0)
0041e7af          label_41e7af:
0041e7af          uint32_t i_1
0041e7af          
0041e7af          do
0041e7b6              int32_t eax_3 = *esi_1
0041e7bf              int32_t edx_2 = *esi_1
0041e7c1              esi_1 = &esi_1[4]
0041e7c1              
0041e7c9              if (((eax_3 ^ 0xffffffff ^ (0x7efefeff + eax_3)) & 0x81010100) != 0)
0041e7cd                  if (edx_2.b == 0)
0041e7fd                      *edi_1 = 0
0041e7ff                      label_41e7ff:
0041e7ff                      edi_1 = &edi_1[4]
0041e802                      eax = 0
0041e804                      i_3 = i_2 - 1
0041e804                      
0041e805                      if (i_2 == 1)
0041e805                          goto label_41e811
0041e805                      
0041e805                      goto label_41e807
0041e805                  
0041e7d1                  if (edx_2:1.b == 0)
0041e7f7                      *edi_1 = edx_2 & 0xff
0041e7f9                      goto label_41e7ff
0041e7f9                  
0041e7d9                  if ((edx_2 & 0xff0000) == 0)
0041e7ed                      *edi_1 = edx_2 & 0xffff
0041e7ef                      goto label_41e7ff
0041e7ef                  
0041e7e1                  if ((edx_2 & 0xff000000) == 0)
0041e7e3                      *edi_1 = edx_2
0041e7e5                      goto label_41e7ff
0041e7e5              
0041e7a9              *edi_1 = edx_2
0041e7ab              edi_1 = &edi_1[4]
0041e7ae              i_1 = i_2
0041e7ae              i_2 -= 1
0041e7af          while (i_1 != 1)
0041e7af          goto label_41e760
0041e7af      
0041e765      label_41e765:
0041e765      
0041e765      while (true)
0041e765          eax.b = *esi_1
0041e767          esi_1 = &esi_1[1]
0041e768          *edi_1 = eax.b
0041e76a          edi_1 = &edi_1[1]
0041e76a          
0041e76d          if (eax.b == 0)
0041e79e              while (true)
0041e79e                  int32_t temp3_1 = ebx_1
0041e79e                  ebx_1 -= 1
0041e79e                  
0041e79f                  if (temp3_1 == 1)
0041e7a8                      return arg1
0041e7a8                  
0041e79b                  label_41e79b:
0041e79b                  *edi_1 = eax.b
0041e79d                  edi_1 = &edi_1[1]
0041e76d          else
0041e76f              int32_t temp4_1 = ebx_1
0041e76f              ebx_1 -= 1
0041e76f              
0041e770              if (temp4_1 == 1)
0041e770                  break
0041e779  return arg1


0041e81e    int32_t sub_41e81e(int32_t* arg1)

0041e82b  SYSTEMTIME systemTime_1
0041e82b  GetLocalTime(lpSystemTime: &systemTime_1)
0041e835  SYSTEMTIME systemTime
0041e835  GetSystemTime(lpSystemTime: &systemTime)
0041e87a  int32_t eax_1
0041e87a  
0041e87a  if (systemTime.wMinute != data_430bca || systemTime.wHour != data_430bc8
0041e87a          || systemTime.wDay != data_430bc6 || systemTime.wMonth != data_430bc2
0041e87a          || systemTime.wYear != data_430bc0)
0041e88a      TIME_ZONE_INFORMATION timeZoneInformation
0041e88a      uint32_t eax_2 = GetTimeZoneInformation(lpTimeZoneInformation: &timeZoneInformation)
0041e88a      
0041e893      if (eax_2 == 0xffffffff)
0041e8b0          eax_1 = 0xffffffff
0041e893      else if (eax_2 != 2 || timeZoneInformation.DaylightDate.wMonth == 0
0041e893              || timeZoneInformation.DaylightBias == 0)
0041e8ac          eax_1 = 0
0041e8a5      else
0041e8a9          eax_1 = 1
0041e8a9      
0041e8bd      data_430bc0 = systemTime.wYear
0041e8bd      (&data_430bc0)[1] = systemTime.wMonth
0041e8bd      void* edi_1 = &data_430bc4
0041e8bd      var_20
0041e8bd      void* esi_1 = &var_20
0041e8be      *edi_1 = *esi_1
0041e8be      void* edi_2 = edi_1 + 4
0041e8be      void* esi_2 = esi_1 + 4
0041e8bf      *edi_2 = *esi_2
0041e8c0      *(edi_2 + 4) = *(esi_2 + 4)
0041e8c2      data_430bb8 = eax_1
0041e87a  else
0041e87c      eax_1 = data_430bb8
0041e87c  
0041e8e7  int32_t result = sub_423190(zx.d(systemTime_1.wYear), zx.d(systemTime_1.wMonth), 
0041e8e7      zx.d(systemTime_1.wDay), zx.d(systemTime_1.wHour), zx.d(systemTime_1.wMinute), 
0041e8e7      zx.d(systemTime_1.wSecond), eax_1)
0041e8e7  
0041e8f4  if (arg1 != 0)
0041e8f6      *arg1 = result
0041e8f6  
0041e8f9  return result


0041e8fa    void* sub_41e8fa(int32_t arg1)

0041e8fb  void* eax = sub_423393()
0041e906  void* eax_1
0041e906  
0041e906  if (*(eax + 0x24) == 0)
0041e90d      eax_1 = sub_41e583(0x86)
0041e915      *(eax + 0x24) = eax_1
0041e915  
0041e918  void* result
0041e918  
0041e918  if (*(eax + 0x24) != 0 || eax_1 != 0)
0041e921      result = *(eax + 0x24)
0041e918  else
0041e91a      result = &data_430bd0
0041e91a  
0041e928  int32_t eax_2 = data_42f9a0
0041e928  
0041e933  if (arg1 s>= 0 && arg1 s< eax_2)
0041e935      eax_2 = arg1
0041e935  
0041e93f  sub_4230a0(result, (&data_42f8f0)[eax_2])
0041e949  return result


0041e94a    void* sub_41e94a(int32_t arg1)

0041e954  int32_t esi = 0
0041e956  *sub_41e9c6() = arg1
0041e956  
0041e96a  for (void* i = &data_42f1b0; i s< &data_42f318; )
0041e95f      if (arg1 == *i)
0041e983          void* eax_2 = sub_41e9bd()
0041e990          *eax_2 = *((esi << 3) + &data_42f1b4)
0041e992          return eax_2
0041e992      
0041e961      i += 8
0041e964      esi += 1
0041e964  
0041e974  if (arg1 u>= 0x13 && arg1 u<= 0x24)
0041e976      void* eax_1 = sub_41e9bd()
0041e97b      *eax_1 = 0xd
0041e982      return eax_1
0041e982  
0041e9a1  if (arg1 u< 0xbc || arg1 u> 0xca)
0041e9b0      void* eax_4 = sub_41e9bd()
0041e9b5      *eax_4 = 0x16
0041e9bc      return eax_4
0041e9bc  
0041e9a3  void* eax_3 = sub_41e9bd()
0041e9a8  *eax_3 = 8
0041e9af  return eax_3


0041e9bd    void* sub_41e9bd()

0041e9c5  return sub_423393() + 8


0041e9c6    void* sub_41e9c6()

0041e9ce  return sub_423393() + 0xc


0041e9cf    uint32_t sub_41e9cf(uint32_t arg1)

0041e9d0  int32_t ebx = 0
0041e9d0  
0041e9d8  if (data_430c8c == 0)
0041e9e6      if (arg1 s>= 0x61 && arg1 s<= 0x7a)
0041e9ec          return arg1 - 0x20
0041e9ec      
0041ea3d      return arg1
0041ea3d  
0041e9f5  int32_t ecx_1 = InterlockedIncrement(&data_282384c)
0041e9f5  
0041ea07  if (data_2823848 != 0)
0041ea0a      InterlockedDecrement(&data_282384c)
0041ea0e      sub_421919(0x13)
0041ea13      ecx_1 = 0x13
0041ea16      ebx = 1
0041ea16  
0041ea17  uint32_t var_10_1 = arg1
0041ea1b  uint32_t eax_2 = sub_41ea3e(ecx_1)
0041ea1b  
0041ea27  if (ebx == 0)
0041ea34      InterlockedDecrement(&data_282384c)
0041ea27  else
0041ea2b      sub_42197a(0x13)
0041ea2b  
0041ea36  return eax_2


0041ea3e    uint32_t __fastcall sub_41ea3e(int32_t arg1)

0041ea41  int32_t var_8 = arg1
0041ea4a  uint32_t arg_4
0041ea4a  
0041ea4a  if (data_430c8c == 0)
0041ea4c      uint32_t eax_1 = arg_4
0041ea4c      
0041ea5b      if (eax_1 s>= 0x61 && eax_1 s<= 0x7a)
0041ea61          return eax_1 - 0x20
0041ea61      
0041eb09      return eax_1
0041eb09  
0041ea69  uint32_t ebx_1 = arg_4
0041ea72  BOOL eax_2
0041ea72  
0041ea72  if (ebx_1 s< 0x100)
0041ea7b      int32_t eax
0041ea7b      int32_t edx
0041ea7b      
0041ea7b      if (data_42f800 s<= 1)
0041ea8e          wchar16 (* eax_3)[0x21]
0041ea8e          eax_3.b = (*data_42f5f4)[ebx_1].b
0041ea91          eax_2 = eax_3 & 2
0041ea7b      else
0041ea80          eax_2 = sub_421804(eax, edx, arg1, ebx_1)
0041ea80  
0041ea96  if (ebx_1 s>= 0x100 || eax_2 != 0)
0041eaa4      char eax_5 = (ebx_1 s>> 8).b
0041eaaf      void* var_10_1
0041eaaf      
0041eaaf      if ((*(&(*data_42f5f4)[zx.d(eax_5)] + 1) & 0x80) == 0)
0041eabf          arg_4:1.b = 0
0041eac3          arg_4.b = ebx_1.b
0041eac6          var_10_1 = 1
0041eaaf      else
0041eab1          arg_4:2.b = 0
0041eab5          arg_4.b = eax_5
0041eab8          arg_4:1.b = ebx_1.b
0041eabb          var_10_1 = 2
0041eabb      
0041eae3      int32_t eax_7 = sub_4233fa(data_430c8c, 0x200, &arg_4, var_10_1, &var_8, 3, 0, 1)
0041eae3      
0041eaed      if (eax_7 != 0)
0041eaf2          if (eax_7 != 1)
0041eb05              return zx.d(var_8:1.b) << 8 | zx.d(var_8.b)
0041eb05          
0041eaf4          return zx.d(var_8.b)
0041eaf4  
0041ea98  return ebx_1


0041eb0a    uint32_t sub_41eb0a(uint32_t arg1)

0041eb0b  int32_t ebx = 0
0041eb0b  
0041eb13  if (data_430c8c == 0)
0041eb21      if (arg1 s>= 0x41 && arg1 s<= 0x5a)
0041eb27          return arg1 + 0x20
0041eb27      
0041eb78      return arg1
0041eb78  
0041eb30  int32_t ecx_1 = InterlockedIncrement(&data_282384c)
0041eb30  
0041eb42  if (data_2823848 != 0)
0041eb45      InterlockedDecrement(&data_282384c)
0041eb49      sub_421919(0x13)
0041eb4e      ecx_1 = 0x13
0041eb51      ebx = 1
0041eb51  
0041eb52  uint32_t var_10_1 = arg1
0041eb56  uint32_t eax_2 = sub_41eb79(ecx_1)
0041eb56  
0041eb62  if (ebx == 0)
0041eb6f      InterlockedDecrement(&data_282384c)
0041eb62  else
0041eb66      sub_42197a(0x13)
0041eb66  
0041eb71  return eax_2


0041eb79    uint32_t __fastcall sub_41eb79(int32_t arg1)

0041eb7c  int32_t var_8 = arg1
0041eb87  uint32_t arg_4
0041eb87  
0041eb87  if (data_430c8c == 0)
0041eb89      uint32_t eax_1 = arg_4
0041eb89      
0041eb98      if (eax_1 s>= 0x41 && eax_1 s<= 0x5a)
0041eb9e          return eax_1 + 0x20
0041eb9e      
0041ec43      return eax_1
0041ec43  
0041eba6  uint32_t ebx_1 = arg_4
0041ebb3  BOOL eax_2
0041ebb3  
0041ebb3  if (ebx_1 s< 0x100)
0041ebbb      int32_t eax
0041ebbb      int32_t edx
0041ebbb      
0041ebbb      if (data_42f800 s<= 1)
0041ebcd          wchar16 (* eax_3)[0x21]
0041ebcd          eax_3.b = (*data_42f5f4)[ebx_1].b
0041ebd0          eax_2 = eax_3 & 1
0041ebbb      else
0041ebbf          eax_2 = sub_421804(eax, edx, arg1, ebx_1)
0041ebbf  
0041ebd4  if (ebx_1 s>= 0x100 || eax_2 != 0)
0041ebe2      char eax_5 = (ebx_1 s>> 8).b
0041ebed      void* eax_6
0041ebed      
0041ebed      if ((*(&(*data_42f5f4)[zx.d(eax_5)] + 1) & 0x80) == 0)
0041ebfe          arg_4:1.b = 0
0041ec02          arg_4.b = ebx_1.b
0041ec05          eax_6 = 1
0041ebed      else
0041ebef          arg_4:2.b = 0
0041ebf5          arg_4.b = eax_5
0041ebf8          arg_4:1.b = ebx_1.b
0041ebfb          eax_6 = 2
0041ebfb      
0041ec1c      int32_t eax_7 = sub_4233fa(data_430c8c, 0x100, &arg_4, eax_6, &var_8, 3, 0, 1)
0041ec1c      
0041ec26      if (eax_7 != 0)
0041ec2a          if (eax_7 != 1)
0041ec3d              return zx.d(var_8:1.b) << 8 | zx.d(var_8.b)
0041ec3d          
0041ec2c          return zx.d(var_8.b)
0041ec2c  
0041ebd6  return ebx_1


0041ec44    int32_t sub_41ec44(int32_t* arg1)

0041ec4b  if (arg1 == 0)
0041ec55      return sub_41ed06(arg1)
0041ec55  
0041ec58  sub_41ff69(arg1)
0041ec5e  int32_t result = sub_41ec73(arg1)
0041ec66  sub_41ffbb(arg1)
0041ec72  return result


0041ec73    int32_t sub_41ec73(int32_t* arg1)

0041ec81  if (sub_41eca1(arg1) != 0)
0041ec87      return 0xffffffff
0041ec87  
0041ec8c  if ((*(arg1 + 0xd) & 0x40) == 0)
0041eca0      return 0
0041eca0  
0041ec91  enum WIN32_ERROR eax_2 = sub_42361e(arg1[4])
0041ec96  int32_t eax_3 = neg.d(eax_2)
0041ec9c  return sbb.d(eax_3, eax_3, eax_2 != NO_ERROR)


0041eca1    int32_t sub_41eca1(int32_t* arg1)

0041eca7  int32_t result = 0
0041ecaa  int16_t eax = (arg1[3]).w
0041ecaa  
0041ecbb  if ((eax.b & 3) == 2 && (eax & 0x108) != 0)
0041ecbd      char* eax_1 = arg1[2]
0041ecc2      uint32_t edi_2 = *arg1 - eax_1
0041ecc2      
0041ecc6      if (edi_2 s> 0)
0041ecd7          if (sub_421458(arg1[4], eax_1, edi_2) != edi_2)
0041ece7              arg1[3] |= 0x20
0041eceb              result = 0xffffffff
0041ecd7          else
0041ecd9              int32_t eax_3 = arg1[3]
0041ecd9              
0041ecde              if ((eax_3.b & 0x80) != 0)
0041ece0                  eax_3.b &= 0xfd
0041ece2                  arg1[3] = eax_3
0041ece2  
0041ecee  int32_t eax_4 = arg1[2]
0041ecf1  arg1[1] = 0
0041ecf5  *arg1 = eax_4
0041ecfc  return result


0041ecfd    int32_t sub_41ecfd()

0041ed05  return sub_41ed06(1)


0041ed06    int32_t sub_41ed06(int32_t arg1)

0041ed0b  int32_t ebx = 0
0041ed0d  int32_t edi = 0
0041ed0f  sub_421919(2)
0041ed14  int32_t i = 0
0041ed14  
0041ed1d  if (data_28249a0 s> 0)
0041ed91      do
0041ed24          void* eax_2 = *(data_2823984 + (i << 2))
0041ed24          
0041ed2f          if (eax_2 != 0 && (*(eax_2 + 0xc) & 0x83) != 0)
0041ed33              sub_41ff98(i, eax_2)
0041ed3f              int32_t* eax_4 = *(data_2823984 + (i << 2))
0041ed42              char ecx_1 = (eax_4[3]).b
0041ed42              
0041ed48              if ((ecx_1 & 0x83) != 0)
0041ed4f                  if (arg1 == 1)
0041ed5b                      if (sub_41ec73(eax_4) != 0xffffffff)
0041ed5d                          ebx += 1
0041ed4f                  else if (arg1 == 0 && (ecx_1 & 2) != 0)
0041ed6d                      int32_t eax_6 = sub_41ec73(eax_4)
0041ed6d                      
0041ed76                      if (eax_6 == 0xffffffff)
0041ed78                          edi |= eax_6
0041ed78              
0041ed83              sub_41ffea(i, *(data_2823984 + (i << 2)))
0041ed83          
0041ed8a          i += 1
0041ed91      while (i s< data_28249a0)
0041ed91  
0041ed95  sub_42197a(2)
0041ed95  
0041eda2  if (arg1 == 1)
0041eda9      return ebx
0041eda9  
0041eda4  return edi


0041edaa    int32_t sub_41edaa(int32_t* arg1, void* arg2, int32_t arg3)

0041edb2  sub_41ff69(arg1)
0041edb8  int32_t eax = sub_42000d(arg1)
0041edbd  int32_t var_18 = arg3
0041edc8  int32_t result = sub_4200c4(arg1, arg2)
0041edd1  sub_42009a(eax, arg1)
0041edd7  sub_41ffbb(arg1)
0041ede4  return result


0041ede5    long double sub_41ede5(double arg1)

0041ede8  int32_t ecx
0041ede8  int32_t var_8 = ecx
0041ede9  int32_t var_c = ecx
0041edf8  int32_t eax
0041edf8  int16_t x87control
0041edf8  int16_t x87control_1
0041edf8  eax, x87control_1 = sub_423edc(x87control, data_42f318, 0xffff)
0041ee14  int32_t var_30
0041ee14  
0041ee14  if ((arg1:6.w & 0x7ff0) != 0x7ff0)
0041ee70      var_c.q = fconvert.d(__frnd(9.18340949e-41f))
0041ee73      long double x87_r7_5 = fconvert.t(var_c.q)
0041ee76      long double temp0_1 = fconvert.t(arg1)
0041ee76      x87_r7_5 - temp0_1
0041ee76      
0041ee91      if (test_bit(
0041ee91              ((x87_r7_5 < temp0_1 ? 1 : 0) << 8
0041ee91                  | (is_unordered.t(x87_r7_5, temp0_1) ? 1 : 0) << 0xa
0041ee91                  | (x87_r7_5 == temp0_1 ? 1 : 0) << 0xe):1.b, 
0041ee91              6) || (eax.b & 0x20) != 0)
0041ee82          sub_423edc(x87control_1, eax, 0xffff)
0041eeb3          return fconvert.t(var_c.q)
0041eeb3      
0041ee96      int32_t var_18_3 = eax
0041ee99      int32_t var_20_1
0041ee99      var_20_1.q = fconvert.d(fconvert.t(var_c.q))
0041eea1      int32_t var_28_1
0041eea1      var_28_1.q = fconvert.d(fconvert.t(arg1))
0041eea6      __builtin_memcpy(dest: &var_30, 
0041eea6          src: "\x10\x00\x00\x00\x0b\x00\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00", 
0041eea6          n: 0x18)
0041ee14  else
0041ee16      int32_t eax_2 = sub_423da4(0xffff, 0xffff)
0041ee16      
0041ee1f      if (eax_2 s> 0)
0041ee24          if (eax_2 s<= 2)
0041ee42              sub_423edc(x87control_1, eax, 0xffff)
0041eeb3              return fconvert.t(arg1)
0041eeb3          
0041ee29          if (eax_2 == 3)
0041ee2f              int32_t var_1c_1 = 0xffff
0041ee36              return sub_4236b1(eax_2, 0, 0xffff, 0xb, 9.18340949e-41f, eax)
0041ee36      
0041ee57      int32_t var_18_2 = eax
0041ee5a      int32_t var_20
0041ee5a      var_20.q = fconvert.d(fconvert.t(arg1) + fconvert.t(1.0))
0041ee62      int32_t var_28
0041ee62      var_28.q = fconvert.d(fconvert.t(arg1))
0041ee67      __builtin_memcpy(dest: &var_30, 
0041ee67          src: "\x08\x00\x00\x00\x0b\x00\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00\xff\xff\x00\x00", 
0041ee67          n: 0x18)
0041ee67  
0041eea8  return sub_423705(var_30, 0xb, 0xffff)


0041eeb4    uint32_t sub_41eeb4(void* arg1)

0041eeb7  sub_421919(9)
0041eeb7  
0041eeca  if (sub_4219cd(arg1) == 0)
0041eede      sub_42197a(9)
0041eef3      return HeapSize(hHeap: data_2823868, dwFlags: HEAP_NONE, lpMem: arg1)
0041eef3  
0041eed1  uint32_t result = *(arg1 - 4) - 9
0041eed4  sub_42197a(9)
0041eef8  return result


0041eef9    int32_t sub_41eef9(char arg1, void* arg2)

0041ef02  uint32_t eax = zx.d(arg1)
0041ef08  void* ecx = arg2
0041ef08  
0041ef0e  if (*(arg2 + 1) == 0x3a)
0041ef10      ecx = arg2 + 2
0041ef10  
0041ef13  char edx = *ecx
0041ef1d  int32_t edi_1
0041ef1d  
0041ef1d  if (edx != 0x5c && edx != 0x2f)
0041ef27      if ((eax.b & 0x10) == 0)
0041ef27          goto label_41ef2b
0041ef27      
0041ef32      edi_1 = 0x4040
0041ef1d  else if (*(ecx + 1) == 0 || (eax.b & 0x10) != 0)
0041ef32      edi_1 = 0x4040
0041ef27  else
0041ef2b      label_41ef2b:
0041ef2b      edi_1 = 0x8000
0041ef2b      
0041ef30      if (edx == 0)
0041ef32          edi_1 = 0x4040
0041ef32  
0041ef37  eax.b = not.b(eax.b)
0041ef3e  int32_t eax_1
0041ef3e  eax_1.b = (eax & 1).b | 2
0041ef44  int32_t edi_2 = edi_1 | eax_1 << 7
0041ef46  char* eax_3 = sub_4240ea(arg2, 0x2e)
0041ef46  
0041ef51  if (eax_3 != 0)
0041ef62      if (sub_423f55(eax_3, ".exe") == 0)
0041ef97          edi_2 |= 0x40
0041ef62      else if (sub_423f55(eax_3, ".cmd") == 0)
0041ef97          edi_2 |= 0x40
0041ef73      else if (sub_423f55(eax_3, ".bat") == 0)
0041ef97          edi_2 |= 0x40
0041ef84      else if (sub_423f55(eax_3, ".com") == 0)
0041ef97          edi_2 |= 0x40
0041ef97  
0041efa2  int32_t edi_3 = edi_2 | (edi_2 u>> 3 & 0x38)
0041efb0  return (edi_3 u>> 6 & 7) | edi_3


0041efb1    int32_t sub_41efb1(void* arg1, int32_t* arg2)

0041efbc  char* lpFileName = arg1
0041efbc  
0041efcf  if (sub_4242bf(lpFileName, "?*") == 0)
0041efd7      int32_t eax_6
0041efd7      
0041efd7      if (lpFileName[1] != 0x3a)
0041f00c          eax_6 = sub_424201()
0041f01c          label_41f01c:
0041f01c          WIN32_FIND_DATAA findFileData
0041f01c          HANDLE hFindFile = FindFirstFileA(lpFileName, lpFindFileData: &findFileData)
0041f02a          var_150
0041f02a          FILETIME var_20
0041f02a          int32_t* esi_1
0041f02a          
0041f02a          if (hFindFile != 0xffffffff)
0041f0ee              SYSTEMTIME systemTime
0041f0ee              
0041f0ee              if (FileTimeToLocalFileTime(lpFileTime: &var_150, lpLocalFileTime: &var_20)
0041f0ee                      == 0)
0041f256                  sub_41e94a(GetLastError())
0041f25f                  FindClose(hFindFile)
0041f0ee              else if (FileTimeToSystemTime(lpFileTime: &var_20, lpSystemTime: &systemTime)
0041f0ee                      == 0)
0041f256                  sub_41e94a(GetLastError())
0041f25f                  FindClose(hFindFile)
0041f104              else
0041f129                  int32_t eax_22 = sub_423190(zx.d(systemTime.wYear), 
0041f129                      zx.d(systemTime.wMonth), zx.d(systemTime.wDay), 
0041f129                      zx.d(systemTime.wHour), zx.d(systemTime.wMinute), 
0041f129                      zx.d(systemTime.wSecond), 0xffffffff)
0041f12e                  esi_1 = arg2
0041f134                  var_158
0041f134                  bool cond:2_1 = var_158.d != 0
0041f13a                  esi_1[7] = eax_22
0041f13a                  
0041f145                  if (not(cond:2_1) && var_158:4.d == 0)
0041f13d                      goto label_41f19d
0041f13d                  
0041f15a                  if (FileTimeToLocalFileTime(lpFileTime: &var_158, 
0041f15a                          lpLocalFileTime: &var_20) == 0)
0041f256                      sub_41e94a(GetLastError())
0041f25f                      FindClose(hFindFile)
0041f15a                  else if (FileTimeToSystemTime(lpFileTime: &var_20, 
0041f15a                          lpSystemTime: &systemTime) == 0)
0041f256                      sub_41e94a(GetLastError())
0041f25f                      FindClose(hFindFile)
0041f170                  else
0041f195                      eax_22 = sub_423190(zx.d(systemTime.wYear), zx.d(systemTime.wMonth), 
0041f195                          zx.d(systemTime.wDay), zx.d(systemTime.wHour), 
0041f195                          zx.d(systemTime.wMinute), zx.d(systemTime.wSecond), 0xffffffff)
0041f19d                      label_41f19d:
0041f19d                      var_160
0041f19d                      bool cond:5_1 = var_160.d != 0
0041f1a3                      esi_1[6] = eax_22
0041f1ae                      int32_t eax_31
0041f1ae                      
0041f1ae                      if (not(cond:5_1) && var_160:4.d == 0)
0041f1b0                          eax_31 = esi_1[7]
0041f20a                          label_41f20a:
0041f20a                          esi_1[8] = eax_31
0041f20d                          FindClose(hFindFile)
0041f20d                          goto label_41f221
0041f20d                      
0041f1c8                      if (FileTimeToLocalFileTime(lpFileTime: &var_160, 
0041f1c8                              lpLocalFileTime: &var_20) == 0)
0041f256                          sub_41e94a(GetLastError())
0041f25f                          FindClose(hFindFile)
0041f1c8                      else
0041f1de                          if (FileTimeToSystemTime(lpFileTime: &var_20, 
0041f1de                                  lpSystemTime: &systemTime) != 0)
0041f1ff                              eax_31 = sub_423190(zx.d(systemTime.wYear), 
0041f1ff                                  zx.d(systemTime.wMonth), zx.d(systemTime.wDay), 
0041f1ff                                  zx.d(systemTime.wHour), zx.d(systemTime.wMinute), 
0041f1ff                                  zx.d(systemTime.wSecond), 0xffffffff)
0041f204                              goto label_41f20a
0041f204                          
0041f256                          sub_41e94a(GetLastError())
0041f25f                          FindClose(hFindFile)
0041f02a          else if (sub_4242bf(lpFileName, "./\") == 0)
0041f0cd              *sub_41e9bd() = 2
0041f0d4              *sub_41e9c6() = 2
0041f03f          else
0041f052              char var_268[0x104]
0041f052              void* lpRootPathName = sub_42415c(&var_268, lpFileName, 0x104)
0041f052              
0041f05e              if (lpRootPathName == 0)
0041f0cd                  *sub_41e9bd() = 2
0041f0d4                  *sub_41e9c6() = 2
0041f05e              else
0041f066                  bool cond:3_1 = sub_422550(lpRootPathName) == 3
0041f06a                  bool cond:4_1
0041f06a                  
0041f06a                  if (not(cond:3_1))
0041f072                      cond:4_1 = sub_41f26c(lpRootPathName) == 0
0041f072                  
0041f075                  if (not(cond:3_1) && cond:4_1)
0041f0cd                      *sub_41e9bd() = 2
0041f0d4                      *sub_41e9c6() = 2
0041f075                  else
0041f081                      if (GetDriveTypeA(lpRootPathName) u> 1)
0041f090                          findFileData.dwFileAttributes = 0x10
0041f09a                          findFileData.nFileSizeHigh = 0
0041f0a0                          findFileData.nFileSizeLow = 0
0041f0a6                          findFileData.cFileName[0] = 0
0041f0ac                          int32_t eax_11 = sub_423190(0x7bc, 1, 1, 0, 0, 0, 0xffffffff)
0041f0b1                          esi_1 = arg2
0041f0b7                          esi_1[7] = eax_11
0041f0ba                          esi_1[6] = eax_11
0041f0bd                          esi_1[8] = eax_11
0041f221                          label_41f221:
0041f221                          *(esi_1 + 6) = sub_41eef9((findFileData.dwFileAttributes).b, arg1)
0041f22b                          esi_1[5] = findFileData.nFileSizeLow
0041f233                          *esi_1 = eax_6 - 1
0041f235                          esi_1[4] = eax_6 - 1
0041f239                          esi_1[2].w = 1
0041f23f                          esi_1[1].w = 0
0041f243                          esi_1[3].w = 0
0041f247                          *(esi_1 + 0xa) = 0
0041f24b                          return 0
0041f24b                      
0041f0cd                      *sub_41e9bd() = 2
0041f0d4                      *sub_41e9c6() = 2
0041f265          return 0xffffffff
0041f265      
0041efd9      void* eax
0041efd9      eax.b = *lpFileName
0041efd9      
0041efe2      if (eax.b == 0 || lpFileName[2] != 0)
0041f000          int32_t var_278_1 = sx.d(eax.b)
0041f007          eax_6 = sub_424244(&data_4292a8) - 0x60
0041f00a          goto label_41f01c
0041f00a  
0041efec  *sub_41e9bd() = 2
0041eff3  *sub_41e9c6() = 2
0041eff5  return 0xffffffff


0041f26c    int32_t sub_41f26c(char* arg1)

0041f27b  if (sub_422550(arg1) u>= 5)
0041f27d      void* eax
0041f27d      eax.b = *arg1
0041f27d      
0041f285      if (eax.b == 0x5c || eax.b == 0x2f)
0041f287          eax.b = arg1[1]
0041f287          
0041f290          if (eax.b == 0x5c || eax.b == 0x2f)
0041f292              char i = arg1[3]
0041f295              void* eax_1 = &arg1[3]
0041f295              
0041f29c              while (i != 0)
0041f2a1                  if (i == 0x5c)
0041f2a1                      break
0041f2a1                  
0041f2a6                  if (i == 0x2f)
0041f2a6                      break
0041f2a6                  
0041f2a8                  i = *(eax_1 + 1)
0041f2ab                  eax_1 += 1
0041f2ab              
0041f2b0              if (*eax_1 != 0)
0041f2b2                  void* eax_2 = eax_1 + 1
0041f2b2                  
0041f2b5                  if (*eax_2 != 0)
0041f2b7                      while (true)
0041f2b7                          i = *eax_2
0041f2b7                          
0041f2bb                          if (i == 0)
0041f2bb                              break
0041f2bb                          
0041f2c0                          if (i == 0x5c)
0041f2c0                              break
0041f2c0                          
0041f2c5                          if (i == 0x2f)
0041f2c5                              break
0041f2c5                          
0041f2c7                          eax_2 += 1
0041f2c7                      
0041f2d1                      if (*eax_2 == 0 || *(eax_2 + 1) == 0)
0041f2d7                          return 1
0041f2d7  
0041f2db  return 0


0041f2dc    char* sub_41f2dc(char* arg1, char* arg2, char* arg3, char* arg4, char* arg5)

0041f2df  int32_t ecx
0041f2df  int32_t var_8 = ecx
0041f2e0  void* result_1 = nullptr
0041f2e5  char* result_2 = arg1
0041f2e5  
0041f2fa  if (sub_422550(result_2) u>= 1 && result_2[1] == 0x3a)
0041f301      if (arg2 != 0)
0041f307          sub_424748(arg2, result_2, 2)
0041f30f          arg2[2] = 0
0041f30f      
0041f314      result_2 = &result_2[2]
0041f2fa  else if (arg2 != 0)
0041f31e      *arg2 = 0
0041f31e  
0041f321  arg2 = nullptr
0041f328  char* result = result_2
0041f32a  void* esi_2 = 0xff
0041f32f  arg1 = result
0041f32f  
0041f332  if (*result_2 != 0)
0041f363      do
0041f334          char* ecx_1
0041f334          ecx_1.b = *result
0041f334          
0041f340          if ((*(zx.d(ecx_1.b) + 0x2823741) & 4) != 0)
0041f342              result = &result[1]
0041f340          else if (ecx_1.b == 0x2f || ecx_1.b == 0x5c)
0041f35c              arg2 = &result[1]
0041f34d          else if (ecx_1.b == 0x2e)
0041f354              result_1 = result
0041f354          
0041f35f          result = &result[1]
0041f363      while (*result != 0)
0041f363      
0041f368      arg1 = result
0041f368  
0041f36d  if (*result_2 != 0 && arg2 != 0)
0041f373      if (arg3 != 0)
0041f375          void* edi_2 = arg2 - result_2
0041f375          
0041f379          if (edi_2 u>= 0xff)
0041f37b              edi_2 = 0xff
0041f37b          
0041f382          sub_424748(arg3, result_2, edi_2)
0041f38d          *(edi_2 + arg3) = 0
0041f391          result = arg1
0041f391      
0041f394      result_2 = arg2
0041f36d  else if (arg3 != 0)
0041f3a0      *arg3 = 0
0041f3a0  
0041f3ac  if (result_1 == 0 || result_1 u< result_2)
0041f3fb      if (arg4 != 0)
0041f3fd          void* eax_5 = result - result_2
0041f3fd          
0041f401          if (eax_5 u< 0xff)
0041f403              esi_2 = eax_5
0041f403          
0041f408          sub_424748(arg4, result_2, esi_2)
0041f410          *(esi_2 + arg4) = 0
0041f410      
0041f414      result = arg5
0041f414      
0041f419      if (result != 0)
0041f41b          *result = 0
0041f3ac  else
0041f3b2      if (arg4 != 0)
0041f3b4          char* edi_4 = result_1 - result_2
0041f3b4          
0041f3b8          if (edi_4 u>= 0xff)
0041f3ba              edi_4 = 0xff
0041f3ba          
0041f3c1          sub_424748(arg4, result_2, edi_4)
0041f3cc          *(edi_4 + arg4) = 0
0041f3d0          result = arg1
0041f3d0      
0041f3d8      if (arg5 != 0)
0041f3da          void* eax_4 = result - result_1
0041f3da          
0041f3df          if (eax_4 u< 0xff)
0041f3e1              esi_2 = eax_4
0041f3e1          
0041f3e8          result = sub_424748(arg5, result_1, esi_2)
0041f3f0          *(esi_2 + arg5) = 0
0041f3f0  
0041f422  return result

0041f423           cc cc cc cc cc cc cc cc cc cc cc cc cc                                                     .............

0041f430    int32_t sub_41f430(void* arg1, void* arg2, int32_t arg3)

0041f436  int32_t i = arg3
0041f436  
0041f439  if (i != 0)
0041f43b      int32_t i_2 = i
0041f43d      void* edi_1 = arg1
0041f440      void* esi_1 = edi_1
0041f440      
0041f444      while (i != 0)
0041f444          bool cond:0_1 = 0 != *edi_1
0041f444          edi_1 += 1
0041f444          i -= 1
0041f444          
0041f444          if (not(cond:0_1))
0041f444              break
0041f444      
0041f448      int32_t i_1 = neg.d(i) + i_2
0041f44a      void* edi_2 = esi_1
0041f44c      void* esi_2 = arg2
0041f44c      
0041f44f      while (i_1 != 0)
0041f44f          bool cond:1_1 = *esi_2 == *edi_2
0041f44f          esi_2 += 1
0041f44f          edi_2 += 1
0041f44f          i_1 -= 1
0041f44f          
0041f44f          if (not(cond:1_1))
0041f44f              break
0041f44f      
0041f451      char eax_1 = *(esi_2 - 1)
0041f454      i = 0
0041f456      char temp0_1 = *(edi_2 - 1)
0041f456      
0041f459      if (eax_1 u> temp0_1)
0041f45f          return not.d(i)
0041f45f      
0041f45b      if (eax_1 != temp0_1)
0041f45f          return not.d(0xfffffffe)
0041f45f  
0041f467  return i

0041f468                          cc cc cc cc cc cc cc cc                                                          ........

0041f470    char* sub_41f470(char* arg1, char* arg2, int32_t arg3)

0041f470  int32_t i_3 = arg3
0041f470  
0041f477  if (i_3 != 0)
0041f47d      char* edi_1 = arg1
0041f489      void* edi_2
0041f489      
0041f489      while ((edi_1 & 3) != 0)
0041f48b          char eax = *edi_1
0041f48d          edi_1 = &edi_1[1]
0041f48d          
0041f490          if (eax == 0)
0041f4cb              label_41f4cb:
0041f4cb              edi_2 = edi_1 - 1
0041f4cc              goto label_41f4db
0041f4cc      
0041f49a      while (true)
0041f49a          int32_t eax_1 = *edi_1
0041f4a8          edi_1 = &edi_1[4]
0041f4a8          
0041f4b0          if (((eax_1 ^ 0xffffffff ^ (0x7efefeff + eax_1)) & 0x81010100) != 0)
0041f4b2              int32_t eax_4 = *(edi_1 - 4)
0041f4b2              
0041f4b7              if (eax_4.b == 0)
0041f4d8                  edi_2 = edi_1 - 4
0041f4d8                  break
0041f4d8              
0041f4bb              if (eax_4:1.b == 0)
0041f4d3                  edi_2 = edi_1 - 3
0041f4d6                  break
0041f4d6              
0041f4c2              if ((eax_4 & 0xff0000) == 0)
0041f4ce                  edi_2 = edi_1 - 2
0041f4d1                  break
0041f4d1              
0041f4c9              if ((eax_4 & 0xff000000) == 0)
0041f4c9                  goto label_41f4cb
0041f4c9      
0041f4db      label_41f4db:
0041f4db      char* esi_1 = arg2
0041f4e5      int32_t edx
0041f4e5      int32_t i_4
0041f4e5      uint32_t i_2
0041f4e5      
0041f4e5      if ((esi_1 & 3) != 0)
0041f503          do
0041f4f0              edx.b = *esi_1
0041f4f2              esi_1 = &esi_1[1]
0041f4f2              
0041f4f5              if (edx.b == 0)
0041f52a                  label_41f52a:
0041f52a                  *edi_2 = edx.b
0041f533                  return arg1
0041f533              
0041f4f7              *edi_2 = edx.b
0041f4f9              edi_2 += 1
0041f4fa              int32_t i_5 = i_3
0041f4fa              i_3 -= 1
0041f4fa              
0041f4fb              if (i_5 == 1)
0041f4fb                  goto label_41f520
0041f503          while ((esi_1 & 3) != 0)
0041f503          
0041f505          i_4 = i_3
0041f507          i_2 = i_3 u>> 2
0041f507          
0041f50a          if (i_2 != 0)
0041f50a              goto label_41f53a
0041f4e5      else
0041f4e7          i_4 = i_3
0041f4e9          i_2 = i_3 u>> 2
0041f4e9          
0041f4ec          if (i_2 != 0)
0041f53a              label_41f53a:
0041f53a              uint32_t i
0041f53a              
0041f53a              do
0041f541                  int32_t eax_7 = *esi_1
0041f54a                  edx = *esi_1
0041f54c                  esi_1 = &esi_1[4]
0041f54c                  
0041f554                  if (((eax_7 ^ 0xffffffff ^ (0x7efefeff + eax_7)) & 0x81010100) != 0)
0041f558                      if (edx.b == 0)
0041f558                          goto label_41f52a
0041f558                      
0041f55c                      if (edx:1.b == 0)
0041f588                          *edi_2 = edx.w
0041f592                          return arg1
0041f592                      
0041f564                      if ((edx & 0xff0000) == 0)
0041f578                          *edi_2 = edx.w
0041f581                          *(edi_2 + 2) = 0
0041f587                          return arg1
0041f587                      
0041f56c                      if ((edx & 0xff000000) == 0)
0041f56e                          *edi_2 = edx
0041f577                          return arg1
0041f577                  
0041f534                  *edi_2 = edx
0041f536                  edi_2 += 4
0041f539                  i = i_2
0041f539                  i_2 -= 1
0041f53a              while (i != 1)
0041f50e      i_3 = i_4 & 3
0041f50e      
0041f511      if (i_3 != 0)
0041f51e          int32_t i_1
0041f51e          
0041f51e          do
0041f513              edx.b = *esi_1
0041f515              esi_1 = &esi_1[1]
0041f516              *edi_2 = edx.b
0041f518              edi_2 += 1
0041f518              
0041f51b              if (edx.b == 0)
0041f529                  return arg1
0041f529              
0041f51d              i_1 = i_3
0041f51d              i_3 -= 1
0041f51e          while (i_1 != 1)
0041f51e      
0041f520      label_41f520:
0041f520      *edi_2 = i_3.b
0041f520  
0041f529  return arg1

0041f593                                                           cc cc cc cc cc cc cc cc cc cc cc cc cc                     .............

0041f5a0    char* sub_41f5a0(char* arg1, char* arg2, int32_t arg3)

0041f5a5  char* esi = arg2
0041f5ab  char* edi = arg1
0041f5ba  uint32_t eax_1
0041f5ba  
0041f5ba  if (edi u> esi && edi u< &esi[arg3])
0041f738      void* esi_1 = &esi[arg3 - 4]
0041f73c      void* edi_1 = &edi[arg3 - 4]
0041f746      int32_t edx_2
0041f746      uint32_t ecx_4
0041f746      
0041f746      if ((edi_1 & 3) == 0)
0041f748          ecx_4 = arg3 u>> 2
0041f74b          edx_2 = arg3 & 3
0041f74b          
0041f751          if (ecx_4 u>= 8)
0041f754              edi_1, esi_1 = __builtin_memcpy(dest: edi_1 - (ecx_4 << 2), 
0041f754                  src: esi_1 - (ecx_4 << 2), n: ecx_4 << 2)
0041f754              
0041f757              switch (edx_2)
0041f896                  case 0
0041f896                      return arg1
0041f757                  case 1
0041f757                      goto label_41f898
0041f757                  case 2
0041f757                      goto label_41f8a8
0041f757                  case 3
0041f757                      goto label_41f8bc
0041f746      else if (arg3 u< 4)
0041f776          switch (arg3)
0041f896              case 0
0041f896                  return arg1
0041f898              case 1
0041f898                  label_41f898:
0041f898                  eax_1.b = *(esi_1 + 3)
0041f89b                  *(edi_1 + 3) = eax_1.b
0041f8a4                  return arg1
0041f8a8              case 2
0041f8a8                  label_41f8a8:
0041f8a8                  eax_1.b = *(esi_1 + 3)
0041f8ab                  *(edi_1 + 3) = eax_1.b
0041f8ae                  eax_1.b = *(esi_1 + 2)
0041f8b1                  *(edi_1 + 2) = eax_1.b
0041f8ba                  return arg1
0041f8bc              case 3
0041f8bc                  label_41f8bc:
0041f8bc                  eax_1.b = *(esi_1 + 3)
0041f8bf                  *(edi_1 + 3) = eax_1.b
0041f8c2                  eax_1.b = *(esi_1 + 2)
0041f8c5                  *(edi_1 + 2) = eax_1.b
0041f8c8                  eax_1.b = *(esi_1 + 1)
0041f8cb                  *(edi_1 + 1) = eax_1.b
0041f8d4                  return arg1
0041f776      else
0041f778          eax_1 = edi_1 & 3
0041f77b          int32_t ecx_6 = arg3 - eax_1
0041f77b          
0041f77d          switch (jump_table_41f788[eax_1])
0041f798              case 0x41f798
0041f798                  eax_1.b = *(esi_1 + 3)
0041f79b                  edx_2 = 3 & ecx_6
0041f79d                  *(edi_1 + 3) = eax_1.b
0041f7a0                  esi_1 -= 1
0041f7a1                  ecx_4 = ecx_6 u>> 2
0041f7a4                  edi_1 -= 1
0041f7a4                  
0041f7a8                  if (ecx_4 u>= 8)
0041f7ab                      edi_1, esi_1 = __builtin_memcpy(dest: edi_1 - (ecx_4 << 2), 
0041f7ab                          src: esi_1 - (ecx_4 << 2), n: ecx_4 << 2)
0041f7ab                      
0041f7ae                      switch (edx_2)
0041f896                          case 0
0041f896                              return arg1
0041f7ae                          case 1
0041f7ae                              goto label_41f898
0041f7ae                          case 2
0041f7ae                              goto label_41f8a8
0041f7ae                          case 3
0041f7ae                              goto label_41f8bc
0041f7b8              case 0x41f7b8
0041f7b8                  eax_1.b = *(esi_1 + 3)
0041f7bb                  edx_2 = 3 & ecx_6
0041f7bd                  *(edi_1 + 3) = eax_1.b
0041f7c0                  eax_1.b = *(esi_1 + 2)
0041f7c3                  ecx_4 = ecx_6 u>> 2
0041f7c6                  *(edi_1 + 2) = eax_1.b
0041f7c9                  esi_1 -= 2
0041f7cc                  edi_1 -= 2
0041f7cc                  
0041f7d2                  if (ecx_4 u>= 8)
0041f7d5                      edi_1, esi_1 = __builtin_memcpy(dest: edi_1 - (ecx_4 << 2), 
0041f7d5                          src: esi_1 - (ecx_4 << 2), n: ecx_4 << 2)
0041f7d5                      
0041f7d8                      switch (edx_2)
0041f896                          case 0
0041f896                              return arg1
0041f7d8                          case 1
0041f7d8                              goto label_41f898
0041f7d8                          case 2
0041f7d8                              goto label_41f8a8
0041f7d8                          case 3
0041f7d8                              goto label_41f8bc
0041f7e0              case 0x41f7e0
0041f7e0                  eax_1.b = *(esi_1 + 3)
0041f7e3                  edx_2 = 3 & ecx_6
0041f7e5                  *(edi_1 + 3) = eax_1.b
0041f7e8                  eax_1.b = *(esi_1 + 2)
0041f7eb                  *(edi_1 + 2) = eax_1.b
0041f7ee                  eax_1.b = *(esi_1 + 1)
0041f7f1                  ecx_4 = ecx_6 u>> 2
0041f7f4                  *(edi_1 + 1) = eax_1.b
0041f7f7                  esi_1 -= 3
0041f7fa                  edi_1 -= 3
0041f7fa                  
0041f800                  if (ecx_4 u>= 8)
0041f807                      edi_1, esi_1 = __builtin_memcpy(dest: edi_1 - (ecx_4 << 2), 
0041f807                          src: esi_1 - (ecx_4 << 2), n: ecx_4 << 2)
0041f807                      
0041f80a                      switch (edx_2)
0041f896                          case 0
0041f896                              return arg1
0041f80a                          case 1
0041f80a                              goto label_41f898
0041f80a                          case 2
0041f80a                              goto label_41f8a8
0041f80a                          case 3
0041f80a                              goto label_41f8bc
0041f80a      
0041f877      switch (edx_2)
0041f896          case 0
0041f896              return arg1
0041f877          case 1
0041f877              goto label_41f898
0041f877          case 2
0041f877              goto label_41f8a8
0041f877          case 3
0041f877              goto label_41f8bc
0041f877  
0041f5c6  uint32_t ecx_1
0041f5c6  int32_t edx_1
0041f5c6  
0041f5c6  if ((edi & 3) != 0)
0041f5e6      if (arg3 u< 4)
0041f5f4          jump(*(((arg3 - 4) << 2) + &data_41f6f8))
0041f5f4      
0041f5e8      eax_1 = edi & 3
0041f5eb      int32_t ecx_3 = arg3 - 4 + eax_1
0041f5eb      
0041f5ed      switch (jump_table_41f600[eax_1])
0041f610          case 0x41f610
0041f610              edx_1 = 3 & ecx_3
0041f612              eax_1.b = *esi
0041f614              *edi = eax_1.b
0041f616              eax_1.b = esi[1]
0041f619              edi[1] = eax_1.b
0041f61c              eax_1.b = esi[2]
0041f61f              ecx_1 = ecx_3 u>> 2
0041f622              edi[2] = eax_1.b
0041f625              esi = &esi[3]
0041f628              edi = &edi[3]
0041f628              
0041f62e              if (ecx_1 u>= 8)
0041f630                  edi, esi = __builtin_memcpy(dest: edi, src: esi, n: ecx_1 << 2)
0041f630                  
0041f632                  switch (edx_1)
0041f6fe                      case 0
0041f6fe                          return arg1
0041f632                      case 1
0041f632                          goto label_41f700
0041f632                      case 2
0041f632                          goto label_41f70c
0041f632                      case 3
0041f632                          goto label_41f720
0041f63c          case 0x41f63c
0041f63c              edx_1 = 3 & ecx_3
0041f63e              eax_1.b = *esi
0041f640              *edi = eax_1.b
0041f642              eax_1.b = esi[1]
0041f645              ecx_1 = ecx_3 u>> 2
0041f648              edi[1] = eax_1.b
0041f64b              esi = &esi[2]
0041f64e              edi = &edi[2]
0041f64e              
0041f654              if (ecx_1 u>= 8)
0041f656                  edi, esi = __builtin_memcpy(dest: edi, src: esi, n: ecx_1 << 2)
0041f656                  
0041f658                  switch (edx_1)
0041f6fe                      case 0
0041f6fe                          return arg1
0041f658                      case 1
0041f658                          goto label_41f700
0041f658                      case 2
0041f658                          goto label_41f70c
0041f658                      case 3
0041f658                          goto label_41f720
0041f660          case 0x41f660
0041f660              edx_1 = 3 & ecx_3
0041f662              eax_1.b = *esi
0041f664              *edi = eax_1.b
0041f666              esi = &esi[1]
0041f667              ecx_1 = ecx_3 u>> 2
0041f66a              edi = &edi[1]
0041f66a              
0041f66e              if (ecx_1 u>= 8)
0041f670                  edi, esi = __builtin_memcpy(dest: edi, src: esi, n: ecx_1 << 2)
0041f670                  
0041f672                  switch (edx_1)
0041f6fe                      case 0
0041f6fe                          return arg1
0041f672                      case 1
0041f672                          goto label_41f700
0041f672                      case 2
0041f672                          goto label_41f70c
0041f672                      case 3
0041f672                          goto label_41f720
0041f5c6  else
0041f5c8      ecx_1 = arg3 u>> 2
0041f5cb      edx_1 = arg3 & 3
0041f5cb      
0041f5d1      if (ecx_1 u>= 8)
0041f5d3          edi, esi = __builtin_memcpy(dest: edi, src: esi, n: ecx_1 << 2)
0041f5d3          
0041f5d5          switch (edx_1)
0041f6fe              case 0
0041f6fe                  return arg1
0041f5d5              case 1
0041f5d5                  goto label_41f700
0041f5d5              case 2
0041f5d5                  goto label_41f70c
0041f5d5              case 3
0041f5d5                  goto label_41f720
0041f5d5  
0041f5fc  switch (ecx_1)
0041f5fc      case 0
0041f5fc          goto label_41f6df
0041f5fc      case 1
0041f5fc          goto label_41f6d0
0041f5fc      case 2
0041f5fc          goto label_41f6c8
0041f5fc      case 3
0041f5fc          goto label_41f6c0
0041f5fc      case 4
0041f5fc          goto label_41f6b8
0041f5fc      case 5
0041f5fc          goto label_41f6b0
0041f5fc      case 6
0041f5fc          goto label_41f6a8
0041f6a0      case 7
0041f6a0          *(edi + (ecx_1 << 2) - 0x1c) = *(esi + (ecx_1 << 2) - 0x1c)
0041f6a8          label_41f6a8:
0041f6a8          *(edi + (ecx_1 << 2) - 0x18) = *(esi + (ecx_1 << 2) - 0x18)
0041f6b0          label_41f6b0:
0041f6b0          *(edi + (ecx_1 << 2) - 0x14) = *(esi + (ecx_1 << 2) - 0x14)
0041f6b8          label_41f6b8:
0041f6b8          *(edi + (ecx_1 << 2) - 0x10) = *(esi + (ecx_1 << 2) - 0x10)
0041f6c0          label_41f6c0:
0041f6c0          *(edi + (ecx_1 << 2) - 0xc) = *(esi + (ecx_1 << 2) - 0xc)
0041f6c8          label_41f6c8:
0041f6c8          *(edi + (ecx_1 << 2) - 8) = *(esi + (ecx_1 << 2) - 8)
0041f6d0          label_41f6d0:
0041f6d0          *(edi + (ecx_1 << 2) - 4) = *(esi + (ecx_1 << 2) - 4)
0041f6d4          eax_1 = ecx_1 << 2
0041f6db          esi = &esi[eax_1]
0041f6dd          edi = &edi[eax_1]
0041f6df          label_41f6df:
0041f6df          
0041f6df          switch (edx_1)
0041f6fe              case 0
0041f6fe                  return arg1
0041f700              case 1
0041f700                  label_41f700:
0041f700                  eax_1.b = *esi
0041f702                  *edi = eax_1.b
0041f70a                  return arg1
0041f70c              case 2
0041f70c                  label_41f70c:
0041f70c                  eax_1.b = *esi
0041f70e                  *edi = eax_1.b
0041f710                  eax_1.b = esi[1]
0041f713                  edi[1] = eax_1.b
0041f71c                  return arg1
0041f720              case 3
0041f720                  label_41f720:
0041f720                  eax_1.b = *esi
0041f722                  *edi = eax_1.b
0041f724                  eax_1.b = esi[1]
0041f727                  edi[1] = eax_1.b
0041f72a                  eax_1.b = esi[2]
0041f72d                  edi[2] = eax_1.b
0041f736                  return arg1

0041f5fb                                                                                   90                                         .
0041f603           90 10 f6 41 00 3c f6 41 00 60 f6 41 00                                                     ...A.<.A.`.A.
0041f639                                                                             8d 49 00                                       .I.
0041f65f                                                                                               90                                 .
0041f679                                                                             8d 49 00                                       .I.
0041f67c  uint32_t jump_table_41f67c[0x8] = 
0041f67c  {
0041f67c      [0x0] =  0x0041f6df
0041f680      [0x1] =  0x0041f6cc
0041f684      [0x2] =  0x0041f6c4
0041f688      [0x3] =  0x0041f6bc
0041f68c      [0x4] =  0x0041f6b4
0041f690      [0x5] =  0x0041f6ac
0041f694      [0x6] =  0x0041f6a4
0041f698      [0x7] =  0x0041f69c
0041f69c  }

0041f6e6                    8b ff                                                                                ..
0041f6e8  uint32_t jump_table_41f6e8[0x4] = 
0041f6e8  {
0041f6e8      [0x0] =  0x0041f6f8
0041f6ec      [0x1] =  0x0041f700
0041f6f0      [0x2] =  0x0041f70c
0041f6f4      [0x3] =  0x0041f720
0041f6f8  }

0041f6ff                                                                                               90                                 .
0041f70b                                   90                                                                         .
0041f71d                                                                                         8d 49 00                               .I.
0041f737                                                                       90                                                 .
0041f75e                                                                                            8b ff                                ..
0041f769                             8d 49 00                                                                       .I.
0041f78b                                   90 98 f7 41 00 b8 f7 41 00 e0 f7 41 00                                     ...A...A...A.
0041f7b5                                                                 8d 49 00                                               .I.
0041f7df                                                                                               90                                 .
0041f811                                                     8d 49 00 34 f8 41 00 3c f8 41 00 44 f8 41 00                   .I.4.A.<.A.D.A.
0041f820  4c f8 41 00 54 f8 41 00 5c f8 41 00 64 f8 41 00                                                  L.A.T.A.\.A.d.A.
0041f830  uint32_t jump_table_41f830[0x1] = 
0041f830  {
0041f830      [0x0] =  0x0041f877
0041f834  }

0041f834                                                              8b 44 8e 1c 89 44 8f 1c 8b 44 8e 18                      .D...D...D..
0041f840  89 44 8f 18 8b 44 8e 14 89 44 8f 14 8b 44 8e 10 89 44 8f 10 8b 44 8e 0c 89 44 8f 0c 8b 44 8e 08  .D...D...D...D...D...D...D...D..
0041f860  89 44 8f 08 8b 44 8e 04 89 44 8f 04 8d 04 8d 00 00 00 00 03 f0 03 f8                             .D...D...D.............
0041f87e                                                                                            8b ff                                ..
0041f880  uint32_t jump_table_41f880[0x4] = 
0041f880  {
0041f880      [0x0] =  0x0041f890
0041f884      [0x1] =  0x0041f898
0041f888      [0x2] =  0x0041f8a8
0041f88c      [0x3] =  0x0041f8bc
0041f890  }

0041f897                                                                       90                                                 .
0041f8a5                 8d 49 00                                                                               .I.
0041f8bb                                                                                   90                                         .

0041f8d5    int32_t _start()

0041f8d5  int32_t ebp
0041f8d5  int32_t var_4 = ebp
0041f8d8  int32_t var_8 = 0xffffffff
0041f8da  int32_t var_c = 0x4292b0
0041f8df  int32_t var_10 = 0x424e8c
0041f8ea  TEB* fsbase
0041f8ea  struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList
0041f8eb  fsbase->NtTib.ExceptionList = &ExceptionList
0041f8f5  int32_t ebx
0041f8f5  int32_t var_28 = ebx
0041f8f6  int32_t esi
0041f8f6  int32_t var_2c = esi
0041f8f7  int32_t edi
0041f8f7  int32_t var_30 = edi
0041f8f8  int32_t* var_1c = &var_30
0041f8fb  uint32_t eax_1 = GetVersion()
0041f903  int32_t edx
0041f903  edx.b = eax_1:1.b
0041f905  data_430b84 = edx
0041f90d  uint32_t ecx_1 = zx.d(eax_1.b)
0041f913  data_430b80 = ecx_1
0041f91e  data_430b7c = (ecx_1 << 8) + edx
0041f927  data_430b78 = eax_1 u>> 0x10
0041f927  
0041f936  if (sub_4218b4(1) == 0)
0041f93a      sub_41f9ea(0x1c)
0041f93a      noreturn
0041f93a  
0041f947  if (sub_42332c() == 0)
0041f94b      sub_41f9ea(0x10)
0041f94b      noreturn
0041f94b  
0041f951  int32_t var_8_1 = 0
0041f955  sub_421648()
0041f960  data_28249a4 = GetCommandLineA()
0041f965  void* eax_6
0041f965  int32_t ecx_5
0041f965  eax_6, ecx_5 = sub_424c60()
0041f96a  data_430bf8 = eax_6
0041f96f  sub_424a13(ecx_5)
0041f974  sub_42495a()
0041f979  sub_41e2e6()
0041f97e  int32_t eax_7 = data_430b94
0041f983  data_430b98 = eax_7
0041f988  int32_t var_34 = eax_7
0041f995  sub_408510(data_430b88, data_430b8c)
0041f99d  int32_t var_20 = 0
0041f9a1  sub_41e313(0)
0041f9ab  int32_t* var_18
0041f9ab  int32_t ecx_7 = **var_18
0041f9ad  int32_t var_24 = ecx_7
0041f9b9  return sub_4247e2(ecx_7, var_18)

0041f93f                                                                                               59                                 Y
0041f950                                                  59                                                               Y
0041f9ba                                                                                8b 65 e8 ff 75 e0                            .e..u.
0041f9c0  e8 5f e9 ff ff                                                                                   ._...

0041f9c5    int32_t sub_41f9c5(uint32_t arg1)

0041f9cc  if (data_430c00 != 2)
0041f9ce      sub_424f64()
0041f9ce  
0041f9d7  sub_424f9d(arg1)
0041f9e9  return data_42f320(0xff)


0041f9ea    void sub_41f9ea(uint32_t arg1) __noreturn

0041f9f1  if (data_430c00 != 2)
0041f9f3      sub_424f64()
0041f9f3  
0041f9fc  sub_424f9d(arg1)
0041fa07  ExitProcess(uExitCode: 0xff)
0041fa07  noreturn

0041fa0d                                         c3                                                                     .

0041fa0e    int32_t sub_41fa0e()

0041fa1f  return sub_425125(0x10000, 0x30000)


0041fa20    int32_t sub_41fa20() __pure

0041fa2c  double var_c = fconvert.d(fconvert.t(3145727.0))
0041fa35  double var_14 = fconvert.d(fconvert.t(4195835.0))
0041fa47  long double x87_r7_6 = fconvert.t(fconvert.d(fconvert.t(var_14)
0041fa47      - fconvert.t(var_14) / fconvert.t(var_c) * fconvert.t(var_c)))
0041fa4a  long double temp0 = fconvert.t(1.0)
0041fa4a  x87_r7_6 - temp0
0041fa50  int16_t eax = (x87_r7_6 < temp0 ? 1 : 0) << 8
0041fa50      | (is_unordered.t(x87_r7_6, temp0) ? 1 : 0) << 0xa
0041fa50      | (x87_r7_6 == temp0 ? 1 : 0) << 0xe
0041fa50  
0041fa53  if (test_bit(eax:1.b, 6) || test_bit(eax:1.b, 0))
0041fa5d      return 0
0041fa5d  
0041fa59  return 1


0041fa5e    int32_t sub_41fa5e()

0041fa63  HMODULE hModule = GetModuleHandleA(lpModuleName: "KERNEL32")
0041fa63  
0041fa6b  if (hModule != 0)
0041fa73      int32_t eax = GetProcAddress(hModule, lpProcName: "IsProcessorFeaturePresent")
0041fa73      
0041fa7b      if (eax != 0)
0041fa81          return eax(0)
0041fa81  
0041fa82  return sub_41fa20() __tailcall


0041fa87    uint32_t sub_41fa87(char* arg1)

0041fa88  char* esi = arg1
0041fa8c  int32_t eax = sx.d(*esi)
0041fa90  uint32_t i
0041fa90  int32_t edx
0041fa90  i, edx = sub_41eb0a(eax)
0041fa98  int32_t ecx = eax
0041fa98  
0041fa99  if (i != 0x65)
0041fac5      do
0041fa9b          esi = &esi[1]
0041fa9b          
0041faa3          if (data_42f800 s<= 1)
0041fab7              ecx = data_42f5f4
0041fabd              int32_t eax_2
0041fabd              eax_2.b = *(ecx + (sx.d(*esi) << 1))
0041fac0              i = eax_2 & 4
0041faa3          else
0041faa5              int32_t eax_1 = sx.d(*esi)
0041faab              i, edx = sub_421804(eax_1, edx, ecx, eax_1)
0041fab1              ecx = 4
0041fac5      while (i != 0)
0041fac5  
0041fac7  ecx.b = data_42f804
0041facd  i.b = *esi
0041facf  *esi = ecx.b
0041fad1  char* esi_1 = &esi[1]
0041fad1  
0041fadd  do
0041fad2      ecx.b = *esi_1
0041fad4      *esi_1 = i.b
0041fad6      i.b = ecx.b
0041fad8      ecx.b = *esi_1
0041fada      esi_1 = &esi_1[1]
0041fadd  while (ecx.b != 0)
0041fadd  
0041fae0  return i


0041fae1    void* sub_41fae1(char* arg1)

0041fae1  char* eax = arg1
0041fae5  char i = data_42f804
0041faeb  char ecx = *eax
0041faeb  
0041faef  if (ecx != 0)
0041faf3      while (ecx != i)
0041faf5          ecx = eax[1]
0041faf8          eax = &eax[1]
0041faf8          
0041fafb          if (ecx == 0)
0041fafb              break
0041fafb  
0041faff  void* result = &eax[1]
0041faff  
0041fb02  if (*eax != 0)
0041fb04      while (true)
0041fb04          ecx = *result
0041fb04          
0041fb08          if (ecx == 0)
0041fb08              break
0041fb08          
0041fb0d          if (ecx == 0x65)
0041fb0d              break
0041fb0d          
0041fb12          if (ecx == 0x45)
0041fb12              break
0041fb12          
0041fb14          result += 1
0041fb14      
0041fb17      void* result_1 = result
0041fb17      
0041fb1d      do
0041fb19          result -= 1
0041fb1d      while (*result == 0x30)
0041fb1d      
0041fb21      if (*result == i)
0041fb23          result -= 1
0041fb23      
0041fb2c      do
0041fb24          i = *result_1
0041fb26          result += 1
0041fb27          result_1 += 1
0041fb2a          *result = i
0041fb2c      while (i != 0)
0041fb2c  
0041fb2e  return result


0041fb2f    int32_t sub_41fb2f(double* arg1)

0041fb33  long double x87_r7 = fconvert.t(*arg1)
0041fb35  long double temp0 = fconvert.t(0.0)
0041fb35  x87_r7 - temp0
0041fb3b  double* eax
0041fb3b  eax.w = (x87_r7 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7, temp0) ? 1 : 0) << 0xa
0041fb3b      | (x87_r7 == temp0 ? 1 : 0) << 0xe
0041fb3b  
0041fb3e  if (test_bit(eax:1.b, 0))
0041fb46      return 0
0041fb46  
0041fb43  return 1


0041fb47    int32_t* __convention("regparm") sub_41fb47(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t* arg5)

0041fb4b  int32_t var_c = arg3
0041fb50  void* arg_c
0041fb50  void* var_10 = arg_c
0041fb50  
0041fb53  if (arg4 == 0)
0041fb74      sub_425615(&arg_c, var_10)
0041fb81      *arg5 = arg_c
0041fb84      return arg5
0041fb84  
0041fb59  sub_4255e8(&var_c, var_10)
0041fb66  *arg5 = var_c
0041fb6b  arg5[1] = arg3
0041fb6f  return arg5


0041fb85    char* __convention("regparm") sub_41fb85(int32_t arg1, int32_t arg2, char* arg3, double* arg4, char* arg5, void* arg6, int32_t arg7)

0041fb8f  void var_2c
0041fb8f  void* var_34 = &var_2c
0041fb93  int32_t var_14[0x4]
0041fb93  int32_t (* var_38)[0x4] = &var_14
0041fb98  int32_t* var_40 = arg3
0041fb9b  var_40.q = fconvert.d(fconvert.t(*arg4))
0041fb9e  sub_4256b9(var_40, arg3)
0041fbb7  int32_t eax_2
0041fbb7  eax_2.b = var_14[0] == 0x2d
0041fbbe  void* ecx
0041fbbe  ecx.b = arg6 s> 0
0041fbc6  sub_425642(ecx + &arg5[eax_2], arg6 + 1, &var_14)
0041fbd8  sub_41fbe6(arg5, arg6, arg7, &var_14, 0)
0041fbe5  return arg5


0041fbe6    char* sub_41fbe6(char* arg1, int32_t arg2, int32_t arg3, int32_t* arg4, char arg5)

0041fbf7  if (arg5 != 0)
0041fbfe      int32_t eax_1
0041fbfe      eax_1.b = arg2 s> 0
0041fc07      void* eax_2
0041fc07      eax_2.b = *arg4 == 0x2d
0041fc0d      sub_41fe88(eax_2 + arg1, eax_1)
0041fc0d  
0041fc17  void* eax_4 = arg1
0041fc17  
0041fc19  if (*arg4 == 0x2d)
0041fc1b      *arg1 = 0x2d
0041fc1e      eax_4 = &arg1[1]
0041fc1e  
0041fc24  if (arg2 s> 0)
0041fc2c      *eax_4 = *(eax_4 + 1)
0041fc2e      eax_4 += 1
0041fc30      void* ecx_2
0041fc30      ecx_2.b = data_42f804
0041fc36      *eax_4 = ecx_2.b
0041fc36  
0041fc42  void* const ecx_3
0041fc42  ecx_3.b = arg5 == 0
0041fc4b  char* eax_5 = sub_4230a0(ecx_3 + eax_4 + arg2, "e+000")
0041fc4b  
0041fc57  if (arg3 != 0)
0041fc59      *eax_5 = 0x45
0041fc59  
0041fc63  if (*arg4[3] != 0x30)
0041fc65      int32_t ebx_1 = arg4[1]
0041fc68      int32_t ebx_2 = ebx_1 - 1
0041fc68      
0041fc69      if (ebx_1 - 1 s< 0)
0041fc6b          ebx_2 = neg.d(ebx_2)
0041fc6d          eax_5[1] = 0x2d
0041fc6d      
0041fc74      if (ebx_2 s>= 0x64)
0041fc7e          eax_5[2] += (divs.dp.d(sx.q(ebx_2), 0x64)).b
0041fc85          ebx_2 = mods.dp.d(sx.q(ebx_2), 0x64)
0041fc85      
0041fc8b      if (ebx_2 s>= 0xa)
0041fc95          eax_5[3] += (divs.dp.d(sx.q(ebx_2), 0xa)).b
0041fc9c          ebx_2 = mods.dp.d(sx.q(ebx_2), 0xa)
0041fc9c      
0041fc9e      eax_5[4] += ebx_2.b
0041fc9e  
0041fca7  return arg1


0041fca8    char* __convention("regparm") sub_41fca8(int32_t arg1, int32_t arg2, char* arg3, double* arg4, char* arg5, int32_t arg6)

0041fcb2  void var_2c
0041fcb2  void* var_34 = &var_2c
0041fcb6  int32_t var_14
0041fcb6  int32_t* var_38 = &var_14
0041fcbb  int32_t* var_40 = arg3
0041fcbe  var_40.q = fconvert.d(fconvert.t(*arg4))
0041fcc1  sub_4256b9(var_40, arg3)
0041fcd9  void* eax_3
0041fcd9  eax_3.b = var_14 == 0x2d
0041fce0  void* var_10
0041fce0  sub_425642(eax_3 + arg5, var_10 + arg6, &var_14)
0041fcef  sub_41fcfd(arg5, arg6, &var_14, 0)
0041fcfc  return arg5


0041fcfd    char* sub_41fcfd(char* arg1, int32_t arg2, int32_t* arg3, char arg4)

0041fd0c  int32_t eax_1 = arg3[1] - 1
0041fd0c  
0041fd16  if (arg4 != 0 && eax_1 == arg2)
0041fd1d      void* ecx_1
0041fd1d      ecx_1.b = *arg3 == 0x2d
0041fd22      char* ecx_3 = ecx_1 + eax_1 + arg1
0041fd26      *ecx_3 = 0x30
0041fd29      ecx_3[1] = 0
0041fd29  
0041fd30  void* edi = arg1
0041fd30  
0041fd32  if (*arg3 == 0x2d)
0041fd34      *arg1 = 0x2d
0041fd37      edi = &arg1[1]
0041fd37  
0041fd3a  int32_t eax_3 = arg3[1]
0041fd3f  void* edi_1
0041fd3f  
0041fd3f  if (eax_3 s> 0)
0041fd51      edi_1 = edi + eax_3
0041fd3f  else
0041fd44      sub_41fe88(edi, 1)
0041fd4a      *edi = 0x30
0041fd4e      edi_1 = edi + 1
0041fd4e  
0041fd57  if (arg2 s> 0)
0041fd5c      sub_41fe88(edi_1, 1)
0041fd67      *edi_1 = data_42f804
0041fd69      int32_t esi_1 = arg3[1]
0041fd69      
0041fd70      if (esi_1 s< 0)
0041fd76          if (arg4 == 0)
0041fd7c              int32_t esi_2 = neg.d(esi_1)
0041fd7c              
0041fd81              if (arg2 s>= esi_2)
0041fd83                  arg2 = esi_2
0041fd76          else
0041fd83              arg2 = neg.d(esi_1)
0041fd83          
0041fd8a          sub_41fe88(edi_1 + 1, arg2)
0041fd95          sub_4257d0(edi_1 + 1, 0x30, arg2)
0041fd95  
0041fda3  return arg1


0041fda4    char* __convention("regparm") sub_41fda4(int32_t arg1, int32_t arg2, char* arg3, double* arg4, char* arg5, int32_t arg6, int32_t arg7)

0041fdb0  void var_2c
0041fdb0  void* var_3c = &var_2c
0041fdb4  int32_t var_14
0041fdb4  int32_t* var_40 = &var_14
0041fdb9  int32_t* var_48 = arg3
0041fdbc  var_48.q = fconvert.d(fconvert.t(*arg4))
0041fdbf  sub_4256b9(var_48, arg3)
0041fdd3  void* eax_2
0041fdd3  eax_2.b = var_14 == 0x2d
0041fdd9  char* edi = eax_2 + arg5
0041fde1  sub_425642(edi, arg6, &var_14)
0041fdf9  int32_t var_10
0041fdf9  
0041fdf9  if (var_10 - 1 s< 0xfffffffc || var_10 - 1 s>= arg6)
0041fe2a      return sub_41fbe6(arg5, arg6, arg7, &var_14, 1)
0041fe2a  
0041fdfd  if (var_10 - 1 s< var_10 - 1 != 0)
0041fe04      int32_t eax_5
0041fe04      
0041fe04      do
0041fdff          eax_5.b = *edi
0041fe01          edi = &edi[1]
0041fe04      while (eax_5.b != 0)
0041fe04      
0041fe06      edi[0xfffffffe] &= eax_5.b
0041fe06  
0041fe13  return sub_41fcfd(arg5, arg6, &var_14, 1)


0041fe37    char* sub_41fe37(double* arg1, char* arg2, int32_t arg3, int32_t arg4, int32_t arg5)

0041fe44  int32_t eax
0041fe44  char* ecx
0041fe44  int32_t edx
0041fe44  
0041fe44  if (arg3 == 0x65 || arg3 == 0x45)
0041fe7e      return sub_41fb85(eax, edx, ecx, arg1, arg2, arg4, arg5)
0041fe7e  
0041fe4a  if (arg3 != 0x66)
0041fe6b      return sub_41fda4(eax, edx, ecx, arg1, arg2, arg4, arg5)
0041fe6b  
0041fe5e  return sub_41fca8(eax, edx, ecx, arg1, arg2, arg4)


0041fe88    void sub_41fe88(char* arg1, int32_t arg2)

0041fe8f  if (arg2 != 0)
0041fea2      sub_41f5a0(&arg1[arg2], arg1, sub_422550(arg1) + 1)


0041fead    int32_t sub_41fead()

0041fead  int32_t eax = data_28249a0
0041fead  
0041feb8  if (eax == 0)
0041feba      eax = 0x200
0041fec7      data_28249a0 = eax
0041feb8  else if (eax s< 0x14)
0041fec5      eax = 0x14
0041fec7      data_28249a0 = eax
0041fec7  
0041fecf  void* eax_1 = sub_425831(eax, 4)
0041fed5  data_2823984 = eax_1
0041fed5  
0041fedd  if (eax_1 == 0)
0041fee2      data_28249a0 = 0x14
0041fee8      void* eax_2 = sub_425831(0x14, 4)
0041feee      data_2823984 = eax_2
0041feee      
0041fef6      if (eax_2 == 0)
0041fefa          sub_41f9c5(0x1a)
0041fefa  
0041ff00  int32_t* ecx_3 = nullptr
0041ff00  
0041ff1b  for (int32_t i = 0x42f340; i s< &data_42f5c0; )
0041ff0d      *(ecx_3 + data_2823984) = i
0041ff10      i += 0x20
0041ff13      ecx_3 = &ecx_3[1]
0041ff13  
0041ff1d  int32_t ecx_4 = 0
0041ff51  int32_t result
0041ff51  
0041ff51  for (void* i_1 = &data_42f350; i_1 s< 0x42f3b0; )
0041ff38      result = *((&data_2823880)[ecx_4 s>> 5] + (ecx_4 & 0x1f) * 0x24)
0041ff38      
0041ff42      if (result == 0xffffffff || result == 0)
0041ff44          *i_1 = 0xffffffff
0041ff44      
0041ff47      i_1 += 0x20
0041ff4a      ecx_4 += 1
0041ff4a  
0041ff54  return result


0041ff55    int32_t sub_41ff55()

0041ff55  int32_t result = sub_41ecfd()
0041ff55  
0041ff61  if (data_430bac == 0)
0041ff68      return result
0041ff68  
0041ff63  return sub_4258be() __tailcall


0041ff69    int32_t sub_41ff69(void* arg1)

0041ff7b  if (arg1 u>= 0x42f340 && arg1 u<= 0x42f5a0)
0041ff8c      return sub_421919(((arg1 - 0x42f340) s>> 5) + 0x1c)
0041ff8c  
0041ff97  return EnterCriticalSection(lpCriticalSection: arg1 + 0x20)


0041ff98    int32_t sub_41ff98(int32_t arg1, void* arg2)

0041ff9f  if (arg1 s>= 0x14)
0041ffba      return EnterCriticalSection(lpCriticalSection: arg2 + 0x20)
0041ffba  
0041ffab  return sub_421919(arg1 + 0x1c)


0041ffbb    int32_t sub_41ffbb(void* arg1)

0041ffcd  if (arg1 u>= 0x42f340 && arg1 u<= 0x42f5a0)
0041ffde      return sub_42197a(((arg1 - 0x42f340) s>> 5) + 0x1c)
0041ffde  
0041ffe9  return LeaveCriticalSection(lpCriticalSection: arg1 + 0x20)


0041ffea    int32_t sub_41ffea(int32_t arg1, void* arg2)

0041fff1  if (arg1 s>= 0x14)
0042000c      return LeaveCriticalSection(lpCriticalSection: arg2 + 0x20)
0042000c  
0041fffd  return sub_42197a(arg1 + 0x1c)


0042000d    int32_t sub_42000d(int32_t* arg1)

0042001d  if (sub_42593f(arg1[4]) != 0)
00420025      int32_t eax_1
00420025      
00420025      if (arg1 == &data_42f360)
00420027          eax_1 = 0
00420036          label_420036:
00420036          data_430c04 += 1
00420036          
00420042          if ((arg1[3].w & 0x10c) == 0)
0042005a              void* eax_2
0042005a              
0042005a              if (*((eax_1 << 2) + &data_430c08) == 0)
0042005d                  eax_2 = sub_41e583(0x1000)
00420065                  *((eax_1 << 2) + &data_430c08) = eax_2
00420065              
00420067              if (*((eax_1 << 2) + &data_430c08) != 0 || eax_2 != 0)
0042007c                  int32_t edi_1 = *((eax_1 << 2) + &data_430c08)
0042007e                  arg1[6] = 0x1000
00420081                  arg1[2] = edi_1
00420084                  *arg1 = edi_1
00420086                  arg1[1] = 0x1000
00420067              else
0042006e                  arg1[2] = &arg1[5]
00420071                  *arg1 = &arg1[5]
00420074                  arg1[6] = 2
00420077                  arg1[1] = 2
00420077              
00420089              arg1[3].w |= 0x1102
00420095              return 1
00420025      else if (arg1 == 0x42f380)
00420035          eax_1 = 1
00420035          goto label_420036
00420035  
00420099  return 0


0042009a    void sub_42009a(int32_t arg1, int32_t* arg2)

004200aa  if (arg1 != 0 && (*(arg2 + 0xd) & 0x10) != 0)
004200ad      sub_41eca1(arg2)
004200b2      *(arg2 + 0xd) &= 0xee
004200b6      arg2[6] = 0
004200ba      *arg2 = 0
004200bd      arg2[2] = 0


004200c4    int32_t sub_4200c4(int32_t* arg1, void* arg2)

004200d0  char* edi = arg2
004200d3  int32_t esi = 0
004200d5  char* ebx
004200d5  ebx.b = *edi
004200d7  void* edi_1 = &edi[1]
004200da  void* var_10 = nullptr
004200dd  int32_t i = 0
004200e0  arg2 = edi_1
004200e0  
004200e3  if (ebx.b != 0)
004200e9      int32_t var_14
004200e9      int32_t ecx_1 = var_14
004200e9      
004200fb      while (i s>= 0)
00420109          int32_t eax_2
00420109          
00420109          if (ebx.b s< 0x20 || ebx.b s> 0x78)
00420119              eax_2 = 0
00420109          else
0042010e              int32_t eax_1
0042010e              eax_1.b = (*"rePresent")[sx.d(ebx.b)]
00420114              eax_2 = eax_1 & 0xf
00420114          
00420123          int32_t eax_4 = sx.d(*(esi + (eax_2 << 3) + 0x429300)) s>> 4
00420129          int32_t var_34_1 = eax_4
00420132          int32_t var_38
00420132          int32_t var_2c
00420132          int32_t var_28
00420132          int32_t var_24
00420132          int32_t* var_20
00420132          char* var_8
00420132          void* arg_c
00420132          
00420132          switch (eax_4)
00420132              case 0
00420132                  goto label_420269
00420139              case 1
00420139                  var_14 = 0xffffffff
0042013d                  var_38 = 0
00420140                  var_2c = 0
00420143                  var_24 = 0
00420146                  var_20 = nullptr
00420149                  var_8 = nullptr
0042014c                  var_28 = 0
00420154              case 2
00420154                  int32_t eax_5 = sx.d(ebx.b)
00420154                  
0042015a                  if (eax_5 == 0x20)
00420197                      var_8 |= 2
0042015a                  else if (eax_5 == 0x23)
0042018e                      var_8.b |= 0x80
0042015f                  else if (eax_5 == 0x2b)
00420185                      var_8 |= 1
00420164                  else if (eax_5 == 0x2d)
0042017c                      var_8 |= 4
00420168                  else if (eax_5 == 0x30)
00420173                      var_8 |= 8
004201a3              case 3
004201a3                  if (ebx.b != 0x2a)
004201c0                      var_24 = sx.d(ebx.b) + var_24 * 0xa - 0x30
004201a3                  else
004201a9                      int32_t eax_12 = sub_4208a3(&arg_c)
004201b1                      var_24 = eax_12
004201b1                      
004201b4                      if (eax_12 s< 0)
004201ba                          var_8 |= 4
004201c0                          var_24 = neg.d(eax_12)
004201d7              case 4
004201d7                  var_14 = 0
004201e2              case 5
004201e2                  if (ebx.b != 0x2a)
0042020c                      var_14 = sx.d(ebx.b) + ecx_1 * 0xa - 0x30
004201e2                  else
004201e8                      int32_t eax_16 = sub_4208a3(&arg_c)
004201f0                      var_14 = eax_16
004201f0                      
004201f3                      if (eax_16 s< 0)
004201f9                          var_14 = 0xffffffff
00420217              case 6
00420217                  if (ebx.b == 0x49)
00420250                      if (*edi_1 != 0x36 || *(edi_1 + 1) != 0x34)
00420260                          var_34_1 = 0
00420269                          label_420269:
00420269                          var_28 = 0
00420269                          
00420274                          if ((*(&(*data_42f5f4)[zx.d(ebx.b)] + 1) & 0x80) != 0)
00420281                              sub_420805(sx.d(ebx.b), arg1, &i)
00420286                              ebx.b = *edi_1
0042028c                              arg2 = edi_1 + 1
0042028c                          
0042029a                          sub_420805(sx.d(ebx.b), arg1, &i)
00420250                      else
00420254                          var_8:1.b |= 0x80
00420258                          arg2 = edi_1 + 2
00420217                  else if (ebx.b == 0x68)
0042023e                      var_8 |= 0x20
0042021c                  else if (ebx.b == 0x6c)
00420235                      var_8 |= 0x10
00420221                  else if (ebx.b == 0x77)
0042022c                      var_8:1.b |= 8
004202a7              case 7
004202a7                  int32_t eax_22 = sx.d(ebx.b)
004202ad                  char var_1a
004202ad                  char* var_c
004202ad                  void* eax_41
004202ad                  
004202ad                  if (eax_22 s> 0x67)
004204d2                      int32_t var_30
004204d2                      int32_t var_10_1
004204d2                      
004204d2                      if (eax_22 == 0x69)
004205a9                          label_4205a9:
004205a9                          var_8 |= 0x40
004205ad                          label_4205ad:
004205ad                          var_10_1 = 0xa
004205b8                          label_4205b8:
004205b8                          uint32_t eax_56
004205b8                          uint32_t edx_3
004205b8                          
004205b8                          if ((var_8:1.b & 0x80) != 0)
004205be                              eax_56, edx_3 = sub_4208b0(&arg_c)
004205b8                          else if ((var_8.b & 0x20) == 0)
004205f4                              int32_t* var_25c_15 = &arg_c
004205f4                              
004205f5                              if ((var_8.b & 0x40) == 0)
004205ff                                  eax_56 = sub_4208a3(var_25c_15)
00420605                                  edx_3 = 0
004205f5                              else
004205df                                  edx_3:eax_56 = sx.q(sub_4208a3(var_25c_15))
004205ca                          else
004205d3                              void** var_25c_14 = &arg_c
004205d4                              int32_t eax_58
004205d4                              
004205d4                              if ((var_8.b & 0x40) == 0)
004205e8                                  eax_58 = zx.d(sub_4208a3(var_25c_14))
004205d4                              else
004205dc                                  eax_58 = sx.d(sub_4208a3(var_25c_14))
004205dc                              
004205df                              edx_3:eax_56 = sx.q(eax_58)
004205df                          
00420615                          uint32_t esi_4
00420615                          uint32_t edi_6
00420615                          
00420615                          if ((var_8.b & 0x40) == 0 || edx_3 s> 0
00420615                                  || (edx_3 s>= 0 && eax_56 u>= 0))
00420628                              esi_4 = eax_56
0042062a                              edi_6 = edx_3
00420615                          else
0042061c                              esi_4 = neg.d(eax_56)
00420620                              var_8:1.b |= 1
00420624                              edi_6 = neg.d(adc.d(edx_3, 0, eax_56 != 0))
00420624                          
00420630                          if ((var_8:1.b & 0x80) == 0)
00420632                              edi_6 = 0
00420632                          
00420639                          if (var_14 s>= 0)
00420644                              var_8 &= 0xfffffff7
00420639                          else
0042063b                              var_14 = 1
0042063b                          
0042064c                          if ((esi_4 | edi_6) == 0)
0042064e                              var_20 = nullptr
0042064e                          
00420655                          void var_4d
00420655                          char* var_c_1 = &var_4d
00420655                          
00420658                          while (true)
00420658                              int32_t eax_63 = var_14
0042065b                              var_14 -= 1
0042065b                              
00420666                              if (eax_63 s<= 0 && (esi_4 | edi_6) == 0)
00420666                                  break
00420666                              
0042066b                              int32_t eax_67
0042066b                              uint32_t edx_6
0042066b                              edx_6:eax_67 = sx.q(var_10_1)
00420680                              ebx = __aullrem(esi_4, edi_6, eax_67, edx_6) + 0x30
00420688                              uint32_t eax_69
00420688                              uint32_t edx_7
00420688                              eax_69, edx_7 = __aulldiv(esi_4, edi_6, eax_67, edx_6)
00420690                              esi_4 = eax_69
00420692                              edi_6 = edx_7
00420692                              
00420694                              if (ebx s> 0x39)
00420696                                  ebx = &ebx[var_30]
00420696                              
00420699                              char* eax_70 = var_c_1
0042069c                              var_c_1 -= 1
0042069f                              *eax_70 = ebx.b
0042069f                          
004206a6                          void* eax_71 = &var_4d - var_c_1
004206a9                          var_c = &var_c_1[1]
004206b0                          var_10 = eax_71
004206b0                          
004206bf                          if ((var_8:1.b & 2) == 0 || (*var_c == 0x30 && eax_71 != 0))
004206b3                              goto label_4206ce
004206b3                          
004206c1                          var_c -= 1
004206c4                          eax_41 = eax_71 + 1
004206c8                          *var_c = 0x30
004206c8                          goto label_4206cb
004206c8                      
004204db                      if (eax_22 != 0x6e)
004204e1                          int32_t eax_49 = eax_22 - 0x6f
004204e1                          
004204e2                          if (eax_22 == 0x6f)
00420570                              var_10_1 = 8
00420570                              
00420577                              if ((var_8.b & 0x80) != 0)
00420579                                  var_8:1.b |= 2
00420579                              
00420577                              goto label_4205b8
00420577                          
004204e9                          if (eax_49 == 1)
0042053c                              var_14 = 8
00420543                              label_420543:
00420543                              var_30 = 7
0042054e                              label_42054e:
0042054e                              var_10_1 = 0x10
0042054e                              
00420555                              if ((var_8.b & 0x80) != 0)
00420557                                  eax_22.b = var_30.b
0042055a                                  var_1a = 0x30
0042055e                                  eax_22.b += 0x51
00420560                                  var_20 = 2
00420567                                  char var_19_1 = eax_22.b
00420567                              
00420555                              goto label_4205b8
00420555                          
004204ee                          if (eax_49 != 4)
004204f6                              if (eax_49 == 6)
004204f6                                  goto label_4205ad
004204f6                              
004204ff                              if (eax_49 != 9)
004204ff                                  goto label_4206ce
004204ff                              
00420505                              var_30 = 0x27
0042050c                              goto label_42054e
0042050c                          
004202f1                          label_4202f1:
004202f1                          int32_t esi_1 = var_14
004202f1                          
004202f7                          if (esi_1 == 0xffffffff)
004202f9                              esi_1 = 0x7fffffff
004202f9                          
0042030e                          void* ecx_7 = sub_4208a3(&arg_c)
00420310                          var_c = ecx_7
00420310                          
00420313                          if ((var_8.w & 0x810) == 0)
00420519                              if (ecx_7 == 0)
0042051b                                  ecx_7 = data_42f5c0
00420521                                  var_c = ecx_7
00420521                              
00420524                              void* eax_54 = ecx_7
00420524                              
00420526                              while (true)
00420526                                  int32_t edx_2 = esi_1
00420528                                  esi_1 -= 1
00420528                                  
0042052b                                  if (edx_2 == 0)
0042052b                                      break
0042052b                                  
00420530                                  if (*eax_54 == 0)
00420530                                      break
00420530                                  
00420532                                  eax_54 += 1
00420532                              
00420535                              eax_41 = eax_54 - ecx_7
00420313                          else
0042031b                              if (ecx_7 == 0)
0042031d                                  ecx_7 = data_42f5c4
00420323                                  var_c = ecx_7
00420323                              
00420326                              var_28 = 1
0042032d                              void* eax_30 = ecx_7
0042032d                              
0042032f                              while (true)
0042032f                                  int32_t edx_1 = esi_1
00420331                                  esi_1 -= 1
00420331                                  
00420334                                  if (edx_1 == 0)
00420334                                      break
00420334                                  
0042033e                                  if (*eax_30 == 0)
0042033e                                      break
0042033e                                  
00420345                                  eax_30 += 2
00420345                              
00420510                              eax_41 = (eax_30 - ecx_7) s>> 1
00420510                          
00420313                          goto label_4206cb
00420313                      
00420583                      int16_t* eax_55 = sub_4208a3(&arg_c)
00420583                      
0042058d                      if ((var_8.b & 0x20) == 0)
0042059b                          *eax_55 = i
0042058d                      else
00420593                          *eax_55 = i.w
00420593                      
0042059d                      var_2c = 1
004202ad                  else
004202b6                      if (eax_22 s>= 0x65)
004202b6                          goto label_420352
004202b6                      
004202bf                      char* var_25c_8
004202bf                      char var_24c
004202bf                      
004202bf                      if (eax_22 s<= 0x58)
004202c5                          if (eax_22 == 0x58)
004202c5                              goto label_420543
004202c5                          
004202ce                          if (eax_22 == 0x43)
00420379                              if ((var_8.w & 0x830) == 0)
0042037b                                  var_8:1.b |= 8
0042037b                              
00420379                              goto label_420388
00420379                          
004202da                          if (eax_22 != 0x45 && eax_22 != 0x47)
004202df                              if (eax_22 != 0x53)
004202df                                  goto label_4206ce
004202df                              
004202eb                              if ((var_8.w & 0x830) == 0)
004202ed                                  var_8:1.b |= 8
004202ed                              
004202eb                              goto label_4202f1
004202eb                          
00420348                          var_38 = 1
0042034f                          ebx.b += 0x20
00420352                          label_420352:
00420352                          var_8 |= 0x40
00420356                          char* edi_5 = &var_24c
0042035e                          var_c = &var_24c
0042035e                          
00420361                          if (ecx_1 s< 0)
00420367                              var_14 = 6
00420361                          else if (ecx_1 == 0 && ebx.b == 0x67)
0042043d                              var_14 = 1
0042043d                          
0042044a                          void* eax_44 = arg_c + 8
0042044d                          arg_c = eax_44
00420456                          int32_t var_4c = *(eax_44 - 8)
0042045c                          int32_t var_48_1 = *(eax_44 - 4)
0042046e                          data_42f328(&var_4c, &var_24c, sx.d(ebx.b), var_14, var_38)
0042047a                          void* esi_3 = var_8 & 0x80
0042047a                          
00420486                          if (esi_3 != 0 && var_14 == 0)
0042048f                              data_42f334(&var_24c)
0042048f                          
0042049d                          if (ebx.b == 0x67 && esi_3 == 0)
004204a6                              data_42f32c(&var_24c)
004204a6                          
004204b4                          if (var_24c == 0x2d)
004204b6                              var_8:1.b |= 1
004204ba                              void var_24b
004204ba                              edi_5 = &var_24b
004204c0                              var_c = &var_24b
004204c0                          
004204c3                          var_25c_8 = edi_5
00420480                          goto label_4204c4
00420480                      
004203b3                      if (eax_22 != 0x5a)
004203b8                          if (eax_22 != 0x63)
004203bb                              if (eax_22 == 0x64)
004203bb                                  goto label_4205a9
004203bb                              
004203bb                              goto label_4206ce
004203bb                          
00420388                          label_420388:
00420388                          void** var_25c_6 = &arg_c
00420388                          
00420389                          if ((var_8.w & 0x810) == 0)
004203cc                              var_24c = sub_4208a3(var_25c_6)
004203d2                              var_10 = 1
00420389                          else
00420398                              BOOL eax_33 = sub_425968(&var_24c, sub_4208c0(var_25c_6))
004203a0                              var_10 = eax_33
004203a0                              
004203a5                              if (eax_33 s< 0)
004203a7                                  var_2c = 1
004203a7                          
004203df                          var_c = &var_24c
004203e2                          goto label_4206ce
004203e2                      
004203eb                      int16_t* eax_38 = sub_4208a3(&arg_c)
004203f3                      char* ecx_10
004203f3                      
004203f3                      if (eax_38 != 0)
004203f5                          ecx_10 = *(eax_38 + 4)
004203f5                      
004203fa                      if (eax_38 == 0 || ecx_10 == 0)
00420428                          char* eax_42 = data_42f5c0
0042042d                          var_c = eax_42
00420430                          var_25c_8 = eax_42
004204c4                          label_4204c4:
004204c4                          eax_41 = sub_422550(var_25c_8)
004206cb                          label_4206cb:
004206cb                          var_10 = eax_41
004206cb                          goto label_4206ce
004206cb                      
00420400                      if ((var_8:1.b & 8) == 0)
00420419                          var_28 = 0
0042041d                          var_c = ecx_10
00420420                          eax_41 = sx.d(*eax_38)
00420423                          goto label_4206cb
00420423                      
00420407                      var_c = ecx_10
0042040a                      var_10 = sx.d(*eax_38) u>> 1
0042040d                      var_28 = 1
004206ce                      label_4206ce:
004206ce                      
004206d2                      if (var_2c == 0)
004206de                          if ((var_8.b & 0x40) != 0)
004206e3                              if ((var_8:1.b & 1) != 0)
004206e5                                  var_1a = 0x2d
004206ff                                  var_20 = 1
004206e3                              else if ((var_8.b & 1) != 0)
004206f0                                  var_1a = 0x2b
004206ff                                  var_20 = 1
004206ee                              else if ((var_8.b & 2) != 0)
004206fb                                  var_1a = 0x20
004206ff                                  var_20 = 1
004206ff                          
0042070c                          int32_t* esi_7 = var_24 - var_20 - var_10
0042070c                          
00420712                          if ((var_8.b & 0xc) == 0)
0042071e                              sub_42083a(0x20, esi_7, arg1, &i)
0042071e                          
00420734                          sub_42086b(&var_1a, var_20, arg1, &i)
00420734                          
00420744                          if ((var_8.b & 8) != 0 && (var_8.b & 4) == 0)
00420750                              sub_42083a(0x30, esi_7, arg1, &i)
00420750                          
00420762                          if (var_28 == 0 || var_10 s<= 0)
004207ac                              sub_42086b(var_c, var_10, arg1, &i)
00420762                          else
00420767                              ebx = var_c
0042076a                              void* j_1 = var_10 - 1
0042079b                              void* j
0042079b                              
0042079b                              do
0042076d                                  j.w = *ebx
00420776                                  ebx = &ebx[2]
00420777                                  void var_3c
00420777                                  BOOL eax_72 = sub_425968(&var_3c, j)
00420777                                  
00420780                                  if (eax_72 s<= 0)
00420780                                      break
00420780                                  
0042078e                                  sub_42086b(&var_3c, eax_72, arg1, &i)
00420796                                  j = j_1
00420798                                  j_1 -= 1
0042079b                              while (j != 0)
0042079b                          
004207b8                          if ((var_8.b & 4) != 0)
004207c4                              sub_42083a(0x20, esi_7, arg1, &i)
004207c4          
004207cf          ebx.b = *arg2
004207d1          edi_1 = arg2 + 1
004207d4          arg2 = edi_1
004207d4          
004207d7          if (ebx.b == 0)
004207d7              break
004207d7          
004200f0          ecx_1 = var_14
004200f3          esi = var_34_1
004200f3  
004207e4  return i

004207e5  uint32_t jump_table_4207e5[0x8] = 
004207e5  {
004207e5      [0x0] =  0x00420263
004207e9      [0x1] =  0x00420139
004207ed      [0x2] =  0x00420154
004207f1      [0x3] =  0x004201a0
004207f5      [0x4] =  0x004201d7
004207f9      [0x5] =  0x004201df
004207fd      [0x6] =  0x00420214
00420801      [0x7] =  0x004202a7
00420805  }

00420805    int32_t* sub_420805(int32_t* arg1, int32_t* arg2, int32_t* arg3)

0042080b  int32_t temp0 = arg2[1]
0042080b  arg2[1] -= 1
0042080e  uint32_t eax_1
0042080e  
0042080e  if (temp0 - 1 s< 0)
0042081e      int32_t* var_8_1 = arg2
00420822      eax_1 = sub_421340(arg1)
0042080e  else
00420812      char eax = arg1.b
00420815      **arg2 = eax
00420817      *arg2 += 1
00420819      eax_1 = zx.d(eax)
00420819  
0042082f  if (eax_1 == 0xffffffff)
00420831      *arg3 = 0xffffffff
00420835      return arg3
00420835  
00420836  *arg3 += 1
00420839  return arg3


0042083a    int32_t* sub_42083a(int32_t* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)

00420840  int32_t* i = arg2
00420842  int32_t* i_1 = arg2 - 1
00420842  
00420845  while (i s> 0)
00420854      i = sub_420805(arg1, arg3, arg4)
00420854      
0042085f      if (*arg4 == 0xffffffff)
0042085f          break
0042085f      
00420861      i = i_1
00420863      i_1 -= 1
00420863  
0042086a  return i


0042086b    int32_t* sub_42086b(char* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4)

00420870  int32_t* i = arg2
00420872  int32_t* i_1 = arg2 - 1
00420872  
00420877  if (i s> 0)
0042087d      char* esi_1 = arg1
0042087d      
0042089d      do
00420881          int32_t eax = sx.d(*esi_1)
00420885          esi_1 = &esi_1[1]
0042088b          i = sub_420805(eax, arg3, arg4)
0042088b          
00420896          if (*arg4 == 0xffffffff)
00420896              break
00420896          
00420898          i = i_1
0042089a          i_1 -= 1
0042089d      while (i s> 0)
0042089d  
004208a2  return i


004208a3    int32_t sub_4208a3(int32_t* arg1)

004208a7  *arg1 += 4
004208af  return *(*arg1 - 4)


004208b0    int32_t sub_4208b0(int32_t* arg1)

004208b4  *arg1 += 8
004208b7  void* ecx = *arg1
004208bc  *(ecx - 4)
004208bf  return *(ecx - 8)


004208c0    void* sub_4208c0(int32_t* arg1)

004208c4  *arg1 += 4
004208c9  void* result
004208c9  result.w = *(*arg1 - 4)
004208cd  return result


004208ce    uint32_t sub_4208ce(int32_t* arg1)

004208d3  int32_t eax = arg1[3]
004208d3  
004208e0  if ((eax.b & 0x83) != 0 && (eax.b & 0x40) == 0)
004208e8      if ((eax.b & 2) == 0)
004208f4          eax.b |= 1
004208fa          arg1[3] = eax
004208fa          
004208fd          if ((eax.w & 0x10c) != 0)
0042090b              *arg1 = arg1[2]
004208fd          else
00420900              sub_425b15(arg1)
00420900          
00420916          void* eax_2 = sub_4209aa(arg1[4], arg1[2], arg1[6])
0042091e          arg1[1] = eax_2
0042091e          
00420928          if (eax_2 != 0 && eax_2 != 0xffffffff)
0042092a              int32_t edx = arg1[3]
0042092a              
00420930              if ((edx.b & 0x82) == 0)
00420932                  int32_t ecx_2 = arg1[4]
00420939                  void* edi_4
00420939                  
00420939                  if (ecx_2 == 0xffffffff)
00420952                      edi_4 = &data_42f5d0
00420939                  else
0042094d                      edi_4 = (&data_2823880)[ecx_2 s>> 5] + (ecx_2 & 0x1f) * 0x24
0042094d                  
00420957                  ecx_2.b = *(edi_4 + 4)
0042095b                  ecx_2.b &= 0x82
0042095b                  
00420961                  if (ecx_2.b == 0x82)
00420963                      edx:1.b |= 0x20
00420966                      arg1[3] = edx
00420966              
00420970              if (arg1[6] == 0x200)
00420972                  int16_t ecx_4 = (arg1[3]).w
00420972                  
0042097d                  if ((ecx_4.b & 8) != 0 && (ecx_4:1.b & 4) == 0)
0042097f                      arg1[6] = 0x1000
0042097f              
00420986              char* ecx_5 = *arg1
00420989              arg1[1] = eax_2 - 1
0042098c              uint32_t result = zx.d(*ecx_5)
00420990              *arg1 = &ecx_5[1]
00420993              return result
00420993          
00420994          int32_t eax_4 = neg.d(eax_2)
0042099e          arg1[3] |= (sbb.d(eax_4, eax_4, eax_2 != 0) & 0x10) + 0x10
004209a1          arg1[1] = 0
004208e8      else
004208ea          eax.b |= 0x20
004208ec          arg1[3] = eax
004208ec  
004209a9  return 0xffffffff


004209aa    void* sub_4209aa(int32_t arg1, uint32_t arg2, uint32_t arg3)

004209b5  if (arg1 u< data_2823980
004209b5          && (*((&data_2823880)[arg1 s>> 5] + (arg1 & 0x1f) * 0x24 + 4) & 1) != 0)
004209d4      sub_425db9(arg1)
004209e2      void* result = sub_420a0f(arg1, arg2, arg3)
004209ea      sub_425e18(arg1)
004209f6      return result
004209f6  
004209fc  *sub_41e9bd() = 9
00420a07  *sub_41e9c6() = 0
00420a0e  return 0xffffffff


00420a0f    void* sub_420a0f(int32_t arg1, uint32_t arg2, uint32_t arg3)

00420a15  int32_t var_c = 0
00420a1e  char* lpBuffer_1 = arg2
00420a23  void* lpBuffer = lpBuffer_1
00420a23  
00420a25  if (arg3 != 0)
00420a33      int32_t ecx_2 = arg1 s>> 5
00420a40      void* edi_1 = &(&data_2823880)[ecx_2]
00420a47      int32_t esi_2 = (arg1 & 0x1f) * 0x24
00420a4a      void* eax_4 = (&data_2823880)[ecx_2] + esi_2
00420a4c      ecx_2.b = *(eax_4 + 4)
00420a4c      
00420a52      if ((ecx_2.b & 2) == 0)
00420a5b          if ((ecx_2.b & 0x48) != 0)
00420a5d              eax_4.b = *(eax_4 + 5)
00420a5d              
00420a62              if (eax_4.b != 0xa)
00420a64                  arg3 -= 1
00420a67                  *lpBuffer_1 = eax_4.b
00420a6b                  lpBuffer = &lpBuffer_1[1]
00420a6e                  var_c = 1
00420a75                  *(*edi_1 + esi_2 + 5) = 0xa
00420a75          
00420a91          uint32_t numberOfBytesRead
00420a91          
00420a91          if (ReadFile(hFile: (*edi_1)[(arg1 & 0x1f) * 9], lpBuffer, 
00420a91                  nNumberOfBytesToRead: arg3, lpNumberOfBytesRead: &numberOfBytesRead, 
00420a91                  lpOverlapped: nullptr) != 0)
00420acc              int32_t eax_11 = *edi_1
00420ace              uint32_t numberOfBytesRead_1 = numberOfBytesRead
00420ad1              void* result = var_c + numberOfBytesRead_1
00420ad4              char* ecx_4 = eax_11 + esi_2 + 4
00420ad8              eax_11.b = *(eax_11 + esi_2 + 4)
00420ad8              
00420ade              if ((eax_11.b & 0x80) == 0)
00420bdc                  return result
00420bdc              
00420aeb              if (numberOfBytesRead_1 == 0 || *lpBuffer_1 != 0xa)
00420af1                  eax_11.b &= 0xfb
00420aeb              else
00420aed                  eax_11.b |= 4
00420aed              
00420af3              *ecx_4 = eax_11.b
00420afb              arg3 = arg2
00420afe              void* ecx_6 = result + arg2
00420b02              void* var_c_1 = ecx_6
00420b02              
00420b05              if (arg2 u< ecx_6)
00420bbe                  do
00420b0e                      uint32_t eax_13
00420b0e                      eax_13.b = *arg3
00420b0e                      
00420b12                      if (eax_13.b == 0x1a)
00420bc8                          char* esi_3 = *edi_1 + esi_2 + 4
00420bcc                          int32_t eax_20
00420bcc                          eax_20.b = *esi_3
00420bcc                          
00420bd0                          if ((eax_20.b & 0x40) == 0)
00420bd2                              eax_20.b |= 2
00420bd4                              *esi_3 = eax_20.b
00420bd4                          
00420bd0                          break
00420bd0                      
00420b1a                      if (eax_13.b != 0xd)
00420b1c                          *lpBuffer_1 = eax_13.b
00420b1e                          lpBuffer_1 = &lpBuffer_1[1]
00420b1f                          arg3 += 1
00420b1a                      else if (arg3 u>= ecx_6 - 1)
00420b4b                          arg3 += 1
00420b61                          uint8_t buffer
00420b61                          
00420b61                          if (ReadFile(hFile: (*edi_1)[(arg1 & 0x1f) * 9], 
00420b61                                  lpBuffer: &buffer, nNumberOfBytesToRead: 1, 
00420b61                                  lpNumberOfBytesRead: &numberOfBytesRead, 
00420b61                                  lpOverlapped: nullptr) != 0)
00420b71                              if (numberOfBytesRead != 0)
00420b71                                  goto label_420b75
00420b71                              
00420bb4                              *lpBuffer_1 = 0xd
00420bb7                              lpBuffer_1 = &lpBuffer_1[1]
00420b61                          else if (GetLastError() != NO_ERROR || numberOfBytesRead == 0)
00420bb4                              *lpBuffer_1 = 0xd
00420bb7                              lpBuffer_1 = &lpBuffer_1[1]
00420b71                          else
00420b75                              label_420b75:
00420b75                              
00420b7a                              if ((*(*edi_1 + esi_2 + 4) & 0x48) != 0)
00420b7c                                  int32_t eax_19
00420b7c                                  eax_19.b = buffer
00420b7c                                  
00420b81                                  if (eax_19.b == 0xa)
00420b9a                                      *lpBuffer_1 = 0xa
00420bb7                                      lpBuffer_1 = &lpBuffer_1[1]
00420b81                                  else
00420b83                                      *lpBuffer_1 = 0xd
00420b88                                      lpBuffer_1 = &lpBuffer_1[1]
00420b89                                      *(*edi_1 + esi_2 + 5) = eax_19.b
00420b7a                              else if (lpBuffer_1 != arg2 || buffer != 0xa)
00420ba6                                  sub_421095(arg1, 0xffffffff, FILE_CURRENT)
00420ba6                                  
00420bb2                                  if (buffer != 0xa)
00420bb4                                      *lpBuffer_1 = 0xd
00420bb7                                      lpBuffer_1 = &lpBuffer_1[1]
00420b98                              else
00420b9a                                  *lpBuffer_1 = 0xa
00420bb7                                  lpBuffer_1 = &lpBuffer_1[1]
00420b2b                      else if (*(arg3 + 1) != 0xa)
00420b3c                          *lpBuffer_1 = 0xd
00420b3f                          lpBuffer_1 = &lpBuffer_1[1]
00420b40                          arg3 += 1
00420b34                      else
00420b36                          arg3 += 2
00420b9a                          *lpBuffer_1 = 0xa
00420bb7                          lpBuffer_1 = &lpBuffer_1[1]
00420bb7                      
00420bb8                      ecx_6 = var_c_1
00420bbe                  while (arg3 u< ecx_6)
00420bbe              
00420bd9              return lpBuffer_1 - arg2
00420bd9          
00420a93          enum WIN32_ERROR eax_8 = GetLastError()
00420a93          
00420a9e          if (eax_8 == ERROR_ACCESS_DENIED)
00420aa5              *sub_41e9bd() = 9
00420ab0              *sub_41e9c6() = 5
00420ac4              return 0xffffffff
00420ac4          
00420ab7          if (eax_8 != ERROR_BROKEN_PIPE)
00420abe              sub_41e94a(eax_8)
00420ac4              return 0xffffffff
00420ac4  
00420be1  return nullptr

00420be8                          cc cc cc cc cc cc cc cc                                                          ........

00420bf0    char* sub_420bf0(char* arg1, char* arg2, int32_t arg3)

00420bf5  char* esi = arg2
00420bfb  char* edi = arg1
00420c0a  uint32_t eax_1
00420c0a  
00420c0a  if (edi u> esi && edi u< &esi[arg3])
00420d88      void* esi_1 = &esi[arg3 - 4]
00420d8c      void* edi_1 = &edi[arg3 - 4]
00420d96      int32_t edx_2
00420d96      uint32_t ecx_4
00420d96      
00420d96      if ((edi_1 & 3) == 0)
00420d98          ecx_4 = arg3 u>> 2
00420d9b          edx_2 = arg3 & 3
00420d9b          
00420da1          if (ecx_4 u>= 8)
00420da4              edi_1, esi_1 = __builtin_memcpy(dest: edi_1 - (ecx_4 << 2), 
00420da4                  src: esi_1 - (ecx_4 << 2), n: ecx_4 << 2)
00420da4              
00420da7              switch (edx_2)
00420ee6                  case 0
00420ee6                      return arg1
00420da7                  case 1
00420da7                      goto label_420ee8
00420da7                  case 2
00420da7                      goto label_420ef8
00420da7                  case 3
00420da7                      goto label_420f0c
00420d96      else if (arg3 u< 4)
00420dc6          switch (arg3)
00420ee6              case 0
00420ee6                  return arg1
00420ee8              case 1
00420ee8                  label_420ee8:
00420ee8                  eax_1.b = *(esi_1 + 3)
00420eeb                  *(edi_1 + 3) = eax_1.b
00420ef4                  return arg1
00420ef8              case 2
00420ef8                  label_420ef8:
00420ef8                  eax_1.b = *(esi_1 + 3)
00420efb                  *(edi_1 + 3) = eax_1.b
00420efe                  eax_1.b = *(esi_1 + 2)
00420f01                  *(edi_1 + 2) = eax_1.b
00420f0a                  return arg1
00420f0c              case 3
00420f0c                  label_420f0c:
00420f0c                  eax_1.b = *(esi_1 + 3)
00420f0f                  *(edi_1 + 3) = eax_1.b
00420f12                  eax_1.b = *(esi_1 + 2)
00420f15                  *(edi_1 + 2) = eax_1.b
00420f18                  eax_1.b = *(esi_1 + 1)
00420f1b                  *(edi_1 + 1) = eax_1.b
00420f24                  return arg1
00420dc6      else
00420dc8          eax_1 = edi_1 & 3
00420dcb          int32_t ecx_6 = arg3 - eax_1
00420dcb          
00420dcd          switch (jump_table_420dd8[eax_1])
00420de8              case 0x420de8
00420de8                  eax_1.b = *(esi_1 + 3)
00420deb                  edx_2 = 3 & ecx_6
00420ded                  *(edi_1 + 3) = eax_1.b
00420df0                  esi_1 -= 1
00420df1                  ecx_4 = ecx_6 u>> 2
00420df4                  edi_1 -= 1
00420df4                  
00420df8                  if (ecx_4 u>= 8)
00420dfb                      edi_1, esi_1 = __builtin_memcpy(dest: edi_1 - (ecx_4 << 2), 
00420dfb                          src: esi_1 - (ecx_4 << 2), n: ecx_4 << 2)
00420dfb                      
00420dfe                      switch (edx_2)
00420ee6                          case 0
00420ee6                              return arg1
00420dfe                          case 1
00420dfe                              goto label_420ee8
00420dfe                          case 2
00420dfe                              goto label_420ef8
00420dfe                          case 3
00420dfe                              goto label_420f0c
00420e08              case 0x420e08
00420e08                  eax_1.b = *(esi_1 + 3)
00420e0b                  edx_2 = 3 & ecx_6
00420e0d                  *(edi_1 + 3) = eax_1.b
00420e10                  eax_1.b = *(esi_1 + 2)
00420e13                  ecx_4 = ecx_6 u>> 2
00420e16                  *(edi_1 + 2) = eax_1.b
00420e19                  esi_1 -= 2
00420e1c                  edi_1 -= 2
00420e1c                  
00420e22                  if (ecx_4 u>= 8)
00420e25                      edi_1, esi_1 = __builtin_memcpy(dest: edi_1 - (ecx_4 << 2), 
00420e25                          src: esi_1 - (ecx_4 << 2), n: ecx_4 << 2)
00420e25                      
00420e28                      switch (edx_2)
00420ee6                          case 0
00420ee6                              return arg1
00420e28                          case 1
00420e28                              goto label_420ee8
00420e28                          case 2
00420e28                              goto label_420ef8
00420e28                          case 3
00420e28                              goto label_420f0c
00420e30              case 0x420e30
00420e30                  eax_1.b = *(esi_1 + 3)
00420e33                  edx_2 = 3 & ecx_6
00420e35                  *(edi_1 + 3) = eax_1.b
00420e38                  eax_1.b = *(esi_1 + 2)
00420e3b                  *(edi_1 + 2) = eax_1.b
00420e3e                  eax_1.b = *(esi_1 + 1)
00420e41                  ecx_4 = ecx_6 u>> 2
00420e44                  *(edi_1 + 1) = eax_1.b
00420e47                  esi_1 -= 3
00420e4a                  edi_1 -= 3
00420e4a                  
00420e50                  if (ecx_4 u>= 8)
00420e57                      edi_1, esi_1 = __builtin_memcpy(dest: edi_1 - (ecx_4 << 2), 
00420e57                          src: esi_1 - (ecx_4 << 2), n: ecx_4 << 2)
00420e57                      
00420e5a                      switch (edx_2)
00420ee6                          case 0
00420ee6                              return arg1
00420e5a                          case 1
00420e5a                              goto label_420ee8
00420e5a                          case 2
00420e5a                              goto label_420ef8
00420e5a                          case 3
00420e5a                              goto label_420f0c
00420e5a      
00420ec7      switch (edx_2)
00420ee6          case 0
00420ee6              return arg1
00420ec7          case 1
00420ec7              goto label_420ee8
00420ec7          case 2
00420ec7              goto label_420ef8
00420ec7          case 3
00420ec7              goto label_420f0c
00420ec7  
00420c16  uint32_t ecx_1
00420c16  int32_t edx_1
00420c16  
00420c16  if ((edi & 3) != 0)
00420c36      if (arg3 u< 4)
00420c44          jump(*(((arg3 - 4) << 2) + &data_420d48))
00420c44      
00420c38      eax_1 = edi & 3
00420c3b      int32_t ecx_3 = arg3 - 4 + eax_1
00420c3b      
00420c3d      switch (jump_table_420c50[eax_1])
00420c60          case 0x420c60
00420c60              edx_1 = 3 & ecx_3
00420c62              eax_1.b = *esi
00420c64              *edi = eax_1.b
00420c66              eax_1.b = esi[1]
00420c69              edi[1] = eax_1.b
00420c6c              eax_1.b = esi[2]
00420c6f              ecx_1 = ecx_3 u>> 2
00420c72              edi[2] = eax_1.b
00420c75              esi = &esi[3]
00420c78              edi = &edi[3]
00420c78              
00420c7e              if (ecx_1 u>= 8)
00420c80                  edi, esi = __builtin_memcpy(dest: edi, src: esi, n: ecx_1 << 2)
00420c80                  
00420c82                  switch (edx_1)
00420d4e                      case 0
00420d4e                          return arg1
00420c82                      case 1
00420c82                          goto label_420d50
00420c82                      case 2
00420c82                          goto label_420d5c
00420c82                      case 3
00420c82                          goto label_420d70
00420c8c          case 0x420c8c
00420c8c              edx_1 = 3 & ecx_3
00420c8e              eax_1.b = *esi
00420c90              *edi = eax_1.b
00420c92              eax_1.b = esi[1]
00420c95              ecx_1 = ecx_3 u>> 2
00420c98              edi[1] = eax_1.b
00420c9b              esi = &esi[2]
00420c9e              edi = &edi[2]
00420c9e              
00420ca4              if (ecx_1 u>= 8)
00420ca6                  edi, esi = __builtin_memcpy(dest: edi, src: esi, n: ecx_1 << 2)
00420ca6                  
00420ca8                  switch (edx_1)
00420d4e                      case 0
00420d4e                          return arg1
00420ca8                      case 1
00420ca8                          goto label_420d50
00420ca8                      case 2
00420ca8                          goto label_420d5c
00420ca8                      case 3
00420ca8                          goto label_420d70
00420cb0          case 0x420cb0
00420cb0              edx_1 = 3 & ecx_3
00420cb2              eax_1.b = *esi
00420cb4              *edi = eax_1.b
00420cb6              esi = &esi[1]
00420cb7              ecx_1 = ecx_3 u>> 2
00420cba              edi = &edi[1]
00420cba              
00420cbe              if (ecx_1 u>= 8)
00420cc0                  edi, esi = __builtin_memcpy(dest: edi, src: esi, n: ecx_1 << 2)
00420cc0                  
00420cc2                  switch (edx_1)
00420d4e                      case 0
00420d4e                          return arg1
00420cc2                      case 1
00420cc2                          goto label_420d50
00420cc2                      case 2
00420cc2                          goto label_420d5c
00420cc2                      case 3
00420cc2                          goto label_420d70
00420c16  else
00420c18      ecx_1 = arg3 u>> 2
00420c1b      edx_1 = arg3 & 3
00420c1b      
00420c21      if (ecx_1 u>= 8)
00420c23          edi, esi = __builtin_memcpy(dest: edi, src: esi, n: ecx_1 << 2)
00420c23          
00420c25          switch (edx_1)
00420d4e              case 0
00420d4e                  return arg1
00420c25              case 1
00420c25                  goto label_420d50
00420c25              case 2
00420c25                  goto label_420d5c
00420c25              case 3
00420c25                  goto label_420d70
00420c25  
00420c4c  switch (ecx_1)
00420c4c      case 0
00420c4c          goto label_420d2f
00420c4c      case 1
00420c4c          goto label_420d20
00420c4c      case 2
00420c4c          goto label_420d18
00420c4c      case 3
00420c4c          goto label_420d10
00420c4c      case 4
00420c4c          goto label_420d08
00420c4c      case 5
00420c4c          goto label_420d00
00420c4c      case 6
00420c4c          goto label_420cf8
00420cf0      case 7
00420cf0          *(edi + (ecx_1 << 2) - 0x1c) = *(esi + (ecx_1 << 2) - 0x1c)
00420cf8          label_420cf8:
00420cf8          *(edi + (ecx_1 << 2) - 0x18) = *(esi + (ecx_1 << 2) - 0x18)
00420d00          label_420d00:
00420d00          *(edi + (ecx_1 << 2) - 0x14) = *(esi + (ecx_1 << 2) - 0x14)
00420d08          label_420d08:
00420d08          *(edi + (ecx_1 << 2) - 0x10) = *(esi + (ecx_1 << 2) - 0x10)
00420d10          label_420d10:
00420d10          *(edi + (ecx_1 << 2) - 0xc) = *(esi + (ecx_1 << 2) - 0xc)
00420d18          label_420d18:
00420d18          *(edi + (ecx_1 << 2) - 8) = *(esi + (ecx_1 << 2) - 8)
00420d20          label_420d20:
00420d20          *(edi + (ecx_1 << 2) - 4) = *(esi + (ecx_1 << 2) - 4)
00420d24          eax_1 = ecx_1 << 2
00420d2b          esi = &esi[eax_1]
00420d2d          edi = &edi[eax_1]
00420d2f          label_420d2f:
00420d2f          
00420d2f          switch (edx_1)
00420d4e              case 0
00420d4e                  return arg1
00420d50              case 1
00420d50                  label_420d50:
00420d50                  eax_1.b = *esi
00420d52                  *edi = eax_1.b
00420d5a                  return arg1
00420d5c              case 2
00420d5c                  label_420d5c:
00420d5c                  eax_1.b = *esi
00420d5e                  *edi = eax_1.b
00420d60                  eax_1.b = esi[1]
00420d63                  edi[1] = eax_1.b
00420d6c                  return arg1
00420d70              case 3
00420d70                  label_420d70:
00420d70                  eax_1.b = *esi
00420d72                  *edi = eax_1.b
00420d74                  eax_1.b = esi[1]
00420d77                  edi[1] = eax_1.b
00420d7a                  eax_1.b = esi[2]
00420d7d                  edi[2] = eax_1.b
00420d86                  return arg1

00420c4b                                   90                                                                         .
00420c53                                                           90 60 0c 42 00 8c 0c 42 00 b0 0c 42 00                     .`.B...B...B.
00420c89                             8d 49 00                                                                       .I.
00420caf                                               90                                                                 .
00420cc9                             8d 49 00                                                                       .I.
00420ccc  uint32_t jump_table_420ccc[0x8] = 
00420ccc  {
00420ccc      [0x0] =  0x00420d2f
00420cd0      [0x1] =  0x00420d1c
00420cd4      [0x2] =  0x00420d14
00420cd8      [0x3] =  0x00420d0c
00420cdc      [0x4] =  0x00420d04
00420ce0      [0x5] =  0x00420cfc
00420ce4      [0x6] =  0x00420cf4
00420ce8      [0x7] =  0x00420cec
00420cec  }

00420d36                                                                    8b ff                                                ..
00420d38  uint32_t jump_table_420d38[0x4] = 
00420d38  {
00420d38      [0x0] =  0x00420d48
00420d3c      [0x1] =  0x00420d50
00420d40      [0x2] =  0x00420d5c
00420d44      [0x3] =  0x00420d70
00420d48  }

00420d4f                                               90                                                                 .
00420d5b                                                                                   90                                         .
00420d6d                                         8d 49 00                                                               .I.
00420d87                       90                                                                                 .
00420dae                                            8b ff                                                                ..
00420db9                                                                             8d 49 00                                       .I.
00420ddb                                                                                   90 e8 0d 42 00                             ...B.
00420de0  08 0e 42 00 30 0e 42 00                                                                          ..B.0.B.
00420e05                 8d 49 00                                                                               .I.
00420e2f                                               90                                                                 .
00420e61     8d 49 00 84 0e 42 00 8c 0e 42 00 94 0e 42 00 9c 0e 42 00 a4 0e 42 00 ac 0e 42 00 b4 0e 42 00   .I...B...B...B...B...B...B...B.
00420e80  uint32_t jump_table_420e80[0x1] = 
00420e80  {
00420e80      [0x0] =  0x00420ec7
00420e84  }

00420e84              8b 44 8e 1c 89 44 8f 1c 8b 44 8e 18 89 44 8f 18 8b 44 8e 14 89 44 8f 14 8b 44 8e 10      .D...D...D...D...D...D...D..
00420ea0  89 44 8f 10 8b 44 8e 0c 89 44 8f 0c 8b 44 8e 08 89 44 8f 08 8b 44 8e 04 89 44 8f 04 8d 04 8d 00  .D...D...D...D...D...D...D......
00420ec0  00 00 00 03 f0 03 f8                                                                             .......
00420ece                                            8b ff                                                                ..
00420ed0  uint32_t jump_table_420ed0[0x4] = 
00420ed0  {
00420ed0      [0x0] =  0x00420ee0
00420ed4      [0x1] =  0x00420ee8
00420ed8      [0x2] =  0x00420ef8
00420edc      [0x3] =  0x00420f0c
00420ee0  }

00420ee7                       90                                                                                 .
00420ef5                                                                 8d 49 00                                               .I.
00420f0b                                   90                                                                         .

00420f25    int32_t sub_420f25(int32_t arg1)

00420f30  if (arg1 u< data_2823980
00420f30          && (*((&data_2823880)[arg1 s>> 5] + (arg1 & 0x1f) * 0x24 + 4) & 1) != 0)
00420f4f      sub_425db9(arg1)
00420f55      int32_t result = sub_420f82(arg1)
00420f5d      sub_425e18(arg1)
00420f69      return result
00420f69  
00420f6f  *sub_41e9bd() = 9
00420f7a  *sub_41e9c6() = 0
00420f81  return 0xffffffff


00420f82    int32_t sub_420f82(int32_t arg1)

00420f92  enum WIN32_ERROR edi_2
00420f92  
00420f92  if (sub_425d77(arg1) == 0xffffffff)
00420fd0      edi_2 = NO_ERROR
00420f92  else if (arg1 == 1 || arg1 == 2)
00420fa0      int32_t eax_1 = sub_425d77(2)
00420fa0      
00420fb2      if (sub_425d77(1) != eax_1)
00420fb2          goto label_420fbc
00420fb2      
00420fd0      edi_2 = NO_ERROR
00420f9c  else
00420fbc      label_420fbc:
00420fbc      
00420fc4      if (CloseHandle(hObject: sub_425d77(arg1)) != 0)
00420fd0          edi_2 = NO_ERROR
00420fc4      else
00420fcc          edi_2 = GetLastError()
00420fcc  
00420fd3  sub_425cf8(arg1)
00420feb  *((&data_2823880)[arg1 s>> 5] + (arg1 & 0x1f) * 0x24 + 4) = 0
00420feb  
00420ff2  if (edi_2 == NO_ERROR)
00421000      return 0
00421000  
00420ff5  sub_41e94a(edi_2)
00420ffb  return 0xffffffff


00421005    char sub_421005(int32_t* arg1)

0042100a  char result = (arg1[3]).b
0042100a  
00421013  if ((result & 0x83) != 0 && (result & 8) != 0)
00421018      sub_41e29e(arg1[2])
0042101d      arg1[3].w &= 0xfbf7
00421023      result = 0
00421026      *arg1 = 0
00421028      arg1[2] = 0
0042102b      arg1[1] = 0
0042102b  
0042102f  return result


00421030    uint32_t sub_421030(int32_t arg1, int32_t arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)

0042103b  if (arg1 u< data_2823980
0042103b          && (*((&data_2823880)[arg1 s>> 5] + (arg1 & 0x1f) * 0x24 + 4) & 1) != 0)
0042105a      sub_425db9(arg1)
00421068      uint32_t result = sub_421095(arg1, arg2, arg3)
00421070      sub_425e18(arg1)
0042107c      return result
0042107c  
00421082  *sub_41e9bd() = 9
0042108d  *sub_41e9c6() = 0
00421094  return 0xffffffff


00421095    uint32_t sub_421095(int32_t arg1, int32_t arg2, enum SET_FILE_POINTER_MOVE_METHOD arg3)

0042109c  HANDLE hFile = sub_425d77(arg1)
0042109c  
004210a5  if (hFile != 0xffffffff)
004210bf      uint32_t result = SetFilePointer(hFile, lDistanceToMove: arg2, 
004210bf          lpDistanceToMoveHigh: nullptr, dwMoveMethod: arg3)
004210ca      enum WIN32_ERROR eax_1
004210ca      
004210ca      if (result != 0xffffffff)
004210d4          eax_1 = NO_ERROR
004210ca      else
004210cc          eax_1 = GetLastError()
004210cc      
004210d8      if (eax_1 == NO_ERROR)
004210f0          int32_t ecx_4 = (&data_2823880)[arg1 s>> 5]
004210f7          int32_t eax_3 = (arg1 & 0x1f) * 9
004210fa          *(ecx_4 + (eax_3 << 2) + 4) &= 0xfd
00421103          return result
00421103      
004210db      sub_41e94a(eax_1)
004210a5  else
004210ac      *sub_41e9bd() = 9
004210ac  
004210e1  return 0xffffffff


00421108    int32_t* sub_421108(PSTR arg1, char* arg2, char arg3, int32_t* arg4)

0042110b  int32_t ecx
0042110b  int32_t var_8 = ecx
0042110c  int32_t var_c = ecx
0042110f  int32_t esi = data_430db8
00421116  char* edi = arg2
0042111b  int32_t var_c_1 = 0
0042111e  int32_t var_8_1 = 0
00421121  int32_t eax
00421121  eax.b = *edi
00421125  int32_t ecx_1
00421125  int32_t esi_1
00421125  
00421125  if (eax.b == 0x61)
00421141      ecx_1 = 0x109
00421146      label_421146:
00421146      esi_1 = esi | 2
0042114b      label_42114b:
0042114b      int32_t edx_1 = 1
0042114b      
0042114c      while (true)
0042114c          eax.b = edi[1]
0042114f          edi = &edi[1]
0042114f          
00421152          if (eax.b == 0)
00421152              break
00421152          
0042115a          if (edx_1 == 0)
0042115a              break
0042115a          
00421160          int32_t eax_1 = sx.d(eax.b)
00421160          
00421166          if (eax_1 s> 0x54)
004211dd              if (eax_1 == 0x62)
0042122a                  if ((ecx_1:1.b & 0xc0) == 0)
00421233                      ecx_1:1.b |= 0x80
00421236                      continue
004211dd              else if (eax_1 == 0x63)
00421213                  if (var_c_1 == 0)
00421215                      var_c_1 = 1
0042121c                      esi_1 |= 0x4000
00421222                      continue
004211e0              else if (eax_1 == 0x6e)
004211fc                  if (var_c_1 == 0)
004211fe                      var_c_1 = 1
00421205                      esi_1 &= 0xffffbfff
0042120b                      continue
004211e5              else if (eax_1 == 0x74 && (ecx_1:1.b & 0xc0) == 0)
004211f1                  ecx_1:1.b |= 0x40
004211f4                  continue
00421166          else if (eax_1 == 0x54)
004211d1              if ((0x1000 & ecx_1) == 0)
004211d3                  ecx_1 |= 0x1000
004211d5                  continue
00421168          else if (eax_1 == 0x2b)
004211b7              if ((ecx_1.b & 2) == 0)
004211bf                  ecx_1 = (ecx_1 & 0xfffffffe) | 2
004211c2                  esi_1 = (esi_1 & 0xfffffffc) | 0x80
004211c8                  continue
0042116d          else if (eax_1 == 0x44)
004211ad              if ((ecx_1.b & 0x40) == 0)
004211af                  ecx_1 |= 0x40
004211b2                  continue
00421172          else if (eax_1 == 0x52)
00421198              if (var_8_1 == 0)
0042119e                  var_8_1 = 1
004211a5                  ecx_1 |= 0x10
004211a8                  continue
00421177          else if (eax_1 == 0x53 && var_8_1 == 0)
00421189              var_8_1 = 1
00421190              ecx_1 |= 0x20
00421193              continue
00421193          
0042122c          edx_1 = 0
0042122c      
0042123b      int32_t var_1c_1 = 0x1a4
00421247      int32_t eax_2 = sub_425e3a(arg1, ecx_1, arg3)
00421247      
00421253      if (eax_2 s>= 0)
0042125c          data_430c04 += 1
00421262          arg4[3] = esi_1
00421265          arg4[1] = 0
00421268          *arg4 = 0
0042126a          arg4[2] = 0
0042126d          arg4[7] = 0
00421270          arg4[4] = eax_2
00421277          return arg4
00421125  else
00421129      if (eax.b == 0x72)
0042113a          ecx_1 = 0
0042113c          esi_1 = esi | 1
0042113f          goto label_42114b
0042113f      
0042112d      if (eax.b == 0x77)
00421133          ecx_1 = 0x301
00421138          goto label_421146
00421255  return nullptr


00421278    int32_t* sub_421278()

0042127f  int32_t* result = nullptr
00421281  sub_421919(2)
00421286  int32_t esi = 0
00421286  
0042128f  if (data_28249a0 s> 0)
0042129a      while (true)
0042129a          void* eax_2 = *(data_2823984 + (esi << 2))
0042129a          
0042129f          if (eax_2 == 0)
004212da              int32_t esi_1 = esi << 2
004212e9              *(esi_1 + data_2823984) = sub_41e583(0x38)
004212f1              void* eax_6 = *(esi_1 + data_2823984)
004212f1              
004212f6              if (eax_6 == 0)
004212f6                  break
004212f6              
004212fc              InitializeCriticalSection(lpCriticalSection: eax_6 + 0x20)
0042130e              EnterCriticalSection(lpCriticalSection: *(esi_1 + data_2823984) + 0x20)
00421319              result = *(esi_1 + data_2823984)
0042129f          else
004212a5              if ((*(eax_2 + 0xc) & 0x83) != 0)
004212a5                  goto label_4212c8
004212a5              
004212a9              sub_41ff98(esi, eax_2)
004212b0              int32_t ecx_1 = data_2823984
004212b6              void* eax_3 = *(ecx_1 + (esi << 2))
004212b6              
004212bd              if ((*(eax_3 + 0xc) & 0x83) == 0)
004212d3                  result = *(ecx_1 + (esi << 2))
004212bd              else
004212c1                  sub_41ffea(esi, eax_3)
004212c8                  label_4212c8:
004212c8                  esi += 1
004212c8                  
004212cf                  if (esi s>= data_28249a0)
004212cf                      break
004212cf                  
004212cf                  continue
004212cf          
0042131e          if (result == 0)
0042131e              break
0042131e          
00421320          result[4] = 0xffffffff
00421324          result[1] = 0
00421327          result[3] = 0
0042132a          result[2] = 0
0042132d          *result = 0
0042132f          result[7] = 0
0042132f          break
0042132f  
00421334  sub_42197a(2)
0042133f  return result


00421340    uint32_t sub_421340(int32_t* arg1)

00421345  int32_t* esi = arg1
00421348  int32_t eax = esi[3]
0042134b  enum WIN32_ERROR ebx = esi[4]
0042134b  
00421358  if ((eax.b & 0x82) == 0 || (eax.b & 0x40) != 0)
0042144c      eax.b |= 0x20
0042144e      esi[3] = eax
00421358  else
00421360      if ((eax.b & 1) == 0)
00421360          goto label_421378
00421360      
00421362      esi[1] = 0
00421362      
00421368      if ((eax.b & 0x10) == 0)
0042144c          eax.b |= 0x20
0042144e          esi[3] = eax
00421368      else
00421371          eax.b &= 0xfe
00421373          *esi = esi[2]
00421375          esi[3] = eax
00421378          label_421378:
00421378          int32_t eax_1 = esi[3]
0042137b          esi[1] = 0
0042137f          arg1 = nullptr
00421383          eax_1.b &= 0xef
00421385          eax_1.b |= 2
0042138b          esi[3] = eax_1
0042138b          
0042138e          if ((eax_1.w & 0x10c) == 0)
0042139e              bool cond:3_1
0042139e              
0042139e              if (esi == &data_42f360 || esi == 0x42f380)
004213a6                  cond:3_1 = sub_42593f(ebx) != 0
004213a6              
004213a9              if ((esi != &data_42f360 && esi != 0x42f380) || not(cond:3_1))
004213ac                  sub_425b15(esi)
004213ac          
004213b9          int32_t arg_4
004213b9          uint32_t edi_2
004213b9          
004213b9          if ((esi[3].w & 0x108) == 0)
00421427              edi_2 = 1
00421433              arg1 = sub_421458(ebx, &arg_4, 1)
004213b9          else
004213bb              char* eax_3 = esi[2]
004213c0              edi_2 = *esi - eax_3
004213c5              *esi = &eax_3[1]
004213cd              esi[1] = esi[6] - 1
004213d0              int32_t ecx_6
004213d0              
004213d0              if (edi_2 s<= 0)
004213e5                  void* eax_8
004213e5                  
004213e5                  if (ebx == ~NO_ERROR)
00421400                      eax_8 = &data_42f5d0
004213e5                  else
004213fb                      eax_8 = (&data_2823880)[ebx s>> 5] + (ebx & ERROR_GEN_FAILURE) * 0x24
004213fb                  
00421409                  if ((*(eax_8 + 4) & 0x20) != 0)
00421410                      sub_421030(ebx, 0, FILE_END)
004213d0              else
004213d5                  int32_t* eax_4
004213d5                  eax_4, ecx_6 = sub_421458(ebx, eax_3, edi_2)
004213dd                  arg1 = eax_4
004213dd              
0042141b              ecx_6.b = arg_4.b
0042141e              *esi[2] = ecx_6.b
0042141e          
0042143a          if (arg1 == edi_2)
00421445              return zx.d(arg_4.b)
00421445          
0042143c          esi[3] |= 0x20
0042143c  
00421451  return 0xffffffff


00421458    int32_t sub_421458(enum WIN32_ERROR arg1, char* arg2, uint32_t arg3)

00421463  if (arg1 u< data_2823980
00421463          && (*((&data_2823880)[arg1 s>> 5] + (arg1 & ERROR_GEN_FAILURE) * 0x24 + 4) & 1)
00421463          != 0)
00421482      sub_425db9(arg1)
00421490      int32_t result = sub_4214bd(arg1, arg2, arg3)
00421498      sub_425e18(arg1)
004214a4      return result
004214a4  
004214aa  *sub_41e9bd() = 9
004214b5  *sub_41e9c6() = 0
004214bc  return 0xffffffff


004214bd    int32_t sub_4214bd(enum WIN32_ERROR arg1, char* arg2, uint32_t arg3)

004214ce  uint32_t numberOfBytesWritten_1 = 0
004214d1  int32_t var_14 = 0
004214d1  
004214d4  if (arg3 != 0)
004214e3      void* ebx_1 = &(&data_2823880)[arg1 s>> 5]
004214f5      int32_t esi_2 = (arg1 & ERROR_GEN_FAILURE) * 0x24
004214f5      
004214fd      if ((*(*ebx_1 + esi_2 + 4) & 0x20) != 0)
00421505          sub_421095(arg1, 0, FILE_END)
00421505      
0042150f      int32_t* eax_7 = *ebx_1 + esi_2
00421515      uint32_t numberOfBytesWritten
00421515      
00421515      if ((eax_7[1].b & 0x80) == 0)
004215f1          if (WriteFile(hFile: *eax_7, lpBuffer: arg2, nNumberOfBytesToWrite: arg3, 
004215f1                  lpNumberOfBytesWritten: &numberOfBytesWritten, lpOverlapped: nullptr) == 0)
00421604              arg1 = GetLastError()
004215f1          else
004215f6              arg1 = NO_ERROR
004215f9              numberOfBytesWritten_1 = numberOfBytesWritten
004215f9          
004215a8          label_4215a8:
004215a8          
004215aa          if (numberOfBytesWritten_1 != 0)
00421640              return numberOfBytesWritten_1 - var_14
00421640          
004215b3          if (arg1 != NO_ERROR)
004215bb              if (arg1 != ERROR_ACCESS_DENIED)
0042160c                  sub_41e94a(arg1)
004215bb              else
004215c2                  *sub_41e9bd() = 9
004215cd                  *sub_41e9c6() = 5
004215cd              
00421612              return 0xffffffff
00421515      else
00421521          char* var_8_1 = arg2
00421524          arg1 = NO_ERROR
00421524          
00421527          if (arg3 u> 0)
004215a1              do
0042152d                  uint8_t buffer[0x404]
0042152d                  uint8_t (* eax_9)[0x404] = &buffer
0042152d                  
0042153c                  while (var_8_1 - arg2 u< arg3)
0042153e                      char* ecx_3 = var_8_1
00421541                      var_8_1 = &var_8_1[1]
00421544                      ecx_3.b = *ecx_3
00421544                      
00421549                      if (ecx_3.b == 0xa)
0042154b                          var_14 += 1
0042154e                          *eax_9 = 0xd
00421551                          eax_9 = &(*eax_9)[1]
00421551                      
00421552                      *eax_9 = ecx_3.b
00421554                      eax_9 = &(*eax_9)[1]
00421554                      
00421565                      if (eax_9 - &buffer s>= 0x400)
00421565                          break
00421565                  
0042156f                  uint32_t nNumberOfBytesToWrite = eax_9 - &buffer
0042156f                  
0042158c                  if (WriteFile(hFile: (*ebx_1)[(arg1 & 0x1f) * 9], lpBuffer: &buffer, 
0042158c                          nNumberOfBytesToWrite, 
0042158c                          lpNumberOfBytesWritten: &numberOfBytesWritten, 
0042158c                          lpOverlapped: nullptr) == 0)
004215d7                      arg1 = GetLastError()
004215da                      break
004215da                  
0042158e                  uint32_t numberOfBytesWritten_2 = numberOfBytesWritten
00421591                  numberOfBytesWritten_1 += numberOfBytesWritten_2
00421591                  
00421596                  if (numberOfBytesWritten_2 s< nNumberOfBytesToWrite)
00421596                      break
004215a1              while (var_8_1 - arg2 u< arg3)
004215a1              
0042158c              goto label_4215a8
0042158c      
00421626      if ((*(*ebx_1 + esi_2 + 4) & 0x40) == 0 || *arg2 != 0x1a)
00421631          *sub_41e9bd() = 0x1c
0042163c          *sub_41e9c6() = 0
00421612          return 0xffffffff
00421612  
004214d6  return 0


00421648    uint32_t sub_421648()

0042165b  void* esi = sub_41e583(0x480)
0042165b  
00421660  if (esi == 0)
00421664      sub_41f9c5(0x1b)
00421664  
0042166a  data_2823880 = esi
00421670  data_2823980 = 0x20
00421670  
00421682  for (void* i = esi + 0x480; esi u< i; i = data_2823880 + 0x480)
00421684      *(esi + 4) = 0
00421688      *esi = 0xffffffff
0042168b      *(esi + 8) = 0
0042168f      *(esi + 5) = 0xa
00421698      esi += 0x24
00421698  
004216a6  STARTUPINFOA startupInfo
004216a6  GetStartupInfoA(lpStartupInfo: &startupInfo)
004216a6  
004216b1  if (startupInfo.cbReserved2 != 0)
004216b7      BYTE* lpReserved2 = startupInfo.lpReserved2
004216b7      
004216bc      if (lpReserved2 != 0)
004216c2          int32_t i_1 = *lpReserved2
004216c4          void* ebx_1 = &lpReserved2[4]
004216ca          void* var_8_1 = ebx_1 + i_1
004216ca          
004216d4          if (i_1 s>= 0x800)
004216d6              i_1 = 0x800
004216d6          
004216de          if (data_2823980 s< i_1)
004216e0              void* esi_1 = &data_2823884
004216e0              
0042172c              do
004216ea                  void* eax_3 = sub_41e583(0x480)
004216ea                  
004216f2                  if (eax_3 == 0)
00421730                      i_1 = data_2823980
00421730                      break
00421730                  
004216f4                  data_2823980 += 0x20
004216fb                  *esi_1 = eax_3
004216fb                  
00421705                  for (void* j = eax_3 + 0x480; eax_3 u< j; j = *esi_1 + 0x480)
00421707                      *(eax_3 + 4) = 0
0042170b                      *eax_3 = 0xffffffff
0042170e                      *(eax_3 + 8) = 0
00421712                      *(eax_3 + 5) = 0xa
00421718                      eax_3 += 0x24
00421718                  
00421723                  esi_1 += 4
0042172c              while (data_2823980 s< i_1)
0042172c          
00421736          int32_t esi_2 = 0
00421736          
0042173a          if (i_1 s> 0)
00421786              do
0042173f                  HANDLE hFile_1 = *var_8_1
0042173f                  
00421744                  if (hFile_1 != 0xffffffff)
00421746                      void* eax_4
00421746                      eax_4.b = *ebx_1
00421746                      
0042174a                      if ((eax_4.b & 1) != 0)
0042174e                          enum FILE_TYPE eax_5
0042174e                          
0042174e                          if ((eax_4.b & 8) == 0)
00421751                              eax_5 = GetFileType(hFile: hFile_1)
00421751                          
00421759                          if ((eax_4.b & 8) != 0 || eax_5 != FILE_TYPE_UNKNOWN)
0042176f                              int32_t* eax_9 =
0042176f                                  (&data_2823880)[esi_2 s>> 5] + (esi_2 & 0x1f) * 0x24
00421777                              *eax_9 = *var_8_1
00421779                              int32_t ecx_8
00421779                              ecx_8.b = *ebx_1
0042177b                              eax_9[1].b = ecx_8.b
0042177b                  
0042177e                  var_8_1 += 4
00421782                  esi_2 += 1
00421783                  ebx_1 += 1
00421786              while (esi_2 s< i_1)
00421786  
004217f1  for (int32_t i_2 = 0; i_2 s< 3; i_2 += 1)
0042178a      int32_t ecx_9 = data_2823880
00421790      int32_t eax_10 = i_2 * 9
00421797      int32_t* esi_3 = ecx_9 + (eax_10 << 2)
00421797      
0042179a      if (*(ecx_9 + (eax_10 << 2)) != 0xffffffff)
004217e9          esi_3[1].b |= 0x80
0042179a      else
0042179e          esi_3[1].b = 0x81
004217a2          enum STD_HANDLE nStdHandle
004217a2          
004217a2          if (i_2 != 0)
004217ac              int32_t eax_13 = neg.d(i_2 - 1)
004217b0              nStdHandle = sbb.d(eax_13, eax_13, i_2 != 1) - 0xb
004217a2          else
004217a6              nStdHandle = STD_INPUT_HANDLE
004217a6          
004217b4          HANDLE hFile = GetStdHandle(nStdHandle)
004217b4          
004217bf          if (hFile == 0xffffffff)
004217d8              esi_3[1].b |= 0x40
004217bf          else
004217c2              enum FILE_TYPE eax_15 = GetFileType(hFile)
004217c2              
004217ca              if (eax_15 == FILE_TYPE_UNKNOWN)
004217d8                  esi_3[1].b |= 0x40
004217ca              else
004217cc                  int32_t eax_16 = eax_15 & 0xff
004217d1                  *esi_3 = hFile
004217d1                  
004217d6                  if (eax_16 == 2)
004217d8                      esi_3[1].b |= 0x40
004217d6                  else if (eax_16 == 3)
004217e3                      esi_3[1].b |= 8
004217e3  
00421803  return SetHandleCount(uNumber: data_2823980)


00421804    BOOL __convention("regparm") sub_421804(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)

00421807  int32_t var_8 = arg3
00421808  int32_t arg_4
00421808  int32_t eax = arg_4
00421814  uint32_t eax_1
00421814  
00421814  if (eax + 1 u> 0x100)
0042182b      char ecx_3 = (eax s>> 8).b
00421837      int32_t __saved_esi_1
00421837      
00421837      if ((*(&(*data_42f5f4)[zx.d(ecx_3)] + 1) & 0x80) == 0)
00421847          var_8:1.b = 0
0042184b          var_8.b = eax.b
0042184e          __saved_esi_1 = 1
00421837      else
00421839          var_8:2.b = 0
0042183d          var_8.b = ecx_3
00421840          var_8:1.b = eax.b
00421843          __saved_esi_1 = 2
00421843      
00421862      BOOL result = sub_426109(1, &var_8, __saved_esi_1, &arg_4:2, 0, 0, 1)
00421862      
0042186c      if (result == 0)
0042186f          return result
0042186f      
00421870      eax_1 = zx.d(arg_4:2.w)
00421814  else
0042181c      eax_1 = zx.d((*data_42f5f4)[eax])
0042181c  
00421878  return eax_1 & arg4

00421879                                                                             cc cc cc cc cc cc cc                           .......

00421880    int32_t __stdcall __allmul(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) __pure

0042188e  if ((arg4 | arg2) == 0)
00421896      return arg1 * arg3
00421896  
004218ac  int32_t result
004218ac  int32_t edx
004218ac  edx:result = mulu.dp.d(arg1, arg3)
004218b1  return result


004218b4    int32_t sub_4218b4(int32_t arg1)

004218c1  enum HEAP_FLAGS flOptions
004218c1  flOptions.b = arg1 == 0
004218c5  HANDLE eax = HeapCreate(flOptions, dwInitialSize: 0x1000, dwMaximumSize: 0)
004218cd  data_2823868 = eax
004218cd  
004218d2  if (eax != 0)
004218db      if (sub_42198f() != 0)
004218ef          return 1
004218ef      
004218e3      HeapDestroy(hHeap: data_2823868)
004218e3  
004218eb  return 0


004218f0    int32_t sub_4218f0()

004218fd  InitializeCriticalSection(lpCriticalSection: data_42f858)
00421905  InitializeCriticalSection(lpCriticalSection: data_42f848)
0042190d  InitializeCriticalSection(lpCriticalSection: data_42f838)
00421918  return InitializeCriticalSection(lpCriticalSection: data_42f818)


00421919    int32_t sub_421919(int32_t arg1)

0042192f  if (*((arg1 << 2) + &data_42f814) == 0)
00421934      void* lpCriticalSection = sub_41e583(0x18)
00421934      
0042193e      if (lpCriticalSection == 0)
00421942          sub_41f9c5(0x11)
00421942      
0042194a      sub_421919(0x11)
0042194a      
00421954      if (*((arg1 << 2) + &data_42f814) != 0)
00421960          sub_41e29e(lpCriticalSection)
00421954      else
00421956          InitializeCriticalSection(lpCriticalSection)
0042195c          *((arg1 << 2) + &data_42f814) = lpCriticalSection
0042195c      
00421968      sub_42197a(0x11)
00421968  
00421979  return EnterCriticalSection(lpCriticalSection: *((arg1 << 2) + &data_42f814))


0042197a    int32_t sub_42197a(int32_t arg1)

0042198e  return LeaveCriticalSection(lpCriticalSection: *((arg1 << 2) + &data_42f814))


0042198f    int32_t sub_42198f()

0042199c  int32_t result = HeapAlloc(hHeap: data_2823868, dwFlags: HEAP_NONE, dwBytes: 0x140)
004219a4  data_2823864 = result
004219a4  
004219a9  if (result == 0)
004219ab      return result
004219ab  
004219ac  data_282385c = 0
004219b3  data_2823860 = 0
004219bc  data_2823858 = result
004219c1  data_2823850 = 0x10
004219cc  return 1


004219cd    void* sub_4219cd(int32_t arg1)

004219d5  void* result = data_2823864
004219da  void* ecx_1 = result + data_2823860 * 0x14
004219da  
004219df  while (true)
004219df      if (result u>= ecx_1)
004219f5          return nullptr
004219f5      
004219ee      if (arg1 - *(result + 0xc) u< 0x100000)
004219ee          break
004219ee      
004219f0      result += 0x14
004219f0  
004219f7  return result


004219f8    int32_t* sub_4219f8(int32_t* arg1, void* arg2)

00421a06  int32_t eax = arg1[4]
00421a11  void* edx_1 = arg2 - 4
00421a15  uint32_t esi_2 = (arg2 - arg1[3]) u>> 0xf
00421a1a  int32_t edi = *(edx_1 - 4)
00421a23  int32_t* ebx_1 = *(arg2 - 4) - 1
00421a2e  int32_t* var_10 = ebx_1
00421a34  int32_t ecx_4 = *(ebx_1 + edx_1)
00421a34  
00421a3d  if ((ecx_4.b & 1) == 0)
00421a46      arg2 = (ecx_4 s>> 4) - 1
00421a46      
00421a4b      if ((ecx_4 s>> 4) - 1 u> 0x3f)
00421a4d          arg2 = 0x3f
00421a4d      
00421a58      if (*(ebx_1 + edx_1 + 4) == *(ebx_1 + edx_1 + 8))
00421a60          if (arg2 u>= 0x20)
00421a8f              uint32_t edi_4 = not.d(0x80000000 u>> (arg2.b - 0x20))
00421a91              *(eax + (esi_2 << 2) + 0xc4) &= edi_4
00421a98              char temp0_1 = *(arg2 + eax + 4)
00421a98              *(arg2 + eax + 4) -= 1
00421a98              
00421a9a              if (temp0_1 == 1)
00421a9f                  arg1[1] &= edi_4
00421a60          else
00421a6d              uint32_t edi_2 = not.d(0x80000000 u>> arg2.b)
00421a6f              *(eax + (esi_2 << 2) + 0x44) &= edi_2
00421a73              char temp1_1 = *(arg2 + eax + 4)
00421a73              *(arg2 + eax + 4) -= 1
00421a73              
00421a75              if (temp1_1 == 1)
00421a7a                  *arg1 &= edi_2
00421a7a      
00421aaa      *(*(ebx_1 + edx_1 + 8) + 4) = *(ebx_1 + edx_1 + 4)
00421aad      void* ecx_16 = *(ebx_1 + edx_1 + 4)
00421ab1      int32_t edi_6 = *(ebx_1 + edx_1 + 8)
00421ab5      ebx_1 += ecx_4
00421ab8      *(ecx_16 + 8) = edi_6
00421abb      var_10 = ebx_1
00421abb  
00421ac3  int32_t edi_9 = (ebx_1 s>> 4) - 1
00421ac3  
00421ac7  if (edi_9 u> 0x3f)
00421acb      edi_9 = 0x3f
00421acb  
00421acf  int32_t ecx_18 = edi & 1
00421acf  
00421ad5  if (ecx_18 == 0)
00421adb      void* edx_2 = edx_1 - edi
00421ae9      void* ecx_21 = (edi s>> 4) - 1
00421aed      arg2 = ecx_21
00421aed      
00421af0      if (ecx_21 u> 0x3f)
00421af2          arg2 = 0x3f
00421af5          ecx_21 = 0x3f
00421af5      
00421af7      ebx_1 += edi
00421afc      var_10 = ebx_1
00421b02      edi_9 = (ebx_1 s>> 4) - 1
00421b02      
00421b05      if (edi_9 u> 0x3f)
00421b07          edi_9 = 0x3f
00421b07      
00421b0b      if (ecx_21 != edi_9)
00421b16          if (*(edx_2 + 4) == *(edx_2 + 8))
00421b1e              if (arg2 u>= 0x20)
00421b4d                  uint32_t edx_7 = not.d(0x80000000 u>> (arg2.b - 0x20))
00421b4f                  *(eax + (esi_2 << 2) + 0xc4) &= edx_7
00421b56                  char temp3_1 = *(arg2 + eax + 4)
00421b56                  *(arg2 + eax + 4) -= 1
00421b56                  
00421b58                  if (temp3_1 == 1)
00421b5d                      arg1[1] &= edx_7
00421b1e              else
00421b2b                  uint32_t edx_5 = not.d(0x80000000 u>> arg2.b)
00421b2d                  *(eax + (esi_2 << 2) + 0x44) &= edx_5
00421b31                  char temp4_1 = *(arg2 + eax + 4)
00421b31                  *(arg2 + eax + 4) -= 1
00421b31                  
00421b33                  if (temp4_1 == 1)
00421b38                      *arg1 &= edx_5
00421b38          
00421b69          *(*(edx_2 + 8) + 4) = *(edx_2 + 4)
00421b75          *(*(edx_2 + 4) + 8) = *(edx_2 + 8)
00421b75      
00421b78      edx_1 = edx_2
00421b78  
00421b84  if (ecx_18 != 0 || arg2 != edi_9)
00421b93      *(edx_1 + 4) = (esi_2 * 0x204 + eax + 0x144)[edi_9 * 2 + 1]
00421b99      void* ecx_38 = &(esi_2 * 0x204 + eax + 0x144)[edi_9 * 2]
00421b9c      *(edx_1 + 8) = ecx_38
00421b9f      *(ecx_38 + 4) = edx_1
00421ba5      *(*(edx_1 + 4) + 8) = edx_1
00421ba5      
00421bae      if (*(edx_1 + 4) == *(edx_1 + 8))
00421bb0          int32_t ecx_40
00421bb0          ecx_40.b = *(edi_9 + eax + 4)
00421bb7          arg2:3.b = ecx_40.b
00421bba          ecx_40.b += 1
00421bbc          *(edi_9 + eax + 4) = ecx_40.b
00421bbc          
00421bc0          if (edi_9 u>= 0x20)
00421beb              if (arg2:3.b == 0)
00421bfa                  arg1[1] |= 0x80000000 u>> (edi_9.b - 0x20)
00421bfa              
00421c0e              *(eax + (esi_2 << 2) + 0xc4) |= 0x80000000 u>> (edi_9.b - 0x20)
00421bc0          else
00421bc6              if (arg2:3.b == 0)
00421bd4                  *arg1 |= 0x80000000 u>> edi_9.b
00421bd4              
00421be3              *(eax + (esi_2 << 2) + 0x44) |= 0x80000000 u>> edi_9.b
00421be3          
00421c10          ebx_1 = var_10
00421c10  
00421c13  int32_t* result = esi_2 * 0x204 + eax + 0x144
00421c16  *edx_1 = ebx_1
00421c18  *(ebx_1 + edx_1 - 4) = ebx_1
00421c1c  int32_t temp2 = *result
00421c1c  *result -= 1
00421c1c  
00421c1e  if (temp2 == 1)
00421c24      int32_t eax_3 = data_282385c
00421c2b      void* eax_9
00421c2b      
00421c2b      if (eax_3 != 0)
00421c4f          VirtualFree(lpAddress: (data_2823854 << 0xf) + *(eax_3 + 0xc), dwSize: 0x8000, 
00421c4f              dwFreeType: MEM_DECOMMIT)
00421c57          void* eax_4 = data_282385c
00421c63          *(eax_4 + 8) |= 0x80000000 u>> (data_2823854).b
00421c74          *(*(data_282385c + 0x10) + (data_2823854 << 2) + 0xc4) = 0
00421c81          void* eax_8 = *(data_282385c + 0x10)
00421c84          *(eax_8 + 0x43) -= 1
00421c87          eax_9 = data_282385c
00421c87          
00421c93          if (*(*(eax_9 + 0x10) + 0x43) == 0)
00421c95              *(eax_9 + 4) &= 0xfffffffe
00421c99              eax_9 = data_282385c
00421c99      
00421ca2      if (eax_3 == 0 || *(eax_9 + 8) != 0xffffffff)
00421d10          result = arg1
00421ca2      else
00421caa          VirtualFree(lpAddress: *(eax_9 + 0xc), dwSize: 0, dwFreeType: MEM_RELEASE)
00421cbc          HeapFree(hHeap: data_2823868, dwFlags: HEAP_NONE, lpMem: *(data_282385c + 0x10))
00421cd5          char* eax_14 = data_282385c
00421ce6          sub_41f5a0(eax_14, &eax_14[0x14], 
00421ce6              data_2823860 * 0x14 - eax_14 + data_2823864 - 0x14)
00421ceb          result = arg1
00421cf1          data_2823860 -= 1
00421cf1          
00421cfd          if (result u> data_282385c)
00421cff              result -= 0x14
00421cff          
00421d08          data_2823858 = data_2823864
00421d08      
00421d13      data_282385c = result
00421d18      data_2823854 = esi_2
00421d18  
00421d22  return result


00421d23    void* sub_421d23(int32_t* arg1)

00421d2e  int32_t* edx = data_2823864
00421d3a  void* edi = &edx[data_2823860 * 5]
00421d46  void* ecx_1 = (arg1 + 0x17) & 0xfffffff0
00421d53  uint32_t var_10
00421d53  uint32_t var_c
00421d53  uint32_t esi
00421d53  
00421d53  if ((ecx_1 s>> 4) - 1 s>= 0x20)
00421d69      esi = 0
00421d6d      var_10 = 0
00421d70      var_c = 0xffffffff u>> (((ecx_1 s>> 4) - 1).b - 0x20)
00421d53  else
00421d58      esi = 0xffffffff u>> ((ecx_1 s>> 4) - 1).b
00421d5a      var_c = 0xffffffff
00421d5e      var_10 = esi
00421d5e  
00421d73  int32_t* eax_4 = data_2823858
00421d78  int32_t* ebx = eax_4
00421d7c  arg1 = ebx
00421d7c  
00421d7f  if (ebx u< edi)
00421d8d      while (((ebx[1] & var_c) | (*ebx & esi)) == 0)
00421d8f          ebx = &ebx[5]
00421d95          arg1 = ebx
00421d95          
00421d98          if (ebx u>= edi)
00421d98              break
00421d98  
00421d9d  if (ebx == edi)
00421d9f      ebx = edx
00421da1      bool cond:4_1
00421da1      
00421da1      while (true)
00421da1          cond:4_1 = ebx != eax_4
00421da3          arg1 = ebx
00421da3          
00421da6          if (ebx u>= eax_4)
00421da6              break
00421da6          
00421db4          if (((ebx[1] & var_c) | (*ebx & esi)) != 0)
00421dbb              cond:4_1 = ebx != eax_4
00421dbb              break
00421dbb          
00421db6          ebx = &ebx[5]
00421db6      
00421dbd      if (not(cond:4_1))
00421dbf          bool cond:5_1
00421dbf          
00421dbf          while (true)
00421dbf              cond:5_1 = ebx != edi
00421dbf              
00421dc2              if (ebx u>= edi)
00421dc2                  break
00421dc2              
00421dc8              if (ebx[2] != 0)
00421dd2                  cond:5_1 = ebx != edi
00421dd2                  break
00421dd2              
00421dca              ebx = &ebx[5]
00421dcd              arg1 = ebx
00421dcd          
00421dd5          if (not(cond:5_1))
00421dd7              ebx = edx
00421dd9              bool cond:7_1
00421dd9              
00421dd9              while (true)
00421dd9                  cond:7_1 = ebx != eax_4
00421ddb                  arg1 = ebx
00421ddb                  
00421dde                  if (ebx u>= eax_4)
00421dde                      break
00421dde                  
00421de4                  if (ebx[2] != 0)
00421deb                      cond:7_1 = ebx != eax_4
00421deb                      break
00421deb                  
00421de6                  ebx = &ebx[5]
00421de6              
00421ded              if (not(cond:7_1))
00421df4                  ebx = sub_42202c()
00421df8                  arg1 = ebx
00421df8                  
00421dfb                  if (ebx == 0)
00421e11                      return nullptr
00421e11          
00421e07          *ebx[4] = sub_4220dd(ebx)
00421e07          
00421e0f          if (*ebx[4] == 0xffffffff)
00421e11              return nullptr
00421e11  
00421e18  data_2823858 = ebx
00421e1e  int32_t* eax_8 = ebx[4]
00421e21  int32_t edx_1 = *eax_8
00421e26  int32_t var_8_1 = edx_1
00421e26  
00421e3d  if (edx_1 == 0xffffffff
00421e3d          || ((eax_8[edx_1 + 0x31] & var_c) | (eax_8[edx_1 + 0x11] & esi)) == 0)
00421e4e      var_8_1 = 0
00421e52      void* ecx_15 = &eax_8[0x11]
00421e57      esi = var_10
00421e57      
00421e5a      if (((eax_8[0x31] & var_c) | (eax_8[0x11] & var_10)) == 0)
00421e71          int32_t edx_6
00421e71          
00421e71          do
00421e62              var_8_1 += 1
00421e65              edx_6 = *(ecx_15 + 0x84) & var_c
00421e68              ecx_15 += 4
00421e71          while ((edx_6 | (esi & *ecx_15)) == 0)
00421e71      
00421e73      edx_1 = var_8_1
00421e73  
00421e78  int32_t edi_9 = 0
00421e8e  int32_t i = eax_8[edx_1 + 0x11] & esi
00421e8e  
00421e90  if (i == 0)
00421e9b      i = eax_8[edx_1 + 0x31] & var_c
00421e9e      edi_9 = 0x20
00421e9e  
00421ea1  while (i s>= 0)
00421ea3      i <<= 1
00421ea5      edi_9 += 1
00421ea5  
00421eab  int32_t* edx_8 = eax_8[edx_1 * 0x81 + 0x51 + edi_9 * 2 + 1]
00421eb1  void* ecx_23 = *edx_8 - ecx_1
00421ebc  int32_t esi_5 = (ecx_23 s>> 4) - 1
00421ebc  
00421ec0  if (esi_5 s> 0x3f)
00421ec4      esi_5 = 0x3f
00421ec4  
00421ec7  if (esi_5 == edi_9)
00421fda      label_421fda:
00421fda      
00421fdc      if (ecx_23 != 0)
00421fde          *edx_8 = ecx_23
00421fe0          *(ecx_23 + edx_8 - 4) = ecx_23
00421ec7  else
00421ed3      if (edx_8[1] == edx_8[2])
00421ed8          if (edi_9 s>= 0x20)
00421f1d              uint32_t ebx_5 = not.d(0x80000000 u>> (edi_9.b - 0x20))
00421f1f              eax_8[var_8_1 + 0x31] &= ebx_5
00421f21              char temp1_1 = *(eax_8 + edi_9 + 4)
00421f21              *(eax_8 + edi_9 + 4) -= 1
00421f21              
00421f26              if (temp1_1 != 1)
00421f33                  ebx = arg1
00421f26              else
00421f28                  ebx = arg1
00421f2e                  ebx[1] &= ebx_5
00421ed8          else
00421eea              uint32_t ebx_2 = not.d(0x80000000 u>> edi_9.b)
00421ef3              eax_8[var_8_1 + 0x11] &= ebx_2
00421ef7              char temp2_1 = *(eax_8 + edi_9 + 4)
00421ef7              *(eax_8 + edi_9 + 4) -= 1
00421ef7              
00421ef9              if (temp2_1 != 1)
00421f33                  ebx = arg1
00421ef9              else
00421efb                  ebx = arg1
00421f01                  *ebx &= ebx_2
00421f01      
00421f40      *(edx_8[2] + 4) = edx_8[1]
00421f49      *(edx_8[1] + 8) = edx_8[2]
00421f49      
00421f4c      if (ecx_23 != 0)
00421f59          void* ecx_35 = &eax_8[edx_1 * 0x81 + 0x51 + esi_5 * 2]
00421f5c          edx_8[1] = eax_8[edx_1 * 0x81 + 0x51 + esi_5 * 2 + 1]
00421f5f          edx_8[2] = ecx_35
00421f62          *(ecx_35 + 4) = edx_8
00421f68          *(edx_8[1] + 8) = edx_8
00421f68          
00421f71          if (edx_8[1] == edx_8[2])
00421f73              int32_t ecx_37
00421f73              ecx_37.b = *(esi_5 + eax_8 + 4)
00421f7a              arg1:3.b = ecx_37.b
00421f7a              
00421f7d              if (esi_5 s>= 0x20)
00421fa8                  ecx_37.b += 1
00421fae                  *(esi_5 + eax_8 + 4) = ecx_37.b
00421fae                  
00421fb2                  if (arg1:3.b == 0)
00421fbe                      ebx[1] |= 0x80000000 u>> (esi_5.b - 0x20)
00421fbe                  
00421fd5                  eax_8[var_8_1 + 0x31] |= 0x80000000 u>> (esi_5.b - 0x20)
00421f7d              else
00421f7f                  ecx_37.b += 1
00421f85                  *(esi_5 + eax_8 + 4) = ecx_37.b
00421f85                  
00421f89                  if (arg1:3.b == 0)
00421f94                      *ebx |= 0x80000000 u>> esi_5.b
00421f94                  
00421fa2                  eax_8[var_8_1 + 0x11] |= 0x80000000 u>> esi_5.b
00421fa2          
00421f71          goto label_421fda
00421f71  
00421fec  void** edx_9 = edx_8 + ecx_23
00421ff1  *edx_9 = ecx_1 + 1
00421ff3  *(edx_9 + ecx_1 - 4) = ecx_1 + 1
00421ffa  int32_t ecx_45 = eax_8[edx_1 * 0x81 + 0x51]
00422001  eax_8[edx_1 * 0x81 + 0x51] = ecx_45 + 1
00422001  
00422016  if (ecx_45 == 0 && ebx == data_282385c && var_8_1 == data_2823854)
00422018      data_282385c = 0
00422018  
00422022  *eax_8 = var_8_1
00422024  return &edx_9[1]


0042202c    int32_t* sub_42202c()

0042202c  int32_t eax_3 = data_2823860
00422031  int32_t ecx = data_2823850
00422031  
0042203d  if (eax_3 != ecx)
0042203d      goto label_422085
0042203d  
00422054  int32_t eax_2 = HeapReAlloc(hHeap: data_2823868, dwFlags: HEAP_NONE, lpMem: data_2823864, 
00422054      dwBytes: (ecx * 5 + 0x50) << 2)
00422054  
0042205c  if (eax_2 != 0)
0042205e      data_2823850 += 0x10
00422065      data_2823864 = eax_2
0042206a      eax_3 = data_2823860
00422085      label_422085:
00422085      int32_t* result = data_2823864 + eax_3 * 0x14
00422088      int32_t eax_5 =
00422088          HeapAlloc(hHeap: data_2823868, dwFlags: HEAP_ZERO_MEMORY, dwBytes: 0x41c4)
00422090      result[4] = eax_5
00422090      
00422093      if (eax_5 != 0)
004220a2          int32_t eax_6 = VirtualAlloc(lpAddress: nullptr, dwSize: 0x100000, 
004220a2              flAllocationType: MEM_RESERVE, flProtect: PAGE_READWRITE)
004220aa          result[3] = eax_6
004220aa          
004220ad          if (eax_6 != 0)
004220c3              result[2] = 0xffffffff
004220c7              *result = 0
004220c9              result[1] = 0
004220cc              data_2823860 += 1
004220d5              *result[4] = 0xffffffff
004220d8              return result
004220d8          
004220b9          HeapFree(hHeap: data_2823868, dwFlags: HEAP_NONE, lpMem: result[4])
004220b9  
004220bf  return nullptr


004220dd    int32_t sub_4220dd(void* arg1)

004220e0  int32_t ecx
004220e0  int32_t var_8 = ecx
004220e7  void* esi = *(arg1 + 0x10)
004220ea  int32_t i = *(arg1 + 8)
004220ed  int32_t result = 0
004220ed  
004220f1  while (i s>= 0)
004220f3      i <<= 1
004220f5      result += 1
004220f5  
00422102  int32_t i_2 = 0x3f
00422103  void* eax_2 = result * 0x204 + esi + 0x144
0042210a  void* var_8_1 = eax_2
00422117  int32_t i_1
00422117  
00422117  do
0042210d      *(eax_2 + 8) = eax_2
00422110      *(eax_2 + 4) = eax_2
00422113      eax_2 += 8
00422116      i_1 = i_2
00422116      i_2 -= 1
00422117  while (i_1 != 1)
00422120  void* lpAddress = (result << 0xf) + *(arg1 + 0xc)
00422120  
00422136  if (VirtualAlloc(lpAddress, dwSize: 0x8000, flAllocationType: MEM_COMMIT, 
00422136          flProtect: PAGE_READWRITE) == 0)
00422138      return 0xffffffff
00422138  
00422148  if (lpAddress u<= lpAddress + 0x7000)
0042214a      void** eax_5 = lpAddress + 0x10
0042214a      
00422184      do
0042214d          eax_5[-2] = 0xffffffff
00422151          eax_5[0x3fb] = 0xffffffff
0042215e          eax_5[-1] = 0xff0
00422165          *eax_5 = &eax_5[0x3ff]
0042216d          eax_5[1] = &eax_5[-0x401]
00422170          eax_5[0x3fa] = 0xff0
0042217a          eax_5 = &eax_5[0x400]
00422184      while (&eax_5[-4] u<= lpAddress + 0x7000)
00422184  
00422194  *(var_8_1 + 0x1fc) = lpAddress + 0xc
00422197  *(lpAddress + 0x14) = var_8_1 + 0x1f8
0042219d  *(var_8_1 + 0x200) = lpAddress + 0x700c
004221a0  *(lpAddress + 0x7010) = var_8_1 + 0x1f8
004221a3  *(esi + (result << 2) + 0x44) = 0
004221a8  *(esi + (result << 2) + 0xc4) = 1
004221af  void* eax_7
004221af  eax_7.b = *(esi + 0x43)
004221b2  void* ecx_6
004221b2  ecx_6.b = eax_7.b
004221b4  ecx_6.b += 1
004221bb  *(esi + 0x43) = ecx_6.b
004221bb  
004221be  if (eax_7.b == 0)
004221c0      *(arg1 + 4) |= 1
004221c0  
004221ce  *(arg1 + 8) &= not.d(0x80000000 u>> result.b)
004221d1  return result


004221d8    int32_t sub_4221d8(int32_t* arg1, void** arg2, void* arg3)

004221f2  int32_t eax_1 = arg1[4]
004221f5  void* esi_1 = (arg3 + 0x17) & 0xfffffff0
004221f8  uint32_t edx_2 = (arg2 - arg1[3]) u>> 0xf
00422210  void* ecx_5 = arg2[-1] - 1
00422216  void* ebx = *(ecx_5 + arg2 - 4)
0042221a  void* edi_1 = ecx_5 + arg2 - 4
0042221a  
00422221  if (esi_1 s> ecx_5)
00422234      if ((ebx.b & 1) != 0 || esi_1 s> ebx + ecx_5)
0042237f          return 0
0042237f      
00422240      int32_t ecx_8 = (ebx s>> 4) - 1
00422244      int32_t var_c_1 = ecx_8
00422244      
00422247      if (ecx_8 u> 0x3f)
0042224b          ecx_8 = 0x3f
0042224c          var_c_1 = 0x3f
0042224c      
00422255      if (*(edi_1 + 4) == *(edi_1 + 8))
0042225a          if (ecx_8 u>= 0x20)
0042228c              uint32_t ebx_6 = not.d(0x80000000 u>> (ecx_8.b - 0x20))
0042228e              *(eax_1 + (edx_2 << 2) + 0xc4) &= ebx_6
00422295              char temp0_1 = *(var_c_1 + eax_1 + 4)
00422295              *(var_c_1 + eax_1 + 4) -= 1
00422295              
00422297              if (temp0_1 == 1)
0042229c                  arg1[1] &= ebx_6
0042225a          else
0042226a              uint32_t ebx_4 = not.d(0x80000000 u>> ecx_8.b)
0042226c              *(eax_1 + (edx_2 << 2) + 0x44) &= ebx_4
00422270              char temp1_1 = *(var_c_1 + eax_1 + 4)
00422270              *(var_c_1 + eax_1 + 4) -= 1
00422270              
00422272              if (temp1_1 == 1)
00422277                  *arg1 &= ebx_4
00422277      
004222a5      *(*(edi_1 + 8) + 4) = *(edi_1 + 4)
004222ae      *(*(edi_1 + 4) + 8) = *(edi_1 + 8)
004222b6      void* var_8_1 = ebx + ecx_5 - esi_1
004222bd      void** edx_4
004222bd      
004222bd      if (var_8_1 s<= 0)
0042236d          edx_4 = arg2
004222bd      else
004222cc          int32_t edi_5 = (var_8_1 s>> 4) - 1
004222cc          
004222d4          if (edi_5 u> 0x3f)
004222d8              edi_5 = 0x3f
004222d8          
004222dc          void* ebx_9 = edx_2 * 0x204 + eax_1 + 0x144 + (edi_5 << 3)
004222e5          *(arg2 + esi_1) = *(ebx_9 + 4)
004222eb          *(arg2 + esi_1 + 4) = ebx_9
004222ee          *(ebx_9 + 4) = arg2 + esi_1 - 4
004222f4          *(*(arg2 + esi_1) + 8) = arg2 + esi_1 - 4
004222f4          
004222fd          if (*(arg2 + esi_1) == *(arg2 + esi_1 + 4))
004222ff              void* ecx_21
004222ff              ecx_21.b = *(edi_5 + eax_1 + 4)
00422306              arg3:3.b = ecx_21.b
00422309              ecx_21.b += 1
0042230b              *(edi_5 + eax_1 + 4) = ecx_21.b
0042230f              int32_t* eax_2
0042230f              char ecx_24
0042230f              
0042230f              if (edi_5 u>= 0x20)
00422336                  if (arg3:3.b == 0)
00422345                      arg1[1] |= 0x80000000 u>> (edi_5.b - 0x20)
00422345                  
00422348                  eax_2 = eax_1 + (edx_2 << 2) + 0xc4
0042234f                  ecx_24 = edi_5.b - 0x20
0042230f              else
00422315                  if (arg3:3.b == 0)
00422323                      *arg1 |= 0x80000000 u>> edi_5.b
00422323                  
00422325                  eax_2 = eax_1 + (edx_2 << 2) + 0x44
0042232e                  ecx_24 = edi_5.b
0042232e              
00422359              *eax_2 |= 0x80000000 u>> ecx_24
00422359          
0042235b          edx_4 = arg2
00422365          *(edx_4 + esi_1 - 4) = var_8_1
00422367          *(var_8_1 + edx_4 + esi_1 - 4 - 4) = var_8_1
00422367      
00422373      edx_4[-1] = esi_1 + 1
00422376      *(edx_4 + esi_1 - 8) = esi_1 + 1
00422221  else if (esi_1 s< ecx_5)
0042238f      arg3 = ecx_5 - esi_1
00422395      arg2[-1] = esi_1 + 1
00422398      void** ebx_17 = arg2 + esi_1 - 4
004223a5      int32_t esi_4 = (arg3 s>> 4) - 1
004223a6      ebx_17[-1] = esi_1 + 1
004223a6      
004223ac      if (esi_4 u> 0x3f)
004223b0          esi_4 = 0x3f
004223b0      
004223b5      if ((ebx.b & 1) == 0)
004223c1          int32_t esi_7 = (ebx s>> 4) - 1
004223c1          
004223c5          if (esi_7 u> 0x3f)
004223c9              esi_7 = 0x3f
004223c9          
004223d0          if (*(edi_1 + 4) == *(edi_1 + 8))
004223d5              if (esi_7 u>= 0x20)
00422403                  uint32_t ebx_21 = not.d(0x80000000 u>> (esi_7.b - 0x20))
00422405                  *(eax_1 + (edx_2 << 2) + 0xc4) &= ebx_21
0042240c                  char temp2_1 = *(esi_7 + eax_1 + 4)
0042240c                  *(esi_7 + eax_1 + 4) -= 1
0042240c                  
0042240e                  if (temp2_1 == 1)
00422413                      arg1[1] &= ebx_21
004223d5              else
004223e4                  uint32_t ebx_19 = not.d(0x80000000 u>> esi_7.b)
004223e6                  *(eax_1 + (edx_2 << 2) + 0x44) &= ebx_19
004223ea                  char temp3_1 = *(esi_7 + eax_1 + 4)
004223ea                  *(esi_7 + eax_1 + 4) -= 1
004223ea                  
004223ec                  if (temp3_1 == 1)
004223f1                      *arg1 &= ebx_19
004223f1          
0042241f          *(*(edi_1 + 8) + 4) = *(edi_1 + 4)
00422428          *(*(edi_1 + 4) + 8) = *(edi_1 + 8)
0042242e          void* esi_12 = arg3 + ebx
00422431          arg3 = esi_12
00422437          esi_4 = (esi_12 s>> 4) - 1
00422437          
0042243b          if (esi_4 u> 0x3f)
0042243f              esi_4 = 0x3f
0042243f      
00422447      void* ecx_38 = edx_2 * 0x204 + eax_1 + 0x144 + (esi_4 << 3)
0042244a      ebx_17[1] = *(edx_2 * 0x204 + eax_1 + 0x144 + (esi_4 << 3) + 4)
0042244d      ebx_17[2] = ecx_38
00422450      *(ecx_38 + 4) = ebx_17
00422456      *(ebx_17[1] + 8) = ebx_17
00422456      
0042245f      if (ebx_17[1] == ebx_17[2])
00422461          int32_t ecx_40
00422461          ecx_40.b = *(esi_4 + eax_1 + 4)
00422468          arg2:3.b = ecx_40.b
0042246b          ecx_40.b += 1
0042246d          *(esi_4 + eax_1 + 4) = ecx_40.b
00422471          int32_t* eax_6
00422471          char ecx_43
00422471          
00422471          if (esi_4 u>= 0x20)
00422498              if (arg2:3.b == 0)
004224a7                  arg1[1] |= 0x80000000 u>> (esi_4.b - 0x20)
004224a7              
004224aa              eax_6 = eax_1 + (edx_2 << 2) + 0xc4
004224b1              ecx_43 = esi_4.b - 0x20
00422471          else
00422477              if (arg2:3.b == 0)
00422485                  *arg1 |= 0x80000000 u>> esi_4.b
00422485              
00422487              eax_6 = eax_1 + (edx_2 << 2) + 0x44
00422490              ecx_43 = esi_4.b
00422490          
004224bb          *eax_6 |= 0x80000000 u>> ecx_43
004224bb      
004224c0      *ebx_17 = arg3
004224c2      *(arg3 + ebx_17 - 4) = arg3
004224c2  
004224c8  return 1


004224ce    int32_t* sub_4224ce(int32_t* arg1, void* arg2)

004224e3  int32_t edi = 0
004224ea  void var_1c
004224ea  char* var_8
004224ea  char eax = sub_426252(&var_1c, &var_8, arg2, 0, 0, 0, 0)
004224f7  int32_t var_10
004224f7  
004224f7  if ((eax & 4) == 0)
0042250e      int32_t eax_1 = sub_4255bc(&var_1c, &var_10)
0042250e      
0042251d      if ((eax & 2) != 0 || eax_1 == 1)
0042251f          edi = 0x80
0042251f      
0042252c      if ((eax & 1) != 0 || eax_1 == 2)
0042252e          edi |= 0x100
004224f7  else
004224f9      edi = 0x200
004224fe      var_10 = 0
00422501      int32_t var_c_1 = 0
00422501  
0042253a  void* ecx_3 = var_8 - arg2
0042253d  long double x87_r7 = fconvert.t(var_10.q)
00422540  *arg1 = edi
00422543  *(arg1 + 0x10) = fconvert.d(x87_r7)
00422547  arg1[1] = ecx_3
0042254c  return arg1

0042254d                                         cc cc cc                                                               ...

00422550    void* sub_422550(char* arg1)

00422550  char* ecx = arg1
00422550  
0042255a  while ((ecx & 3) != 0)
0042255c      int32_t eax
0042255c      eax.b = *ecx
0042255e      ecx = &ecx[1]
0042255e      
00422561      if (eax.b == 0)
004225ac          return &ecx[0xffffffff] - arg1
004225ac  
00422570  while (true)
00422570      int32_t eax_2 = *ecx
0042257e      ecx = &ecx[4]
0042257e      
00422586      if (((eax_2 ^ 0xffffffff ^ (0x7efefeff + eax_2)) & 0x81010100) != 0)
00422588          int32_t eax_5 = *(ecx - 4)
00422588          
0042258d          if (eax_5.b == 0)
004225ca              return &ecx[0xfffffffc] - arg1
004225ca          
00422591          if (eax_5:1.b == 0)
004225c0              return &ecx[0xfffffffd] - arg1
004225c0          
00422598          if ((eax_5 & 0xff0000) == 0)
004225b6              return &ecx[0xfffffffe] - arg1
004225b6          
0042259f          if ((eax_5 & 0xff000000) == 0)
0042259f              break
0042259f  
004225ac  return &ecx[0xffffffff] - arg1


004225cb    int32_t sub_4225cb(int32_t* arg1, char* arg2, void* arg3)

004225d4  char var_19 = 0
004225da  char* esi = arg2
004225e0  void* eax
004225e0  eax.b = *esi
004225e2  void* var_8 = nullptr
004225e7  int32_t result = 0
004225ea  void* var_18
004225ea  
004225ea  if (eax.b != 0)
004225f0      int32_t* edi_1 = arg1
004225f0      
00422601      while (true)
00422601          BOOL eax_2
00422601          uint32_t ecx
00422601          int32_t edx
00422601          
00422601          if (data_42f800 s<= 1)
00422612              ecx = data_42f5f4
0042261b              uint32_t eax_3
0042261b              eax_3.b = *(ecx + (zx.d(eax.b) << 1))
0042261e              eax_2 = eax_3 & 8
00422601          else
00422603              uint32_t eax_1 = zx.d(eax.b)
00422609              eax_2, edx = sub_421804(eax_1, edx, ecx, eax_1)
0042260f              ecx = 8
0042260f          
00422623          if (eax_2 != 0)
00422625              var_8 -= 1
00422636              sub_423041(sub_423058(&var_8, edi_1), edi_1)
0042263b              uint32_t eax_5 = zx.d(esi[1])
0042263f              esi = &esi[1]
00422641              BOOL i
00422641              i, ecx, edx = sub_426849(eax_5)
00422641              
0042264b              while (i != 0)
0042264d                  uint32_t eax_6 = zx.d(esi[1])
00422651                  esi = &esi[1]
00422653                  i, edx = sub_426849(eax_6)
00422658                  ecx = eax_6
00422658          
0042265e          if (*esi != 0x25)
00422f3d              var_8 += 1
00422f41              uint32_t eax_58
00422f41              eax_58, edx = sub_423027(edi_1)
00422f49              uint32_t eax_59 = zx.d(*esi)
00422f4c              esi = &esi[1]
00422f4f              var_18 = eax_58
00422f52              arg2 = esi
00422f52              
00422f55              if (eax_59 != eax_58)
00422fac                  var_8 -= 1
00422fb1                  sub_423041(eax_58, edi_1)
00422fb8                  break
00422fb8              
00422f57              ecx = data_42f5f4
00422f57              
00422f65              if ((*(ecx + (zx.d(eax_58.b) << 1) + 1) & 0x80) != 0)
00422f67                  var_8 += 1
00422f6b                  eax, edx = sub_423027(edi_1)
00422f71                  ecx = zx.d(*esi)
00422f74                  esi = &esi[1]
00422f77                  arg2 = esi
00422f77                  
00422f7a                  if (ecx != eax)
00422fba                      var_8 -= 1
00422fbf                      sub_423041(eax, edi_1)
00422fc4                      var_8 -= 1
00422fc9                      sub_423041(eax_58, edi_1)
00422fce                      break
00422fce                  
00422f7c                  var_8 -= 1
0042265e          else
00422664              char var_39_1 = 0
00422668              char var_1c_1 = 0
0042266c              char var_1b_1 = 0
00422670              char var_12_1 = 0
00422674              char i_1 = 0
00422678              char var_1a_1 = 0
0042267c              void* edi_2 = nullptr
0042267e              char var_9_1 = 0
00422682              int32_t var_20_1 = 0
00422685              int32_t var_24_1 = 0
00422688              void* var_10_1 = nullptr
0042268b              char var_11_1 = 1
0042268f              int32_t var_34_1 = 0
0042273d              void* var_2c
0042273d              uint32_t var_28
0042273d              void* eax_8
0042273d              
0042273d              do
00422692                  uint32_t ebx_1 = zx.d(esi[1])
00422696                  esi = &esi[1]
00422696                  
0042269e                  if (data_42f800 s<= 1)
004226af                      ecx = data_42f5f4
004226b8                      uint32_t eax_9
004226b8                      eax_9.b = *(ecx + (zx.d(ebx_1.b) << 1))
004226bb                      eax_8 = eax_9 & 4
0042269e                  else
004226a0                      uint32_t eax_7 = zx.d(ebx_1.b)
004226a6                      eax_8, edx = sub_421804(eax_7, edx, ecx, eax_7)
004226ac                      ecx = 4
004226ac                  
004226c0                  if (eax_8 != 0)
004226c5                      var_24_1 += 1
004226cf                      var_10_1 = ebx_1 + var_10_1 * 0xa - 0x30
004226c0                  else if (ebx_1 s> 0x4e)
0042271a                      if (ebx_1 == 0x68)
00422733                          var_11_1 -= 1
00422736                          var_9_1 -= 1
0042271a                      else if (ebx_1 == 0x6c)
0042272b                          var_11_1 += 1
0042272e                          var_9_1 += 1
0042271f                      else if (ebx_1 == 0x77)
0042272e                          var_9_1 += 1
00422724                      else
00422726                          i_1 += 1
004226d7                  else if (ebx_1 != 0x4e)
004226de                      if (ebx_1 == 0x2a)
00422712                          var_12_1 += 1
004226de                      else if (ebx_1 != 0x46)
004226e8                          if (ebx_1 == 0x49)
00422701                              if (esi[1] != 0x36 || esi[2] != 0x34)
00422726                                  i_1 += 1
00422701                              else
00422703                                  var_34_1 += 1
00422706                                  var_2c = nullptr
0042270a                                  var_28 = 0
0042270e                                  esi = &esi[2]
004226e8                          else if (ebx_1 != 0x4c)
00422726                              i_1 += 1
004226ed                          else
004226ef                              var_11_1 += 1
0042273d              while (i_1 == 0)
0042273d              
00422747              arg2 = esi
0042274a              void* var_48
0042274a              void* var_30
0042274a              
0042274a              if (var_12_1 == 0)
0042274f                  var_48 = arg3
00422752                  void* eax_13 = arg3 + 4
00422755                  arg3 = eax_13
0042275b                  var_30 = *(eax_13 - 4)
0042275b              
0042275e              char var_13_1 = 0
0042275e              
00422766              if (var_9_1 == 0)
00422768                  eax_8.b = *esi
00422768                  
00422770                  if (eax_8.b == 0x53 || eax_8.b == 0x43)
00422778                      var_9_1 = 1
00422770                  else
00422772                      var_9_1 = 0xff
00422772              
00422782              int32_t esi_2 = zx.d(*arg2) | 0x20
00422782              
0042278b              if (esi_2 != 0x6e)
00422795                  int32_t* var_1d8_3
00422795                  uint32_t eax_14
00422795                  
00422795                  if (esi_2 == 0x63 || esi_2 == 0x7b)
004227a6                      var_1d8_3 = arg1
004227a9                      var_8 += 1
004227ac                      eax_14, edx = sub_423027(var_1d8_3)
00422795                  else
00422797                      var_1d8_3 = arg1
0042279e                      eax_14, edx = sub_423058(&var_8, var_1d8_3)
0042279e                  
004227b1                  ecx = var_1d8_3
004227b2                  var_18 = eax_14
004227b2              
004227b5              eax = nullptr
004227b5              
004227bf              if (var_24_1 != 0 && var_10_1 == 0)
00422fa1                  label_422fa1:
00422fa4                  var_8 -= 1
00422fb1                  sub_423041(var_18, arg1)
00422fb8                  break
00422fb8              
004227c8              void* ebx_3
004227c8              void* edi_4
004227c8              
004227c8              if (esi_2 s<= 0x6f)
004227ce                  if (esi_2 == 0x6f)
004227ce                      goto label_422cde
004227ce                  
004227d7                  if (esi_2 == 0x63)
00422a0c                      if (var_24_1 == 0)
00422a0e                          var_10_1 += 1
00422a11                          var_24_1 = 1
00422a11                      
00422a1c                      if (var_9_1 s> 0)
00422a1e                          var_1a_1 = 1
00422a1e                      
00422a22                      edi_4 = &data_42f8e8
00422a1c                      goto label_422b37
00422a1c                  
004227e0                  if (esi_2 == 0x64)
004227e0                      goto label_422cde
004227e0                  
004227e6                  if (esi_2 s> 0x64)
004227ef                      if (esi_2 s<= 0x67)
00422829                          void* ebx_4 = var_18
0042282c                          char var_1c8
0042282c                          char* esi_3 = &var_1c8
00422835                          int32_t* edi_3
00422835                          
00422835                          if (ebx_4 != 0x2d)
00422848                              if (ebx_4 == 0x2b)
00422848                                  goto label_42284a
00422848                              
00422861                              edi_3 = arg1
00422835                          else
00422837                              var_1c8 = ebx_4.b
0042283d                              void var_1c7
0042283d                              esi_3 = &var_1c7
0042284a                              label_42284a:
0042284a                              edi_3 = arg1
0042284d                              var_10_1 -= 1
00422850                              var_8 += 1
00422854                              eax, edx = sub_423027(edi_3)
00422859                              ebx_4 = eax
0042285b                              ecx = edi_3
0042285c                              var_18 = ebx_4
0042285c                          
00422871                          if (var_24_1 == 0 || var_10_1 s> 0x15d)
00422873                              var_10_1 = 0x15d
00422873                          
00422881                          while (true)
00422881                              BOOL eax_15
00422881                              
00422881                              if (data_42f800 s<= 1)
00422894                                  wchar16 (* eax_16)[0x21]
00422894                                  eax_16.b = (*data_42f5f4)[ebx_4].b
00422897                                  eax_15 = eax_16 & 4
00422881                              else
00422886                                  eax_15 = sub_421804(eax, edx, ecx, ebx_4)
00422886                              
0042289c                              if (eax_15 == 0)
0042289c                                  break
0042289c                              
0042289e                              void* eax_17 = var_10_1
004228a1                              var_10_1 -= 1
004228a1                              
004228a6                              if (eax_17 == 0)
004228a6                                  break
004228a6                              
004228a8                              var_20_1 += 1
004228ab                              *esi_3 = ebx_4.b
004228ad                              esi_3 = &esi_3[1]
004228ae                              var_8 += 1
004228b2                              eax, edx = sub_423027(edi_3)
004228b7                              ebx_4 = eax
004228b9                              ecx = edi_3
004228ba                              var_18 = ebx_4
004228ba                          
004228c5                          if (data_42f804 == ebx_4.b)
004228c7                              void* eax_18 = var_10_1
004228ca                              var_10_1 -= 1
004228ca                              
004228cf                              if (eax_18 != 0)
004228d1                                  var_8 += 1
004228d5                                  uint32_t eax_19
004228d5                                  int32_t edx_1
004228d5                                  eax_19, edx_1 = sub_423027(edi_3)
004228da                                  ebx_4 = eax_19
004228dc                                  eax_19.b = data_42f804
004228e1                                  *esi_3 = eax_19.b
004228e3                                  int32_t* ecx_4 = edi_3
004228e4                                  var_18 = ebx_4
004228e7                                  esi_3 = &esi_3[1]
004228e7                                  
004228ef                                  while (true)
004228ef                                      BOOL eax_20
004228ef                                      
004228ef                                      if (data_42f800 s<= 1)
00422902                                          wchar16 (* eax_21)[0x21]
00422902                                          eax_21.b = (*data_42f5f4)[ebx_4].b
00422905                                          eax_20 = eax_21 & 4
004228ef                                      else
004228f4                                          eax_20 = sub_421804(eax_19, edx_1, ecx_4, ebx_4)
004228f4                                      
0042290a                                      if (eax_20 == 0)
0042290a                                          break
0042290a                                      
0042290c                                      void* eax_22 = var_10_1
0042290f                                      var_10_1 -= 1
0042290f                                      
00422914                                      if (eax_22 == 0)
00422914                                          break
00422914                                      
00422916                                      var_20_1 += 1
00422919                                      *esi_3 = ebx_4.b
0042291b                                      esi_3 = &esi_3[1]
0042291c                                      var_8 += 1
00422920                                      eax_19, edx_1 = sub_423027(edi_3)
00422925                                      ebx_4 = eax_19
00422927                                      ecx_4 = edi_3
00422928                                      var_18 = ebx_4
00422928                          
0042293f                          if (var_20_1 != 0 && (ebx_4 == 0x65 || ebx_4 == 0x45))
00422948                              void* var_10_2 = var_10_1 - 1
00422948                              
0042294d                              if (var_10_1 != 0)
0042294f                                  *esi_3 = 0x65
00422952                                  esi_3 = &esi_3[1]
00422953                                  var_8 += 1
00422957                                  uint32_t eax_24
00422957                                  int32_t edx_2
00422957                                  eax_24, edx_2 = sub_423027(edi_3)
0042295c                                  ebx_4 = eax_24
0042295e                                  int32_t* ecx_6 = edi_3
00422962                                  var_18 = ebx_4
00422962                                  
00422965                                  if (ebx_4 == 0x2d)
00422967                                      *esi_3 = eax_24.b
00422969                                      esi_3 = &esi_3[1]
00422971                                      label_422971:
00422971                                      eax_24 = var_10_2
00422974                                      var_10_2 -= 1
00422974                                      
00422979                                      if (eax_24 != 0)
00422979                                          goto label_422980
00422979                                      
0042297b                                      var_10_2 &= eax_24
00422965                                  else if (ebx_4 == 0x2b)
0042296f                                      goto label_422971
0042296f                                  
00422996                                  while (true)
00422996                                      BOOL eax_25
00422996                                      
00422996                                      if (data_42f800 s<= 1)
004229a9                                          wchar16 (* eax_26)[0x21]
004229a9                                          eax_26.b = (*data_42f5f4)[ebx_4].b
004229ac                                          eax_25 = eax_26 & 4
00422996                                      else
0042299b                                          eax_25 = sub_421804(eax_24, edx_2, ecx_6, ebx_4)
0042299b                                      
004229b1                                      if (eax_25 == 0)
004229b1                                          break
004229b1                                      
004229b3                                      void* eax_27 = var_10_2
004229b6                                      var_10_2 -= 1
004229b6                                      
004229bb                                      if (eax_27 == 0)
004229bb                                          break
004229bb                                      
004229bd                                      var_20_1 += 1
004229c0                                      *esi_3 = ebx_4.b
004229c2                                      esi_3 = &esi_3[1]
00422980                                      label_422980:
00422980                                      var_8 += 1
00422984                                      eax_24, edx_2 = sub_423027(edi_3)
00422989                                      ebx_4 = eax_24
0042298b                                      ecx_6 = edi_3
0042298c                                      var_18 = ebx_4
0042298c                          
004229c5                          var_8 -= 1
004229ca                          eax, edx = sub_423041(ebx_4, edi_3)
004229d4                          ecx = edi_3
004229d4                          
004229d5                          if (var_20_1 == 0)
004229d5                              break
004229d5                          
004229df                          if (var_12_1 == 0)
004229e5                              result += 1
004229e8                              *esi_3 = 0
004229fb                              eax, edx, ecx =
004229fb                                  data_42f330(sx.d(var_11_1) - 1, var_30, &var_1c8)
004229fb                          
0042293f                          goto label_422f32
0042293f                      
004227f4                      if (esi_2 == 0x69)
00422813                          esi_2 = 0x64
00422814                          label_422814:
00422814                          ebx_3 = var_18
00422814                          
0042281a                          if (ebx_3 == 0x2d)
00422820                              var_1b_1 = 1
00422aa3                              label_422aa3:
00422aa3                              void* temp6_1 = var_10_1
00422aa3                              var_10_1 -= 1
00422aa3                              
00422aac                              if (temp6_1 != 1 || var_24_1 == 0)
00422ab7                                  var_8 += 1
00422aba                                  eax, edx = sub_423027(arg1)
00422abf                                  ebx_3 = eax
00422ac1                                  ecx = arg1
00422ac2                                  var_18 = ebx_3
00422aac                              else
00422aae                                  var_13_1 = 1
0042281a                          else if (ebx_3 == 0x2b)
00422aa1                              goto label_422aa3
00422aa1                          
00422ac8                          if (ebx_3 != 0x30)
00422ac8                              goto label_422d17
00422ac8                          
00422ad1                          var_8 += 1
00422ad4                          eax, edx = sub_423027(arg1)
00422ad9                          ebx_3 = eax
00422adb                          ecx = arg1
00422adf                          var_18 = ebx_3
00422ae7                          int32_t var_1d8_14
00422ae7                          
00422ae7                          if (ebx_3.b == 0x78 || ebx_3.b == 0x58)
00422b16                              var_8 += 1
00422b19                              eax, edx = sub_423027(arg1)
00422b1e                              ecx = arg1
00422b1f                              ebx_3 = eax
00422b21                              var_18 = ebx_3
00422b24                              var_1d8_14 = 0x78
00422ae7                          else
00422aec                              var_20_1 = 1
00422aec                              
00422af3                              if (esi_2 == 0x78)
00422b00                                  var_8 -= 1
00422b04                                  eax, edx = sub_423041(ebx_3, arg1)
00422b0a                                  ecx = arg1
00422b0d                                  ebx_3 = 0x30
00422b0e                                  goto label_422d10
00422b0e                              
00422af5                              var_1d8_14 = 0x6f
00422af5                          
00422af7                          esi_2 = var_1d8_14
00422af8                          goto label_422d17
00422af8                      
004227f9                      if (esi_2 == 0x6e)
00422803                          edi_2 = var_8
00422803                          
00422806                          if (var_12_1 == 0)
00422806                              goto label_422f0c
00422806                          
00422806                          goto label_422f32
00422806                  
00422a59                  label_422a59:
00422a59                  
00422a5c                  if (zx.d(*arg2) != var_18)
00422a5c                      goto label_422fa1
00422a5c                  
00422a62                  var_19 -= 1
00422a62                  
00422a69                  if (var_12_1 == 0)
00422a72                      arg3 = var_48
00422a72                  
00422a69                  goto label_422f32
00422a69              
00422a2e              eax = esi_2 - 0x70
00422a2e              
00422a31              if (esi_2 != 0x70)
00422a3a                  if (eax == 3)
00422b2c                      if (var_9_1 s> 0)
00422b2e                          var_1a_1 = 1
00422b2e                      
00422b32                      edi_4 = " \t-\r]"
00422b32                      goto label_422b37
00422b32                  
00422a40                  void* eax_32 = eax - 4
00422a41                  eax = eax_32 - 1
00422a41                  
00422a42                  if (eax_32 == 1)
00422a42                      goto label_422cde
00422a42                  
00422a48                  void* temp3_1 = eax
00422a48                  eax -= 3
00422a48                  
00422a4b                  if (temp3_1 == 3)
00422a4b                      goto label_422814
00422a4b                  
00422a54                  if (eax != 3)
00422a54                      goto label_422a59
00422a54                  
00422a7e                  if (var_9_1 s> 0)
00422a80                      var_1a_1 = 1
00422a80                  
00422a87                  edi_4 = &arg2[1]
00422a88                  arg2 = edi_4
00422a88                  
00422a8e                  if (*edi_4 == 0x5e)
00422a96                      edi_4 += 1
00422b37                      label_422b37:
00422b37                      var_1c_1 = 0xff
00422b37                  
00422b43                  char var_68[0xb]
00422b43                  char* eax_35
00422b43                  uint32_t edx_3
00422b43                  eax_35, edx_3 = sub_4257d0(&var_68, 0, 0x20)
00422b43                  
00422b54                  if (esi_2 != 0x7b || *edi_4 != 0x5d)
00422b5f                      edx_3.b = var_39_1
00422b54                  else
00422b56                      edx_3.b = 0x5d
00422b58                      edi_4 += 1
00422b59                      char var_5d_1 = 0x20
00422b59                  
00422b62                  while (true)
00422b62                      eax_35.b = *edi_4
00422b62                      
00422b66                      if (eax_35.b == 0x5d)
00422b66                          break
00422b66                      
00422b68                      edi_4 += 1
00422b6f                      int32_t __saved_ebp
00422b6f                      char* ebx_2
00422b6f                      
00422b6f                      if (eax_35.b == 0x2d && edx_3.b != 0)
00422b71                          char ecx_8 = *edi_4
00422b71                          
00422b76                          if (ecx_8 != 0x5d)
00422b78                              edi_4 += 1
00422b78                              
00422b7b                              if (edx_3.b u>= ecx_8)
00422b81                                  eax_35.b = edx_3.b
00422b83                                  edx_3.b = ecx_8
00422b7b                              else
00422b7d                                  eax_35.b = ecx_8
00422b7d                              
00422b87                              if (edx_3.b u<= eax_35.b)
00422b89                                  edx_3 = zx.d(edx_3.b)
00422b91                                  int32_t i_3 = zx.d(eax_35.b) - edx_3 + 1
00422ba8                                  int32_t i_2
00422ba8                                  
00422ba8                                  do
00422b99                                      ebx_2.b = 1
00422b9e                                      ebx_2.b = 1 << (edx_3.b & 7)
00422ba4                                      *(&__saved_ebp + (edx_3 u>> 3) - 0x64) |= ebx_2.b
00422ba6                                      edx_3 += 1
00422ba7                                      i_2 = i_3
00422ba7                                      i_3 -= 1
00422ba8                                  while (i_2 != 1)
00422ba8                              
00422baa                              edx_3.b = 0
00422bac                              continue
00422bac                      
00422bae                      uint32_t ecx_10 = zx.d(eax_35.b)
00422bb1                      edx_3.b = eax_35.b
00422bb8                      ebx_2.b = 1
00422bbd                      ebx_2.b = 1 << (ecx_10.b & 7)
00422bc3                      *(&__saved_ebp + (ecx_10 u>> 3) - 0x64) |= ebx_2.b
00422bc3                  
00422bca                  if (*edi_4 == 0)
00422bca                      break
00422bca                  
00422bd4                  if (esi_2 == 0x7b)
00422bd6                      arg2 = edi_4
00422bd6                  
00422bdc                  char* esi_6 = var_30
00422bdf                  var_8 -= 1
00422be6                  char* var_34_2 = esi_6
00422be9                  edx = sub_423041(var_18, arg1)
00422bef                  ecx = arg1
00422bef                  
00422bf4                  while (true)
00422bf4                      if (var_24_1 != 0)
00422bf6                          eax = var_10_1
00422bf9                          var_10_1 -= 1
00422bf9                          
00422bfe                          if (eax == 0)
00422bfe                              break
00422bfe                      
00422c04                      var_8 += 1
00422c08                      uint32_t eax_40 = sub_423027(arg1)
00422c11                      var_18 = eax_40
00422c11                      
00422c14                      if (eax_40 != 0xffffffff)
00422c22                          edx = 1 << (eax_40.b & 7)
00422c2e                          ecx = sx.d(var_68[eax_40 s>> 3]) ^ sx.d(var_1c_1)
00422c2e                          
00422c32                          if ((ecx & edx) != 0)
00422c38                              if (var_12_1 != 0)
00422c8c                                  var_34_2 = &var_34_2[1]
00422c8f                                  continue
00422c38                              else
00422c3e                                  if (var_1a_1 == 0)
00422c81                                      *esi_6 = eax_40.b
00422c83                                      esi_6 = &esi_6[1]
00422c3e                                  else
00422c40                                      wchar16 (* ecx_17)[0x21] = data_42f5f4
00422c46                                      char var_3c = eax_40.b
00422c46                                      
00422c51                                      if ((*(&(*ecx_17)[zx.d(eax_40.b)] + 1) & 0x80) != 0)
00422c53                                          var_8 += 1
00422c5d                                          char var_3b_1 = sub_423027(arg1)
00422c5d                                      
00422c6e                                      int16_t var_42
00422c6e                                      ecx, edx = sub_426723(&var_42, &var_3c, data_42f800)
00422c7a                                      *esi_6 = var_42
00422c7e                                      esi_6 = &esi_6[2]
00422c7e                                  
00422c84                                  var_30 = esi_6
00422c87                                  continue
00422c87                      
00422c94                      var_8 -= 1
00422c99                      eax, edx = sub_423041(eax_40, arg1)
00422c9f                      ecx = arg1
00422c9f                      break
00422c9f                  
00422ca3                  if (var_34_2 == esi_6)
00422ca3                      break
00422ca3                  
00422cad                  if (var_12_1 == 0)
00422cb3                      result += 1
00422cb3                      
00422cba                      if (esi_2 != 0x63)
00422cc7                          if (var_1a_1 == 0)
00422cd2                              *var_30 = 0
00422cc7                          else
00422cc9                              *var_30 = 0
00422cc9                  
00422bca                  goto label_422f32
00422bca              
00422cda              var_11_1 = 1
00422cde              label_422cde:
00422cde              ebx_3 = var_18
00422cde              
00422ce4              if (ebx_3 != 0x2d)
00422cef                  if (ebx_3 != 0x2b)
00422cef                      goto label_422d17
00422cef                  
00422cef                  goto label_422cf1
00422cef              
00422ce6              var_1b_1 = 1
00422cf1              label_422cf1:
00422cf1              void* temp4_1 = var_10_1
00422cf1              var_10_1 -= 1
00422cf1              
00422cfa              if (temp4_1 != 1 || var_24_1 == 0)
00422d05                  var_8 += 1
00422d08                  eax, edx = sub_423027(arg1)
00422d0d                  ecx = arg1
00422d0e                  ebx_3 = eax
00422d10                  label_422d10:
00422d10                  var_18 = ebx_3
00422d10                  goto label_422d17
00422d10              
00422cfc              var_13_1 = 1
00422d17              label_422d17:
00422d17              
00422d17              if (var_34_1 == 0)
00422e30                  if (var_13_1 == 0)
00422e3e                      while (true)
00422e3e                          int32_t edi_7
00422e3e                          
00422e3e                          if (esi_2 == 0x78 || esi_2 == 0x70)
00422e81                              BOOL eax_56
00422e81                              
00422e81                              if (data_42f800 s<= 1)
00422e97                                  wchar16 (* eax_57)[0x21]
00422e97                                  eax_57.b = (*data_42f5f4)[ebx_3].b
00422e9a                                  eax_56 = eax_57 & 0x80
00422e81                              else
00422e89                                  eax_56 = sub_421804(eax, edx, ecx, ebx_3)
00422e89                              
00422ea1                              if (eax_56 == 0)
00422edd                                  label_422edd:
00422edd                                  var_8 -= 1
00422ee1                                  eax, edx = sub_423041(ebx_3, arg1)
00422ee7                                  ecx = arg1
00422ee7                                  break
00422ee7                              
00422ea3                              void* var_1d8_26 = ebx_3
00422ea4                              edi_7 = edi_2 << 4
00422ea7                              eax, edx = sub_422ff0(var_1d8_26)
00422eac                              ebx_3 = eax
00422eae                              ecx = var_1d8_26
00422eaf                              var_18 = ebx_3
00422e3e                          else
00422e47                              if (data_42f800 s<= 1)
00422e5a                                  wchar16 (* eax_55)[0x21]
00422e5a                                  eax_55.b = (*data_42f5f4)[ebx_3].b
00422e5d                                  eax = eax_55 & 4
00422e47                              else
00422e4c                                  eax, edx = sub_421804(eax, edx, ecx, ebx_3)
00422e52                                  ecx = 4
00422e52                              
00422e62                              if (eax == 0)
00422e62                                  goto label_422edd
00422e62                              
00422e67                              if (esi_2 != 0x6f)
00422e76                                  edi_7 = edi_2 * 0xa
00422e67                              else
00422e6c                                  if (ebx_3 s>= 0x38)
00422e6c                                      goto label_422edd
00422e6c                                  
00422e6e                                  edi_7 = edi_2 << 3
00422e6e                          
00422eb2                          var_20_1 += 1
00422eb9                          edi_2 = edi_7 + ebx_3 - 0x30
00422eb9                          
00422ebd                          if (var_24_1 != 0)
00422ebf                              void* temp9_1 = var_10_1
00422ebf                              var_10_1 -= 1
00422ebf                              
00422ec2                              if (temp9_1 == 1)
00422ec2                                  break
00422ec2                          
00422ec7                          var_8 += 1
00422eca                          eax, edx = sub_423027(arg1)
00422ecf                          ebx_3 = eax
00422ed1                          ecx = arg1
00422ed2                          var_18 = ebx_3
00422ed2                  
00422eec                  if (var_1b_1 != 0)
00422eee                      edi_2 = neg.d(edi_2)
00422d17              else
00422d21                  if (var_13_1 == 0)
00422d2a                      while (true)
00422d2a                          int32_t var_2c_1
00422d2a                          int32_t var_28_1
00422d2a                          
00422d2a                          if (esi_2 != 0x78)
00422d82                              BOOL eax_49
00422d82                              
00422d82                              if (data_42f800 s<= 1)
00422d95                                  wchar16 (* eax_50)[0x21]
00422d95                                  eax_50.b = (*data_42f5f4)[ebx_3].b
00422d98                                  eax_49 = eax_50 & 4
00422d82                              else
00422d87                                  eax_49 = sub_421804(eax, edx, ecx, ebx_3)
00422d87                              
00422d9d                              if (eax_49 == 0)
00422dff                                  label_422dff:
00422dff                                  var_8 -= 1
00422e03                                  eax, edx = sub_423041(ebx_3, arg1)
00422e09                                  ecx = arg1
00422e09                                  break
00422e09                              
00422da2                              int32_t eax_52
00422da2                              int32_t edx_7
00422da2                              
00422da2                              if (esi_2 != 0x6f)
00422dc3                                  eax_52, ecx, edx_7 = __allmul(var_2c, var_28, 0xa, 0)
00422dc8                                  var_2c_1 = eax_52
00422dcb                                  var_28_1 = edx_7
00422da2                              else
00422da7                                  if (ebx_3 s>= 0x38)
00422da7                                      goto label_422dff
00422da7                                  
00422db2                                  eax_52, ecx, edx_7 = __allshl(var_2c, var_28, 3)
00422dc8                                  var_2c_1 = eax_52
00422dcb                                  var_28_1 = edx_7
00422d2a                          else
00422d33                              BOOL eax_44
00422d33                              
00422d33                              if (data_42f800 s<= 1)
00422d49                                  wchar16 (* eax_45)[0x21]
00422d49                                  eax_45.b = (*data_42f5f4)[ebx_3].b
00422d4c                                  eax_44 = eax_45 & 0x80
00422d33                              else
00422d3b                                  eax_44 = sub_421804(eax, edx, ecx, ebx_3)
00422d3b                              
00422d53                              if (eax_44 == 0)
00422d53                                  goto label_422dff
00422d53                              
00422d62                              int32_t eax_47
00422d62                              int32_t edx_5
00422d62                              eax_47, edx_5 = __allshl(var_2c, var_28, 4)
00422d67                              void* var_1d8_23 = ebx_3
00422d68                              var_2c_1 = eax_47
00422d6b                              var_28_1 = edx_5
00422d73                              ebx_3 = sub_422ff0(var_1d8_23)
00422d75                              ecx = var_1d8_23
00422d76                              var_18 = ebx_3
00422d76                          
00422dce                          var_20_1 += 1
00422dd4                          edx:eax = sx.q(ebx_3 - 0x30)
00422dd5                          var_2c = var_2c_1 + eax
00422dd8                          var_28 = adc.d(var_28_1, edx, var_2c_1 + eax u< var_2c_1)
00422dd8                          
00422ddf                          if (var_24_1 != 0)
00422de1                              void* temp10_1 = var_10_1
00422de1                              var_10_1 -= 1
00422de1                              
00422de4                              if (temp10_1 == 1)
00422de4                                  break
00422de4                          
00422de9                          var_8 += 1
00422dec                          eax, edx = sub_423027(arg1)
00422df1                          ebx_3 = eax
00422df3                          ecx = arg1
00422df4                          var_18 = ebx_3
00422df4                  
00422e0e                  if (var_1b_1 != 0)
00422e1c                      int32_t ecx_22 = adc.d(var_28, 0, var_2c != 0)
00422e1f                      var_2c = neg.d(var_2c)
00422e22                      ecx = neg.d(ecx_22)
00422e24                      var_28 = ecx
00422e24              
00422ef3              if (esi_2 == 0x46)
00422ef5                  var_20_1 = 0
00422ef5              
00422efd              if (var_20_1 == 0)
00422efd                  break
00422efd              
00422f07              if (var_12_1 != 0)
00422f07                  goto label_422f32
00422f07              
00422f09              result += 1
00422f0c              label_422f0c:
00422f0c              
00422f10              if (var_34_1 == 0)
00422f29                  if (var_11_1 == 0)
00422f2f                      *var_30 = edi_2.w
00422f29                  else
00422f2b                      *var_30 = edi_2
00422f2b                  
00422f29                  goto label_422f32
00422f29              
00422f18              *var_30 = var_2c
00422f1a              ecx = var_28
00422f1d              *(var_30 + 4) = ecx
00422f32              label_422f32:
00422f32              var_19 += 1
00422f35              arg2 = &arg2[1]
00422f38              esi = arg2
00422f38          
00422f83          if (var_18 == 0xffffffff)
00422f88              if (*esi != 0x25)
00422f88                  goto label_422fd7
00422f88              
00422f8a              eax = arg2
00422f8a              
00422f91              if (*(eax + 1) != 0x6e)
00422f91                  goto label_422fd7
00422f91              
00422f93              esi = eax
00422f93          
00422f95          eax.b = *esi
00422f95          
00422f99          if (eax.b == 0)
00422f99              break
00422f99          
004225f5          edi_1 = arg1
004225f5  
00422fd5  if (var_18 != 0xffffffff)
00422fe8      return result
00422fe8  
00422fd7  label_422fd7:
00422fd7  
00422fe1  if (result == 0 && var_19 == result.b)
00422fe3      return 0xffffffff
00422fe3  
00422fef  return result


00422ff0    int32_t sub_422ff0(int32_t arg1)

00422ff8  BOOL eax_1
00422ff8  int32_t result
00422ff8  
00422ff8  if (data_42f800 s<= 1)
0042300a      result = arg1
00423013      wchar16 (* eax_2)[0x21]
00423013      eax_2.b = (*data_42f5f4)[result].b
00423016      eax_1 = eax_2 & 4
00422ff8  else
00422ffa      result = arg1
00423001      int32_t eax
00423001      int32_t ecx
00423001      int32_t edx
00423001      eax_1 = sub_421804(eax, edx, ecx, result)
00423001  
0042301b  if (eax_1 != 0)
00423026      return result
00423026  
00423020  return (result & 0xffffffdf) - 7


00423027    uint32_t sub_423027(int32_t* arg1)

0042302b  int32_t temp0 = arg1[1]
0042302b  arg1[1] -= 1
0042302b  
0042302e  if (temp0 - 1 s< 0)
00423040      return sub_4208ce(arg1)
00423040  
00423030  char* ecx = *arg1
00423032  uint32_t result = zx.d(*ecx)
00423036  *arg1 = &ecx[1]
00423038  return result


00423041    void sub_423041(int32_t arg1, int32_t* arg2)

00423046  if (arg1 != 0xffffffff)
00423050      sub_42689f(arg1, arg2)


00423058    uint32_t sub_423058(int32_t* arg1, int32_t* arg2)

00423075  uint32_t result
00423075  bool cond:0_1
00423075  
00423075  do
00423062      *arg1 += 1
00423064      result = sub_423027(arg2)
00423072      cond:0_1 = sub_426849(result) != 0
00423075  while (cond:0_1)
0042307b  return result


0042307c    int32_t sub_42307c(int32_t arg1)

0042307c  int32_t eax_3 = data_430c74
0042307c  
00423083  if (eax_3 != 0 && eax_3(arg1) != 0)
00423093      return 1
00423093  
00423096  return 0

00423097                                                                       cc cc cc cc cc cc cc cc cc                         .........

004230a0    char* sub_4230a0(char* arg1, char* arg2)

004230a1  char* edi = arg1
00423111  char* ecx = arg2
0042311b  int32_t edx
0042311b  
0042311b  while ((ecx & 3) != 0)
0042311d      edx.b = *ecx
0042311f      ecx = &ecx[1]
0042311f      
00423122      if (edx.b == 0)
00423122          goto label_423188
00423122      
00423124      *edi = edx.b
00423126      edi = &edi[1]
00423126  
0042313b  while (true)
0042313b      int32_t eax_1 = *ecx
00423144      edx = *ecx
00423146      ecx = &ecx[4]
00423146      
0042314e      if (((eax_1 ^ 0xffffffff ^ (0x7efefeff + eax_1)) & 0x81010100) != 0)
00423152          if (edx.b == 0)
00423152              break
00423152          
00423156          if (edx:1.b == 0)
0042317f              *edi = edx.w
00423187              return arg1
00423187          
0042315e          if ((edx & 0xff0000) == 0)
00423172              *edi = edx.w
00423179              edi[2] = 0
0042317e              return arg1
0042317e          
00423166          if ((edx & 0xff000000) == 0)
0042316a              *edi = edx
00423171              return arg1
00423171      
00423131      *edi = edx
00423133      edi = &edi[4]
00423133  
00423188  label_423188:
00423188  *edi = edx.b
0042318f  return arg1

004230a7                       8d a4 24 00 00 00 00 8b ff                                                         ..$......

004230b0    char* sub_4230b0(char* arg1, char* arg2)

004230b0  char* ecx = arg1
004230bb  void* edi
004230bb  
004230bb  while ((ecx & 3) != 0)
004230bd      char eax = *ecx
004230bf      ecx = &ecx[1]
004230bf      
004230c2      if (eax == 0)
004230ff          label_4230ff:
004230ff          edi = &ecx[0xffffffff]
00423102          goto label_423111
00423102  
004230cc  while (true)
004230cc      int32_t eax_1 = *ecx
004230da      ecx = &ecx[4]
004230da      
004230e2      if (((eax_1 ^ 0xffffffff ^ (0x7efefeff + eax_1)) & 0x81010100) != 0)
004230e4          int32_t eax_4 = *(ecx - 4)
004230e4          
004230e9          if (eax_4.b == 0)
0042310e              edi = &ecx[0xfffffffc]
0042310e              break
0042310e          
004230ed          if (eax_4:1.b == 0)
00423109              edi = &ecx[0xfffffffd]
0042310c              break
0042310c          
004230f4          if ((eax_4 & 0xff0000) == 0)
00423104              edi = &ecx[0xfffffffe]
00423107              break
00423107          
004230fb          if ((eax_4 & 0xff000000) == 0)
004230fb              goto label_4230ff
004230fb  
00423111  label_423111:
00423111  char* ecx_1 = arg2
0042311b  int32_t edx
0042311b  
0042311b  while ((ecx_1 & 3) != 0)
0042311d      edx.b = *ecx_1
0042311f      ecx_1 = &ecx_1[1]
0042311f      
00423122      if (edx.b == 0)
00423122          goto label_423188
00423122      
00423124      *edi = edx.b
00423126      edi += 1
00423126  
0042313b  while (true)
0042313b      int32_t eax_5 = *ecx_1
00423144      edx = *ecx_1
00423146      ecx_1 = &ecx_1[4]
00423146      
0042314e      if (((eax_5 ^ 0xffffffff ^ (0x7efefeff + eax_5)) & 0x81010100) != 0)
00423152          if (edx.b == 0)
00423152              break
00423152          
00423156          if (edx:1.b == 0)
0042317f              *edi = edx.w
00423187              return arg1
00423187          
0042315e          if ((edx & 0xff0000) == 0)
00423172              *edi = edx.w
00423179              *(edi + 2) = 0
0042317e              return arg1
0042317e          
00423166          if ((edx & 0xff000000) == 0)
0042316a              *edi = edx
00423171              return arg1
00423171      
00423131      *edi = edx
00423133      edi += 4
00423133  
00423188  label_423188:
00423188  *edi = edx.b
0042318f  return arg1


00423190    int32_t sub_423190(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7)

004231af  if (arg1 - 0x76c s< 0x46 || arg1 - 0x76c s> 0x8a)
0042324c      return 0xffffffff
0042324c  
004231c1  int32_t esi_2 = *((arg2 << 2) + &data_42ff04) + arg3
004231c1  
004231cc  if (((arg1 - 0x76c).b & 3) == 0 && arg2 s> 2)
004231ce      esi_2 += 1
004231ce  
004231cf  sub_42690d()
004231e4  int32_t var_c_1 = esi_2
004231e9  int32_t var_14_1 = arg1 - 0x76c
004231f7  int32_t var_20_1 = arg4
00423211  int32_t var_18_1 = arg2 - 1
00423216  int32_t result = (
00423216      (arg4 + ((arg1 - 0x76c) * 0x16d + esi_2 + ((arg1 - 0x76d) s>> 2)) * 0x18) * 0x3c
00423216      + arg5) * 0x3c + data_42fe20 + arg6 + 0x7c558180
00423216  
00423220  if (arg7 != 1)
0042322f      if (arg7 != 0xffffffff || data_42fe24 == 0)
00423248          return result
00423248      
00423240      void var_28
00423240      
00423240      if (sub_426bc2(&var_28) == 0)
00423248          return result
00423248  
00423242  return result + data_42fe28

00423252                                                        cc cc cc cc cc cc cc cc cc cc cc cc cc cc                    ..............
00423265                 8d a4 24 00 00 00 00 8d 64 24 00                                                       ..$.....d$.

00423270    void* sub_423270(char* arg1, char arg2)

00423272  int32_t eax
00423272  eax.b = arg2
0042327c  char* edx = arg1
0042327c  
00423286  while ((edx & 3) != 0)
00423288      char ecx = *edx
0042328a      edx = &edx[1]
0042328a      
0042328d      if (ecx == eax.b)
00423264          return &edx[0xffffffff]
00423264      
00423291      if (ecx == 0)
004232e7          return 0
004232e7  
0042329b  int32_t ebx_1 = eax | eax << 8
004232a4  int32_t ebx_3 = ebx_1 << 0x10 | ebx_1
004232a4  
004232a6  while (true)
004232a6      int32_t ecx_1 = *edx
004232b1      int32_t ecx_2 = ecx_1 ^ ebx_3
004232c1      edx = &edx[4]
004232c1      
004232ca      if (((ecx_2 ^ 0xffffffff ^ (0x7efefeff + ecx_2)) & 0x81010100) != 0)
004232e8          int32_t eax_9 = *(edx - 4)
004232e8          
004232ed          if (eax_9.b == ebx_3.b)
0042332b              return &edx[0xfffffffc]
0042332b          
004232f1          if (eax_9.b == 0)
004232f1              break
004232f1          
004232f5          if (eax_9:1.b == ebx_3.b)
00423324              return &edx[0xfffffffd]
00423324          
004232f9          if (eax_9:1.b == 0)
004232f9              break
004232f9          
004232fb          uint16_t eax_10 = (eax_9 u>> 0x10).w
004232fb          
00423300          if (eax_10.b == ebx_3.b)
0042331d              return &edx[0xfffffffe]
0042331d          
00423304          if (eax_10.b == 0)
00423304              break
00423304          
00423308          if (eax_10:1.b == ebx_3.b)
00423316              return &edx[0xffffffff]
00423316          
0042330c          if (eax_10:1.b == 0)
0042330c              break
004232ca      else
004232cc          int32_t eax_6 = (ecx_1 ^ 0xffffffff ^ (0x7efefeff + ecx_1)) & 0x81010100
004232cc          
004232d1          if (eax_6 != 0)
004232d8              if ((eax_6 & 0x1010100) != 0)
004232d8                  break
004232d8              
004232e0              if (((0x7efefeff + ecx_1) & 0x80000000) == 0)
004232e0                  break
004232e0  
004232e7  return 0


0042332c    int32_t sub_42332c()

0042332d  sub_4218f0()
00423332  uint32_t eax = TlsAlloc()
0042333b  data_42f9a4 = eax
0042333b  
00423340  if (eax != 0xffffffff)
00423346      void* lpTlsValue = sub_425831(1, 0x74)
00423346      
00423351      if (lpTlsValue != 0 && TlsSetValue(dwTlsIndex: data_42f9a4, lpTlsValue) != 0)
00423365          sub_423380(lpTlsValue)
0042336b          uint32_t eax_2 = GetCurrentThreadId()
00423371          *(lpTlsValue + 4) = 0xffffffff
00423377          *lpTlsValue = eax_2
0042337b          return 1
0042337b  
0042337f  return 0


00423380    void* sub_423380(void* arg1)

00423384  *(arg1 + 0x50) = 0x42fcc8
0042338b  *(arg1 + 0x14) = 1
00423392  return arg1


00423393    void* sub_423393()

00423395  enum WIN32_ERROR dwErrCode = GetLastError()
004233a9  void* lpTlsValue = TlsGetValue(dwTlsIndex: data_42f9a4)
004233a9  
004233ad  if (lpTlsValue == 0)
004233b8      lpTlsValue = sub_425831(1, 0x74)
004233be      BOOL eax_2
004233be      
004233be      if (lpTlsValue != 0)
004233c7          eax_2 = TlsSetValue(dwTlsIndex: data_42f9a4, lpTlsValue)
004233c7      
004233cf      if (lpTlsValue == 0 || eax_2 == 0)
004233e8          sub_41f9c5(0x10)
004233cf      else
004233d2          sub_423380(lpTlsValue)
004233d8          uint32_t eax_3 = GetCurrentThreadId()
004233de          *(lpTlsValue + 4) = 0xffffffff
004233e2          *lpTlsValue = eax_3
004233e2  
004233ef  SetLastError(dwErrCode)
004233f9  return lpTlsValue


004233fa    int32_t sub_4233fa(uint32_t arg1, uint32_t arg2, uint8_t* arg3, void* arg4, PSTR arg5, int32_t arg6, uint32_t arg7, int32_t arg8)

004233fd  int32_t var_8 = 0xffffffff
004233ff  int32_t var_c = 0x4296b8
00423404  int32_t var_10 = 0x424e8c
0042340f  TEB* fsbase
0042340f  struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList
00423410  fsbase->NtTib.ExceptionList = &ExceptionList
0042341d  int32_t __saved_edi
0042341d  int32_t* var_1c = &__saved_edi
0042341d  
00423428  if (data_430ca4 != 0)
00423428      goto label_423473
00423428  
00423444  int32_t result
00423444  
00423444  if (LCMapStringW(Locale: 0, dwMapFlags: 0x100, lpSrcStr: &data_4296b0, cchSrc: 1, 
00423444          lpDestStr: nullptr, cchDest: 0) == 0)
00423460      if (LCMapStringA(Locale: 0, dwMapFlags: 0x100, lpSrcStr: &data_4296ac, cchSrc: 1, 
00423460              lpDestStr: nullptr, cchDest: 0) != 0)
00423466          data_430ca4 = 2
00423466          goto label_423473
00423466      
00423588      result = 0
00423444  else
00423446      data_430ca4 = 1
00423473      label_423473:
00423473      
00423473      if (arg4 s> 0)
00423482          arg4 = sub_427f9c(arg3, arg4)
00423482      
00423485      int32_t eax_4 = data_430ca4
00423485      
0042348d      if (eax_4 == 2)
004234a1          result = LCMapStringA(Locale: arg1, dwMapFlags: arg2, lpSrcStr: arg3, 
004234a1              cchSrc: arg4, lpDestStr: arg5, cchDest: arg6)
0042348d      else if (eax_4 != 1)
00423588          result = 0
004234af      else
004234b8          if (arg7 == 0)
004234bf              arg7 = data_430c9c
004234bf          
004234cd          int32_t eax_7 = neg.d(arg8)
004234d9          int32_t eax_11 = MultiByteToWideChar(CodePage: arg7, 
004234d9              dwFlags: (sbb.d(eax_7, eax_7, arg8 != 0) & 8) + 1, lpMultiByteStr: arg3, 
004234d9              cbMultiByte: arg4, lpWideCharStr: nullptr, cchWideChar: 0)
004234d9          
004234e6          if (eax_11 == 0)
00423588              result = 0
004234e6          else
004234ec              int32_t var_8_1 = 0
004234f5              int32_t eax_13
004234f5              eax_13.b = (eax_11 * 2 + 3).b & 0xfc
004234f7              sub_41e520(eax_13)
004234fc              int32_t* var_1c_1 = &__saved_edi
00423501              int32_t* var_28_1 = &__saved_edi
00423504              int32_t var_8_2 = 0xffffffff
00423504              
00423520              if (var_28_1 == 0)
00423588                  result = 0
00423520              else if (MultiByteToWideChar(CodePage: arg7, dwFlags: MB_PRECOMPOSED, 
00423520                      lpMultiByteStr: arg3, cbMultiByte: arg4, lpWideCharStr: var_28_1, 
00423520                      cchWideChar: eax_11) == 0)
00423588                  result = 0
00423539              else
0042354d                  int32_t result_1 = LCMapStringW(Locale: arg1, dwMapFlags: arg2, 
0042354d                      lpSrcStr: var_28_1, cchSrc: eax_11, lpDestStr: nullptr, cchDest: 0)
0042354f                  int32_t result_2 = result_1
0042354f                  
00423554                  if (result_1 == 0)
00423588                      result = 0
00423554                  else if ((arg2:1.b & 4) == 0)
0042359c                      int32_t var_8_3 = 1
004235a9                      int32_t eax_18
004235a9                      eax_18.b = (result_1 * 2 + 3).b & 0xfc
004235ab                      sub_41e520(eax_18)
004235b0                      int32_t* var_1c_2 = &__saved_edi
004235b5                      int32_t* var_24_1 = &__saved_edi
004235b8                      int32_t var_8_4 = 0xffffffff
004235b8                      
004235d2                      if (&__saved_edi == 0)
00423588                          result = 0
004235d2                      else if (LCMapStringW(Locale: arg1, dwMapFlags: arg2, 
004235d2                              lpSrcStr: var_28_1, cchSrc: eax_11, lpDestStr: &__saved_edi, 
004235d2                              cchDest: result_1) == 0)
00423588                          result = 0
004235ea                      else
004235f1                          PSTR lpMultiByteStr
004235f1                          int32_t cbMultiByte
004235f1                          
004235f1                          if (arg6 != 0)
004235f7                              cbMultiByte = arg6
004235fa                              lpMultiByteStr = arg5
004235f1                          else
004235f3                              cbMultiByte = 0
004235f4                              lpMultiByteStr = nullptr
004235f4                          
0042360d                          result_1 = WideCharToMultiByte(CodePage: arg7, dwFlags: 0x220, 
0042360d                              lpWideCharStr: &__saved_edi, cchWideChar: result_1, 
0042360d                              lpMultiByteStr, cbMultiByte, lpDefaultChar: nullptr, 
0042360d                              lpUsedDefaultChar: nullptr)
0042360d                          
00423611                          if (result_1 == 0)
00423588                              result = 0
00423611                          else
00423617                              result = result_1
0042355a                  else if (arg6 == 0)
00423617                      result = result_1
0042355f                  else if (result_1 s> arg6)
00423588                      result = 0
00423568                  else if (LCMapStringW(Locale: arg1, dwMapFlags: arg2, lpSrcStr: var_28_1, 
00423568                          cchSrc: eax_11, lpDestStr: arg5, cchDest: arg6) != 0)
00423617                      result = result_1
00423582                  else
00423588                      result = 0
00423588  
00423590  fsbase->NtTib.ExceptionList = ExceptionList
0042359b  return result


0042350a    int32_t sub_42350a() __pure

0042350d  return 1

0042350e                                            8b 65 e8 33 ff 89 7d dc 83 4d fc ff 8b 5d e4                         .e.3..}..M...].

004235be    int32_t sub_4235be() __pure

004235c1  return 1

004235c2        8b 65 e8 33 ff 33 db 83 4d fc ff 8b 75 d8                                                    .e.3.3..M...u.

0042361e    enum WIN32_ERROR sub_42361e(int32_t arg1)

0042362b  if (arg1 u< data_2823980)
00423643      int32_t esi_2 = (arg1 & 0x1f) * 0x24
00423643      
0042364b      if ((*((&data_2823880)[arg1 s>> 5] + esi_2 + 4) & 1) != 0)
0042364e          sub_425db9(arg1)
0042365b          enum WIN32_ERROR result
0042365b          
0042365b          if ((*((&data_2823880)[arg1 s>> 5] + esi_2 + 4) & 1) == 0)
0042368b              *sub_41e9bd() = 9
00423691              result = ~NO_ERROR
0042365b          else
0042366d              if (FlushFileBuffers(hFile: sub_425d77(arg1)) != 0)
00423679                  result = NO_ERROR
0042366d              else
00423675                  result = GetLastError()
00423675              
0042367d              if (result != NO_ERROR)
00423684                  *sub_41e9c6() = result
0042368b                  *sub_41e9bd() = 9
00423691                  result = ~NO_ERROR
00423691          
00423695          sub_425e18(arg1)
0042369b          return result
0042369b  
004236a4  *sub_41e9bd() = 9
004236aa  return ~NO_ERROR


004236b1    long double __convention("regparm") sub_4236b1(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, double arg5, int32_t arg6)

004236bb  if (data_42ff40 != 0)
004236f0      *sub_41e9bd() = 0x21
004236f9      int16_t x87control
004236f9      sub_423edc(x87control, arg6, 0xffff)
00423704      return fconvert.t(arg5)
00423704  
004236c3  int32_t var_c = arg3
004236c4  int32_t var_10 = arg3
004236c5  var_10.q = fconvert.d(fconvert.t(arg5))
004236c9  int32_t var_18 = arg3
004236cc  var_18.q = fconvert.d(float.t(0))
004236d3  int32_t var_20 = arg3
004236d4  var_20.q = fconvert.d(fconvert.t(arg5))
004236e5  return sub_423c67(1, arg4, var_20, arg3, var_18, arg3, var_10, arg6)


00423705    long double sub_423705(int32_t arg1, int32_t arg2, int32_t arg3)

0042371f  double arg_c
0042371f  double arg_14
0042371f  
0042371f  if (sub_423a50(arg1, &arg_14, arg3.b) == 0)
00423724      int32_t var_24
00423724      int32_t var_24_1 = var_24 & 0xfffffffe
0042373b      void var_5c
0042373b      sub_42379d(&var_5c, &arg3, arg1.b, arg2, &arg_c, &arg_14)
0042373b      noreturn
0042373b  
00423746  int32_t eax_1 = sub_423d3c(arg1.b)
00423746  
00423757  if (data_42ff40 != 0 || eax_1 == 0)
00423782      sub_423cef(eax_1)
00423791      int16_t x87control
00423791      sub_423edc(x87control, arg3, 0xffff)
0042379c      return fconvert.t(arg_14)
0042379c  
0042375f  int32_t var_64_2 = arg1
00423760  int32_t var_68_2 = arg1
00423761  var_68_2.q = fconvert.d(fconvert.t(arg_14))
00423765  int32_t var_70_1 = arg1
00423768  var_70_1.q = fconvert.d(float.t(0))
0042376f  int32_t var_78 = arg1
00423770  var_78.q = fconvert.d(fconvert.t(arg_c))
00423780  return sub_423c67(eax_1, arg2, var_78, arg1, var_70_1, arg1, var_68_2, arg3)

00423740  83 c4 18                                                                                         ...

0042379d    void sub_42379d(uint32_t arg1, int32_t* arg2, char arg3, int32_t arg4, double* arg5, double* arg6) __noreturn

004237a7  *(arg1 + 4) = 0
004237b0  *(arg1 + 8) = 0
004237b7  *(arg1 + 0xc) = 0
004237ba  uint32_t ecx_2
004237ba  ecx_2.b = arg3
004237ba  
004237c0  if ((ecx_2.b & 0x10) != 0)
004237c2      uint32_t eax_1 = arg1
004237c5      arg3.d = 0xc000008f
004237cc      *(eax_1 + 4) |= 1
004237cc  
004237d2  if ((ecx_2.b & 2) != 0)
004237d4      uint32_t eax_2 = arg1
004237d7      arg3.d = 0xc0000093
004237de      *(eax_2 + 4) |= 2
004237de  
004237e4  if ((1 & ecx_2.b) != 0)
004237e6      uint32_t eax_3 = arg1
004237e9      arg3.d = 0xc0000091
004237f0      *(eax_3 + 4) |= 4
004237f0  
004237f7  if ((ecx_2.b & 4) != 0)
004237f9      uint32_t eax_4 = arg1
004237fc      arg3.d = 0xc000008e
00423803      *(eax_4 + 4) |= 8
00423803  
0042380a  if ((ecx_2.b & 8) != 0)
0042380c      uint32_t eax_5 = arg1
0042380f      arg3.d = 0xc0000090
00423816      *(eax_5 + 4) |= 0x10
00423816  
0042381d  uint32_t eax_6 = arg1
00423834  *(eax_6 + 8) = (not.d(*arg2) & 1) << 4 | (*(eax_6 + 8) & 0xffffffef)
00423839  uint32_t eax_7 = arg1
0042384b  *(eax_7 + 8) = (not.d(*arg2) & 4) << 1 | (*(eax_7 + 8) & 0xfffffff7)
00423850  uint32_t eax_8 = arg1
00423862  *(eax_8 + 8) = (not.d(*arg2) u>> 1 & 4) | (*(eax_8 + 8) & 0xfffffffb)
00423867  uint32_t eax_9 = arg1
00423879  *(eax_9 + 8) = (not.d(*arg2) u>> 3 & 2) | (*(eax_9 + 8) & 0xfffffffd)
0042387e  uint32_t eax_10 = arg1
00423890  *(eax_10 + 8) = (not.d(*arg2) u>> 5 & 1) | (*(eax_10 + 8) & 0xfffffffe)
00423893  char eax_11 = sub_423ebf()
00423893  
0042389a  if ((1 & eax_11) != 0)
0042389c      uint32_t ecx_28 = arg1
0042389f      *(ecx_28 + 0xc) |= 0x10
0042389f  
004238a5  if ((eax_11 & 4) != 0)
004238a7      uint32_t ecx_29 = arg1
004238aa      *(ecx_29 + 0xc) |= 8
004238aa  
004238b0  if ((eax_11 & 8) != 0)
004238b2      uint32_t ecx_30 = arg1
004238b5      *(ecx_30 + 0xc) |= 4
004238b5  
004238bb  if ((eax_11 & 0x10) != 0)
004238bd      uint32_t ecx_31 = arg1
004238c0      *(ecx_31 + 0xc) |= 2
004238c0  
004238c5  if ((eax_11 & 0x20) != 0)
004238c7      uint32_t eax_12 = arg1
004238ca      *(eax_12 + 0xc) |= 1
004238ca  
004238d4  int32_t eax_14 = *arg2 & 0xc00
004238d4  
004238d6  if (eax_14 == 0)
0042390c      uint32_t eax_17 = arg1
0042390f      *eax_17 &= 0xfffffffc
004238d6  else
004238dd      uint32_t eax_16
004238dd      
004238dd      if (eax_14 == 0x400)
004238fe          eax_16 = arg1
00423908          *eax_16 = (*eax_16 & 0xfffffffd) | 1
004238dd      else if (eax_14 == 0x800)
004238f2          eax_16 = arg1
00423908          *eax_16 = (*eax_16 & 0xfffffffe) | 2
004238e4      else if (eax_14 == 0xc00)
004238ea          uint32_t eax_15 = arg1
004238ed          *eax_15 |= 3
004238ed  
00423919  int32_t eax_19 = *arg2 & 0x300
0042391b  uint32_t eax_21
0042391b  
0042391b  if (eax_19 == 0)
0042393d      eax_21 = arg1
00423948      *eax_21 = (*eax_21 & 0xffffffeb) | 8
0042391b  else if (eax_19 == 0x200)
00423930      eax_21 = arg1
00423948      *eax_21 = (*eax_21 & 0xffffffe7) | 4
00423922  else if (eax_19 == 0x300)
00423928      uint32_t eax_20 = arg1
0042392b      *eax_20 &= 0xffffffe3
0042394a  uint32_t eax_22 = arg1
00423963  *eax_22 = (arg4 & 0xfff) << 5 | (*eax_22 & 0xfffe001f)
00423965  uint32_t eax_23 = arg1
00423968  *(eax_23 + 0x20) |= 1
0042396b  uint32_t eax_24 = arg1
00423976  *(eax_24 + 0x20) = (*(eax_24 + 0x20) & 0xffffffe3) | 2
00423981  *(arg1 + 0x10) = fconvert.d(fconvert.t(*arg5))
00423984  uint32_t eax_27 = arg1
00423987  *(eax_27 + 0x50) |= 1
0042398a  uint32_t eax_28 = arg1
00423998  *(eax_28 + 0x50) = (*(eax_28 + 0x50) & 0xffffffe3) | 2
004239a0  *(arg1 + 0x40) = fconvert.d(fconvert.t(*arg6))
004239a3  sub_423ecd()
004239b2  RaiseException(dwExceptionCode: arg3.d, dwExceptionFlags: 0, nNumberOfArguments: 1, 
004239b2      lpArguments: &arg1)
004239b2  noreturn

004239b8                                                                          8b 45 08 f6 40 08 10 74                          .E..@..t
004239c0  03 83 26 fe f6 40 08 08 74 03 83 26 fb f6 40 08 04 74 03 83 26 f7 f6 40 08 02 74 03 83 26 ef 84  ..&..@..t..&..@..t..&..@..t..&..
004239e0  58 08 74 03 83 26 df 8b 08 ba ff f3 ff ff 83 e1 03 83 e9 00 74 25 49 74 16 49 74 09 49 75 1e 80  X.t..&..............t%It.It.Iu..
00423a00  4e 01 0c eb 18 8b 0e 80 e5 fb 80 cd 08 eb 08 8b 0e 80 e5 f7 80 cd 04 89 0e eb 02 21 16 8b 08 c1  N..........................!....
00423a20  e9 02 83 e1 07 83 e9 00 74 13 49 74 07 49 75 16 21 16 eb 12 8b 0e 23 ca 80 cd 02 eb 07 8b 0e 23  ........t.It.Iu.!.....#........#
00423a40  ca 80 cd 03 89 0e dd 40 40 dd 1f 5f 5e 5b 5d c3                                                  .......@@.._^[].

00423a50    int32_t sub_423a50(int32_t arg1, double* arg2, char arg3)

00423a5d  int32_t edi_1 = arg1 & 0x1f
00423a6a  long double st0
00423a6a  int80_t x87_r0
00423a6a  
00423a6a  if ((arg1.b & 8) != 0 && (arg3 & 1) != 0)
00423a6d      sub_423eff(x87_r0, 1)
00423a73      edi_1 &= 0xfffffff7
00423a6a  else if ((arg1.b & 4) != 0 && (arg3 & 4) != 0)
00423a87      sub_423eff(x87_r0, 4)
00423a8d      edi_1 &= 0xfffffffb
00423a83  else if ((1 & arg1.b) != 0 && (arg3 & 8) != 0)
00423aa9      sub_423eff(x87_r0, 8)
00423ab7      int32_t ecx_4 = arg3.d & 0xc00
00423ab9      int16_t eax_1
00423ab9      
00423ab9      if (ecx_4 == 0)
00423b4a          long double x87_r0_10 = fconvert.t(*arg2)
00423b4c          long double temp0_1 = fconvert.t(0.0)
00423b4c          x87_r0_10 - temp0_1
00423b52          long double x87_r0_11 = fconvert.t(data_42fb90)
00423b58          eax_1 = (x87_r0_10 < temp0_1 ? 1 : 0) << 8
00423b58              | (is_unordered.t(x87_r0_10, temp0_1) ? 1 : 0) << 0xa
00423b58              | (x87_r0_10 == temp0_1 ? 1 : 0) << 0xe
00423b58          
00423b5b          if (test_bit(eax_1:1.b, 6) || test_bit(eax_1:1.b, 0))
00423b5d              x87_r0_11 = fneg(x87_r0_11)
00423b5d          
00423b65          *arg2 = fconvert.d(fconvert.t(fconvert.d(x87_r0_11)))
00423ab9      else if (ecx_4 == 0x400)
00423b22          long double x87_r0_7 = fconvert.t(*arg2)
00423b24          long double temp2_1 = fconvert.t(0.0)
00423b24          x87_r0_7 - temp2_1
00423b2a          eax_1 = (x87_r0_7 < temp2_1 ? 1 : 0) << 8
00423b2a              | (is_unordered.t(x87_r0_7, temp2_1) ? 1 : 0) << 0xa
00423b2a              | (x87_r0_7 == temp2_1 ? 1 : 0) << 0xe | 0x800
00423b2d          long double x87_r0_8
00423b2d          
00423b2d          if (test_bit(eax_1:1.b, 6) || test_bit(eax_1:1.b, 0))
00423b3d              x87_r0_8 = fneg(fconvert.t(data_42fb90))
00423b2d          else
00423b2f              x87_r0_8 = fconvert.t(data_42fba0)
00423b2f          
00423b65          *arg2 = fconvert.d(fconvert.t(fconvert.d(x87_r0_8)))
00423ac5      else if (ecx_4 == 0x800)
00423afa          long double x87_r0_4 = fconvert.t(*arg2)
00423afc          long double temp3_1 = fconvert.t(0.0)
00423afc          x87_r0_4 - temp3_1
00423b02          eax_1 = (x87_r0_4 < temp3_1 ? 1 : 0) << 8
00423b02              | (is_unordered.t(x87_r0_4, temp3_1) ? 1 : 0) << 0xa
00423b02              | (x87_r0_4 == temp3_1 ? 1 : 0) << 0xe | 0x800
00423b05          long double x87_r0_5
00423b05          
00423b05          if (test_bit(eax_1:1.b, 6) || test_bit(eax_1:1.b, 0))
00423b15              x87_r0_5 = fneg(fconvert.t(data_42fba0))
00423b05          else
00423b07              x87_r0_5 = fconvert.t(data_42fb90)
00423b07          
00423b65          *arg2 = fconvert.d(fconvert.t(fconvert.d(x87_r0_5)))
00423acd      else if (ecx_4 == 0xc00)
00423ada          long double x87_r0_1 = fconvert.t(*arg2)
00423adc          long double temp5_1 = fconvert.t(0.0)
00423adc          x87_r0_1 - temp5_1
00423ae2          long double x87_r0_2 = fconvert.t(data_42fba0)
00423ae8          eax_1 = (x87_r0_1 < temp5_1 ? 1 : 0) << 8
00423ae8              | (is_unordered.t(x87_r0_1, temp5_1) ? 1 : 0) << 0xa
00423ae8              | (x87_r0_1 == temp5_1 ? 1 : 0) << 0xe
00423ae8          
00423aeb          if (test_bit(eax_1:1.b, 6) || test_bit(eax_1:1.b, 0))
00423aed              x87_r0_2 = fneg(x87_r0_2)
00423aed          
00423b65          *arg2 = fconvert.d(fconvert.t(fconvert.d(x87_r0_2)))
00423b67      edi_1 &= 0xfffffffe
00423aa1  else if ((arg1.b & 2) != 0 && (arg3 & 0x10) != 0)
00423b82      int32_t esi_1 = 0
00423b82      
00423b86      if ((arg1.b & 0x10) != 0)
00423b88          esi_1 = 1
00423b88      
00423b8f      double var_10_5 = fconvert.d(fconvert.t(*arg2))
00423b92      long double x87_r7_2 = fconvert.t(var_10_5)
00423b95      long double temp1_1 = fconvert.t(0.0)
00423b95      x87_r7_2 - temp1_1
00423b9b      double* eax_2
00423b9b      eax_2.w = (x87_r7_2 < temp1_1 ? 1 : 0) << 8
00423b9b          | (is_unordered.t(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
00423b9b          | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe
00423b9b      
00423b9e      if (test_bit(eax_2:1.b, 6))
00423c33          esi_1 = 1
00423b9e      else
00423bab          int32_t ecx
00423bab          int32_t var_24_1 = ecx
00423bac          int32_t var_28_1 = ecx
00423bad          var_28_1.q = fconvert.d(fconvert.t(var_10_5))
00423bb0          int32_t var_8
00423bb0          st0 = sub_423dfe(esi_1, var_28_1, &var_8)
00423bbb          double var_10_6 = fconvert.d(st0)
00423bbb          
00423bca          if (var_8 - 0x600 s>= 0xfffffbce)
00423bd5              long double x87_r7_6 = fconvert.t(var_10_6)
00423bd8              long double temp4_1 = fconvert.t(0.0)
00423bd8              x87_r7_6 - temp4_1
00423bde              int32_t eax_3
00423bde              eax_3.w = (x87_r7_6 < temp4_1 ? 1 : 0) << 8
00423bde                  | (is_unordered.t(x87_r7_6, temp4_1) ? 1 : 0) << 0xa
00423bde                  | (x87_r7_6 == temp4_1 ? 1 : 0) << 0xe
00423be1              int32_t edx_1
00423be1              
00423be1              if (not(test_bit(eax_3:1.b, 0)))
00423be7                  edx_1 = 0
00423be1              else
00423be3                  edx_1 = 1
00423be3              
00423be9              eax_3.b = var_10_6:6.b
00423bef              int16_t eax_4
00423bef              eax_4.b = (eax_3.w & 0xf).b | 0x10
00423bf1              var_10_6:6.w = eax_4
00423bf1              
00423bfc              if (var_8 - 0x600 s< 0xfffffc03)
00423bfe                  int32_t i_1 = 0xfffffc03 - (var_8 - 0x600)
00423c1b                  int32_t i
00423c1b                  
00423c1b                  do
00423c07                      if ((var_10_6.b & 1) != 0 && esi_1 == 0)
00423c09                          esi_1 = 1
00423c09                      
00423c0b                      var_10_6.d u>>= 1
00423c0b                      
00423c11                      if ((var_10_6:4.b & 1) != 0)
00423c13                          var_10_6:3.b |= 0x80
00423c13                      
00423c17                      var_10_6:4.d u>>= 1
00423c1a                      i = i_1
00423c1a                      i_1 -= 1
00423c1b                  while (i != 1)
00423c1b              
00423c1f              if (edx_1 != 0)
00423c26                  var_10_6 = fconvert.d(fneg(fconvert.t(var_10_6)))
00423bca          else
00423bce              esi_1 = 1
00423bd0              var_10_6 = fconvert.d(float.t(0))
00423bd0          
00423c2f          *arg2 = fconvert.d(fconvert.t(var_10_6))
00423c2f      
00423c38      if (esi_1 != 0)
00423c3c          sub_423eff(x87_r0, 0x10)
00423c3c      
00423c42      edi_1 &= 0xfffffffd
00423c42  
00423c4f  if ((arg1.b & 0x10) != 0 && (arg3 & 0x20) != 0)
00423c53      sub_423eff(st0, 0x20)
00423c59      edi_1 &= 0xffffffef
00423c59  
00423c62  int32_t result
00423c62  result.b = edi_1 == 0
00423c66  return result


00423c67    long double sub_423c67(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, double arg7, int32_t arg8)

00423c70  int32_t eax = sub_423d17(arg2)
00423c78  int32_t var_20 = eax
00423c7b  int16_t x87control
00423c7b  
00423c7b  if (eax == 0)
00423cda      sub_423edc(x87control, arg8, 0xffff)
00423ce2      sub_423cef(arg1)
00423cee      return fconvert.t(arg7)
00423cee  
00423c81  int32_t var_1c = arg3
00423c87  int32_t var_18 = arg4
00423c90  int32_t var_14 = arg5
00423c9e  int32_t var_10 = arg6
00423ca4  void* var_24 = arg1
00423cad  int32_t var_8 = arg7:4.d
00423cb0  sub_423edc(x87control, arg8, 0xffff)
00423cb8  int32_t* var_34 = &var_24
00423cc6  sub_423cef(arg1)
00423cd1  return fconvert.t(arg7.d.q)


00423cef    void* sub_423cef(void* arg1)

00423cef  void* eax_1 = arg1
00423cef  
00423cf6  if (eax_1 == 1)
00423d0b      eax_1 = sub_41e9bd()
00423d10      *eax_1 = 0x21
00423cf6  else if (eax_1 s> 1 && eax_1 s<= 3)
00423cff      void* eax = sub_41e9bd()
00423d04      *eax = 0x22
00423d0a      return eax
00423d0a  
00423d16  return eax_1


00423d17    int32_t sub_423d17(int32_t arg1)

00423d17  int32_t ecx = 0
00423d17  
00423d2f  for (void* i = &data_42fab8; i s< &data_42fb90; )
00423d24      if (*i == arg1)
00423d3b          return *((ecx << 3) + &data_42fabc)
00423d3b      
00423d26      i += 8
00423d29      ecx += 1
00423d29  
00423d33  return 0


00423d3c    int32_t sub_423d3c(char arg1) __pure

00423d42  if ((arg1 & 0x20) != 0)
00423d44      return 5
00423d44  
00423d4a  if ((arg1 & 8) != 0)
00423d4c      return 1
00423d4c  
00423d52  if ((arg1 & 4) != 0)
00423d54      return 2
00423d54  
00423d5a  if ((arg1 & 1) == 0)
00423d68      return (zx.d(arg1) & 2) << 1
00423d68  
00423d5c  return 3


00423d69    long double __frnd(double arg1) __pure

00423d6c  int32_t ecx
00423d6c  int32_t var_8 = ecx
00423d6d  int32_t var_c = ecx
00423d73  var_c.q = fconvert.d(roundint.t(fconvert.t(arg1)))
00423d7a  return fconvert.t(var_c.q)


00423d7b    long double sub_423d7b(double arg1, int16_t arg2, int32_t arg3) __pure

00423d7e  int32_t ecx
00423d7e  int32_t var_8 = ecx
00423d7f  int32_t var_c = ecx
00423d93  var_c.q = fconvert.d(fconvert.t(arg1))
00423d9b  var_8:2.w = ((arg3 + 0x3fe) << 4).w | (arg2 & 0x800f)
00423da3  return fconvert.t(var_c.q)


00423da4    int32_t sub_423da4(int32_t arg1, int32_t arg2) __pure

00423db0  if (arg2 != 0x7ff00000)
00423dc7      if (arg2 == 0xfff00000 && arg1 == 0)
00423dc9          return 2
00423db0  else if (arg1 == 0)
00423db7      return 1
00423db7  
00423dd5  int16_t ecx_2 = arg2:2.w & 0x7ff8
00423dd5  
00423dda  if (ecx_2 == 0x7ff8)
00423ddc      return 3
00423ddc  
00423df3  if (ecx_2 == 0x7ff0 && ((arg2 & 0x7ffff) != 0 || arg1 != 0))
00423df5      return 4
00423df5  
00423dfd  return 0


00423dfe    long double sub_423dfe(int32_t arg1 @ esi, double arg2, int32_t* arg3)

00423e01  int32_t ecx
00423e01  int32_t var_8 = ecx
00423e02  int32_t var_c = ecx
00423e03  long double x87_r7 = fconvert.t(arg2)
00423e06  long double temp0 = fconvert.t(0.0)
00423e06  x87_r7 - temp0
00423e10  int32_t esi
00423e10  
00423e10  if (test_bit(
00423e10          ((x87_r7 < temp0 ? 1 : 0) << 8 | (is_unordered.t(x87_r7, temp0) ? 1 : 0) << 0xa
00423e10              | (x87_r7 == temp0 ? 1 : 0) << 0xe):1.b, 
00423e10          6))
00423e14      esi = 0
00423e16      var_c.q = fconvert.d(float.t(0))
00423e10  else if ((arg2:6.w & 0x7ff0) != 0 || ((arg2:4.d & 0xfffff) == 0 && arg2.d == 0))
00423e91      int32_t var_18_2 = 0
00423ea1      var_c.q = fconvert.d(sub_423d7b(0f, 0, arg1))
00423eae      esi = sx.d((arg2:6.d u>> 4).w & 0x7ff) - 0x3fe
00423e34  else
00423e36      long double x87_r7_2 = fconvert.t(arg2)
00423e39      long double temp1_1 = fconvert.t(0.0)
00423e39      x87_r7_2 - temp1_1
00423e3f      esi = 0xfffffc03
00423e47      int32_t eax_1
00423e47      
00423e47      if (not(test_bit(
00423e47              ((x87_r7_2 < temp1_1 ? 1 : 0) << 8
00423e47                  | (is_unordered.t(x87_r7_2, temp1_1) ? 1 : 0) << 0xa
00423e47                  | (x87_r7_2 == temp1_1 ? 1 : 0) << 0xe):1.b, 
00423e47              0)))
00423e4e          eax_1 = 0
00423e47      else
00423e4b          eax_1 = 1
00423e4b      
00423e54      while ((arg2:6.b & 0x10) == 0)
00423e56          arg2:4.d <<= 1
00423e56          
00423e5d          if ((arg2:3.b & 0x80) != 0)
00423e5f              arg2:4.d |= 1
00423e5f          
00423e63          arg2.d <<= 1
00423e66          esi -= 1
00423e66      
00423e69      arg2:6.w &= 0xffef
00423e69      
00423e71      if (eax_1 != 0)
00423e73          arg2:7.b |= 0x80
00423e73      
00423e7b      int32_t var_18_1 = 0
00423e85      var_c.q = fconvert.d(sub_423d7b(0f, 0, arg1))
00423e85  
00423eba  *arg3 = esi
00423ebe  return fconvert.t(var_c.q)


00423ebf    int32_t sub_423ebf() __pure

00423ec2  int32_t ecx
00423ec2  int32_t var_8 = ecx
00423ec4  bool c0
00423ec4  bool c1
00423ec4  bool c2
00423ec4  bool c3
00423ec4  var_8:2.w =
00423ec4      (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe
00423ecc  return sx.d(var_8:2.w)


00423ecd    int32_t sub_423ecd()

00423ed0  int32_t ecx
00423ed0  int32_t var_8 = ecx
00423ed1  bool c0
00423ed1  bool c1
00423ed1  bool c2
00423ed1  bool c3
00423ed1  var_8:2.w =
00423ed1      (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa | (c3 ? 1 : 0) << 0xe
00423ed4  __fnclex()
00423edb  return sx.d(var_8:2.w)


00423edc    int32_t sub_423edc(int16_t arg1 @ x87control, int32_t arg2, int32_t arg3)

00423edf  int32_t ecx
00423edf  int32_t var_8 = ecx
00423ee1  int16_t x87status
00423ee1  int16_t temp0
00423ee1  temp0, x87status = __fnstcw_memmem16(arg1)
00423ee1  var_8.w = temp0
00423ef6  int16_t x87control
00423ef6  int16_t x87status_1
00423ef6  x87control, x87status_1 = __fldcw_memmem16(((not.d(arg3) & var_8) | (arg3 & arg2)).w)
00423efe  return sx.d(var_8.w)


00423eff    void sub_423eff(int80_t arg1 @ st0, char arg2)

00423f02  int32_t ecx
00423f02  int32_t var_8 = ecx
00423f03  int32_t var_c = ecx
00423f04  ecx.b = arg2
00423f0a  int16_t top
00423f0a  bool c1
00423f0a  
00423f0a  if ((ecx.b & 1) != 0)
00423f0c      data_42fbb8
00423f12      arg2.d = int.d(arg1)
00423f12      top = 1
00423f12      c1 = unimplemented  {fistp dword [ebp+0x8], st0}
00423f12  
00423f19  if ((ecx.b & 8) != 0)
00423f1c      int32_t eax
00423f1c      bool c0
00423f1c      bool c2
00423f1c      bool c3
00423f1c      eax.w = (c0 ? 1 : 0) << 8 | (c1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa
00423f1c          | (c3 ? 1 : 0) << 0xe | (top & 7) << 0xb
00423f1e      unimplemented  {fld st0, tword [&data_42fbb8]}
00423f24      int64_t temp1_1 = unimplemented  {fstp qword [ebp-0x8], st0}
00423f24      unimplemented  {fstp qword [ebp-0x8], st0}
00423f24      var_c.q = fconvert.d(temp1_1)
00423f24      bool c1_1 = unimplemented  {fstp qword [ebp-0x8], st0}
00423f29      eax.w = (c0 ? 1 : 0) << 8 | (c1_1 ? 1 : 0) << 9 | (c2 ? 1 : 0) << 0xa
00423f29          | (c3 ? 1 : 0) << 0xe | (top & 7) << 0xb
00423f29  
00423f2e  if ((ecx.b & 0x10) != 0)
00423f30      unimplemented  {fld st0, tword [&data_42fbc4]}
00423f36      var_c.q = fconvert.d(unimplemented  {fstp qword [ebp-0x8], st0})
00423f36      unimplemented  {fstp qword [ebp-0x8], st0}
00423f36  
00423f3d  if ((ecx.b & 4) != 0)
00423f3f      unimplemented  {fldz }
00423f41      unimplemented  {fld1 }
00423f43      unimplemented  {fdivrp st1, st0}
00423f43      unimplemented  {fdivrp st1, st0}
00423f45      unimplemented  {fstp st0, st0}
00423f45      unimplemented  {fstp st0, st0}
00423f45  
00423f4b  if ((ecx.b & 0x20) != 0)
00423f4d      unimplemented  {fldpi }
00423f4f      var_c.q = fconvert.d(unimplemented  {fstp qword [ebp-0x8], st0})
00423f4f      unimplemented  {fstp qword [ebp-0x8], st0}


00423f55    int32_t sub_423f55(void* arg1, char* arg2)

00423f64  int32_t edi
00423f64  int32_t var_1c = edi
00423f65  int32_t eax
00423f65  int32_t ecx
00423f65  int32_t edx
00423f65  
00423f65  if (data_282363c == 0)
004240e9      return sub_426fe0(eax, edx, ecx, arg1, arg2)
00423f7b  sub_421919(0x19)
00423f80  char* esi_1 = arg2
00423f84  char* ecx_2 = arg1
00423f8f  void* var_10_1 = &esi_1[0xffffffff]
00423f95  int32_t var_c_1 = &ecx_2[0xffffffff]
00423f95  
00423f98  while (true)
00423f98      int32_t eax_3
00423f98      eax_3.w = zx.w(*ecx_2)
00423fa0      var_c_1 += 1
00423faa      arg1 = &ecx_2[1]
00423faa      
00423fad      if ((*(zx.d(eax_3.b) + 0x2823741) & 4) == 0)
00424006          eax_3 = zx.d(eax_3.w)
00424009          void* ecx_3
00424009          ecx_3.b = *(eax_3 + 0x2823741)
0042400f          ecx_3.b &= 0x10
0042400f          
00424015          if (ecx_3.b != 0x10)
00424021              edi = eax_3
00424015          else
00424017              edi.w = zx.w(*(eax_3 + 0x2823640))
00424017          
00424015          goto label_424023
00424015      
00423fb2      char var_8
00423fb2      char var_7
00423fb2      
00423fb2      if (ecx_2[1] != 0)
00423fd2          eax_3 = sub_4233fa(data_2823844, 0x200, var_c_1, 2, &var_8, 2, data_2823620, 1)
00423fd2          
00423fdd          if (eax_3 == 1)
00423fdf              edi.w = zx.w(var_8)
00423ffe              label_423ffe:
00423ffe              arg1 += 1
00424001              var_c_1 += 1
00424004              goto label_424023
00424004          
00423fe9          if (eax_3 == 2)
00423fef              edi.w = zx.w(var_8)
00423ff4              eax_3.w = zx.w(var_7)
00423ffc              edi = (edi << 8) + eax_3
00423ffc              goto label_423ffe
00423fb2      else
00423fb4          edi = 0
00424023          label_424023:
00424023          eax_3.w = zx.w(*esi_1)
0042402b          var_10_1 += 1
00424035          arg2 = &esi_1[1]
00424038          void* esi_2
00424038          
00424038          if ((*(zx.d(eax_3.b) + 0x2823741) & 4) == 0)
0042408d              esi_2 = zx.d(eax_3.w)
00424090              eax_3.b = *(esi_2 + 0x2823741)
00424096              eax_3.b &= 0x10
00424096              
0042409a              if (eax_3.b == 0x10)
0042409c                  esi_2.w = zx.w(*(esi_2 + 0x2823640))
0042409c              
0042409a              goto label_4240a4
0042409a          
0042403d          if (esi_1[1] != 0)
0042405d              eax_3 =
0042405d                  sub_4233fa(data_2823844, 0x200, var_10_1, 2, &var_8, 2, data_2823620, 1)
0042405d              
00424068              if (eax_3 == 1)
0042406a                  esi_2.w = zx.w(var_8)
00424085                  label_424085:
00424085                  arg2 = &arg2[1]
00424088                  var_10_1 += 1
0042408b                  goto label_4240a4
0042408b              
00424074              if (eax_3 == 2)
00424076                  esi_2.w = zx.w(var_8)
0042407b                  eax_3.w = zx.w(var_7)
00424083                  esi_2 = (esi_2 << 8) + eax_3
00424083                  goto label_424085
0042403d          else
0042403f              esi_2 = nullptr
004240a4              label_4240a4:
004240a4              
004240a7              if (edi.w != esi_2.w)
004240ca                  int32_t eax_4 = sub_42197a(0x19)
004240d8                  return (sbb.d(eax_4, eax_4, esi_2.w u< edi.w) & 2) - 1
004240d8              
004240ac              if (edi.w == 0)
004240ac                  break
004240ac              
004240ae              esi_1 = arg2
004240b1              ecx_2 = arg1
004240b4              continue
004240bb      sub_42197a(0x19)
004240c1      return 0x7fffffff
004240c1  
004240dd  sub_42197a(0x19)
004240e3  return 0


004240ea    char* sub_4240ea(char* arg1, int32_t arg2)

004240ee  char* result = nullptr
004240ee  
004240f6  if (data_282363c == 0)
0042415b      return sub_4270b0(arg1, arg2.b)
0042415b  
0042410a  sub_421919(0x19)
00424110  char* result_1 = arg1
0042414c  char i
0042414c  
0042414c  do
00424113      i = *result_1
00424115      uint32_t i_1 = zx.d(i)
00424122      bool cond:0_1
00424122      
00424122      if ((*(zx.d(i_1.b) + 0x2823741) & 4) == 0)
00424142          cond:0_1 = arg2 != i_1
00424145          label_424145:
00424145          
00424145          if (not(cond:0_1))
00424147              result = result_1
00424122      else
00424124          i = result_1[1]
00424127          result_1 = &result_1[1]
00424127          
0042412a          if (i == 0)
0042413e              cond:0_1 = result != 0
00424140              goto label_424145
00424140          
00424137          if (arg2 == (i_1 << 8 | zx.d(i)))
00424139              result = &result_1[0xffffffff]
00424149      result_1 = &result_1[1]
0042414c  while (i != 0)
00424150  sub_42197a(0x19)
00424156  return result


0042415c    void* sub_42415c(void* arg1, PSTR arg2, int32_t* arg3)

00424160  PSTR lpFileName = arg2
00424160  
0042416f  if (lpFileName == 0 || *lpFileName == 0)
00424200      return sub_4270d7(arg1, arg3)
00424200  
00424171  void* lpBuffer = arg1
00424171  
00424176  if (lpBuffer != 0)
00424176      goto label_4241a6
00424176  
00424182  lpBuffer = sub_41e583(0x104)
00424182  
00424187  if (lpBuffer != 0)
00424196      arg3 = 0x104
004241a6      label_4241a6:
004241a6      uint32_t eax_3 =
004241a6          GetFullPathNameA(lpFileName, nBufferLength: arg3, lpBuffer, lpFilePart: &arg2)
004241a6      
004241af      if (eax_3 u< arg3)
004241cd          if (eax_3 != 0)
004241ec              return lpBuffer
004241ec          
004241d2          if (arg1 == eax_3)
004241d5              sub_41e29e(lpBuffer)
004241d5          
004241e2          sub_41e94a(GetLastError())
004241af      else
004241b5          if (arg1 == 0)
004241b8              sub_41e29e(lpBuffer)
004241b8          
004241c3          *sub_41e9bd() = 0x22
00424187  else
0042418e      *sub_41e9bd() = 0xc
0042418e  
004241e8  return nullptr


00424201    int32_t sub_424201()

0042422a  uint8_t buffer
0042422a  char var_107
0042422a  
0042422a  if (GetCurrentDirectoryA(nBufferLength: 0x104, lpBuffer: &buffer) != 0 && var_107 == 0x3a)
0042423c      return sub_41e9cf(zx.d(buffer)) - 0x40
0042423c  
00424243  return 0


00424244    uint32_t __fastcall sub_424244(int32_t arg1)

00424247  int32_t var_8 = arg1
00424249  uint32_t result_1
00424249  uint32_t result = result_1
00424249  
00424252  if (result u> 0xff)
00424256      result_1:3.b = result.b
00424259      uint8_t eax_2 = (result u>> 8).b
0042425c      result_1:2.b = eax_2
0042425c      
00424269      if ((*(zx.d(eax_2) + 0x2823741) & 4) != 0 &&
00424269              sub_4233fa(data_2823844, 0x100, &result_1:2, 2, &var_8, 2, data_2823620, 1) != 0)
004242a1          return (zx.d(var_8.b) << 8) + zx.d(var_8:1.b)
00424252  else if ((*(result + 0x2823741) & 0x10) == 0x10)
004242b1      return zx.d(*(result + 0x2823640))
004242b1  
004242ba  return result


004242bf    void* sub_4242bf(char* arg1, char* arg2)

004242c8  if (data_282363c == 0)
004242da      return sub_426fa0(arg1, arg2)
004242da  
004242de  sub_421919(0x19)
004242e3  char* esi = arg1
004242e3  
004242ea  while (*esi != 0)
004242f3      char* eax_2 = arg2
004242f3      
004242f5      if (*arg2 != 0)
00424324          do
004242f7              void* ecx_1
004242f7              ecx_1.b = *eax_2
004242f7              
00424303              if ((*(zx.d(ecx_1.b) + 0x2823741) & 4) != 0)
00424307                  if (ecx_1.b == *esi)
00424309                      ecx_1.b = eax_2[1]
00424309                      
0042430f                      if (ecx_1.b == esi[1])
0042430f                          break
0042430f                  
00424317                  if (eax_2[1] == 0)
00424317                      break
00424317                  
00424319                  eax_2 = &eax_2[1]
00424303              else if (ecx_1.b == *esi)
0042431f                  break
0042431f              
00424321              eax_2 = &eax_2[1]
00424324          while (*eax_2 != 0)
00424324      
00424328      if (*eax_2 != 0)
00424328          break
00424328      
00424334      if ((*(zx.d(*esi) + 0x2823741) & 4) != 0)
00424336          esi = &esi[1]
00424336          
00424339          if (*esi == 0)
00424339              break
00424339      
0042433b      esi = &esi[1]
0042433b  
00424343  sub_42197a(0x19)
00424348  int32_t eax_4
00424348  eax_4.b = *esi
0042434b  char temp0 = eax_4.b
0042434b  eax_4.b = neg.b(eax_4.b)
00424353  return sbb.d(eax_4, eax_4, temp0 != 0) & esi


00424354    int32_t sub_424354(uint32_t arg1)

0042435f  sub_421919(0x19)
00424367  uint32_t CodePage = sub_424501(arg1)
00424379  int32_t result
00424379  
00424379  if (CodePage != data_2823620)
00424384      if (CodePage == 0)
004244e0          label_4244e0:
004244e0          sub_42457e()
00424384      else
0042438a          void* edx_1 = nullptr
0042438c          void* eax = &data_42fbd8
0042438c          
00424393          while (true)
00424393              if (*eax == CodePage)
00424409                  void* i = nullptr
0042441c                  int32_t esi_2 = edx_1 * 0x30
0042441f                  *__builtin_memset(s: 0x2823740, c: 0, n: 0x100) = 0
00424420                  char* ebx_1 = esi_2 + 0x42fbe8
00424420                  
00424463                  do
00424429                      char* ecx_2 = ebx_1
00424429                      
0042442b                      if (*ebx_1 != 0)
00424457                          do
0042442d                              edx_1.b = ecx_2[1]
0042442d                              
00424432                              if (edx_1.b == 0)
00424432                                  break
00424432                              
00424434                              uint32_t eax_2 = zx.d(*ecx_2)
00424437                              uint32_t edi_5 = zx.d(edx_1.b)
00424437                              
0042443c                              if (eax_2 u<= edi_5)
00424441                                  edx_1.b = *(i + 0x42fbd0)
00424441                                  
00424450                                  do
00424447                                      *(eax_2 + 0x2823741) |= edx_1.b
0042444d                                      eax_2 += 1
00424450                                  while (eax_2 u<= edi_5)
00424450                              
00424453                              ecx_2 = &ecx_2[2]
00424457                          while (*ecx_2 != 0)
00424457                      
00424459                      i += 1
0042445c                      ebx_1 = &ebx_1[8]
00424463                  while (i u< 4)
00424463                  
00424468                  data_282363c = 1
00424473                  data_2823620 = CodePage
00424478                  int32_t eax_4 = sub_42454b(CodePage)
00424488                  data_2823630 = *(esi_2 + 0x42fbdc)
00424488                  void* edi_6 = &data_2823634
00424488                  void* esi_4 = esi_2 + 0x42fbe0
00424489                  *edi_6 = *esi_4
0042448b                  data_2823844 = eax_4
00424490                  *(edi_6 + 4) = *(esi_4 + 4)
00424490                  break
00424490              
00424395              eax += 0x30
00424398              edx_1 += 1
00424398              
0042439e              if (eax s>= 0x42fcc8)
004243a5                  CPINFO cPInfo
004243a5                  BOOL eax_1
004243a5                  uint32_t edx_2
004243a5                  eax_1, edx_2 = GetCPInfo(CodePage, lpCPInfo: &cPInfo)
004243a5                  
004243b0                  if (eax_1 != 1)
004244de                      if (data_430ca8 != 0)
004244de                          goto label_4244e0
004244de                      
004244ef                      result = 0xffffffff
004244ef                      goto label_4244f4
004244ef                  
004243b8                  data_2823844 = 0
004243c7                  bool cond:2_1 = cPInfo.MaxCharSize u<= 1
004243cc                  *__builtin_memset(s: 0x2823740, c: 0, n: 0x100) = 0
004243cd                  data_2823620 = CodePage
004243cd                  
004243d3                  if (cond:2_1)
004244c4                      data_282363c = 0
004243d3                  else
004243dd                      if (cPInfo.LeadByte[0] != 0)
004243e3                          var_15
004243e3                          void* ecx_1 = &var_15
004243e3                          
00424499                          do
004243e6                              edx_2.b = *ecx_1
004243e6                              
004243ea                              if (edx_2.b == 0)
004243ea                                  break
004243ea                              
004243f9                              for (uint32_t i_1 = zx.d(*(ecx_1 - 1)); 
004243f9                                      i_1 u<= zx.d(edx_2.b); i_1 += 1)
004243ff                                  *(i_1 + 0x2823741) |= 4
004243ff                              
00424494                              ecx_1 += 2
00424499                          while (*(ecx_1 - 1) != 0)
00424499                      
004244ae                      for (void* i_2 = 1; i_2 u< 0xff; i_2 += 1)
004244a1                          *(i_2 + 0x2823741) |= 8
004244a1                      
004244b7                      data_2823844 = sub_42454b(CodePage)
004244bc                      data_282363c = 1
004244bc                  
004244d2                  data_2823630 = 0
004244d2                  void* edi_9 = &data_2823634
004244d3                  *edi_9 = 0
004244d4                  *(edi_9 + 4) = 0
004244d2                  goto label_4244e5
004244d2      
004244e5      label_4244e5:
004244e5      sub_4245a7()
004244e5  
0042437b  result = 0
004244f4  label_4244f4:
004244f4  sub_42197a(0x19)
00424500  return result


00424501    int32_t sub_424501(int32_t arg1)

00424501  int32_t result = arg1
00424505  data_430ca8 = 0
00424505  
0042450f  if (result == 0xfffffffe)
00424511      data_430ca8 = 1
0042451b      return GetOEMCP() __tailcall
0042451b  
00424524  if (result == 0xfffffffd)
00424526      data_430ca8 = 1
00424530      return GetACP() __tailcall
00424530  
00424539  if (result == 0xfffffffc)
0042453b      result = data_430c9c
00424540      data_430ca8 = 1
00424540  
0042454a  return result


0042454b    int32_t sub_42454b(int32_t arg1) __pure

00424554  if (arg1 == 0x3a4)
0042457d      return 0x411
0042457d  
00424559  if (arg1 == 0x3a8)
00424577      return 0x804
00424577  
0042455e  if (arg1 == 0x3b5)
00424571      return 0x412
00424571  
00424561  if (arg1 == 0x3b6)
0042456b      return 0x404
0042456b  
00424565  return 0


0042457e    int32_t sub_42457e()

0042458b  *__builtin_memset(s: 0x2823740, c: 0, n: 0x100) = 0
00424593  data_2823620 = 0
00424598  data_282363c = 0
0042459d  data_2823844 = 0
004245a2  data_2823630 = 0
004245a2  void* edi_2 = &data_2823634
004245a3  *edi_2 = 0
004245a4  *(edi_2 + 4) = 0
004245a6  return 0


004245a7    void* sub_4245a7()

004245c4  CPINFO cPInfo
004245c4  void* i
004245c4  
004245c4  if (GetCPInfo(CodePage: data_2823620, lpCPInfo: &cPInfo) != 1)
00424727      for (i = nullptr; i u< 0x100; i += 1)
004246ef          if (i u>= 0x41 && i u<= 0x5a)
004246f1              *(i + 0x2823741) |= 0x10
004246fd              *(i + 0x2823640) = i.b + 0x20
004246ef          else if (i u< 0x61 || i u> 0x7a)
0042471d              *(i + 0x2823640) = 0
0042470d          else
0042470f              *(i + 0x2823741) |= 0x20
004246fd              *(i + 0x2823640) = i.b - 0x20
004245c4  else
004245db      uint8_t var_118[0x100]
004245db      uint32_t i_1
004245db      
004245db      for (i_1 = 0; i_1 u< 0x100; i_1 += 1)
004245d1          var_118[i_1] = i_1.b
004245d1      
004245dd      i_1.b = cPInfo.LeadByte[0]
004245e0      var_118[0] = 0x20
004245e0      
004245e9      if (i_1.b != 0)
004245ed          var_11
004245ed          void* edx_1 = &var_11
004245ed          
0042461e          do
004245f0              uint32_t ecx_2 = zx.d(*edx_1)
004245f3              i_1 = zx.d(i_1.b)
004245f3              
004245f8              if (i_1 u<= ecx_2)
00424603                  int32_t ecx_4 = ecx_2 - i_1 + 1
00424615                  int32_t __saved_ebp
00424615                  __builtin_memset(
00424615                      s: __builtin_memset(s: &__saved_ebp + i_1 - 0x114, c: 0x20202020, 
00424615                          n: ecx_4 u>> 2 << 2), 
00424615                      c: 0x20, n: ecx_4 & 3)
00424615              
00424618              edx_1 += 2
00424619              i_1.b = *(edx_1 - 1)
0042461e          while (i_1.b != 0)
0042461e      
00424641      uint16_t var_518[0x100]
00424641      sub_426109(1, &var_118, 0x100, &var_518, data_2823620, data_2823844, 0)
00424665      char var_218[0x100]
00424665      sub_4233fa(data_2823844, 0x100, &var_118, 0x100, &var_218, 0x100, data_2823620, 0)
0042468d      char var_318[0x100]
0042468d      sub_4233fa(data_2823844, 0x200, &var_118, 0x100, &var_318, 0x100, data_2823620, 0)
00424695      i = nullptr
00424697      uint16_t (* ecx_8)[0x100] = &var_518
00424697      
004246dc      do
0042469d          uint8_t edx_3 = (*ecx_8).b
0042469d          
004246a3          if ((edx_3 & 1) != 0)
004246a5              *(i + 0x2823741) |= 0x10
004246b3              *(i + 0x2823640) = *(&var_218 + i)
004246a3          else if ((edx_3 & 2) == 0)
004246d0              *(i + 0x2823640) = 0
004246be          else
004246c0              *(i + 0x2823741) |= 0x20
004246b3              *(i + 0x2823640) = *(&var_318 + i)
004246b3          
004246d7          i += 1
004246d9          ecx_8 = &(*ecx_8)[1]
004246dc      while (i u< 0x100)
004246dc  
0042472b  return i


0042472c    void sub_42472c()

00424733  if (data_28249ac == 0)
00424737      sub_424354(0xfffffffd)
0042473d      data_28249ac = 1


00424748    char* sub_424748(char* arg1, void* arg2, int32_t arg3)

00424753  char* s = arg1
00424756  arg1 = s
00424756  
00424759  if (data_282363c == 0)
00424762      return sub_41e720(s, arg2, arg3)
00424762  
0042476f  sub_421919(0x19)
00424774  int32_t i = arg3
00424774  
0042477a  if (i != 0)
0042477c      void* ecx_2 = arg2
0042477c      
004247ab      do
0042477f          char eax_2 = *ecx_2
00424781          i -= 1
00424785          bool cond:2_1 = (*(zx.d(eax_2) + 0x2823741) & 4) == 0
0042478c          *s = eax_2
0042478c          
0042478e          if (cond:2_1)
004247a3              s = &s[1]
004247a4              ecx_2 += 1
004247a4              
004247a7              if (eax_2 == 0)
004247a7                  break
0042478e          else
00424790              s = &s[1]
00424790              
00424794              if (i == 0)
004247af                  s[0xffffffff] = 0
004247b3                  break
004247b3              
00424796              eax_2 = *(ecx_2 + 1)
00424798              i -= 1
00424799              *s = eax_2
0042479b              s = &s[1]
0042479c              ecx_2 += 2
0042479c              
0042479f              if (eax_2 == 0)
004247b5                  s[0xfffffffe] = 0
004247b5                  break
004247ab      while (i != 0)
004247ab  
004247bf  if (i != 0)
004247d2      __builtin_memset(s: __builtin_memset(s, c: 0, n: i u>> 2 << 2), c: 0, n: i & 3)
004247d2  
004247d6  sub_42197a(0x19)
004247e1  return arg1


004247e2    int32_t sub_4247e2(int32_t arg1, EXCEPTION_POINTERS* arg2)

004247e5  int32_t ecx
004247e5  int32_t var_8 = ecx
004247e8  void* eax = sub_423393()
004247f5  int32_t* eax_1 = sub_424920(arg1, *(eax + 0x50))
004247f5  
004247fe  if (eax_1 != 0)
00424804      int32_t ebx_1 = eax_1[2]
00424804      
0042480c      if (ebx_1 != 0)
00424815          if (ebx_1 == 5)
00424817              eax_1[2] = 0
0042481d              return 1
0042481d          
00424826          if (ebx_1 != 1)
0042482c              int32_t ecx_2 = *(eax + 0x54)
00424835              *(eax + 0x54) = arg2
00424838              int32_t ecx_4 = eax_1[1]
00424838              
0042483e              if (ecx_4 != 8)
00424900                  eax_1[2] = 0
00424905                  ebx_1(ecx_4)
0042483e              else
00424844                  int32_t i = data_42fd40
00424844                  
00424855                  if (i s< data_42fd44 + i)
0042485a                      int32_t ecx_8 = i * 0xc
0042485a                      
00424879                      do
00424860                          ecx_8 += 0xc
00424863                          *(ecx_8 + *(eax + 0x50) - 4) = 0
00424874                          i += 1
00424879                      while (i s< data_42fd44 + data_42fd40)
00424879                  
00424880                  int32_t edi_3 = *(eax + 0x58)
00424880                  
00424888                  switch (*eax_1)
004248c3                      case 0xc000008d
004248ca                          *(eax + 0x58) = 0x82
00424883                      case 0xc000008e
0042488a                          *(eax + 0x58) = 0x83
004248d3                      case 0xc000008f
004248da                          *(eax + 0x58) = 0x86
00424893                      case 0xc0000090
0042489a                          *(eax + 0x58) = 0x81
004248a3                      case 0xc0000091
004248aa                          *(eax + 0x58) = 0x84
004248e3                      case 0xc0000092
004248ea                          *(eax + 0x58) = 0x8a
004248b3                      case 0xc0000093
004248ba                          *(eax + 0x58) = 0x85
004248ba                  
004248f6                  ebx_1(8, *(eax + 0x58))
004248f9                  *(eax + 0x58) = edi_3
004248f9              
0042490b              *(eax + 0x54) = ecx_2
0042490b          
0042490e          return 0xffffffff
0042490e  
00424916  return UnhandledExceptionFilter(ExceptionInfo: arg2)


00424920    int32_t* sub_424920(int32_t arg1, int32_t* arg2)

00424924  int32_t ecx = data_42fd4c
00424932  int32_t* result = arg2
00424932  
00424934  if (*arg2 != arg1)
00424945      do
0042493c          result = &result[3]
0042493c          
00424941          if (result u>= &arg2[ecx * 3])
00424941              break
00424945      while (*result != arg1)
00424945  
00424953  if (result u< &arg2[ecx * 3] && *result == arg1)
00424959      return result
00424959  
00424955  return nullptr


0042495a    int32_t sub_42495a()

00424965  if (data_28249ac == 0)
00424967      sub_42472c()
00424967  
0042496c  char* esi = data_430bf8
00424972  int32_t edi = 0
00424972  
00424974  while (true)
00424974      void* eax
00424974      eax.b = *esi
00424974      
00424978      if (eax.b == 0)
00424978          break
00424978      
0042497c      if (eax.b != 0x3d)
0042497e          edi += 1
0042497e      
00424986      esi = esi + sub_422550(esi) + 1
00424986  
00424999  void* esi_1 = sub_41e583((edi << 2) + 4)
0042499e  data_430b94 = esi_1
0042499e  
004249a4  if (esi_1 == 0)
004249a8      sub_41f9c5(9)
004249a8  
004249ae  char* edi_1 = data_430bf8
004249ae  
004249b6  while (*edi_1 != 0)
004249c2      void* ebp_2 = sub_422550(edi_1) + 1
004249c2      
004249c6      if (*edi_1 != 0x3d)
004249c9          void* eax_4 = sub_41e583(ebp_2)
004249d1          *esi_1 = eax_4
004249d1          
004249d3          if (eax_4 == 0)
004249d7              sub_41f9c5(9)
004249d7          
004249e0          sub_4230a0(*esi_1, edi_1)
004249e6          esi_1 += 4
004249e6      
004249ea      edi_1 += ebp_2
004249ea  
004249f7  int32_t result = sub_41e29e(data_430bf8)
004249fd  data_430bf8 = 0
00424a03  *esi_1 = 0
00424a07  data_28249a8 = 1
00424a12  return result


00424a13    int32_t __fastcall sub_424a13(int32_t arg1)

00424a16  int32_t var_8 = arg1
00424a17  int32_t var_c = arg1
00424a17  
00424a23  if (data_28249ac == 0)
00424a25      sub_42472c()
00424a25  
00424a36  GetModuleFileNameA(hModule: nullptr, lpFilename: &data_430cac, nSize: 0x104)
00424a3c  char* eax = data_28249a4
00424a41  data_430ba4 = &data_430cac
00424a47  void* edi = &data_430cac
00424a47  
00424a4b  if (*eax != 0)
00424a4d      edi = eax
00424a4d  
00424a5a  sub_424aac(edi, nullptr, nullptr, &var_8, &var_c)
00424a69  void* eax_3 = sub_41e583(var_c + (var_8 << 2))
00424a69  
00424a75  if (eax_3 == 0)
00424a79      sub_41f9c5(8)
00424a79  
00424a90  sub_424aac(edi, eax_3, eax_3 + (var_8 << 2), &var_8, &var_c)
00424a9b  int32_t result = var_8 - 1
00424a9c  data_430b8c = eax_3
00424aa4  data_430b88 = result
00424aab  return result


00424aac    int32_t* sub_424aac(char* arg1, int32_t* arg2, char* arg3, int32_t* arg4, int32_t* arg5)

00424aaf  int32_t* ecx = arg5
00424ab7  *ecx = 0
00424aba  char* esi = arg3
00424abe  int32_t* edi = arg2
00424ac1  *arg4 = 1
00424ac7  char* eax_1 = arg1
00424ac7  
00424acc  if (edi != 0)
00424ace      *edi = esi
00424ad0      edi = &edi[1]
00424ad3      arg2 = edi
00424ad3  
00424ad9  uint32_t edx
00424ad9  
00424ad9  if (*eax_1 != 0x22)
00424b1f      while (true)
00424b1f          *ecx += 1
00424b1f          
00424b23          if (esi != 0)
00424b25              edx.b = *eax_1
00424b27              *esi = edx.b
00424b29              esi = &esi[1]
00424b29          
00424b2a          edx.b = *eax_1
00424b2c          eax_1 = &eax_1[1]
00424b2c          
00424b37          if ((*(zx.d(edx.b) + 0x2823741) & 4) != 0)
00424b39              *ecx += 1
00424b39              
00424b3d              if (esi != 0)
00424b3f                  uint32_t ebx_1
00424b3f                  ebx_1.b = *eax_1
00424b41                  *esi = ebx_1.b
00424b43                  esi = &esi[1]
00424b43              
00424b44              eax_1 = &eax_1[1]
00424b44          
00424b48          if (edx.b == 0x20)
00424b53              label_424b53:
00424b53              
00424b55              if (edx.b != 0)
00424b5c                  if (esi != 0)
00424b5e                      esi[0xffffffff] = 0
00424b5e                  
00424b5c                  break
00424b48          else if (edx.b != 0)
00424b51              if (edx.b == 9)
00424b51                  goto label_424b53
00424b51              
00424b51              continue
00424b51          
00424b57          eax_1 -= 1
00424b58          break
00424ad9  else
00424adb      while (true)
00424adb          edx.b = eax_1[1]
00424ade          eax_1 = &eax_1[1]
00424ade          
00424ae2          if (edx.b == 0x22)
00424ae2              break
00424ae2          
00424ae6          if (edx.b == 0)
00424ae6              break
00424ae6          
00424af2          if ((*(zx.d(edx.b) + 0x2823741) & 4) != 0)
00424af4              *ecx += 1
00424af4              
00424af8              if (esi != 0)
00424afa                  edx.b = *eax_1
00424afc                  *esi = edx.b
00424afe                  esi = &esi[1]
00424aff                  eax_1 = &eax_1[1]
00424aff          
00424b00          *ecx += 1
00424b00          
00424b04          if (esi != 0)
00424b06              edx.b = *eax_1
00424b08              *esi = edx.b
00424b0a              esi = &esi[1]
00424b0a      
00424b0d      *ecx += 1
00424b0d      
00424b11      if (esi != 0)
00424b13          *esi = 0
00424b16          esi = &esi[1]
00424b16      
00424b1a      if (*eax_1 == 0x22)
00424b1c          eax_1 = &eax_1[1]
00424b1c  
00424b62  arg5 = nullptr
00424b62  
00424b69  while (*eax_1 != 0)
00424b6f      while (true)
00424b6f          edx.b = *eax_1
00424b6f          
00424b79          if (edx.b != 0x20 && edx.b != 9)
00424b79              break
00424b79          
00424b7b          eax_1 = &eax_1[1]
00424b7b      
00424b81      if (*eax_1 == 0)
00424b81          break
00424b81      
00424b89      if (edi != 0)
00424b8b          *edi = esi
00424b8d          edi = &edi[1]
00424b90          arg2 = edi
00424b90      
00424b96      *arg4 += 1
00424b96      
00424b98      while (true)
00424b98          arg1 = 1
00424b9f          uint32_t i_2 = 0
00424b9f          
00424ba4          while (*eax_1 == 0x5c)
00424ba6              eax_1 = &eax_1[1]
00424ba7              i_2 += 1
00424ba7          
00424bad          if (*eax_1 == 0x22)
00424bb2              if ((i_2.b & 1) == 0)
00424bc2                  if (arg5 == 0 || eax_1[1] != 0x22)
00424bc8                      arg1 = nullptr
00424bc2                  else
00424bc4                      eax_1 = &eax_1[1]
00424bc4                  
00424bcb                  edi = arg2
00424bd3                  int32_t* edx_3
00424bd3                  edx_3.b = arg5 == 0
00424bd6                  arg5 = edx_3
00424bd6              
00424bd9              i_2 u>>= 1
00424bd9          
00424be0          if (i_2 != 0)
00424be2              int32_t i_1 = i_2
00424bee              int32_t i
00424bee              
00424bee              do
00424be5                  if (esi != 0)
00424be7                      *esi = 0x5c
00424bea                      esi = &esi[1]
00424bea                  
00424beb                  *ecx += 1
00424bed                  i = i_1
00424bed                  i_1 -= 1
00424bee              while (i != 1)
00424bee          
00424bf0          edx.b = *eax_1
00424bf0          
00424bf4          if (edx.b == 0)
00424bf4              break
00424bf4          
00424bfa          if (arg5 == 0)
00424bff              if (edx.b == 0x20)
00424bff                  break
00424bff              
00424c04              if (edx.b == 9)
00424c04                  break
00424c04          
00424c0a          if (arg1 != 0)
00424c0e              if (esi != 0)
00424c1a                  if ((*(zx.d(edx.b) + 0x2823741) & 4) != 0)
00424c1c                      *esi = edx.b
00424c1e                      esi = &esi[1]
00424c1f                      eax_1 = &eax_1[1]
00424c20                      *ecx += 1
00424c20                  
00424c22                  edx.b = *eax_1
00424c24                  *esi = edx.b
00424c26                  esi = &esi[1]
00424c0e              else if ((*(zx.d(edx.b) + 0x2823741) & 4) != 0)
00424c35                  eax_1 = &eax_1[1]
00424c36                  *ecx += 1
00424c36              
00424c38              *ecx += 1
00424c38          
00424c3a          eax_1 = &eax_1[1]
00424c3a      
00424c42      if (esi != 0)
00424c44          *esi = 0
00424c47          esi = &esi[1]
00424c47      
00424c48      *ecx += 1
00424c48  
00424c51  if (edi != 0)
00424c53      *edi = 0
00424c53  
00424c5c  *arg4 += 1
00424c5f  return arg4


00424c60    void* sub_424c60()

00424c60  int32_t ecx
00424c60  int32_t var_4 = ecx
00424c61  int32_t var_8 = ecx
00424c62  int32_t eax = data_430db0
00424c71  void* lpMultiByteStr_2 = nullptr
00424c73  PWSTR esi = nullptr
00424c75  char* penv = nullptr
00424c75  
00424c79  if (eax == 0)
00424c7d      esi = GetEnvironmentStringsW()
00424c7d      
00424c81      if (esi == 0)
00424c95          penv = GetEnvironmentStrings()
00424c95          
00424c99          if (penv == 0)
00424d89              return nullptr
00424d89          
00424c9f          data_430db0 = 2
00424d3f          label_424d3f:
00424d3f          
00424d3f          if (penv == 0)
00424d47              penv = GetEnvironmentStrings()
00424d47              
00424d4b              if (penv == 0)
00424d89                  return nullptr
00424d89          
00424d4f          char* penv_1 = penv
00424d4f          
00424d51          if (*penv != 0)
00424d53              while (true)
00424d53                  penv_1 = &penv_1[1]
00424d53                  
00424d56                  if (*penv_1 == 0)
00424d58                      penv_1 = &penv_1[1]
00424d58                      
00424d5b                      if (*penv_1 == 0)
00424d5b                          break
00424d5b          
00424d68          void* esi_1 = sub_41e583(penv_1 - penv + 1)
00424d68          
00424d6d          if (esi_1 != 0)
00424d76              sub_420bf0(esi_1, penv, penv_1 - penv + 1)
00424d6d          else
00424d6f              esi_1 = nullptr
00424d6f          
00424d7f          FreeEnvironmentStringsA(penv)
00424d85          return esi_1
00424d85      
00424c83      data_430db0 = 1
00424c79  else if (eax != 1)
00424d3b      if (eax != 2)
00424d89          return nullptr
00424d89      
00424d3b      goto label_424d3f
00424d3b  
00424cb9  if (esi == 0)
00424cbd      esi = GetEnvironmentStringsW()
00424cbd      
00424cc1      if (esi == 0)
00424d89          return nullptr
00424d89  
00424cca  PWSTR eax_4 = esi
00424cca  
00424ccc  if (*esi != 0)
00424ccf      while (true)
00424ccf          eax_4 = &eax_4[1]
00424ccf          
00424cd3          if (*eax_4 == 0)
00424cd6              eax_4 = &eax_4[1]
00424cd6              
00424cda              if (*eax_4 == 0)
00424cda                  break
00424cda  
00424cf3  int32_t cbMultiByte = WideCharToMultiByte(CodePage: 0, dwFlags: 0, lpWideCharStr: esi, 
00424cf3      cchWideChar: ((eax_4 - esi) s>> 1) + 1, lpMultiByteStr: nullptr, cbMultiByte: 0, 
00424cf3      lpDefaultChar: nullptr, lpUsedDefaultChar: nullptr)
00424cf3  
00424cf9  if (cbMultiByte != 0)
00424cfc      void* lpMultiByteStr = sub_41e583(cbMultiByte)
00424d04      void* lpMultiByteStr_1 = lpMultiByteStr
00424d04      
00424d08      if (lpMultiByteStr != 0)
00424d19          if (WideCharToMultiByte(CodePage: 0, dwFlags: 0, lpWideCharStr: esi, 
00424d19                  cchWideChar: ((eax_4 - esi) s>> 1) + 1, lpMultiByteStr, cbMultiByte, 
00424d19                  lpDefaultChar: nullptr, lpUsedDefaultChar: nullptr) == 0)
00424d1f              sub_41e29e(lpMultiByteStr_1)
00424d25              lpMultiByteStr_1 = nullptr
00424d25          
00424d29          lpMultiByteStr_2 = lpMultiByteStr_1
00424d29  
00424d2e  FreeEnvironmentStringsW(penv: esi)
00424d34  return lpMultiByteStr_2

00424d92                                                        cc cc                                                        ..

00424d94    int32_t sub_424d94(int32_t arg1)

00424d94  int32_t ebp
00424d94  int32_t var_4 = ebp
00424da7  int32_t result = RtlUnwind(TargetFrame: arg1, TargetIp: &data_424dac, 
00424da7      ExceptionRecord: nullptr, ReturnValue: nullptr)
00424d9a  var_4
00424db3  return result


00424db4    int32_t sub_424db4(int32_t arg1, int32_t arg2, int32_t* arg3)

00424dc4  if ((*(arg1 + 4) & 6) == 0)
00424dd5      return 1
00424dd5  
00424dce  *arg3 = arg2
00424dd0  return 3


00424dd6    void* sub_424dd6(void* arg1, int32_t arg2)

00424ddd  void* var_10 = arg1
00424dde  int32_t var_14 = 0xfffffffe
00424de0  int32_t (* var_18)(int32_t arg1, int32_t arg2, int32_t* arg3) = sub_424db4
00424de5  TEB* fsbase
00424de5  struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList
00424dec  fsbase->NtTib.ExceptionList = &ExceptionList
00424dec  
00424df7  while (true)
00424df7      int32_t ebx_1 = *(arg1 + 8)
00424dfa      int32_t esi_1 = *(arg1 + 0xc)
00424dfa      
00424e06      if (esi_1 == 0xffffffff || esi_1 == arg2)
00424e30          fsbase->NtTib.ExceptionList = ExceptionList
00424e3d          return arg1
00424e3d      
00424e08      int32_t esi_2 = esi_1 * 3
00424e0b      int32_t ecx_1 = *(ebx_1 + (esi_2 << 2))
00424e0e      int32_t var_14_1 = ecx_1
00424e12      *(arg1 + 0xc) = ecx_1
00424e12      
00424e1a      if (*(ebx_1 + (esi_2 << 2) + 4) == 0)
00424e1c          int32_t var_20_1 = 0x101
00424e25          void* ebp
00424e25          sub_424e6a(*(ebx_1 + (esi_2 << 2) + 8), ebp)
00424e2a          (*(ebx_1 + (esi_2 << 2) + 8))()


00424e3e    int32_t __abnormal_termination()

00424e40  TEB* fsbase
00424e40  struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList
00424e40  
00424e59  if (ExceptionList->Handler == sub_424db4
00424e59          && ExceptionList->__offset(0x8).d == *(ExceptionList->__offset(0xc).d + 0xc))
00424e5b      return 1
00424e5b  
00424e60  return 0

00424e61     53 51 bb 50 fd 42 00 eb 0a                                                                     SQ.P.B...

00424e6a    void __convention("regparm") sub_424e6a(int32_t arg1, void* arg2 @ ebp)

00424e74  data_42fd58 = *(arg2 + 8)
00424e77  data_42fd54 = arg1
00424e7a  data_42fd5c = arg2

00424e82        cc cc                                                                                        ..

00424e84    int32_t __convention("regparm") $$000000(char* arg1, int16_t arg2, void* arg3, void* arg4, int32_t arg5)

00424e84  char* esi
00424e84  char* var_4 = esi
00424e86  arg2:1.b ^= *arg1
00424e88  char* eax = var_4
00424e8a  *eax ^= arg2:1.b
00424e8c  char* ebp
00424e8c  var_4 = ebp
00424e8d  char** ebp_1 = &var_4
00424e92  int32_t ebx
00424e92  int32_t var_10 = ebx + 2
00424e93  char* var_14 = esi
00424e95  char** var_1c = &var_4
00424e97  void* ebx_3 = arg4
00424ea4  int32_t result
00424ea4  
00424ea4  if ((*(arg3 + 4) & 6) != 0)
00424f2c      char** var_20_5 = &var_4
00424f33      sub_424dd6(ebx_3, 0xffffffff)
00424f3c      result = 1
00424ea4  else
00424eaa      void* var_c = arg3
00424eb0      int32_t var_8_1 = arg5
00424eb6      *(ebx_3 - 4) = &var_c
00424eb9      int32_t esi_1 = *(ebx_3 + 0xc)
00424ebc      int32_t edi_1 = *(ebx_3 + 8)
00424ebc      
00424ec2      while (true)
00424ec2          if (esi_1 == 0xffffffff)
00424f25              result = 1
00424f2a              break
00424f2a          
00424ec4          int32_t ecx_1 = esi_1 * 3
00424ec4          
00424ecc          if (*(edi_1 + (ecx_1 << 2) + 4) != 0)
00424ed3              int32_t eax_3 = (*(edi_1 + (ecx_1 << 2) + 4))(ebp_1, esi_1, var_1c)
00424ed9              ebx_3 = ebp_1[3]
00424ed9              
00424ede              if (eax_3 != 0)
00424ee0                  if (eax_3 s< 0)
00424f1e                      result = 0
00424f23                      break
00424f23                  
00424ee2                  int32_t edi_2 = *(ebx_3 + 8)
00424ee6                  sub_424d94(ebx_3)
00424eee                  ebp_1 = ebx_3 + 0x10
00424ef3                  sub_424dd6(ebx_3, esi_1)
00424efb                  int32_t ecx_2 = esi_1 * 3
00424efe                  int32_t var_20_4 = 1
00424f04                  sub_424e6a(*(edi_2 + (ecx_2 << 2) + 8), ebp_1)
00424f0c                  *(ebx_3 + 0xc) = *(edi_2 + (ecx_2 << 2))
00424f0f                  (*(edi_2 + (ecx_2 << 2) + 8))()
00424f0f          
00424f13          edi_1 = *(ebx_3 + 8)
00424f19          esi_1 = *(edi_1 + esi_1 * 0xc)
00424f19  
00424f47  *var_1c
00424f48  return result


00424f49    void* __stdcall __seh_longjmp_unwind@4(int32_t* arg1)

00424f4e  *arg1
00424f61  return sub_424dd6(arg1[6], arg1[7])


00424f64    int32_t* sub_424f64()

00424f64  int32_t* result = data_430c00
00424f64  
00424f6c  if (result == 1)
00424f80      label_424f80:
00424f80      sub_424f9d(0xfc)
00424f85      int32_t eax = data_430db4
00424f85      
00424f8d      if (eax != 0)
00424f8f          eax()
00424f8f      
00424f96      result = sub_424f9d(0xff)
00424f6c  else if (result == 0 && data_42f324 == 1)
00424f79      goto label_424f80
00424f79  
00424f9c  return result


00424f9d    void* sub_424f9d(uint32_t arg1)

00424fa6  uint32_t i = arg1
00424fa9  int32_t ecx = 0
00424fab  void* result = &data_42fd60
00424fab  
00424fb2  while (i != *result)
00424fb4      result += 8
00424fb7      ecx += 1
00424fb7      
00424fbd      if (result s>= &data_42fdf0)
00424fbd          break
00424fbd  
00424fcb  if (i == *((ecx << 3) + &data_42fd60))
00424fd1      result = data_430c00
00424fd1      
00424fd9      if (result == 1)
004250d0          label_4250d0:
004250d0          OVERLAPPED* __saved_edi_3 = nullptr
004250d2          uint32_t* lpNumberOfBytesWritten = &arg1
004250db          uint32_t nNumberOfBytesToWrite = sub_422550((&data_42fd64)[ecx * 2])
004250e7          return WriteFile(hFile: GetStdHandle(nStdHandle: STD_ERROR_HANDLE), 
004250e7              lpBuffer: (&data_42fd64)[ecx * 2], nNumberOfBytesToWrite, 
004250e7              lpNumberOfBytesWritten, lpOverlapped: __saved_edi_3)
004250e7      
00424fea      if (result == 0 && data_42f324 == 1)
00424fea          goto label_4250d0
00424fea      
00424ff6      if (i != 0xfc)
00425012          void filename
00425012          
00425012          if (GetModuleFileNameA(hModule: nullptr, lpFilename: &filename, nSize: 0x104)
00425012                  == 0)
00425020              sub_4230a0(&filename, "<program name unknown>")
00425020          
0042502f          void* edi_1 = &filename
0042502f          
0042503f          if (sub_422550(&filename) + 1 u> 0x3c)
00425058              int32_t var_1b8_2 = 3
0042505a              void var_1e3
0042505a              edi_1 = sub_422550(&filename) + &var_1e3
00425062              sub_41e720(edi_1, "...", var_1b8_2)
00425062          
00425076          char var_a4[0xa0]
00425076          sub_4230a0(&var_a4, "Runtime Error!\n\nProgram: ")
00425083          sub_4230b0(&var_a4, edi_1)
00425094          sub_4230b0(&var_a4, "\n\n")
004250a6          sub_4230b0(&var_a4, (&data_42fd64)[ecx * 2])
004250bc          return sub_42720a(&var_a4, "Microsoft Visual C++ Runtime Lib…", 0x12010)
004250bc  
004250ef  return result


004250f0    int32_t sub_4250f0(int16_t arg1 @ x87control, int32_t arg2, int32_t arg3)

004250f3  int32_t ecx
004250f3  int32_t var_8 = ecx
004250f6  int16_t x87status
004250f6  int16_t temp0
004250f6  temp0, x87status = __fnstcw_memmem16(arg1)
004250f6  var_8.w = temp0
00425110  int32_t result = (sub_42513b(var_8.w) & not.d(arg3)) | (arg2 & arg3)
0042511d  int16_t x87control
0042511d  int16_t x87status_1
0042511d  x87control, x87status_1 = __fldcw_memmem16(sub_4251cd(result).w)
00425124  return result


00425125    int32_t sub_425125(int32_t arg1, int32_t arg2)

0042513a  int16_t x87control
0042513a  return sub_4250f0(x87control, arg1, arg2 & 0xfff7ffff)


0042513b    int32_t sub_42513b(int16_t arg1) __pure

00425140  int32_t result = 0
00425140  
00425147  if ((arg1.b & 1) != 0)
0042514b      result = 0x10
0042514b  
0042514f  if ((arg1.b & 4) != 0)
00425151      result.b |= 8
00425151  
00425156  if ((arg1.b & 8) != 0)
00425158      result.b |= 4
00425158  
0042515d  if ((arg1.b & 0x10) != 0)
0042515f      result.b |= 2
0042515f  
00425164  if ((arg1.b & 0x20) != 0)
00425166      result.b |= 1
00425166  
0042516b  if ((arg1.b & 2) != 0)
0042516d      result |= 0x80000
0042516d  
00425172  uint32_t ecx = zx.d(arg1)
00425182  int32_t edx_1 = ecx & 0xc00
00425182  
00425189  if (edx_1 != 0)
00425191      if (edx_1 == 0x400)
004251a7          result:1.b |= 1
00425191      else if (edx_1 == 0x800)
004251a3          result |= 0x200
00425199      else if (edx_1 == 0xc00)
0042519f          result |= 0x300
0042519f  
004251aa  int32_t ecx_1 = ecx & 0x300
004251aa  
004251ad  if (ecx_1 == 0)
004251ba      result |= 0x20000
004251ad  else if (ecx_1 == 0x200)
004251b3      result |= 0x10000
004251b3  
004251c5  if ((arg1:1.b & 0x10) == 0)
004251cc      return result
004251cc  
004251c7  return result | 0x40000


004251cd    int32_t sub_4251cd(int32_t arg1) __pure

004251d2  int32_t result = 0
004251d2  
004251d8  if ((arg1.b & 0x10) != 0)
004251dc      result = 1
004251dc  
004251e0  if ((arg1.b & 8) != 0)
004251e2      result.b |= 4
004251e2  
004251e7  if ((arg1.b & 4) != 0)
004251e9      result.b |= 8
004251e9  
004251ee  if ((arg1.b & 2) != 0)
004251f0      result.b |= 0x10
004251f0  
004251f5  if ((arg1.b & 1) != 0)
004251f7      result.b |= 0x20
004251f7  
004251ff  if ((arg1 & 0x80000) != 0)
00425201      result.b |= 2
00425201  
0042520a  int32_t ecx_1 = arg1 & 0x300
0042520a  
00425211  if (ecx_1 != 0)
00425219      if (ecx_1 == 0x100)
0042522d          result:1.b |= 4
00425219      else if (ecx_1 == 0x200)
00425228          result:1.b |= 8
0042521d      else if (ecx_1 == 0x300)
00425223          result:1.b |= 0xc
00425223  
00425232  int32_t ecx_3 = arg1 & 0x30000
00425232  
00425238  if (ecx_3 == 0)
00425246      result |= 0x300
00425238  else if (ecx_3 == 0x10000)
00425242      result |= 0x200
00425242  
00425250  if ((arg1 & 0x40000) != 0)
00425252      result:1.b |= 0x10
00425252  
00425255  return result


00425256    int32_t sub_425256(int32_t arg1, int32_t arg2)

0042525f  int32_t temp0 = divs.dp.d(sx.q(arg2), 0x20)
0042525f  
0042527d  if ((*(arg1 + (temp0 << 2))
0042527d          & not.d(0xffffffff << (0x1f - (mods.dp.d(sx.q(arg2), 0x20)).b))) != 0)
0042529e      return 0
0042529e  
0042527f  int32_t esi_1 = temp0 + 1
0042527f  
00425283  if (esi_1 s>= 3)
0042529a      return 1
0042529a  
00425285  int32_t* eax_5 = arg1 + (esi_1 << 2)
00425285  
0042528b  while (true)
0042528b      if (*eax_5 != 0)
0042529e          return 0
0042529e      
0042528d      esi_1 += 1
0042528e      eax_5 = &eax_5[1]
0042528e      
00425294      if (esi_1 s>= 3)
0042529a          return 1


0042529f    int32_t sub_42529f(int32_t arg1, int32_t arg2)

004252ae  int32_t temp0 = divs.dp.d(sx.q(arg2), 0x20)
004252b9  int32_t* edi = arg1 + (temp0 << 2)
004252ca  int32_t i = sub_427293(*edi, 1 << (0x1f - (mods.dp.d(sx.q(arg2), 0x20)).b), edi)
004252d2  int32_t esi_1 = temp0 - 1
004252d2  
004252d3  if (temp0 - 1 s>= 0)
004252d5      int32_t* edi_1 = arg1 + (esi_1 << 2)
004252d5      
004252da      while (i != 0)
004252e1          i = sub_427293(*edi_1, 1, edi_1)
004252e9          esi_1 -= 1
004252ea          edi_1 -= 4
004252ea          
004252ef          if (esi_1 s< 0)
004252ef              break
004252ef  
004252f4  return i


004252f5    int32_t sub_4252f5(int32_t arg1, int32_t* arg2)

004252f8  int32_t ecx
004252f8  int32_t var_8 = ecx
004252f9  int32_t var_c = ecx
00425300  void* edi = arg2 - 1
00425306  int32_t result = 0
00425313  int32_t temp0 = divs.dp.d(sx.q(edi + 1), 0x20)
0042531b  int32_t eax_5
0042531b  int32_t edx_1
0042531b  edx_1:eax_5 = sx.q(edi + 1)
00425327  int32_t* eax_7 = arg1 + (temp0 << 2)
00425327  
00425336  if ((*eax_7 & 1 << (0x1f - (mods.dp.d(edx_1:eax_5, 0x20)).b)) != 0
00425336          && sub_425256(arg1, edi + 2) == 0)
00425352      result = sub_42529f(arg1, edi)
00425352  
00425363  *eax_7 &= 0xffffffff << (0x1f - (mods.dp.d(edx_1:eax_5, 0x20)).b)
00425363  
0042536b  if (temp0 + 1 s< 3)
00425377      __builtin_memset(s: arg1 + ((temp0 + 1) << 2), c: 0, n: (3 - (temp0 + 1)) << 2)
00425377  
00425380  return result


00425381    int32_t* sub_425381(int32_t arg1, int32_t* arg2)

00425381  int32_t* result = arg2
0042538c  int32_t* ecx_1 = arg1 - result
0042538e  int32_t i_1 = 3
00425398  int32_t i
00425398  
00425398  do
00425391      *(ecx_1 + result) = *result
00425394      result = &result[1]
00425397      i = i_1
00425397      i_1 -= 1
00425398  while (i != 1)
0042539b  return result


0042539c    int32_t sub_42539c(int32_t* arg1)

004253a3  *arg1 = 0
004253a3  void* edi_1 = &arg1[1]
004253a4  *edi_1 = 0
004253a5  *(edi_1 + 4) = 0
004253a7  return 0


004253a8    int32_t sub_4253a8(int32_t* arg1)

004253a8  int32_t* eax = arg1
004253a8  
004253ba  for (int32_t i = 0; i s< 3; )
004253b1      if (*eax != 0)
004253c2          return 0
004253c2      
004253b3      i += 1
004253b4      eax = &eax[1]
004253b4  
004253bf  return 1


004253c3    int32_t* sub_4253c3(int32_t* arg1, int32_t arg2)

004253d1  int32_t* edi = arg1
004253db  int32_t i_1 = 3
004253e2  int32_t temp0 = divs.dp.d(sx.q(arg2), 0x20)
004253eb  char temp1 = (mods.dp.d(sx.q(arg2), 0x20)).b
004253ed  arg2 = 0
0042541b  int32_t i
0042541b  
0042541b  do
004253f9      int32_t eax_6 = *edi
00425409      *edi = eax_6 u>> temp1 | arg2
00425410      edi = &edi[1]
00425415      i = i_1
00425415      i_1 -= 1
00425418      arg2 = (eax_6 & not.d(0xffffffff << temp1)) << (0x20 - temp1)
0042541b  while (i != 1)
00425422  int32_t ebx_1 = 2
00425427  int32_t* ecx_5 = 8
00425449  int32_t* result
00425449  int32_t* temp3_1
00425449  
00425449  do
0042542d      if (ebx_1 s< temp0)
0042543e          result = arg1
00425441          *(ecx_5 + result) = 0
0042542d      else
00425436          result = *(ecx_5 - (temp0 << 2) + arg1)
00425439          *(ecx_5 + arg1) = result
00425439      
00425445      ebx_1 -= 1
00425446      temp3_1 = ecx_5
00425446      ecx_5 -= 4
00425449  while (temp3_1 - 4 s>= 0)
0042544f  return result


00425450    int32_t sub_425450(int16_t* arg1, int32_t* arg2, int32_t* arg3)

0042545c  uint32_t ecx = zx.d(arg1[5])
00425462  int16_t* ecx_1 = ecx & 0x8000
0042546e  int32_t var_10 = *(arg1 + 6)
00425471  int32_t ecx_3 = *(arg1 + 2)
00425480  int32_t ebx_2 = (ecx & 0x7fff) - 0x3fff
00425492  uint32_t var_8 = zx.d(*arg1) << 0x10
00425495  int32_t result
00425495  int32_t esi_1
00425495  
00425495  if (ebx_2 != 0xffffc001)
004254c5      void var_1c
004254c5      sub_425381(&var_1c, &var_10)
004254c5      
004254db      if (sub_4252f5(&var_10, arg3[2]) != 0)
004254dd          ebx_2 += 1
004254dd      
004254de      int32_t eax_5 = arg3[1]
004254de      
004254e8      if (ebx_2 s>= eax_5 - arg3[2])
004254f8          if (ebx_2 s<= eax_5)
00425506              sub_425381(&var_10, &var_1c)
00425510              sub_4253c3(&var_10, eax_5 - ebx_2)
0042551c              sub_4252f5(&var_10, arg3[2])
0042552a              sub_4253c3(&var_10, arg3[3] + 1)
0042552f              goto label_425532
0042552f          
0042553b          if (ebx_2 s< *arg3)
0042556b              var_10:3.b &= 0x7f
00425573              esi_1 = arg3[5] + ebx_2
00425575              sub_4253c3(&var_10, arg3[3])
0042557c              result = 0
0042553b          else
00425541              sub_42539c(&var_10)
00425549              var_10:3.b |= 0x80
00425551              sub_4253c3(&var_10, arg3[3])
0042555c              esi_1 = arg3[5] + *arg3
004254b7              result = 1
004254e8      else
004254ee          sub_42539c(&var_10)
00425532          label_425532:
00425532          esi_1 = 0
004254b7          result = 2
00425495  else
0042549a      esi_1 = 0
0042549a      
004254a5      if (sub_4253a8(&var_10) != 0)
0042557c          result = 0
004254a5      else
004254af          sub_42539c(&var_10)
004254b7          result = 2
004254b7  
00425584  int32_t edi_1 = arg3[4]
0042558c  int32_t ecx_12 = neg.d(ecx_1)
00425598  int32_t esi_7 = esi_1 << (0x1f - (arg3[3]).b)
00425598      | (sbb.d(ecx_12, ecx_12, ecx_1 != 0) & 0x80000000) | var_10
00425598  
0042559e  if (edi_1 == 0x40)
004255a6      arg2[1] = esi_7
004255a9      *arg2 = ecx_3
0042559e  else if (edi_1 == 0x20)
004255b5      *arg2 = esi_7
004255b5  
004255bb  return result


004255bc    int32_t sub_4255bc(int16_t* arg1, int32_t* arg2)

004255d1  return sub_425450(arg1, arg2, &data_42fdf0)


004255d2    int32_t sub_4255d2(int16_t* arg1, int32_t* arg2)

004255e7  return sub_425450(arg1, arg2, &data_42fe08)


004255e8    int32_t sub_4255e8(int32_t* arg1, void* arg2)

004255ff  void var_10
004255ff  sub_426252(&var_10, &arg2, arg2, 0, 0, 0, 0)
00425614  return sub_4255bc(&var_10, arg1)


00425615    int32_t sub_425615(int32_t* arg1, void* arg2)

0042562c  void var_10
0042562c  sub_426252(&var_10, &arg2, arg2, 0, 0, 0, 0)
00425641  return sub_4255d2(&var_10, arg1)


00425642    char* sub_425642(char* arg1, char* arg2, int32_t arg3)

00425645  int32_t edx = arg3
00425649  char* ebx = arg2
0042564d  char* esi = arg1
00425650  char* ecx = *(edx + 0xc)
00425657  *esi = 0x30
0042565c  char* result = &esi[1]
0042565c  
0042565e  if (ebx s> 0)
00425660      arg1 = ebx
00425663      ebx = nullptr
0042567a      char* i
0042567a      
0042567a      do
00425665          edx.b = *ecx
00425665          
00425669          if (edx.b == 0)
00425673              edx = 0x30
00425669          else
0042566b              edx = sx.d(edx.b)
0042566e              ecx = &ecx[1]
0042566e          
00425674          *result = edx.b
00425676          result = &result[1]
00425677          i = arg1
00425677          arg1 -= 1
0042567a      while (i != 1)
0042567c      edx = arg3
0042567c  
0042567f  *result = 0
0042567f  
00425689  if (ebx s>= 0 && *ecx s>= 0x35)
0042568b      while (true)
0042568b          result -= 1
0042568b          
0042568f          if (*result != 0x39)
0042568f              break
0042568f          
00425691          *result = 0x30
00425691      
00425696      *result += 1
00425696  
0042569b  if (*esi != 0x31)
004256ac      return sub_41f5a0(esi, &esi[1], sub_422550(&esi[1]) + 1)
004256ac  
0042569d  *(edx + 4) += 1
004256b8  return result


004256b9    int32_t* sub_4256b9(int32_t* arg1, char* arg2)

004256c9  int32_t var_10
004256c9  void arg_4
004256c9  sub_425715(&var_10, &arg_4)
004256d6  int16_t var_2c
004256d6  int16_t* var_38_1 = &var_2c
004256d7  int32_t var_3c_1 = 0
004256d9  int32_t var_40 = 0x11
004256e0  int32_t var_4c = var_10
004256e0  void var_48
004256e0  void* edi = &var_48
004256e0  void var_c
004256e0  void* esi = &var_c
004256e1  *edi = *esi
004256e2  *(edi + 4) = *(esi + 4)
004256ef  arg1[2] = sub_427434(var_4c)
004256f6  char var_2a
004256f6  *arg1 = sx.d(var_2a)
004256fc  arg1[1] = sx.d(var_2c)
00425702  void var_28
00425702  void* var_50 = &var_28
00425704  sub_4230a0(arg2, var_50)
0042570c  arg1[3] = arg2
00425714  return arg1


00425715    int32_t* sub_425715(int32_t* arg1, int32_t* arg2)

00425718  int32_t ecx
00425718  int32_t var_8 = ecx
0042571f  int32_t eax
0042571f  eax.w = *(arg2 + 6)
00425732  int32_t ecx_3 = eax u>> 4 & 0x7ff
0042573a  int32_t edx_1 = *arg2
0042573c  uint32_t ebx = zx.d(ecx_3.w)
00425744  int32_t eax_3 = arg2[1] & 0xfffff
0042574b  int32_t var_8_1 = 0x80000000
0042574e  int32_t edi_1
0042574e  
0042574e  if (ebx != 0)
00425752      if (ebx == 0x7ff)
0042575c          edi_1 = 0x7fff
00425752      else
00425754          edi_1 = ecx_3 + 0x3c00
00425754      
00425752      goto label_42578e
00425752  
0042576b  int32_t* result
0042576b  
0042576b  if (eax_3 != 0 || edx_1 != 0)
0042577b      edi_1 = ecx_3 + 0x3c01
00425781      var_8_1 = 0
0042578e      label_42578e:
0042578e      result = arg1
00425791      int32_t ecx_7 = edx_1 u>> 0x15 | eax_3 << 0xb | var_8_1
00425797      result[1] = ecx_7
0042579a      *result = edx_1 << 0xb
0042579a      
0042579e      while ((0x80000000 & ecx_7) == 0)
004257a0          int32_t edx_3 = *result
004257a9          int32_t ebx_3 = edx_3 u>> 0x1f | (ecx_7 * 2)
004257ae          *result = edx_3 * 2
004257b0          result[1] = ebx_3
004257b3          edi_1 += 0xffff
004257b9          ecx_7 = ebx_3
004257b9      
004257c2      result[2].w = (eax & 0x8000).w | edi_1.w
0042576b  else
0042576d      result = arg1
00425770      result[1] = 0
00425773      *result = 0
00425775      result[2].w = 0
00425775  
004257ca  return result

004257cb                                   cc cc cc cc cc                                                             .....

004257d0    char* sub_4257d0(char* arg1, char arg2, int32_t arg3)

004257d0  int32_t i_3 = arg3
004257d0  
004257da  if (i_3 == 0)
00425827      return arg1
00425827  
004257de  int32_t eax
004257de  eax.b = arg2
004257e3  char* edi = arg1
004257e3  
004257e8  if (i_3 u< 4)
0042581b      label_42581b:
0042581b      int32_t i
0042581b      
0042581b      do
00425817          *edi = eax.b
00425819          edi = &edi[1]
0042581a          i = i_3
0042581a          i_3 -= 1
0042581b      while (i != 1)
004257e8  else
004257ec      int32_t i_2 = neg.d(arg1) & 3
004257ec      
004257ef      if (i_2 != 0)
004257f1          i_3 -= i_2
004257f7          int32_t i_1
004257f7          
004257f7          do
004257f3              *edi = eax.b
004257f5              edi = &edi[1]
004257f6              i_1 = i_2
004257f6              i_2 -= 1
004257f7          while (i_1 != 1)
004257f7      
00425805      eax *= 0x1010101
00425807      int32_t i_4 = i_3
00425809      i_3 &= 3
0042580c      uint32_t ecx_4 = i_4 u>> 2
0042580c      
0042580f      if (ecx_4 == 0)
0042580f          goto label_42581b
0042580f      
00425811      int32_t ecx_5
00425811      edi, ecx_5 = __memfill_u32(edi, eax, ecx_4)
00425811      
00425815      if (i_3 != 0)
00425815          goto label_42581b
00425815  
00425822  return arg1


00425828    int32_t sub_425828()

00425830  return sub_41f9c5(2)


00425831    void* sub_425831(int32_t arg1, int32_t arg2)

00425838  uint32_t dwBytes = arg1 * arg2
00425840  uint32_t dwBytes_1 = dwBytes
00425840  
00425842  if (dwBytes u<= 0xffffffe0)
00425846      if (dwBytes == 0)
0042584a          dwBytes = 1
0042584a      
0042584e      dwBytes = (dwBytes + 0xf) & 0xfffffff0
0042584e  
004258a4  bool cond:1_1
004258a4  
004258a4  do
00425851      void* result = nullptr
00425851      
00425856      if (dwBytes u<= 0xffffffe0)
0042585e          if (dwBytes_1 u<= data_42f8d4)
00425862              sub_421919(9)
0042586f              result = sub_421d23(dwBytes_1)
00425871              sub_42197a(9)
00425871          
0042587b          if (dwBytes_1 u<= data_42f8d4 && result != 0)
004258ac              sub_4257d0(result, 0, dwBytes_1)
004258b4              return result
004258b4          
0042588c          result = HeapAlloc(hHeap: data_2823868, dwFlags: HEAP_ZERO_MEMORY, dwBytes)
0042588c          
00425890          if (result != 0 || data_430c70 == 0)
004258b4              return result
00425856      else if (data_430c70 == 0)
004258b4          return result
004258b4      
004258a1      cond:1_1 = sub_42307c(dwBytes) == 0
004258a4  while (not(cond:1_1))
004258ba  return nullptr


004258be    int32_t sub_4258be()

004258c2  int32_t result = 0
004258c4  sub_421919(2)
004258cc  int32_t i = 3
004258cc  
004258d3  if (data_28249a0 s> 3)
0042592f      do
004258dd          int32_t esi_2 = i << 2
004258e0          int32_t* eax_2 = *(esi_2 + data_2823984)
004258e0          
004258e5          if (eax_2 != 0)
004258eb              if ((eax_2[3].b & 0x83) != 0 && sub_41ddd2(eax_2) != 0xffffffff)
004258f9                  result += 1
004258f9              
004258fd              if (i s>= 0x14)
0042590b                  DeleteCriticalSection(lpCriticalSection: *(esi_2 + data_2823984) + 0x20)
00425919                  sub_41e29e(*(esi_2 + data_2823984))
00425924                  *(esi_2 + data_2823984) = 0
00425924          
00425928          i += 1
0042592f      while (i s< data_28249a0)
0042592f  
00425934  sub_42197a(2)
0042593e  return result


0042593f    int32_t sub_42593f(int32_t arg1)

00425949  if (arg1 u>= data_2823980)
0042594d      return 0
0042594d  
00425960  int32_t eax_2
00425960  eax_2.b = *((&data_2823880)[arg1 s>> 5] + (arg1 & 0x1f) * 0x24 + 4)
00425967  return eax_2 & 0x40


00425968    BOOL sub_425968(BOOL arg1, BOOL arg2)

00425974  InterlockedIncrement(&data_282384c)
00425980  int32_t ebx = 0
00425980  
00425988  if (data_2823848 != 0)
0042598b      InterlockedDecrement(&data_282384c)
0042598f      sub_421919(0x13)
00425997      ebx = 1
00425997  
0042599e  BOOL result = sub_4259c1(arg1, arg2.w)
0042599e  
004259aa  if (ebx == 0)
004259b7      InterlockedDecrement(&data_282384c)
004259aa  else
004259ae      sub_42197a(0x13)
004259ae  
004259c0  return result


004259c1    BOOL sub_4259c1(BOOL arg1, wchar16 arg2)

004259c4  BOOL lpMultiByteStr = arg1
004259c4  
004259c9  if (lpMultiByteStr == 0)
004259cc      return lpMultiByteStr
004259cc  
004259d4  if (data_430c8c != 0)
004259eb      arg1 = 0
00425a0a      int32_t eax_1 = WideCharToMultiByte(CodePage: data_430c9c, dwFlags: 0x220, 
00425a0a          lpWideCharStr: &arg2, cchWideChar: 1, lpMultiByteStr, cbMultiByte: data_42f800, 
00425a0a          lpDefaultChar: nullptr, lpUsedDefaultChar: &arg1)
00425a0a      
00425a18      if (eax_1 != 0 && arg1 == 0)
00425a29          return eax_1
004259d4  else
004259d6      wchar16 ecx = arg2
004259d6      
004259df      if (ecx u<= 0xff)
004259e3          *lpMultiByteStr = ecx.b
004259e7          return 1
004259e7  
00425a1f  *sub_41e9bd() = 0x2a
00425a25  return 0xffffffff

00425a2a                                cc cc cc cc cc cc                                                            ......

00425a30    uint32_t __stdcall __aulldiv(int32_t arg1, uint32_t arg2, int32_t arg3, uint32_t arg4) __pure

00425a38  if (arg4 == 0)
00425a95      return divu.dp.d((modu.dp.d(0:arg2, arg3)):arg1, arg3)
00425a95  
00425a52  uint32_t i = arg4
00425a54  int32_t ebx_1 = arg3
00425a58  uint32_t edx_3 = arg2
00425a5c  int32_t eax_6 = arg1
00425a5c  
00425a6a  do
00425a62      ebx_1 = rrc.d(ebx_1, 1, (i & 1) != 0)
00425a64      uint32_t temp4_1 = edx_3
00425a64      edx_3 u>>= 1
00425a66      eax_6 = rrc.d(eax_6, 1, (temp4_1 & 1) != 0)
00425a68      i u>>= 1
00425a6a  while (i != 0)
00425a6a  
00425a6c  uint32_t result = divu.dp.d(edx_3:eax_6, ebx_1)
00425a70  int32_t eax_8 = result * arg4
00425a7a  int32_t eax_10
00425a7a  int32_t edx_4
00425a7a  edx_4:eax_10 = mulu.dp.d(arg3, result)
00425a7c  int32_t edx_5 = edx_4 + eax_8
00425a7c  
00425a8c  if (edx_4 + eax_8 u>= edx_4 && edx_5 u<= arg2 && (edx_5 u< arg2 || eax_10 u<= arg1))
00425a91      return result
00425a91  
00425a8e  return result - 1

00425a98                                                                          cc cc cc cc cc cc cc cc                          ........

00425aa0    uint32_t __stdcall __aullrem(int32_t arg1, uint32_t arg2, int32_t arg3, uint32_t arg4) __pure

00425aa7  uint32_t result
00425aa7  
00425aa7  if (arg4 != 0)
00425ac1      uint32_t i = arg4
00425ac3      int32_t ebx_1 = arg3
00425ac7      uint32_t edx_4 = arg2
00425acb      int32_t eax_4 = arg1
00425acb      
00425ad9      do
00425ad1          ebx_1 = rrc.d(ebx_1, 1, (i & 1) != 0)
00425ad3          uint32_t temp4_1 = edx_4
00425ad3          edx_4 u>>= 1
00425ad5          eax_4 = rrc.d(eax_4, 1, (temp4_1 & 1) != 0)
00425ad7          i u>>= 1
00425ad9      while (i != 0)
00425ad9      
00425adb      uint32_t temp0_1 = divu.dp.d(edx_4:eax_4, ebx_1)
00425adf      int32_t eax_6 = temp0_1 * arg4
00425ae4      int32_t eax_8
00425ae4      int32_t edx_5
00425ae4      edx_5:eax_8 = mulu.dp.d(temp0_1, arg3)
00425ae8      int32_t edx_6 = edx_5 + eax_6
00425ae8      
00425af0      if (edx_5 + eax_6 u< edx_5 || edx_6 u> arg2)
00425afa          eax_8 -= arg3
00425af0      else if (edx_6 u>= arg2 && eax_8 u> arg1)
00425afa          eax_8 -= arg3
00425afa      
00425b0c      result = neg.d(eax_8 - arg1)
00425aa7  else
00425abb      result = modu.dp.d((modu.dp.d(0:arg2, arg3)):arg1, arg3)
00425abb  
00425b12  return result


00425b15    int32_t sub_425b15(int32_t* arg1)

00425b15  data_430c04 += 1
00425b20  void* eax = sub_41e583(0x1000)
00425b2c  arg1[2] = eax
00425b2c  
00425b2f  if (eax == 0)
00425b3e      arg1[3] |= 4
00425b45      arg1[2] = &arg1[5]
00425b48      arg1[6] = 2
00425b2f  else
00425b31      arg1[3] |= 8
00425b35      arg1[6] = 0x1000
00425b35  
00425b4f  int32_t result = arg1[2]
00425b52  arg1[1] = 0
00425b56  *arg1 = result
00425b58  return result


00425b59    int32_t sub_425b59()

00425b59  int32_t ecx
00425b59  int32_t var_4_1 = ecx
00425b5a  int32_t var_8 = ecx
00425b61  int32_t result = 0xffffffff
00425b64  sub_421919(0x12)
00425b69  int32_t ebx = 0
00425b6c  int32_t var_8_1 = 0
00425b70  int32_t var_4 = 0
00425b70  
00425c15  for (int32_t* i = &data_2823880; i s< &data_2823980; )
00425b79      int32_t* esi_1 = *i
00425b79      
00425b7e      if (esi_1 == 0)
00425c23          void* eax_8 = sub_41e583(0x480)
00425c23          
00425c2b          if (eax_8 != 0)
00425c2d              data_2823980 += 0x20
00425c3b              void* j = eax_8 + 0x480
00425c41              (&data_2823880)[ebx] = eax_8
00425c41              
00425c45              for (; eax_8 u< j; j = (&data_2823880)[ebx] + 0x480)
00425c47                  *(eax_8 + 4) = 0
00425c4b                  *eax_8 = 0xffffffff
00425c4e                  *(eax_8 + 8) = 0
00425c52                  *(eax_8 + 5) = 0xa
00425c58                  eax_8 += 0x24
00425c58              
00425c62              result = ebx << 5
00425c65              sub_425db9(result)
00425c65          
00425c2b          break
00425c2b      
00425b84      void* eax_1 = &esi_1[0x120]
00425b84      
00425b8c      while (true)
00425b8c          if (esi_1 u>= eax_1)
00425b8c              goto label_425c02
00425b8c          
00425b92          if ((esi_1[1].b & 1) == 0)
00425b98              if (esi_1[2] == 0)
00425b9c                  sub_421919(0x11)
00425b9c                  
00425ba6                  if (esi_1[2] == 0)
00425bac                      InitializeCriticalSection(lpCriticalSection: &esi_1[3])
00425bb2                      esi_1[2] += 1
00425bb2                  
00425bb7                  sub_42197a(0x11)
00425bb7              
00425bc1              EnterCriticalSection(lpCriticalSection: &esi_1[3])
00425bc1              
00425bcb              if ((esi_1[1].b & 1) == 0)
00425bcb                  break
00425bcb              
00425bce              LeaveCriticalSection(lpCriticalSection: &esi_1[3])
00425bd4              ebx = var_8_1
00425bd4          
00425bdb          esi_1 = &esi_1[9]
00425bde          eax_1 = *i + 0x480
00425bde      
00425be5      *esi_1 = 0xffffffff
00425bf5      result = divs.dp.d(sx.q(esi_1 - *i), 0x24) + var_4
00425bf5      
00425bfc      if (result != 0xffffffff)
00425bfc          break
00425bfc      
00425bfe      ebx = var_8_1
00425c02      label_425c02:
00425c02      var_4 += 0x20
00425c07      i = &i[1]
00425c0a      ebx += 1
00425c11      var_8_1 = ebx
00425c11  
00425c6d  sub_42197a(0x12)
00425c7b  return result


00425c7c    int32_t sub_425c7c(int32_t arg1, HANDLE arg2)

00425c88  if (arg1 u< data_2823980 && (&data_2823880)[arg1 s>> 5][(arg1 & 0x1f) * 9] == 0xffffffff)
00425cb5      if (data_42f324 == 1)
00425cba          if (arg1 == 0)
00425ccf              SetStdHandle(nStdHandle: STD_INPUT_HANDLE, hHandle: arg2)
00425cba          else if (arg1 == 1)
00425ccf              SetStdHandle(nStdHandle: STD_OUTPUT_HANDLE, hHandle: arg2)
00425cbd          else if (arg1 == 2)
00425ccf              SetStdHandle(nStdHandle: STD_ERROR_HANDLE, hHandle: arg2)
00425ccf      
00425cd7      (&data_2823880)[arg1 s>> 5][(arg1 & 0x1f) * 9] = arg2
00425cda      return 0
00425cda  
00425ce4  *sub_41e9bd() = 9
00425cef  *sub_41e9c6() = 0
00425cf2  return 0xffffffff


00425cf8    int32_t sub_425cf8(int32_t arg1)

00425d04  if (arg1 u< data_2823980)
00425d1f      int32_t* eax_6 = (&data_2823880)[arg1 s>> 5] + (arg1 & 0x1f) * 0x24
00425d1f      
00425d2a      if ((eax_6[1].b & 1) != 0 && *eax_6 != 0xffffffff)
00425d33          if (data_42f324 == 1)
00425d39              if (arg1 == 0)
00425d4b                  int32_t var_c_3 = 0
00425d4e                  SetStdHandle(nStdHandle: STD_INPUT_HANDLE, hHandle: nullptr)
00425d39              else if (arg1 == 1)
00425d46                  int32_t var_c_2 = 0
00425d4e                  SetStdHandle(nStdHandle: STD_OUTPUT_HANDLE, hHandle: nullptr)
00425d3c              else if (arg1 == 2)
00425d41                  int32_t var_c_1 = 0
00425d4e                  SetStdHandle(nStdHandle: STD_ERROR_HANDLE, hHandle: nullptr)
00425d4e          
00425d56          (&data_2823880)[arg1 s>> 5][(arg1 & 0x1f) * 9] = 0xffffffff
00425d5a          return 0
00425d5a  
00425d63  *sub_41e9bd() = 9
00425d6e  *sub_41e9c6() = 0
00425d71  return 0xffffffff


00425d77    int32_t sub_425d77(int32_t arg1)

00425d81  if (arg1 u< data_2823980)
00425d8b      int32_t eax_1 = (arg1 & 0x1f) * 9
00425d8e      int32_t ecx_3 = (&data_2823880)[arg1 s>> 5]
00425d8e      
00425d9d      if ((*(ecx_3 + (eax_1 << 2) + 4) & 1) != 0)
00425da1          return *(ecx_3 + (eax_1 << 2))
00425da1  
00425da7  *sub_41e9bd() = 9
00425db2  *sub_41e9c6() = 0
00425db8  return 0xffffffff


00425db9    int32_t sub_425db9(int32_t arg1)

00425dc3  int32_t ecx_1 = arg1 s>> 5
00425dd9  int32_t edi_1 = (arg1 & 0x1f) * 0x24
00425ddc  void* esi_1 = (&data_2823880)[ecx_1] + edi_1
00425ddc  
00425de2  if (*(esi_1 + 8) == 0)
00425de6      sub_421919(0x11)
00425de6      
00425df0      if (*(esi_1 + 8) == 0)
00425df6          InitializeCriticalSection(lpCriticalSection: esi_1 + 0xc)
00425dfc          *(esi_1 + 8) += 1
00425dfc      
00425e01      sub_42197a(0x11)
00425e01  
00425e17  return EnterCriticalSection(lpCriticalSection: (&data_2823880)[ecx_1] + edi_1 + 0xc)


00425e18    int32_t sub_425e18(int32_t arg1)

00425e39  return LeaveCriticalSection(lpCriticalSection: (&data_2823880)[arg1 s>> 5]
00425e39      + (arg1 & 0x1f) * 0x24 + 0xc)


00425e3a    int32_t sub_425e3a(PSTR arg1, int32_t arg2, char arg3)

00425e4b  SECURITY_ATTRIBUTES securityAttributes
00425e4b  securityAttributes.nLength = 0xc
00425e52  securityAttributes.lpSecurityDescriptor = 0
00425e55  char var_5
00425e55  
00425e55  if ((arg2.b & 0x80) == 0)
00425e60      var_5 = 0
00425e64      securityAttributes.bInheritHandle = 1
00425e55  else
00425e57      securityAttributes.bInheritHandle = 0
00425e5a      var_5 = 0x10
00425e5a  
00425e7f  if ((0x8000 & arg2) == 0 && ((arg2:1.b & 0x40) != 0 || data_430f00 != 0x8000))
00425e81      var_5 |= 0x80
00425e81  
00425e8a  int32_t eax_1 = arg2 & 3
00425e8e  uint32_t dwDesiredAccess
00425e8e  
00425e8e  if (eax_1 == 0)
00425eac      dwDesiredAccess = 0x80000000
00425eb3      label_425eb3:
00425eb3      int32_t arg_c
00425eb3      int32_t eax_5 = arg_c
00425eb9      enum FILE_SHARE_MODE dwShareMode
00425eb9      
00425eb9      if (eax_5 == 0x10)
00425ee1          dwShareMode = FILE_SHARE_NONE
00425eee          label_425eee:
00425f30          enum FILE_CREATION_DISPOSITION dwCreationDisposition
00425f30          
00425f30          switch (arg2 & 0x700)
00425ef5              case 0, 0x400
00425f25                  dwCreationDisposition = OPEN_EXISTING
00425f28                  goto label_425f6b
00425eff              case 0x100
00425f1c                  dwCreationDisposition = OPEN_ALWAYS
00425f23                  goto label_425f6b
00425f03              case 0x200
00425f09                  goto label_425f58
00425f0b              case 0x300
00425f13                  dwCreationDisposition = CREATE_ALWAYS
00425f1a                  goto label_425f6b
00425f2a              case 0x500
00425f61                  label_425f61:
00425f61                  dwCreationDisposition = CREATE_NEW
00425f6b                  label_425f6b:
00425f6b                  enum FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes =
00425f6b                      FILE_ATTRIBUTE_NORMAL
00425f6b                  
00425f82                  if ((0x100 & arg2) != 0 && ((not.d(data_430b74)).b & arg3 & 0x80) == 0)
00425f86                      dwFlagsAndAttributes = FILE_ATTRIBUTE_READONLY
00425f86                  
00425f89                  if ((arg2.b & 0x40) != 0)
00425f8b                      dwFlagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE
00425f91                      dwDesiredAccess:2.b |= 1
00425f91                  
00425f98                  if ((arg2:1.b & 0x10) != 0)
00425f9a                      dwFlagsAndAttributes |= FILE_ATTRIBUTE_TEMPORARY
00425f9a                  
00425f9e                  if ((arg2.b & 0x20) != 0)
00425fa0                      dwFlagsAndAttributes |= FILE_FLAG_SEQUENTIAL_SCAN
00425f9e                  else if ((arg2.b & 0x10) != 0)
00425fac                      dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS
00425fac                  
00425fb2                  int32_t result_1 = sub_425b59()
00425fb2                  
00425fbe                  if (result_1 == 0xffffffff)
00425fc5                      *sub_41e9bd() = 0x18
00425fd0                      *sub_41e9c6() = 0
00425fd3                      return 0xffffffff
00425fd3                  
00425fed                  HANDLE eax_12 = CreateFileA(lpFileName: arg1, dwDesiredAccess, 
00425fed                      dwShareMode, lpSecurityAttributes: &securityAttributes, 
00425fed                      dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile: nullptr)
00425ff7                  int32_t result
00425ff7                  
00425ff7                  if (eax_12 != 0xffffffff)
0042600e                      enum FILE_TYPE eax_14 = GetFileType(hFile: eax_12)
0042600e                      
00426016                      if (eax_14 != FILE_TYPE_UNKNOWN)
00426024                          if (eax_14 == FILE_TYPE_CHAR)
00426026                              var_5 |= 0x40
00426024                          else if (eax_14 == FILE_TYPE_PIPE)
00426031                              var_5 |= 8
00426031                          
00426037                          sub_425c7c(result_1, eax_12)
0042604f                          char ecx_6 = var_5 | 1
00426055                          arg1:3.b = ecx_6
0042605d                          int32_t esi_3 = (result_1 & 0x1f) * 0x24
00426060                          char temp3_1 = arg1:3.b & 0x48
00426060                          arg1:3.b = temp3_1
00426064                          *((&data_2823880)[result_1 s>> 5] + esi_3 + 4) = ecx_6
00426064                          
00426073                          if (temp3_1 != 0 || (ecx_6 & 0x80) == 0 || (arg2.b & 2) == 0)
004260ec                              label_4260ec:
004260ec                              
004260ec                              if (arg1:3.b == 0 && (arg2.b & 8) != 0)
004260ee                                  int32_t eax_25 = (&data_2823880)[result_1 s>> 5]
004260f0                                  *(eax_25 + esi_3 + 4) |= 0x20
004260f0                              
004260f9                              result = result_1
00426073                          else
0042607a                              int32_t eax_20 = sub_421095(result_1, 0xffffffff, FILE_END)
0042607a                              
00426088                              if (eax_20 != 0xffffffff)
004260a3                                  arg_c:3.b = 0
004260a3                                  
004260be                                  if (sub_420a0f(result_1, &arg_c:3, 1) != 0
004260be                                          || arg_c:3.b != 0x1a)
004260d5                                      label_4260d5:
004260d5                                      
004260e0                                      if (sub_421095(result_1, 0, FILE_BEGIN) != 0xffffffff)
004260e0                                          goto label_4260ec
004260e0                                      
00426098                                      sub_420f25(result_1)
0042609e                                      result = 0xffffffff
004260be                                  else
004260ce                                      if (sub_4276c7(result_1, eax_20) != 0xffffffff)
004260ce                                          goto label_4260d5
004260ce                                      
00426098                                      sub_420f25(result_1)
0042609e                                      result = 0xffffffff
00426088                              else
00426095                                  if (*sub_41e9c6() == 0x83)
00426095                                      goto label_4260ec
00426095                                  
00426098                                  sub_420f25(result_1)
0042609e                                  result = 0xffffffff
00426016                      else
00426019                          CloseHandle(hObject: eax_12)
00426000                          sub_41e94a(GetLastError())
00426006                          result = 0xffffffff
00425ff7                  else
00426000                      sub_41e94a(GetLastError())
00426006                      result = 0xffffffff
00426006                  
004260fc                  sub_425e18(result_1)
00426102                  return result
00425f32              case 0x600
00425f58                  label_425f58:
00425f58                  dwCreationDisposition = TRUNCATE_EXISTING
00425f5f                  goto label_425f6b
00425f3a              case 0x700
00425f3c                  goto label_425f61
00425eb9      else
00425ebe          if (eax_5 == 0x20)
00425ed8              dwShareMode = FILE_SHARE_READ
00425edf              goto label_425eee
00425edf          
00425ec3          if (eax_5 == 0x30)
00425ecf              dwShareMode = FILE_SHARE_WRITE
00425ed6              goto label_425eee
00425ed6          
00425ec8          if (eax_5 == 0x40)
00425eca              dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE
00425ecd              goto label_425eee
00425e8e  else
00425e91      if (eax_1 == 1)
00425ea3          dwDesiredAccess = 0x40000000
00425eaa          goto label_425eb3
00425eaa      
00425e94      if (eax_1 == 2)
00425e9a          dwDesiredAccess = 0xc0000000
00425ea1          goto label_425eb3
00425f43  *sub_41e9bd() = 0x16
00425f4e  *sub_41e9c6() = 0
00425f50  return 0xffffffff


00426109    BOOL sub_426109(uint32_t arg1, uint8_t* arg2, int32_t arg3, uint16_t* arg4, uint32_t arg5, uint32_t arg6, int32_t arg7)

0042610c  int32_t var_8 = 0xffffffff
0042610e  int32_t var_c = 0x429a70
00426113  int32_t var_10 = 0x424e8c
0042611e  TEB* fsbase
0042611e  struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList
0042611f  fsbase->NtTib.ExceptionList = &ExceptionList
0042612c  int32_t __saved_edi
0042612c  int32_t* var_1c = &__saved_edi
0042612f  int32_t eax_1 = data_430dbc
0042612f  
00426138  if (eax_1 != 0)
00426138      goto label_426178
00426138  
00426150  uint16_t charType
00426150  BOOL result
00426150  
00426150  if (GetStringTypeW(dwInfoType: 1, lpSrcStr: &data_4296b0, cchSrc: 1, 
00426150          lpCharType: &charType) == 0)
0042616a      if (GetStringTypeA(Locale: 0, dwInfoType: 1, lpSrcStr: &data_4296ac, cchSrc: 1, 
0042616a              lpCharType: &charType) != 0)
00426172          eax_1 = 2
00426172          goto label_426173
00426172      
0042623e      result = 0
00426150  else
00426152      eax_1 = 1
00426173      label_426173:
00426173      data_430dbc = eax_1
00426178      label_426178:
00426178      
0042617b      if (eax_1 == 2)
0042617d          uint32_t Locale = arg6
0042617d          
00426182          if (Locale == 0)
00426184              Locale = data_430c8c
00426184          
00426196          result = GetStringTypeA(Locale, dwInfoType: arg1, lpSrcStr: arg2, cchSrc: arg3, 
00426196              lpCharType: arg4)
0042617b      else if (eax_1 != 1)
0042623e          result = 0
004261a4      else
004261ad          if (arg5 == 0)
004261b4              arg5 = data_430c9c
004261b4          
004261c2          int32_t eax_6 = neg.d(arg7)
004261ce          int32_t cchWideChar = MultiByteToWideChar(CodePage: arg5, 
004261ce              dwFlags: (sbb.d(eax_6, eax_6, arg7 != 0) & 8) + 1, lpMultiByteStr: arg2, 
004261ce              cbMultiByte: arg3, lpWideCharStr: nullptr, cchWideChar: 0)
004261ce          
004261d9          if (cchWideChar == 0)
0042623e              result = 0
004261d9          else
004261db              int32_t var_8_1 = 0
004261de              int32_t edi_1 = cchWideChar * 2
004261e6              int32_t eax_11
004261e6              eax_11.b = (edi_1 + 3).b & 0xfc
004261e8              sub_41e520(eax_11)
004261ed              int32_t* var_1c_1 = &__saved_edi
004261f2              int32_t* var_28_1 = &__saved_edi
004261f8              sub_4257d0(&__saved_edi, 0, edi_1)
0042620d              int32_t var_8_2 = 0xffffffff
0042620d              
00426213              if (&__saved_edi == 0)
0042623e                  result = 0
00426213              else
00426224                  int32_t cchSrc = MultiByteToWideChar(CodePage: arg5, 
00426224                      dwFlags: MB_PRECOMPOSED, lpMultiByteStr: arg2, cbMultiByte: arg3, 
00426224                      lpWideCharStr: &__saved_edi, cchWideChar)
00426224                  
0042622c                  if (cchSrc == 0)
0042623e                      result = 0
0042622c                  else
00426236                      result = GetStringTypeW(dwInfoType: arg1, lpSrcStr: &__saved_edi, 
00426236                          cchSrc, lpCharType: arg4)
00426236  
00426246  fsbase->NtTib.ExceptionList = ExceptionList
00426251  return result


00426202    int32_t sub_426202() __pure

00426205  return 1

00426206                    8b 65 e8 33 db 33 f6                                                                 .e.3.3.

00426252    int32_t sub_426252(int16_t* arg1, char** arg2, void* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7)

00426258  int32_t ebx
00426258  int32_t var_64 = ebx
0042625b  char* edi = arg3
00426263  void var_60
00426263  void* var_10 = &var_60
00426266  int32_t eax = 0
00426268  int32_t edx = 1
00426269  int16_t var_2c = 0
0042626c  int32_t var_1c = 1
0042626f  int32_t var_8 = 0
00426272  int32_t var_14 = 0
00426275  int32_t var_28 = 0
00426278  int32_t var_24 = 0
0042627b  int32_t var_30 = 0
0042627e  int32_t var_34 = 0
00426281  void* var_20 = nullptr
00426284  int32_t var_c = 0
00426287  int32_t result = 0
0042628a  arg3 = edi
0042628a  
0042628d  while (true)
0042628d      void* ecx
0042628d      ecx.b = *edi
0042628d      
004262a1      if (ecx.b != 0x20 && ecx.b != 9 && ecx.b != 0xa && ecx.b != 0xd)
004262a9          while (true)
004262a9              ebx.b = *edi
004262ab              edi = &edi[1]
004262b5              int32_t var_70_1
004262b5              
004262b5              switch (eax)
004262c4                  case 0
004262c4                      if (ebx.b s>= 0x31 && ebx.b s<= 0x39)
004262c6                          label_4262c6:
004262c6                          var_70_1 = 3
004264ea                          label_4264ea:
004264ea                          eax = var_70_1
004264eb                          edi -= 1
004264ec                          continue
004262c4                      else if (ebx.b != data_42f804)
004262dc                          int32_t eax_1 = sx.d(ebx.b)
004262dc                          
004262e2                          if (eax_1 == 0x2b)
00426302                              var_2c = 0
00426308                              eax = 2
00426309                              continue
004262e2                          else if (eax_1 == 0x2d)
004262f8                              var_2c = -0x8000
004262ff                              eax = 2
00426300                              continue
004262e6                          else
004262eb                              if (eax_1 == 0x30)
00426385                                  eax = 1
00426387                                  continue
00426387                              
004265c5                              edi -= 1
004265c6                              break
004262d3                      else
004262d5                          label_4262d5:
00426522                          eax = 5
00426523                          continue
0042630e                  case 1
0042630e                      var_14 = 1
0042630e                      
00426316                      if (ebx.b s>= 0x31 && ebx.b s<= 0x39)
00426311                          goto label_4262c6
00426311                      
0042631e                      if (ebx.b == data_42f804)
004263e0                          eax = 4
004263e2                          continue
0042631e                      else if (ebx.b == 0x2b || ebx.b == 0x2d)
0042635a                          label_42635a:
0042635a                          edi -= 1
00426522                          eax = 0xb
00426523                          continue
0042632c                      else if (ebx.b == 0x30)
00426385                          eax = 1
00426387                          continue
00426331                      else
00426333                          label_426333:
00426333                          
0042634d                          if (ebx.b s<= 0x43
0042634d                                  || (ebx.b s> 0x45 && (ebx.b s<= 0x63 || ebx.b s> 0x65)))
004265c5                              edi -= 1
004265c6                              break
004265c6                          
00426522                          eax = 6
00426523                          continue
0042636a                  case 2
0042636a                      if (ebx.b s>= 0x31 && ebx.b s<= 0x39)
00426365                          goto label_4262c6
00426365                      
00426376                      if (ebx.b == data_42f804)
00426376                          goto label_4262d5
00426376                      
0042637f                      if (ebx.b == 0x30)
00426385                          eax = 1
00426387                          continue
00426387                      
0042653a                      edi = arg3
0042653d                      break
0042638c                  case 3
0042638c                      var_14 = 1
0042638c                      
00426395                      while (true)
00426395                          BOOL eax_7
00426395                          
00426395                          if (data_42f800 s<= 1)
004263a8                              ecx = data_42f5f4
004263b1                              uint32_t eax_8
004263b1                              eax_8.b = *(ecx + (zx.d(ebx.b) << 1))
004263b4                              eax_7 = eax_8 & 4
00426395                          else
00426397                              uint32_t eax_6 = zx.d(ebx.b)
0042639c                              eax_7 = sub_421804(eax_6, 1, ecx, eax_6)
004263a2                              ecx = 4
004263a5                              edx = 1
004263a5                          
004263b8                          if (eax_7 == 0)
004263b8                              break
004263b8                          
004263be                          if (var_8 u>= 0x19)
004263d0                              var_c += 1
004263be                          else
004263c0                              void* eax_9 = var_10
004263c3                              var_8 += 1
004263c6                              ebx.b -= 0x30
004263c9                              var_10 += 1
004263cc                              *eax_9 = ebx.b
004263cc                          
004263d3                          ebx.b = *edi
004263d5                          edi = &edi[1]
004263d5                      
004263de                      if (ebx.b == data_42f804)
004263e0                          eax = 4
004263e2                          continue
004263e2                      
00426447                      label_426447:
00426447                      
00426453                      if (ebx.b == 0x2b || ebx.b == 0x2d)
0042644a                          goto label_42635a
0042644a                      
0042644a                      goto label_426333
004263eb                  case 4
004263eb                      var_14 = 1
004263ee                      var_28 = 1
004263ee                      
004263f1                      if (var_8 == 0)
004263f6                          while (ebx.b == 0x30)
004263f8                              var_c -= 1
004263fb                              ebx.b = *edi
004263fd                              edi = &edi[1]
004263fd                      
00426406                      while (true)
00426406                          BOOL eax_11
00426406                          
00426406                          if (data_42f800 s<= 1)
00426419                              ecx = data_42f5f4
00426422                              uint32_t eax_12
00426422                              eax_12.b = *(ecx + (zx.d(ebx.b) << 1))
00426425                              eax_11 = eax_12 & 4
00426406                          else
00426408                              uint32_t eax_10 = zx.d(ebx.b)
0042640d                              eax_11 = sub_421804(eax_10, 1, ecx, eax_10)
00426413                              ecx = 4
00426416                              edx = 1
00426416                          
00426429                          if (eax_11 == 0)
00426429                              break
00426429                          
0042642f                          if (var_8 u< 0x19)
00426431                              void* eax_13 = var_10
00426434                              var_8 += 1
00426437                              ebx.b -= 0x30
0042643a                              var_10 += 1
0042643d                              var_c -= 1
00426440                              *eax_13 = ebx.b
00426440                          
00426442                          ebx.b = *edi
00426444                          edi = &edi[1]
00426444                      
00426429                      goto label_426447
00426464                  case 5
00426464                      var_28 = 1
00426467                      BOOL eax_15
00426467                      
00426467                      if (data_42f800 s<= 1)
0042647a                          ecx = data_42f5f4
00426483                          uint32_t eax_16
00426483                          eax_16.b = *(ecx + (zx.d(ebx.b) << 1))
00426486                          eax_15 = eax_16 & 4
00426467                      else
00426469                          uint32_t eax_14 = zx.d(ebx.b)
0042646e                          eax_15 = sub_421804(eax_14, 1, ecx, eax_14)
00426474                          ecx = 4
00426477                          edx = 1
00426477                      
0042648a                      if (eax_15 == 0)
0042653a                          edi = arg3
0042653d                          break
0042653d                      
00426490                      eax = 4
004264eb                      edi -= 1
004264ec                      continue
00426494                  case 6
00426494                      ecx = &edi[0xfffffffe]
0042649a                      arg3 = ecx
0042649a                      
004264a2                      if (ebx.b s>= 0x31 && ebx.b s<= 0x39)
004264e8                          label_4264e8:
004264e8                          var_70_1 = 9
004264e8                          goto label_4264ea
004264e8                      
004264a4                      int32_t eax_17 = sx.d(ebx.b)
004264a4                      
004264aa                      if (eax_17 == 0x2b)
004264aa                          goto label_426520
004264aa                      
004264ae                      if (eax_17 == 0x2d)
004264ae                          goto label_426514
004264ae                      
004264b3                      if (eax_17 == 0x30)
004264b3                          goto label_4264b9
004264b3                      
004265c8                      edi = ecx
004265c8                      break
004264e6                  case 7
004264e6                      if (ebx.b s>= 0x31 && ebx.b s<= 0x39)
004264e1                          goto label_4264e8
004264e1                      
004264f4                      if (ebx.b != 0x30)
0042653a                          edi = arg3
0042653d                          break
0042653d                      
004264b9                      label_4264b9:
00426522                      eax = 8
00426523                      continue
004264bd                  case 8
004264bd                      var_24 = 1
004264bd                      
004264c3                      while (ebx.b == 0x30)
004264c5                          ebx.b = *edi
004264c7                          edi = &edi[1]
004264c7                      
004264d6                      if (ebx.b s>= 0x31 && ebx.b s<= 0x39)
004264cd                          goto label_4264e8
004264cd                      
004265c5                      edi -= 1
004265c6                      break
00426542                  case 9
00426542                      var_24 = 1
00426549                      void* esi_1 = nullptr
00426549                      
00426552                      while (true)
00426552                          BOOL eax_27
00426552                          
00426552                          if (data_42f800 s<= 1)
00426563                              ecx = data_42f5f4
0042656c                              uint32_t eax_28
0042656c                              eax_28.b = *(ecx + (zx.d(ebx.b) << 1))
0042656f                              eax_27 = eax_28 & 4
00426552                          else
00426554                              uint32_t eax_26 = zx.d(ebx.b)
0042655a                              eax_27, edx = sub_421804(eax_26, edx, ecx, eax_26)
00426560                              ecx = 4
00426560                          
00426574                          if (eax_27 == 0)
00426574                              break
00426574                          
00426576                          ecx = sx.d(ebx.b)
0042657c                          esi_1 = ecx + esi_1 * 0xa - 0x30
0042657c                          
00426586                          if (esi_1 s> 0x1450)
0042658d                              esi_1 = 0x1451
0042658d                              break
0042658d                          
00426588                          ebx.b = *edi
0042658a                          edi = &edi[1]
0042658a                      
00426592                      var_20 = esi_1
00426592                      
0042659c                      while (true)
0042659c                          BOOL eax_31
0042659c                          
0042659c                          if (data_42f800 s<= 1)
004265ad                              ecx = data_42f5f4
004265b6                              uint32_t eax_32
004265b6                              eax_32.b = *(ecx + (zx.d(ebx.b) << 1))
004265b9                              eax_31 = eax_32 & 4
0042659c                          else
0042659e                              uint32_t eax_30 = zx.d(ebx.b)
004265a4                              eax_31, edx = sub_421804(eax_30, edx, ecx, eax_30)
004265aa                              ecx = 4
004265aa                          
004265be                          if (eax_31 == 0)
004265be                              break
004265be                          
004265c0                          ebx.b = *edi
004265c2                          edi = &edi[1]
004265c2                      
004265c5                      edi -= 1
004265c6                      break
004264fc                  case 0xb
004264fc                      if (arg7 == 0)
0042652a                          edi -= 1
0042652b                          eax = 0xa
004264fc                      else
004264fe                          int32_t eax_22 = sx.d(ebx.b)
00426501                          ecx = &edi[0xffffffff]
00426507                          arg3 = ecx
00426507                          
0042650a                          if (eax_22 == 0x2b)
00426520                              label_426520:
00426522                              eax = 7
00426523                              continue
0042650a                          else
0042650e                              if (eax_22 != 0x2d)
004265c8                                  edi = ecx
004265c8                                  break
004265c8                              
00426514                              label_426514:
00426514                              var_1c = 0xffffffff
0042651a                              eax = 7
0042651b                              continue
0042651b              
0042652f              if (eax == 0xa)
0042652f                  break
0042652f          
004265d1          *arg2 = edi
004265d3          int16_t eax_38
004265d3          int16_t edx_1
004265d3          void* ebx_1
004265d3          void* esi_2
004265d3          
004265d3          if (var_14 == 0)
004266b2              edx_1 = 0
004266b4              eax_38 = 0
004266b6              esi_2 = nullptr
004266b8              ebx_1 = nullptr
004266ba              result = 4
004265d3          else
004265df              void* eax_35
004265df              
004265df              if (var_8 u<= 0x18)
004265f6                  eax_35 = var_10
004265df              else
004265e5                  char var_49
004265e5                  
004265e5                  if (var_49 s>= 5)
004265e7                      char var_49_1 = var_49 + 1
004265e7                  
004265ea                  var_8 = 0x18
004265f0                  eax_35 = var_10 - 1
004265f1                  var_c += 1
004265f1              
004265fd              if (var_8 u<= 0)
004266a8                  edx_1 = 0
004266aa                  eax_38 = 0
004266ac                  esi_2 = nullptr
004266ae                  ebx_1 = nullptr
004265fd              else
00426603                  while (true)
00426603                      eax_35 -= 1
00426603                      
00426607                      if (*eax_35 != 0)
00426607                          break
00426607                      
00426609                      var_8 -= 1
0042660c                      var_c += 1
0042660c                  
0042661c                  int32_t var_44
0042661c                  sub_42736d(&var_60, var_8, &var_44)
00426621                  void* eax_36 = var_20
00426621                  
0042662c                  if (var_1c s< 0)
0042662e                      eax_36 = neg.d(eax_36)
0042662e                  
00426630                  void* eax_37 = eax_36 + var_c
00426630                  
00426636                  if (var_24 == 0)
00426638                      eax_37 += arg5
00426638                  
0042663e                  if (var_28 == 0)
00426640                      eax_37 -= arg6
00426640                  
00426648                  if (eax_37 s<= 0x1450)
0042667f                      if (eax_37 s< 0xffffebb0)
00426681                          var_34 = 1
00426688                          goto label_426651
00426688                      
00426692                      sub_427a0c(&var_44, eax_37, arg4)
00426697                      edx_1 = var_44.w
0042669a                      ebx_1 = var_44
0042669d                      void* var_3e
0042669d                      esi_2 = var_3e
004266a0                      int16_t var_3a
004266a0                      eax_38 = var_3a
00426648                  else
0042664a                      var_30 = 1
00426651                      label_426651:
00426651                      ebx_1 = arg3
00426654                      esi_2 = arg3
00426657                      eax_38 = arg3.w
0042665a                      edx_1 = arg3.w
0042665a              
00426661              if (var_30 != 0)
00426663                  ebx_1 = nullptr
00426665                  eax_38 = 0x7fff
0042666a                  esi_2 = 0x80000000
0042666f                  edx_1 = 0
00426671                  result = 2
00426661              else if (var_34 != 0)
004266c9                  edx_1 = 0
004266cb                  eax_38 = 0
004266cd                  esi_2 = nullptr
004266cf                  ebx_1 = nullptr
004266d1                  result = 1
004266d1          
004266df          *(arg1 + 6) = esi_2
004266e2          *(arg1 + 2) = ebx_1
004266e5          arg1[5] = eax_38 | var_2c
004266ed          *arg1 = edx_1
004266f2          return result
004266f2      
004262a3      edi = &edi[1]

004266f3  uint32_t jump_table_4266f3[0xc] = 
004266f3  {
004266f3      [0x0] =  0x004262bc
004266f7      [0x1] =  0x0042630b
004266fb      [0x2] =  0x00426362
004266ff      [0x3] =  0x0042638c
00426703      [0x4] =  0x004263e7
00426707      [0x5] =  0x0042645e
0042670b      [0x6] =  0x00426494
0042670f      [0x7] =  0x004264de
00426713      [0x8] =  0x004264bd
00426717      [0x9] =  0x00426542
0042671b      [0xa] =  0x0042652c
0042671f      [0xb] =  0x004264f8
00426723  }

00426723    int32_t sub_426723(int16_t* arg1, char* arg2, int32_t arg3)

0042672f  InterlockedIncrement(&data_282384c)
0042673b  int32_t ebx = 0
0042673b  
00426743  if (data_2823848 != 0)
00426746      InterlockedDecrement(&data_282384c)
0042674a      sub_421919(0x13)
00426752      ebx = 1
00426752  
0042675c  int32_t result = sub_426780(arg1, arg2, arg3)
0042675c  
00426769  if (ebx == 0)
00426776      InterlockedDecrement(&data_282384c)
00426769  else
0042676d      sub_42197a(0x13)
0042676d  
0042677f  return result


00426780    int32_t sub_426780(int16_t* arg1, char* arg2, int32_t arg3)

00426791  if (arg2 != 0 && arg3 != 0)
00426793      uint16_t eax
00426793      eax.b = *arg2
00426793      
00426797      if (eax.b != 0)
004267af          if (data_430c8c != 0)
004267d2              if ((*(&(*data_42f5f4)[zx.d(eax.b)] + 1) & 0x80) != 0)
004267d4                  int32_t cbMultiByte = data_42f800
004267d4                  
004267dc                  if (cbMultiByte s<= 1)
00426808                      label_426808:
00426808                      
00426810                      if (arg3 u>= cbMultiByte && arg2[1] != 0)
004267a8                          return cbMultiByte
004267dc                  else if (arg3 s>= cbMultiByte)
004267e8                      int32_t cchWideChar_1
004267e8                      cchWideChar_1.b = arg1 != 0
004267ff                      bool cond:0_1 = MultiByteToWideChar(CodePage: data_430c9c, 
004267ff                          dwFlags: MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, 
004267ff                          lpMultiByteStr: arg2, cbMultiByte, lpWideCharStr: arg1, 
004267ff                          cchWideChar: cchWideChar_1) != 0
00426801                      cbMultiByte = data_42f800
00426801                      
00426806                      if (cond:0_1)
004267a8                          return cbMultiByte
004267a8                      
00426806                      goto label_426808
00426806                  
00426817                  *sub_41e9bd() = 0x2a
0042681d                  return 0xffffffff
0042681d              
00426827              int32_t cchWideChar
00426827              cchWideChar.b = arg1 != 0
00426827              
00426841              if (MultiByteToWideChar(CodePage: data_430c9c, 
00426841                      dwFlags: MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, lpMultiByteStr: arg2, 
00426841                      cbMultiByte: 1, lpWideCharStr: arg1, cchWideChar) == 0)
00426817                  *sub_41e9bd() = 0x2a
0042681d                  return 0xffffffff
004267af          else if (arg1 != 0)
004267bc              *arg1 = zx.w(eax.b)
004267bc          
004267c1          return 1
004267c1      
0042679e      if (arg1 != 0)
004267a0          *arg1 = 0
004267a0  
004267a3  return 0


00426849    BOOL sub_426849(int32_t arg1)

00426850  if (data_42f800 s> 1)
0042685f      int32_t eax
0042685f      int32_t ecx
0042685f      int32_t edx
0042685f      return sub_421804(eax, edx, ecx, arg1)
0042685f  
0042686a  int32_t eax_2
0042686a  eax_2.b = (*data_42f5f4)[arg1].b
00426870  return eax_2 & 8

00426871                                                     cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc                   ...............

00426880    int32_t __convention("regparm") __allshl(int32_t arg1, int32_t arg2, char arg3) __pure

00426883  if (arg3 u>= 0x40)
0042689e      return 0
0042689e  
00426888  if (arg3 u>= 0x20)
00426899      return 0
00426899  
0042688f  return arg1 << arg3


0042689f    uint32_t sub_42689f(int32_t arg1, int32_t* arg2)

004268a8  if (arg1 != 0xffffffff)
004268ae      char eax_1 = (arg2[3]).b
004268ae      
004268b3      if ((eax_1 & 1) != 0)
004268c1          label_4268c1:
004268c1          
004268c1          if (arg2[2] == 0)
004268c4              sub_425b15(arg2)
004268c4          
004268ca          int32_t eax_2 = *arg2
004268ca          
004268cf          if (eax_2 != arg2[2])
004268cf              goto label_4268da
004268cf          
004268d5          if (arg2[1] == 0)
004268d8              *arg2 = eax_2 + 1
004268da              label_4268da:
004268da              
004268de              if ((arg2[3].b & 0x40) == 0)
004268f1                  *arg2 -= 1
004268f5                  **arg2 = arg1.b
004268f7                  label_4268f7:
004268f7                  int32_t eax_8 = arg2[3]
004268fa                  arg2[1] += 1
004268fd                  eax_8.b &= 0xef
004268ff                  eax_8.b |= 1
00426901                  arg2[3] = eax_8
00426906                  return zx.d(arg1.b)
00426906              
004268e0              *arg2 -= 1
004268e2              char* eax_4 = *arg2
004268e2              
004268e6              if (*eax_4 == arg1.b)
004268e6                  goto label_4268f7
004268e6              
004268e9              *arg2 = &eax_4[1]
004268b3      else if ((eax_1 & 0x80) != 0 && (eax_1 & 2) == 0)
004268bb          goto label_4268c1
004268bb  
004268eb  return 0xffffffff


0042690d    void sub_42690d()

00426914  if (data_430e78 == 0)
00426918      sub_421919(0xb)
00426918      
00426925      if (data_430e78 == 0)
00426927          sub_42693b(0xb)
0042692c          data_430e78 += 1
0042692c      
00426934      sub_42197a(0xb)


0042693b    uint32_t __fastcall sub_42693b(BOOL arg1)

0042693e  BOOL usedDefaultChar = arg1
0042693f  BOOL var_c = arg1
00426949  int32_t var_c_1 = 0
0042694c  sub_421919(0xc)
00426951  data_42fec8 = 0xffffffff
00426958  data_42feb8 = 0xffffffff
0042695f  data_430dc0 = 0
0042696c  void* eax = sub_427a88(&data_429abc)
00426976  uint32_t result
00426976  
00426976  if (eax == 0)
0042697d      sub_42197a(0xc)
00426989      result = GetTimeZoneInformation(lpTimeZoneInformation: &data_430dc8)
00426989      
00426992      if (result != 0xffffffff)
0042699d          int32_t ecx_1 = data_430e1c
004269a3          int32_t eax_2 = data_430dc8 * 0x3c
004269a6          bool cond:0_1 = data_430e0e == 0
004269b0          data_42fe20 = eax_2
004269b5          data_430dc0 = 1
004269b5          
004269bb          if (not(cond:0_1))
004269c4              data_42fe20 = eax_2 + ecx_1 * 0x3c
004269c4          
004269d0          int32_t eax_4
004269d0          
004269d0          if (data_430e62 != 0)
004269d2              eax_4 = data_430e70
004269d2          
004269d9          if (data_430e62 == 0 || eax_4 == 0)
004269ed              data_42fe24 = 0
004269f3              data_42fe28 = 0
004269d9          else
004269dd              data_42fe24 = 1
004269e6              data_42fe28 = (eax_4 - ecx_1) * 0x3c
004269e6          
00426a28          if (WideCharToMultiByte(CodePage: data_430c9c, dwFlags: 0x220, 
00426a28                  lpWideCharStr: &data_430dcc, cchWideChar: 0xffffffff, 
00426a28                  lpMultiByteStr: data_42feac, cbMultiByte: 0x3f, lpDefaultChar: nullptr, 
00426a28                  lpUsedDefaultChar: &usedDefaultChar) == 0 || usedDefaultChar != 0)
00426a3a              *data_42feac = 0
00426a28          else
00426a2f              *(data_42feac + 0x3f) = 0
00426a2f          
00426a65          if (WideCharToMultiByte(CodePage: data_430c9c, dwFlags: 0x220, 
00426a65                  lpWideCharStr: &data_430e20, cchWideChar: 0xffffffff, 
00426a65                  lpMultiByteStr: data_42feb0, cbMultiByte: 0x3f, lpDefaultChar: nullptr, 
00426a65                  lpUsedDefaultChar: &usedDefaultChar) == 0 || usedDefaultChar != 0)
00426bac              result = data_42feb0
00426bb1              *result = 0
00426a65          else
00426a6b              result = data_42feb0
00426a70              *(result + 0x3f) = 0
00426976  else if (*eax == 0)
00426bb7      result = sub_42197a(0xc)
00426a7c  else
00426a82      char* eax_11 = data_430e74
00426a89      bool cond:2_1
00426a89      
00426a89      if (eax_11 != 0)
00426a93          cond:2_1 = sub_426ed0(eax, eax_11) == 0
00426a93      
00426a96      if (eax_11 != 0 && cond:2_1)
00426bb7          result = sub_42197a(0xc)
00426a96      else
00426aa2          sub_41e29e(data_430e74)
00426aaf          void* eax_15 = sub_41e583(sub_422550(eax) + 1)
00426ab9          data_430e74 = eax_15
00426ab9          
00426abe          if (eax_15 == 0)
00426bb7              result = sub_42197a(0xc)
00426abe          else
00426ac6              sub_4230a0(eax_15, eax)
00426acc              sub_42197a(0xc)
00426ada              sub_41e720(data_42feac, eax, 3)
00426ae4              void* esi_3 = eax + 3
00426aea              *(data_42feac + 3) = 0
00426aea              
00426af1              if (*esi_3 == 0x2d)
00426af3                  var_c_1 = 1
00426afa                  esi_3 += 1
00426afa              
00426b06              int32_t ecx_4 = sub_41e208(esi_3) * 0xe10
00426b0c              data_42fe20 = ecx_4
00426b0c              
00426b12              while (true)
00426b12                  int32_t eax_17
00426b12                  eax_17.b = *esi_3
00426b12                  
00426b16                  if (eax_17.b != 0x2b)
00426b1a                      if (eax_17.b s< 0x30)
00426b1a                          break
00426b1a                      
00426b1e                      if (eax_17.b s> 0x39)
00426b1e                          break
00426b1e                  
00426b20                  esi_3 += 1
00426b20              
00426b26              if (*esi_3 == 0x3a)
00426b28                  esi_3 += 1
00426b2f                  int32_t eax_19 = sub_41e208(esi_3) * 0x3c
00426b39                  ecx_4 = data_42fe20 + eax_19
00426b3b                  data_42fe20 = ecx_4
00426b3b                  
00426b41                  while (true)
00426b41                      eax_19.b = *esi_3
00426b41                      
00426b45                      if (eax_19.b s< 0x30)
00426b45                          break
00426b45                      
00426b49                      if (eax_19.b s> 0x39)
00426b49                          break
00426b49                      
00426b4b                      esi_3 += 1
00426b4b                  
00426b51                  if (*esi_3 == 0x3a)
00426b53                      esi_3 += 1
00426b55                      int32_t eax_20 = sub_41e208(esi_3)
00426b61                      ecx_4 = data_42fe20 + eax_20
00426b63                      data_42fe20 = ecx_4
00426b63                      
00426b69                      while (true)
00426b69                          eax_20.b = *esi_3
00426b69                          
00426b6d                          if (eax_20.b s< 0x30)
00426b6d                              break
00426b6d                          
00426b71                          if (eax_20.b s> 0x39)
00426b71                              break
00426b71                          
00426b73                          esi_3 += 1
00426b73              
00426b7a              if (var_c_1 != 0)
00426b7e                  data_42fe20 = neg.d(ecx_4)
00426b7e              
00426b84              int32_t eax_21 = sx.d(*esi_3)
00426b89              data_42fe24 = eax_21
00426b89              
00426b8e              if (eax_21 == 0)
00426bac                  result = data_42feb0
00426bb1                  *result = 0
00426b8e              else
00426b99                  sub_41e720(data_42feb0, esi_3, 3)
00426b9e                  result = data_42feb0
00426ba6                  *(result + 3) = 0
00426ba6  
00426bc1  return result


00426bc2    int32_t sub_426bc2(void* arg1)

00426bc5  sub_421919(0xb)
00426bce  int32_t result = sub_426be3(arg1)
00426bd7  sub_42197a(0xb)
00426be2  return result


00426be3    int32_t sub_426be3(void* arg1)

00426bee  if (data_42fe24 != 0)
00426bfe      int32_t eax_1 = *(arg1 + 0x14)
00426bfe      
00426c0f      if (eax_1 != data_42feb8 || eax_1 != data_42fec8)
00426c1b          if (data_430dc0 == 0)
00426cfa              sub_426d8f(1, 1, eax_1, 4, 1, 0, 0, 2, 0, 0, 0)
00426d0f              sub_426d8f(0, 1, *(arg1 + 0x14), 0xa, 5, 0, 0, 2, 0, 0, 0)
00426c1b          else
00426c48              int32_t var_34_1
00426c48              int32_t var_30_1
00426c48              uint32_t var_2c_1
00426c48              uint32_t var_28_1
00426c48              uint32_t var_24_1
00426c48              uint32_t var_20_1
00426c48              
00426c48              if (data_430e60 != 0)
00426c6e                  var_20_1 = zx.d(data_430e66)
00426c6f                  var_24_1 = 0
00426c77                  var_28_1 = 0
00426c78                  var_2c_1 = zx.d(data_430e62)
00426c79                  var_30_1 = eax_1
00426c7a                  var_34_1 = 0
00426c48              else
00426c51                  var_20_1 = 0
00426c52                  var_24_1 = zx.d(data_430e64)
00426c5a                  var_28_1 = zx.d(data_430e66)
00426c62                  var_2c_1 = zx.d(data_430e62)
00426c63                  var_30_1 = eax_1
00426c64                  var_34_1 = 1
00426c64              
00426c7c              sub_426d8f(1, var_34_1, var_30_1, var_2c_1, var_28_1, var_24_1, var_20_1, 
00426c7c                  zx.d(data_430e68), zx.d(data_430e6a), zx.d(data_430e6c), 
00426c7c                  zx.d(data_430e6e))
00426cab              int32_t var_34_2
00426cab              int32_t var_30_2
00426cab              uint32_t var_2c_2
00426cab              uint32_t var_28_2
00426cab              uint32_t var_24_2
00426cab              uint32_t var_20_2
00426cab              
00426cab              if (data_430e0c != 0)
00426cdc                  var_20_2 = zx.d(data_430e12)
00426cdd                  var_24_2 = 0
00426ce5                  var_28_2 = 0
00426ce6                  var_2c_2 = zx.d(data_430e0e)
00426ce7                  var_30_2 = *(arg1 + 0x14)
00426cea                  var_34_2 = 0
00426cab              else
00426cb4                  var_20_2 = 0
00426cb5                  var_24_2 = zx.d(data_430e10)
00426cbd                  var_28_2 = zx.d(data_430e12)
00426cc5                  var_2c_2 = zx.d(data_430e0e)
00426cc6                  var_30_2 = *(arg1 + 0x14)
00426cc9                  var_34_2 = 1
00426cc9              
00426ccb              sub_426d8f(0, var_34_2, var_30_2, var_2c_2, var_28_2, var_24_2, var_20_2, 
00426ccb                  zx.d(data_430e14), zx.d(data_430e16), zx.d(data_430e18), 
00426ccb                  zx.d(data_430e1a))
00426ccb      
00426d17      int32_t edx_1 = data_42febc
00426d1d      int32_t eax_11 = data_42fecc
00426d22      int32_t ecx_10 = *(arg1 + 0x1c)
00426d22      
00426d27      if (edx_1 s>= eax_11)
00426d4d          if (ecx_10 s< eax_11 || ecx_10 s> edx_1)
00426d41              return 1
00426d41          
00426d55          if (ecx_10 s<= eax_11 || ecx_10 s>= edx_1)
00426d69              label_426d69:
00426d69              int32_t eax_18 = ((*(arg1 + 8) * 0x3c + *(arg1 + 4)) * 0x3c + *arg1) * 0x3e8
00426d71              int32_t result
00426d71              
00426d71              if (ecx_10 != edx_1)
00426d8a                  result.b = eax_18 s< data_42fed0
00426d71              else
00426d7b                  result.b = eax_18 s>= data_42fec0
00426d7b              
00426d7e              return result
00426d27      else if (ecx_10 s>= edx_1 && ecx_10 s<= eax_11)
00426d3f          if (ecx_10 s<= edx_1 || ecx_10 s>= eax_11)
00426d3b              goto label_426d69
00426d3b          
00426d41          return 1
00426d41  
00426bf0  return 0


00426d8f    int32_t sub_426d8f(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, int32_t arg9, int32_t arg10, int32_t arg11)

00426d9b  int32_t ecx_1
00426d9b  
00426d9b  if (arg2 != 1)
00426e30      int32_t ecx_2
00426e30      
00426e30      if ((arg3.b & 3) != 0)
00426e3b          ecx_2 = *((arg4 << 2) + &data_42ff04)
00426e30      else
00426e32          ecx_2 = (&data_42fed0)[arg4]
00426e32      
00426e42      ecx_1 = ecx_2 + arg7
00426d9b  else
00426da7      int32_t temp2_1 = arg3 & 3
00426dad      int32_t eax_1
00426dad      int32_t esi_2
00426dad      
00426dad      if (temp2_1 != 0)
00426dba          esi_2 = arg4 << 2
00426dbd          eax_1 = *(esi_2 + &data_42ff04)
00426dad      else
00426daf          esi_2 = arg4 << 2
00426db2          eax_1 = *(esi_2 + &data_42fed0)
00426db2      
00426de4      int32_t temp1_1 =
00426de4          mods.dp.d(sx.q(arg3 * 0x16d + eax_1 + 1 + ((arg3 - 1) s>> 2) - 0x63db), 7)
00426de4      
00426ded      if (temp1_1 s>= arg6)
00426e05          ecx_1 = eax_1 + 1 + arg5 * 7 - temp1_1 + arg6
00426ded      else
00426df7          ecx_1 = eax_1 + 1 + arg5 * 7 - temp1_1 + arg6 - 7
00426df7      
00426e0b      if (arg5 == 5)
00426e11          int32_t esi_3
00426e11          
00426e11          if (temp2_1 != 0)
00426e1b              esi_3 = *(esi_2 + 0x42ff08)
00426e11          else
00426e13              esi_3 = *(esi_2 + 0x42fed4)
00426e13          
00426e23          if (ecx_1 s> esi_3)
00426e25              ecx_1 -= 7
00426e25  
00426e49  int32_t result
00426e49  
00426e49  if (arg1 != 1)
00426e79      data_42fecc = ecx_1
00426e91      int32_t eax_26 = ((arg8 * 0x3c + arg9) * 0x3c + data_42fe28 + arg10) * 0x3e8
00426e97      result = eax_26 + arg11
00426e9a      data_42fed0 = result
00426e9a      
00426e9f      if (eax_26 + arg11 s< 0)
00426ea1          result += 0x5265c00
00426ea7          data_42fed0 = result
00426ebf          data_42fecc = ecx_1 - 1
00426e9f      else if (result s>= 0x5265c00)
00426eb7          result -= 0x5265c00
00426eba          data_42fed0 = result
00426ebf          data_42fecc = ecx_1 + 1
00426ebf      
00426ec5      data_42fec8 = arg3
00426e49  else
00426e4e      data_42febc = ecx_1
00426e5a      data_42feb8 = arg3
00426e6c      result = ((arg8 * 0x3c + arg9) * 0x3c + arg10) * 0x3e8 + arg11
00426e6f      data_42fec0 = result
00426e6f  
00426ece  return result

00426ecf                                               cc                                                                 .

00426ed0    int32_t sub_426ed0(int32_t* arg1, char* arg2)

00426ed0  int32_t* edx = arg1
00426ed4  char* ecx = arg2
00426ede  uint32_t eax
00426ede  
00426ede  if ((edx & 3) != 0)
00426f22      if ((edx & 1) == 0)
00426f38          label_426f38:
00426f38          eax.w = *edx
00426f3b          edx += 2
00426f3e          char temp1_1 = *ecx
00426f3e          
00426f40          if (eax.b != temp1_1)
00426f19              return (sbb.d(eax, eax, eax.b u< temp1_1) << 1) + 1
00426f19          
00426f42          eax.b = eax.b
00426f42          
00426f44          if (eax.b == 0)
00426f12              return 0
00426f12          
00426f46          char temp4_1 = ecx[1]
00426f46          
00426f49          if (eax:1.b != temp4_1)
00426f19              return (sbb.d(eax, eax, eax:1.b u< temp4_1) << 1) + 1
00426f19          
00426f4b          eax:1.b = eax:1.b
00426f4b          
00426f4d          if (eax:1.b == 0)
00426f12              return 0
00426f12          
00426f4f          ecx = &ecx[2]
00426f22      else
00426f24          eax.b = *edx
00426f26          edx += 1
00426f27          char temp2_1 = *ecx
00426f27          
00426f29          if (eax.b != temp2_1)
00426f19              return (sbb.d(eax, eax, eax.b u< temp2_1) << 1) + 1
00426f19          
00426f2b          ecx = &ecx[1]
00426f2c          eax.b = eax.b
00426f2c          
00426f2e          if (eax.b == 0)
00426f12              return 0
00426f12          
00426f36          if ((edx & 2) != 0)
00426f36              goto label_426f38
00426f36  
00426ee0  while (true)
00426ee0      eax = *edx
00426ee2      char temp0_1 = *ecx
00426ee2      
00426ee4      if (eax.b != temp0_1)
00426f19          return (sbb.d(eax, eax, eax.b u< temp0_1) << 1) + 1
00426f19      
00426ee6      eax.b = eax.b
00426ee6      
00426ee8      if (eax.b == 0)
00426f12          return 0
00426f12      
00426eea      char temp3_1 = ecx[1]
00426eea      
00426eed      if (eax:1.b != temp3_1)
00426f19          return (sbb.d(eax, eax, eax:1.b u< temp3_1) << 1) + 1
00426f19      
00426eef      eax:1.b = eax:1.b
00426eef      
00426ef1      if (eax:1.b == 0)
00426f12          return 0
00426f12      
00426ef3      eax u>>= 0x10
00426ef6      char temp5_1 = ecx[2]
00426ef6      
00426ef9      if (eax.b != temp5_1)
00426f19          return (sbb.d(eax, eax, eax.b u< temp5_1) << 1) + 1
00426f19      
00426efb      eax.b = eax.b
00426efb      
00426efd      if (eax.b == 0)
00426f12          return 0
00426f12      
00426eff      char temp6_1 = ecx[3]
00426eff      
00426f02      if (eax:1.b != temp6_1)
00426f19          return (sbb.d(eax, eax, eax:1.b u< temp6_1) << 1) + 1
00426f19      
00426f04      ecx = &ecx[4]
00426f07      edx = &edx[1]
00426f0a      eax:1.b = eax:1.b
00426f0a      
00426f0c      if (eax:1.b == 0)
00426f12          return 0

00426f13                                                           90                                                         .
00426f1a                                                                                8b ff                                        ..
00426f54                                                              cc cc cc cc cc cc cc cc cc cc cc cc                      ............

00426f60    int32_t sub_426f60(char* arg1, char* arg2)

00426f6d  int32_t s
00426f6d  __builtin_memset(&s, c: 0, n: 0x20)
00426f6e  char* edx = arg2
00426f74  int32_t eax
00426f74  
00426f74  while (true)
00426f74      eax.b = *edx
00426f76      eax.b = eax.b
00426f76      
00426f78      if (eax.b == 0)
00426f78          break
00426f78      
00426f7a      edx = &edx[1]
00426f7b      s |= 1 << (eax u% 0x20)
00426f7b  
00426f81  char* esi = arg1
00426f84  int32_t result = 0xffffffff
00426f84  
00426f94  do
00426f88      result += 1
00426f89      eax.b = *esi
00426f8b      eax.b = eax.b
00426f8b      
00426f8d      if (eax.b == 0)
00426f8d          break
00426f8d      
00426f8f      esi = &esi[1]
00426f94  while (not(test_bit(s, eax)))
00426f94  
00426f9d  return result

00426f9e                                                                                            cc cc                                ..

00426fa0    void* sub_426fa0(char* arg1, char* arg2)

00426fad  int32_t s
00426fad  __builtin_memset(&s, c: 0, n: 0x20)
00426fae  char* edx = arg2
00426fb4  void* result
00426fb4  
00426fb4  while (true)
00426fb4      result.b = *edx
00426fb6      result.b = result.b
00426fb6      
00426fb8      if (result.b == 0)
00426fb8          break
00426fb8      
00426fba      edx = &edx[1]
00426fbb      s |= 1 << (result u% 0x20)
00426fbb  
00426fc1  char* esi = arg1
00426fc1  
00426fcf  do
00426fc4      result.b = *esi
00426fc6      result.b = result.b
00426fc6      
00426fc8      if (result.b == 0)
00426fd9          return result
00426fd9      
00426fca      esi = &esi[1]
00426fcf  while (not(test_bit(s, result)))
00426fcf  
00426fd1  return &esi[0xffffffff]


00426fda    int32_t sub_426fda() __pure

00426fdc  return 0

00426fdd                                                                                         cc cc cc                               ...

00426fe0    int32_t __convention("regparm") sub_426fe0(int32_t arg1, int32_t arg2, int32_t arg3, char* arg4, char* arg5)

00426fe6  char* esi = arg5
00426fe9  char* edi = arg4
00426fe9  
00426ff6  if (data_430c8c == 0)
00426ff8      int16_t eax
00426ff8      eax.b = 0xff
00426ffa      char* edi_1 = edi
00426ffa      
00426ffc      while (true)
00426ffc          eax.b = eax.b
00426ffc          
00426ffe          if (eax.b == 0)
00426ffe              break
00426ffe          
00427000          eax.b = *esi
00427002          esi = &esi[1]
00427003          eax:1.b = *edi_1
00427005          edi_1 = &edi_1[1]
00427005          
00427008          if (eax:1.b != eax.b)
0042700a              eax.b -= 0x41
0042700e              arg3.b = sbb.b(arg3.b, arg3.b, eax.b u< 0x1a)
00427010              arg3.b &= 0x20
00427013              eax.b += arg3.b
00427015              eax.b += 0x41
00427017              char temp0_1 = eax.b
00427017              eax.b = eax:1.b
00427017              eax:1.b = temp0_1
00427019              eax.b -= 0x41
0042701d              arg3.b = sbb.b(arg3.b, arg3.b, eax.b u< 0x1a)
0042701f              arg3.b &= 0x20
00427022              eax.b += arg3.b
00427024              eax.b += 0x41
00427024              
00427028              if (eax.b != eax:1.b)
0042702a                  eax.b = sbb.b(eax.b, eax.b, eax.b u< eax:1.b)
0042702a                  bool c_4 = unimplemented  {sbb al, al}
0042702c                  eax.b = sbb.b(eax.b, 0xff, c_4)
0042702c                  break
0042702c      
0042702e      return sx.d(eax.b)
0042702e  
00427033  data_282384c += 1
00427041  int32_t var_14_1
00427041  
00427041  if (data_2823848 s> 0)
00427047      data_282384c -= 1
00427050      arg3 = sub_421919(0x13)
00427055      var_14_1 = 1
00427041  else
00427043      var_14_1 = 0
00427043  
0042705c  int32_t result = 0xff
0042705c  
00427064  while (true)
00427064      result.b = result.b
00427064      
00427066      if (result.b == 0)
00427066          break
00427066      
00427068      result.b = *esi
0042706a      esi = &esi[1]
0042706b      uint32_t ebx_1
0042706b      ebx_1.b = *edi
0042706d      edi = &edi[1]
0042706d      
00427070      if (result.b != ebx_1.b)
00427072          int32_t result_1 = result
00427073          uint32_t var_1c_1 = ebx_1
00427074          uint32_t eax_1
00427074          int32_t ecx
00427074          eax_1, ecx = sub_41eb79(arg3)
0042707e          result, arg3 = sub_41eb79(ecx)
0042707e          
00427088          if (eax_1.b != result.b)
0042708a              bool c_6 = unimplemented  {sbb eax, eax}
0042708c              result = sbb.d(sbb.d(result, result, eax_1.b u< result.b), 0xffffffff, c_6)
0042708c              break
0042708c  
00427094  if (var_14_1 != 0)
004270a1      sub_42197a(0x13)
00427094  else
00427096      data_282384c -= 1
00427096  
004270a9  return result


004270b0    char* sub_4270b0(int32_t arg1, char arg2)

004270b4  int32_t edi = arg1
004270b9  int32_t i = 0xffffffff
004270b9  
004270bc  while (i != 0)
004270bc      bool cond:0_1 = 0 != *edi
004270bc      edi += 1
004270bc      i -= 1
004270bc      
004270bc      if (not(cond:0_1))
004270bc          break
004270bc  
004270bf  int32_t i_1 = neg.d(i + 1)
004270c1  void* edi_1 = edi - 1
004270c1  
004270c6  while (i_1 != 0)
004270c6      bool cond:1_1 = arg2 != *edi_1
004270c6      edi_1 -= 1
004270c6      i_1 -= 1
004270c6      
004270c6      if (not(cond:1_1))
004270c6          break
004270c6  
004270cb  if (*(edi_1 + 1) == arg2)
004270d1      return edi_1 + 1
004270d1  
004270cd  return nullptr


004270d7    char* sub_4270d7(void* arg1, int32_t* arg2)

004270da  sub_421919(0xc)
004270e9  char* result = sub_4270fe(0, arg1, arg2)
004270f2  sub_42197a(0xc)
004270fd  return result


004270fe    char* sub_4270fe(int32_t arg1, void* arg2, int32_t* arg3)

00427108  int32_t ebx = arg1
0042710d  void buffer
0042710d  uint32_t eax_4
0042710d  
0042710d  if (ebx == 0)
0042716f      eax_4 = GetCurrentDirectoryA(nBufferLength: 0x104, lpBuffer: &buffer)
00427175      label_427175:
00427175      
00427177      if (eax_4 != 0)
00427179          int32_t* eax_5 = eax_4 + 1
00427179          
0042717f          if (eax_5 u<= 0x104)
00427186              if (arg2 != 0)
004271ad                  if (eax_5 s<= arg3)
00427134                      return sub_4230a0(arg2, &buffer)
00427134                  
004271b4                  *sub_41e9bd() = 0x22
00427186              else
0042718b                  if (eax_5 s<= arg3)
0042718d                      eax_5 = arg3
0042718d                  
00427197                  void* ecx_2 = sub_41e583(eax_5)
00427197                  
0042719b                  if (ecx_2 != 0)
00427134                      return sub_4230a0(ecx_2, &buffer)
00427134                  
004271a2                  *sub_41e9bd() = 0xc
0042710d  else
00427118      if (sub_4271d3(ebx) != 0)
00427138          arg1:3.b = 0
00427147          ebx.b += 0x40
00427150          arg1.b = ebx.b
00427153          arg1:1.b = 0x3a
00427157          arg1:2.b = 0x2e
0042715b          PSTR filePart
0042715b          eax_4 = GetFullPathNameA(lpFileName: &arg1, nBufferLength: 0x104, 
0042715b              lpBuffer: &buffer, lpFilePart: &filePart)
00427161          goto label_427175
00427161      
0042711f      *sub_41e9c6() = 0xf
0042712a      *sub_41e9bd() = 0xd
00427130  return nullptr


004271d3    int32_t sub_4271d3(int32_t arg1)

004271d6  int32_t eax = arg1
004271d6  
004271db  if (eax != 0)
004271dd      arg1:3.b = 0
004271e1      eax.b += 0x40
004271e3      arg1.b = eax.b
004271ea      arg1:1.b = 0x3a
004271ee      arg1:2.b = 0x5c
004271f2      uint32_t eax_1 = GetDriveTypeA(lpRootPathName: &arg1)
004271f2      
004271ff      if (eax_1 == 0 || eax_1 == 1)
00427209          return 0
00427209  
00427205  return 1


0042720a    int32_t sub_42720a(int32_t arg1, int32_t arg2, int32_t arg3)

0042720b  int32_t ebx = 0
0042720b  
00427215  if (data_430ee0 == 0)
0042721c      HMODULE hModule = LoadLibraryA(lpLibFileName: "user32.dll")
00427226      int32_t eax_1
00427226      
00427226      if (hModule != 0)
00427234          eax_1 = GetProcAddress(hModule, lpProcName: "MessageBoxA")
00427238          data_430ee0 = eax_1
00427238      
0042723d      if (hModule == 0 || eax_1 == 0)
0042728f          return 0
0042728f      
0042724d      data_430ee4 = GetProcAddress(hModule, lpProcName: "GetActiveWindow")
00427254      data_430ee8 = GetProcAddress(hModule, lpProcName: "GetLastActivePopup")
00427254  
00427259  int32_t eax_4 = data_430ee4
00427259  
00427260  if (eax_4 != 0)
00427264      ebx = eax_4()
00427264      
00427268      if (ebx != 0)
0042726a          int32_t eax_6 = data_430ee8
0042726a          
00427271          if (eax_6 != 0)
00427276              ebx = eax_6(ebx)
00427276  
00427285  return data_430ee0(ebx, arg1, arg2, arg3)


00427293    int32_t sub_427293(int32_t arg1, int32_t arg2, int32_t* arg3)

0042729c  int32_t result = 0
0042729e  int32_t ecx = arg1 + arg2
0042729e  
004272a7  if (ecx u< arg1 || ecx u< arg2)
004272ab      result = 1
004272ab  
004272b1  *arg3 = ecx
004272b3  return result


004272b4    int32_t sub_4272b4(int32_t* arg1, int32_t* arg2)

004272cd  if (sub_427293(*arg1, *arg2, arg1) != 0 && sub_427293(arg1[1], 1, &arg1[1]) != 0)
004272e3      arg1[2] += 1
004272e3  
004272f9  if (sub_427293(arg1[1], arg2[1], &arg1[1]) != 0)
004272fb      arg1[2] += 1
004272fb  
00427311  return sub_427293(arg1[2], arg2[2], &arg1[2])


00427312    int32_t* sub_427312(int32_t* arg1)

00427318  int32_t esi = *arg1
0042731a  int32_t edi = arg1[1]
00427321  *arg1 = esi * 2
0042732b  int32_t ecx_2 = arg1[2]
00427330  arg1[1] = (edi * 2) | esi u>> 0x1f
0042733b  arg1[2] = ecx_2 << 1 | edi u>> 0x1f
0042733f  return arg1


00427340    int32_t* sub_427340(int32_t* arg1)

00427346  int32_t edx = arg1[2]
00427349  int32_t ecx = arg1[1]
00427357  arg1[1] = ecx u>> 1 | edx << 0x1f
00427363  int32_t ecx_5 = *arg1 u>> 1 | ecx << 0x1f
00427366  arg1[2] = edx u>> 1
00427369  *arg1 = ecx_5
0042736c  return arg1


0042736d    int32_t sub_42736d(char* arg1, int32_t arg2, int32_t arg3)

00427377  int32_t* ebx = arg3
0042737f  int32_t var_8 = 0x404e
00427386  *ebx = 0
00427388  ebx[1] = 0
0042738b  ebx[2] = 0
0042738b  
0042738e  if (arg2 u> 0)
00427391      arg3 = arg2
004273dc      int32_t i
004273dc      
004273dc      do
00427399          int32_t var_14 = *ebx
00427399          int32_t var_10
00427399          int32_t* edi_1 = &var_10
00427399          void* esi_2 = &ebx[1]
0042739a          *edi_1 = *esi_2
0042739c          edi_1[1] = *(esi_2 + 4)
0042739d          sub_427312(ebx)
004273a3          sub_427312(ebx)
004273ad          sub_4272b4(ebx, &var_14)
004273b3          sub_427312(ebx)
004273bb          var_10 = 0
004273bf          int32_t var_c_1 = 0
004273c6          var_14 = sx.d(*arg1)
004273ce          sub_4272b4(ebx, &var_14)
004273d6          arg1 = &arg1[1]
004273d9          i = arg3
004273d9          arg3 -= 1
004273dc      while (i != 1)
004273dc  
004273e4  while (ebx[2] == 0)
004273e6      int32_t ecx_1 = ebx[1]
004273ee      ebx[2] = ecx_1 u>> 0x10
004273f1      int32_t eax_4 = *ebx
00427400      var_8 += 0xfff0
00427407      ebx[1] = eax_4 u>> 0x10 | ecx_1 << 0x10
0042740a      *ebx = eax_4 << 0x10
0042740a  
00427416  while ((ebx[2] & 0x8000) == 0)
00427419      sub_427312(ebx)
0042741e      var_8 += 0xffff
0042741e  
00427428  int32_t result
00427428  result.w = var_8.w
0042742d  *(ebx + 0xa) = result.w
00427433  return result


00427434    int32_t sub_427434(int16_t arg1, void* arg2, char arg3, void* arg4)

0042743e  int16_t* ebx = arg4
00427449  int16_t ecx_1 = arg1 & 0x8000
0042744f  int16_t eax_1 = arg1 & 0x7fff
00427455  char var_20 = 0xcc
00427459  char var_1f = 0xcc
0042745d  char var_1e = 0xcc
00427461  char var_1d = 0xcc
00427465  char var_1c = 0xcc
00427469  char var_1b = 0xcc
0042746d  char var_1a = 0xcc
00427471  char var_19 = 0xcc
00427475  char var_18 = 0xcc
00427479  char var_17 = 0xcc
0042747d  char var_16 = 0xfb
00427481  char var_15 = 0x3f
00427485  int32_t result = 1
00427485  
0042748e  if (ecx_1 == 0)
00427496      ebx[1].b = 0x20
0042748e  else
00427490      ebx[1].b = 0x2d
00427490  
0042749a  int32_t arg_8
0042749a  int32_t edi = arg_8
004274a9  int32_t arg_4
004274a9  
004274a9  if (eax_1 != 0 || edi != 0 || arg_4 != edi)
004274c3      if (eax_1 == 0x7fff)
004274ca          *ebx = 1
004274ca          
004274df          if ((edi != 0x80000000 || arg_4 != 0) && (edi & 0x40000000) == 0)
00427532              sub_4230a0(&ebx[2], "1#SNAN")
00427538              *(ebx + 3) = 6
004274df          else if (ecx_1 != 0 && edi == 0xc0000000)
004274f9              if (arg_4 != 0)
004274f9                  goto label_427529
004274f9              
00427515              sub_4230a0(&ebx[2], "1#IND")
0042751b              *(ebx + 3) = 5
004274f3          else if (edi != 0x80000000 || arg_4 != 0)
00427529              label_427529:
00427532              sub_4230a0(&ebx[2], "1#QNAN")
00427538              *(ebx + 3) = 6
0042750a          else
00427515              sub_4230a0(&ebx[2], "1#INF")
0042751b              *(ebx + 3) = 5
0042751b          
00427520          return 0
00427520      
0042753f      uint32_t eax_4 = zx.d(eax_1)
00427552      int16_t var_14 = 0
00427563      int32_t var_e_1 = edi
00427570      int32_t esi_4 = (((eax_4 u>> 8) + (edi u>> 0x18 << 1)) * 0x4d + eax_4 * 0x4d10
00427570          - 0x134312f4) s>> 0x10
00427573      int32_t var_12 = arg_4
00427580      sub_427a0c(&var_14, neg.d(sx.d(esi_4.w)), 1)
00427580      
0042758e      if (eax_1 u>= 0x3fff)
00427593          esi_4 += 1
00427599          sub_4277ec(&var_14, &var_20)
00427599      
004275a4      *ebx = esi_4.w
004275a7      void* edi_2
004275a7      
004275a7      if ((arg3 & 1) == 0)
004275ba          edi_2 = arg2
004275a7      else
004275af          edi_2 = arg2 + sx.d(esi_4.w)
004275af          
004275b3          if (edi_2 s<= 0)
004275b3              goto label_4274ab
004275b3      
004275c0      if (edi_2 s> 0x15)
004275c4          edi_2 = 0x15
004275c4      
004275cf      int16_t var_a_2 = 0
004275d4      arg4 = 8
004275e8      void* i
004275e8      
004275e8      do
004275df          sub_427312(&var_14)
004275e4          i = arg4
004275e4          arg4 -= 1
004275e8      while (i != 1)
004275e8      
004275ec      if (zx.d(eax_1) - 0x3ffe s< 0)
004275f0          uint32_t i_3 = zx.d((neg.d(zx.d(eax_1) - 0x3ffe)).b)
004275f0          
004275f6          if (i_3 s> 0)
00427603              uint32_t i_1
00427603              
00427603              do
004275fc                  sub_427340(&var_14)
00427601                  i_1 = i_3
00427601                  i_3 -= 1
00427603              while (i_1 != 1)
00427603      
00427608      void* eax_10 = &ebx[2]
0042760d      arg4 = eax_10
00427610      void* ecx_11
00427610      
00427610      if (edi_2 + 1 s> 0)
00427612          arg2 = edi_2 + 1
0042765d          void* i_2
0042765d          
0042765d          do
0042761b              arg_4 = var_14.d
0042761b              int32_t* edi_3 = &arg_8
0042761b              void* esi_8 = &var_12:2
0042761c              *edi_3 = *esi_8
00427621              edi_3[1] = *(esi_8 + 4)
00427622              sub_427312(&var_14)
0042762b              sub_427312(&var_14)
00427638              sub_4272b4(&var_14, &arg_4)
00427641              sub_427312(&var_14)
00427646              char eax_11 = var_a_2:1.b
00427649              ecx_11 = arg4
0042764c              var_a_2:1.b = 0
00427655              arg4 += 1
00427658              i_2 = arg2
00427658              arg2 -= 1
0042765b              *ecx_11 = eax_11 + 0x30
0042765d          while (i_2 != 1)
0042765f          eax_10 = arg4
0042765f      
00427662      ecx_11.b = *(eax_10 - 1)
00427666      void* eax_13 = eax_10 - 2
00427666      
0042766d      if (ecx_11.b s>= 0x35)
00427671          while (true)
00427671              if (eax_13 u>= &ebx[2])
00427676                  if (*eax_13 == 0x39)
00427678                      *eax_13 = 0x30
0042767b                      eax_13 -= 1
0042767c                      continue
00427676                  else if (eax_13 u>= &ebx[2])
00427680                      break
00427680              
00427682              eax_13 += 1
00427683              *ebx += 1
00427683              break
00427683          
00427686          *eax_13 += 1
00427686          goto label_427688
00427686      
004276a1      while (true)
004276a1          if (eax_13 u< &ebx[2])
004276a1              goto label_4276af
004276a1          
004276a6          if (*eax_13 != 0x30)
004276a6              break
004276a6          
004276a8          eax_13 -= 1
004276a8      
004276ad      if (eax_13 u>= &ebx[2])
00427688          label_427688:
00427688          eax_13.b -= ebx.b
0042768a          eax_13.b -= 3
0042768c          *(ebx + 3) = eax_13.b
00427692          *(sx.d(eax_13.b) + ebx + 4) = 0
00427697          return result
00427697      
004276af      label_4276af:
004276af      *ebx = 0
004276b3      ebx[1].b = 0x20
004276b7      *(ebx + 3) = 1
004276bb      ebx[2].b = 0x30
004274a9  else
004274ab      label_4274ab:
004274ab      *ebx = 0
004274af      ebx[1].b = 0x20
004274b3      *(ebx + 3) = 1
004274b7      ebx[2].b = 0x30
004274b7  
004276be  *(ebx + 5) = 0
004276c4  return 1


004276c7    int32_t sub_4276c7(enum WIN32_ERROR arg1, int32_t arg2)

004276cf  sub_41e520(0x1004)
004276d4  int32_t ebx
004276d4  int32_t var_8 = ebx
004276d6  int32_t result = 0
004276de  uint32_t eax = sub_421095(arg1, 0, FILE_CURRENT)
004276de  
004276ee  if (eax != 0xffffffff)
004276fa      uint32_t eax_1 = sub_421095(arg1, 0, FILE_END)
004276fa      
00427704      if (eax_1 != 0xffffffff)
0042770e          int32_t i = arg2 - eax_1
0042770e          
00427712          if (i s> 0)
00427722              char var_1008[0xfe4]
00427722              sub_4257d0(&var_1008, 0, 0x1000)
0042772f              int32_t eax_2 = sub_427c11(arg1, 0x8000)
0042772f              
0042775e              do
0042773c                  int32_t i_1 = 0x1000
0042773c                  
0042773e                  if (i s< 0x1000)
00427740                      i_1 = i
00427740                  
0042774d                  int32_t eax_3 = sub_4214bd(arg1, &var_1008, i_1)
0042774d                  
00427758                  if (eax_3 == 0xffffffff)
0042776a                      if (*sub_41e9c6() == 5)
00427771                          *sub_41e9bd() = 0xd
00427771                      
00427777                      result = 0xffffffff
00427777                      break
00427777                  
0042775a                  i -= eax_3
0042775e              while (i s> 0)
0042775e              
00427780              sub_427c11(arg1, eax_2)
00427712          else if (i s< 0)
00427793              sub_421095(arg1, arg2, FILE_BEGIN)
004277a4              BOOL eax_7 = SetEndOfFile(hFile: sub_425d77(arg1))
004277ac              int32_t esi_1 = neg.d(eax_7)
004277b2              result = neg.d(sbb.d(esi_1, esi_1, eax_7 != 0)) - 1
004277b2              
004277b5              if (result == 0xffffffff)
004277bc                  *sub_41e9bd() = 0xd
004277cf                  *sub_41e9c6() = GetLastError()
004277cf          
004277d9          sub_421095(arg1, eax, FILE_BEGIN)
004277e1          return result
004277e1  
004277e6  return 0xffffffff


004277ec    int16_t* sub_4277ec(int16_t* arg1, int32_t* arg2)

004277f3  int32_t* ebx = arg2
004277f7  int16_t* esi = arg1
004277fa  int32_t ecx
004277fa  ecx.w = *(ebx + 0xa)
00427801  int32_t var_18 = 0
00427804  int32_t var_28 = 0
00427807  int32_t var_24 = 0
0042780a  int32_t var_20 = 0
0042780d  int32_t eax
0042780d  eax.w = esi[5]
0042781a  int16_t* result = eax & 0x7fff
0042781c  int32_t* ecx_1 = ecx & 0x7fff
0042781e  int32_t edi_2 = (ecx ^ eax) & 0x8000
00427828  void* edx = ecx_1 + result
0042782b  arg1 = edx
0042782b  
00427844  if (result.w u>= 0x7fff || ecx_1.w u>= 0x7fff || edx.w u> 0xbffd)
004279ec      label_4279ec:
004279ec      int16_t temp0_1 = edi_2.w
004279ec      edi_2.w = neg.w(edi_2.w)
004279f1      *(esi + 4) = 0
00427a01      *esi = 0
00427a04      *(esi + 8) = (sbb.d(edi_2, edi_2, temp0_1 != 0) & 0x80000000) + 0x7fff8000
00427844  else if (edx.w u> 0x3fbf)
0042785d      if (result.w == 0)
0042785f          arg1 += 1
0042785f      
00427865      if (result.w != 0 || (*(esi + 8) & 0x7fffffff) != 0)
00427877          result = nullptr
0042787c          label_42787c:
0042787c          
0042787c          if (ecx_1.w == 0)
0042787e              arg1 += 1
0042787e          
0042788d          if (ecx_1.w == 0 && (ebx[2] & 0x7fffffff) == 0 && ebx[1] == 0 && *ebx == 0)
00427884              goto label_42788f
00427884          
0042789c          void* var_14_1 = nullptr
004278a2          int32_t* var_8_1 = &var_24
004278a2          
0042790e          for (arg2 = 5; arg2 s> 0; arg2 -= 1)
004278b5              if (arg2 s> 0)
004278bc                  void* var_c_1 = var_14_1 * 2 + esi
004278c2                  void* var_10_1 = &ebx[2]
004278c5                  int32_t* j_1 = arg2
004278fe                  int32_t* j
004278fe                  
004278fe                  do
004278e1                      int32_t eax_8
004278e1                      eax_8, ecx_1 = sub_427293(var_8_1[-1], 
004278e1                          zx.d(*var_c_1) * zx.d(*var_10_1), &var_8_1[-1])
004278e1                      
004278eb                      if (eax_8 != 0)
004278f0                          *var_8_1 += 1
004278f0                      
004278f3                      var_c_1 += 2
004278f7                      var_10_1 -= 2
004278fb                      j = j_1
004278fb                      j_1 -= 1
004278fe                  while (j != 1)
004278fe              
00427900              var_8_1 += 2
00427904              var_14_1 += 1
00427904          
00427910          arg1 = &arg1[0x6001]
00427910          
0042791c          if (arg1.w s<= 0)
00427943              label_427943:
00427943              arg1 += 0xffff
00427943              
0042794f              if (arg1.w s< 0)
00427955                  int32_t i_2 = neg.d(sx.d(arg1.w))
00427957                  arg1 += i_2
0042795a                  int32_t i_1 = i_2
00427970                  int32_t i
00427970                  
00427970                  do
00427960                      if ((var_28.b & 1) != 0)
00427962                          var_18 += 1
00427962                      
00427969                      sub_427340(&var_28)
0042796e                      i = i_1
0042796e                      i_1 -= 1
00427970                  while (i != 1)
00427970                  
00427976                  if (var_18 != 0)
00427978                      var_28.b |= 1
0042791c          else
00427922              while ((var_20:3.b & 0x80) == 0)
00427928                  sub_427312(&var_28)
0042792d                  arg1 += 0xffff
0042792d                  
0042793a                  if (arg1.w s<= 0)
0042793a                      break
0042793a              
00427941              if (arg1.w s<= 0)
00427941                  goto label_427943
00427941          
00427991          if (var_28.w u> 0x8000 || (var_28 & 0x1ffff) == 0x18000)
00427997              if (var_28 != 0xffffffff)
004279c5                  var_28 += 1
00427997              else
00427999                  var_28 = 0
00427999                  
004279a1                  if (var_24 != 0xffffffff)
004279c0                      var_24 += 1
004279a1                  else
004279a3                      var_24 = 0
004279a3                      
004279ad                      if (var_20:2.w != 0xffff)
004279ba                          var_20:2.w += 1
004279ad                      else
004279af                          arg1 += 1
004279b2                          var_20:2.w = 0x8000
004279b2          
004279c8          result = arg1
004279c8          
004279cf          if (result.w u>= 0x7fff)
004279cf              goto label_4279ec
004279cf          
004279d1          ecx_1.w = var_28:2.w
004279d5          result |= edi_2
004279d7          *esi = ecx_1.w
004279dd          *(esi + 2) = var_24
004279e3          *(esi + 6) = var_20
004279e6          esi[5] = result.w
00427865      else
00427867          result = nullptr
00427867          
00427870          if (*(esi + 4) != 0 || *esi != 0)
0042786c              goto label_42787c
0042786c          
004279e6          esi[5] = result.w
0042784f  else
00427851      result = nullptr
0042788f      label_42788f:
0042788f      *(esi + 8) = 0
00427892      *(esi + 4) = 0
00427895      *esi = 0
00427895  
00427a0b  return result


00427a0c    void sub_427a0c(int32_t arg1, int32_t arg2, int32_t arg3)

00427a1a  int32_t ebx = 0x42fff0
00427a1a  
00427a20  if (arg2 != 0)
00427a22      if (arg2 s< 0)
00427a2e          arg2 = neg.d(arg2)
00427a31          ebx = 0x430150
00427a31      
00427a37      if (arg3 == 0)
00427a3c          *arg1 = 0
00427a3c      
00427a42      while (arg2 != 0)
00427a46          int32_t eax_2 = arg2
00427a49          ebx += 0x54
00427a4c          arg2 s>>= 3
00427a50          int32_t eax = eax_2 & 7
00427a50          
00427a55          if (eax != 0)
00427a57              int32_t eax_3 = eax * 3
00427a60              int32_t* esi_1 = ebx + (eax_3 << 2)
00427a60              
00427a63              if (*(ebx + (eax_3 << 2)) u>= 0x8000)
00427a68                  int32_t var_10 = *esi_1
00427a68                  void var_c
00427a68                  int32_t* edi_1 = &var_c
00427a68                  void* esi_2 = &esi_1[1]
00427a69                  *edi_1 = *esi_2
00427a6a                  edi_1[1] = *(esi_2 + 4)
00427a6b                  var_10 -= 1
00427a6e                  esi_1 = &var_10
00427a6e              
00427a75              sub_4277ec(arg1, esi_1)


00427a88    void* sub_427a88(uint8_t* arg1)

00427a91  int32_t* esi = data_430b94
00427a91  
00427a98  if (data_28249a8 != 0)
00427a9c      if (esi != 0)
00427abd          label_427abd:
00427abd          
00427abf          if (arg1 != 0)
00427ac2              void* eax_2 = sub_422550(arg1)
00427ac2              
00427aca              while (true)
00427aca                  char* eax_3 = *esi
00427aca                  
00427ace                  if (eax_3 == 0)
00427ace                      break
00427ace                  
00427ad9                  if (sub_422550(eax_3) u> eax_2)
00427adb                      char* eax_5 = *esi
00427adb                      
00427ae1                      if (*(eax_5 + eax_2) == 0x3d && sub_427c72(eax_5, arg1, eax_2) == 0)
00427af9                          return *esi + eax_2 + 1
00427af9                  
00427af2                  esi = &esi[1]
00427a9c      else if (data_430b9c != esi && sub_427cb1() == 0)
00427aaf          esi = data_430b94
00427aaf          
00427ab7          if (esi != 0)
00427ab7              goto label_427abd
00427ab7  
00427aff  return nullptr

00427b05                 cc cc cc cc cc cc cc cc cc cc cc                                                       ...........

00427b10    int32_t sub_427b10(char* arg1, char* arg2, int32_t arg3)

00427b19  int32_t result = arg3
00427b19  
00427b1b  if (result != 0)
00427b21      char* esi_1 = arg1
00427b24      char* edi_1 = arg2
00427b24      
00427b31      if (data_430c8c != 0)
00427b81          data_282384c += 1
00427b8f          int32_t var_14_1
00427b8f          
00427b8f          if (data_2823848 s> 0)
00427b95              data_282384c -= 1
00427ba0              sub_421919(0x13)
00427ba5              var_14_1 = 1
00427b8f          else
00427b91              var_14_1 = 0
00427b91          
00427bb2          char* edi_2 = edi_1
00427bb2          
00427bb4          while (true)
00427bb4              uint32_t eax_2
00427bb4              eax_2.b = *esi_1
00427bb8              uint32_t ebx_2
00427bb8              ebx_2.b = *edi_2
00427bbe              bool cond:1_1
00427bbe              
00427bbe              if (eax_2 == 0 || ebx_2 == 0)
00427bdf                  label_427bdf:
00427bdf                  result = 0
00427be1                  cond:1_1 = eax_2 u< ebx_2
00427be1                  
00427be3                  if (eax_2 == ebx_2)
00427be3                      break
00427bbe              else
00427bc0                  esi_1 = &esi_1[1]
00427bc1                  edi_2 = &edi_2[1]
00427bc3                  uint32_t var_1c_1 = eax_2
00427bc4                  uint32_t var_20_1 = ebx_2
00427bc5                  uint32_t eax_3
00427bc5                  int32_t ecx_1
00427bc5                  eax_3, ecx_1 = sub_41eb79(result)
00427bca                  ebx_2 = eax_3
00427bcf                  eax_2 = sub_41eb79(ecx_1)
00427bd8                  cond:1_1 = eax_2 u< ebx_2
00427bd8                  
00427bda                  if (eax_2 == ebx_2)
00427bdc                      int32_t result_2 = result
00427bdc                      result -= 1
00427bdc                      
00427bdd                      if (result_2 != 1)
00427bdd                          continue
00427bdd                      
00427bdd                      goto label_427bdf
00427bdd              
00427be5              result = 0xffffffff
00427be5              
00427bea              if (not(cond:1_1))
00427bec                  result = 1
00427bec              
00427bea              break
00427bea          
00427bf1          if (var_14_1 != 0)
00427c00              sub_42197a(0x13)
00427c08              return result
00427c08          
00427bf3          data_282384c -= 1
00427b31      else
00427b39          int32_t result_1 = result
00427b39          
00427b3c          while (true)
00427b3c              int16_t eax_1
00427b3c              eax_1:1.b = *esi_1
00427b3e              eax_1:1.b = eax_1:1.b
00427b3e              bool cond:3_1 = eax_1:1.b == 0
00427b40              eax_1.b = *edi_1
00427b42              bool cond:0_1
00427b42              
00427b42              if (cond:3_1)
00427b65                  label_427b65:
00427b65                  result = 0
00427b67                  cond:0_1 = eax_1:1.b u< eax_1.b
00427b67                  
00427b69                  if (eax_1:1.b == eax_1.b)
00427b69                      break
00427b42              else
00427b44                  eax_1.b = eax_1.b
00427b44                  
00427b46                  if (eax_1.b == 0)
00427b46                      goto label_427b65
00427b46                  
00427b48                  esi_1 = &esi_1[1]
00427b49                  edi_1 = &edi_1[1]
00427b49                  
00427b50                  if (eax_1:1.b u>= 0x41 && eax_1:1.b u<= 0x5a)
00427b52                      eax_1:1.b += 0x20
00427b52                  
00427b5a                  if (eax_1.b u>= 0x41 && eax_1.b u<= 0x5a)
00427b5c                      eax_1.b += 0x20
00427b5c                  
00427b5e                  cond:0_1 = eax_1:1.b u< eax_1.b
00427b5e                  
00427b60                  if (eax_1:1.b == eax_1.b)
00427b62                      int32_t result_3 = result_1
00427b62                      result_1 -= 1
00427b62                      
00427b63                      if (result_3 != 1)
00427b63                          continue
00427b63                      
00427b63                      goto label_427b65
00427b63              
00427b6f              result = 0xffffffff
00427b6f              
00427b74              if (not(cond:0_1))
00427b7a                  return 1
00427b7a              
00427b74              break
00427b74  
00427c10  return result


00427c11    int32_t sub_427c11(int32_t arg1, int32_t arg2)

00427c1e  int32_t eax_1 = (arg1 & 0x1f) * 9
00427c26  int32_t ecx_2 = (&data_2823880)[arg1 s>> 5]
00427c2d  char* edx = ecx_2 + (eax_1 << 2) + 4
00427c31  ecx_2.b = *(ecx_2 + (eax_1 << 2) + 4)
00427c35  eax_1.b = ecx_2.b
00427c37  int32_t eax_2 = eax_1 & 0x80
00427c37  
00427c40  if (arg2 != 0x8000)
00427c4f      if (arg2 != 0x4000)
00427c67          *sub_41e9bd() = 0x16
00427c71          return 0xffffffff
00427c71      
00427c51      ecx_2.b |= 0x80
00427c40  else
00427c42      ecx_2.b &= 0x7f
00427c42  
00427c54  int32_t eax_3 = neg.d(eax_2)
00427c58  *edx = ecx_2.b
00427c5a  int32_t eax_4
00427c5a  eax_4.w = sbb.d(eax_3, eax_3, eax_2 != 0).w & 0xc000
00427c61  return eax_4 + 0x8000


00427c72    int32_t sub_427c72(char* arg1, uint8_t* arg2, void* arg3)

00427c79  if (arg3 == 0)
00427c7e      return 0
00427c7e  
00427c99  enum COMPARESTRING_RESULT eax_1 =
00427c99      sub_427d1f(data_2823844, 1, arg1, arg3, arg2, arg3, data_2823620)
00427c99  
00427ca3  if (eax_1 != 0)
00427cb0      return eax_1 - 2
00427cb0  
00427cab  return 0x7fffffff


00427cb1    int32_t sub_427cb1()

00427cb1  void* ecx
00427cb1  void* var_4 = ecx
00427cb5  int32_t* esi = data_430b9c
00427cbe  wchar16* lpWideCharStr = *esi
00427cbe  
00427cc2  while (lpWideCharStr != 0)
00427cd4      int32_t cbMultiByte = WideCharToMultiByte(CodePage: 1, dwFlags: 0, lpWideCharStr, 
00427cd4          cchWideChar: 0xffffffff, lpMultiByteStr: nullptr, cbMultiByte: 0, 
00427cd4          lpDefaultChar: nullptr, lpUsedDefaultChar: nullptr)
00427cd4      
00427cda      if (cbMultiByte == 0)
00427d1a          return 0xffffffff
00427d1a      
00427cdd      void* lpMultiByteStr = sub_41e583(cbMultiByte)
00427cdd      
00427ce9      if (lpMultiByteStr == 0)
00427d1a          return 0xffffffff
00427d1a      
00427cfa      if (WideCharToMultiByte(CodePage: 1, dwFlags: 0, lpWideCharStr: *esi, 
00427cfa              cchWideChar: 0xffffffff, lpMultiByteStr, cbMultiByte, lpDefaultChar: nullptr, 
00427cfa              lpUsedDefaultChar: nullptr) == 0)
00427d1a          return 0xffffffff
00427d1a      
00427d01      sub_427fc7(lpMultiByteStr, 0)
00427d06      lpWideCharStr = esi[1]
00427d09      esi = &esi[1]
00427d09  
00427d12  return 0


00427d1f    enum COMPARESTRING_RESULT sub_427d1f(uint32_t arg1, uint32_t arg2, char* arg3, void* arg4, uint8_t* arg5, void* arg6, uint32_t arg7)

00427d22  int32_t var_8 = 0xffffffff
00427d24  int32_t var_c = 0x429c40
00427d29  int32_t var_10 = 0x424e8c
00427d34  TEB* fsbase
00427d34  struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList = fsbase->NtTib.ExceptionList
00427d35  fsbase->NtTib.ExceptionList = &ExceptionList
00427d42  int32_t __saved_edi
00427d42  int32_t* var_1c = &__saved_edi
00427d42  
00427d50  if (data_430f1c != 0)
00427d50      goto label_427d92
00427d50  
00427d65  enum COMPARESTRING_RESULT result
00427d65  
00427d65  if (CompareStringW(Locale: 0, dwCmpFlags: 0, lpString1: &data_4296b0, cchCount1: 1, 
00427d65          lpString2: &data_4296b0, cchCount2: 1) == 0)
00427d82      if (CompareStringA(Locale: 0, dwCmpFlags: 0, lpString1: &data_4296ac, cchCount1: 1, 
00427d82              lpString2: &data_4296ac, cchCount2: 1) != 0)
00427d88          data_430f1c = 2
00427d88          goto label_427d92
00427d88      
00427f88      result = 0
00427d65  else
00427d67      data_430f1c = 1
00427d92      label_427d92:
00427d92      void* esi_1 = arg4
00427d92      
00427d97      if (esi_1 s> 0)
00427da4          esi_1 = sub_427f9c(arg3, esi_1)
00427da6          arg4 = esi_1
00427da6      
00427dac      if (arg6 s> 0)
00427dbb          arg6 = sub_427f9c(arg5, arg6)
00427dbb      
00427dbe      int32_t eax_5 = data_430f1c
00427dbe      
00427dc6      if (eax_5 == 2)
00427dd8          result = CompareStringA(Locale: arg1, dwCmpFlags: arg2, lpString1: arg3, 
00427dd8              cchCount1: esi_1, lpString2: arg5, cchCount2: arg6)
00427dc6      else if (eax_5 != 1)
00427f88          result = 0
00427de5      else
00427dee          if (arg7 == 0)
00427df5              arg7 = data_430c9c
00427df5          
00427dff          if (esi_1 != 0 && arg6 != 0)
00427ea8              label_427ea8:
00427ea8              int32_t eax_12 = MultiByteToWideChar(CodePage: arg7, 
00427ea8                  dwFlags: MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, lpMultiByteStr: arg3, 
00427ea8                  cbMultiByte: esi_1, lpWideCharStr: nullptr, cchWideChar: 0)
00427ea8              
00427eb3              if (eax_12 == 0)
00427f88                  result = 0
00427eb3              else
00427eb9                  int32_t var_8_1 = 0
00427ec1                  int32_t eax_14
00427ec1                  eax_14.b = (eax_12 * 2 + 3).b & 0xfc
00427ec3                  sub_41e520(eax_14)
00427ec8                  int32_t* var_1c_1 = &__saved_edi
00427ecd                  int32_t* var_28_1 = &__saved_edi
00427ed0                  int32_t var_8_2 = 0xffffffff
00427ed0                  
00427eef                  if (var_28_1 == 0)
00427f88                      result = 0
00427eef                  else if (MultiByteToWideChar(CodePage: arg7, dwFlags: MB_PRECOMPOSED, 
00427eef                          lpMultiByteStr: arg3, cbMultiByte: esi_1, 
00427eef                          lpWideCharStr: var_28_1, cchWideChar: eax_12) == 0)
00427f88                      result = 0
00427f0d                  else
00427f1c                      int32_t eax_16 = MultiByteToWideChar(CodePage: arg7, 
00427f1c                          dwFlags: MB_ERR_INVALID_CHARS | MB_PRECOMPOSED, 
00427f1c                          lpMultiByteStr: arg5, cbMultiByte: arg6, lpWideCharStr: nullptr, 
00427f1c                          cchWideChar: 0)
00427f20                      int32_t var_24_1 = eax_16
00427f20                      
00427f25                      if (eax_16 == 0)
00427f88                          result = 0
00427f25                      else
00427f27                          int32_t var_8_3 = 1
00427f30                          int32_t eax_18
00427f30                          eax_18.b = (eax_16 * 2 + 3).b & 0xfc
00427f32                          sub_41e520(eax_18)
00427f37                          int32_t* var_1c_2 = &__saved_edi
00427f3c                          int32_t* var_2c_1 = &__saved_edi
00427f3f                          int32_t var_8_4 = 0xffffffff
00427f3f                          
00427f59                          if (&__saved_edi == 0)
00427f88                              result = 0
00427f59                          else if (MultiByteToWideChar(CodePage: arg7, 
00427f59                                  dwFlags: MB_PRECOMPOSED, lpMultiByteStr: arg5, 
00427f59                                  cbMultiByte: arg6, lpWideCharStr: &__saved_edi, 
00427f59                                  cchWideChar: eax_16) == 0)
00427f88                              result = 0
00427f70                          else
00427f80                              result = CompareStringW(Locale: arg1, dwCmpFlags: arg2, 
00427f80                                  lpString1: var_28_1, cchCount1: eax_12, 
00427f80                                  lpString2: &__saved_edi, cchCount2: eax_16)
00427dff          else if (esi_1 == arg6)
00427e0a              label_427e0a:
00427e0c              result = CSTR_EQUAL
00427e08          else if (arg6 s> 1)
00427e17              result = CSTR_LESS_THAN
00427e15          else
00427e20              CPINFO cPInfo
00427e20              
00427e20              if (esi_1 s> 1)
00427e0c                  result = CSTR_GREATER_THAN
00427e20              else if (GetCPInfo(CodePage: arg7, lpCPInfo: &cPInfo) == 0)
00427f88                  result = 0
00427e31              else
00427e39                  var_3a
00427e39                  char edx_1
00427e39                  
00427e39                  if (esi_1 s<= 0)
00427e6a                      if (arg6 s<= 0)
00427e6a                          goto label_427ea8
00427e6a                      
00427e70                      if (cPInfo.MaxCharSize u>= 2)
00427e72                          char* eax_10 = &var_3a
00427e72                          
00427e78                          if (cPInfo.LeadByte[0] != 0)
00427e96                              do
00427e7a                                  edx_1 = eax_10[1]
00427e7a                                  
00427e7f                                  if (edx_1 == 0)
00427e7f                                      break
00427e7f                                  
00427e84                                  uint8_t* ecx_4
00427e84                                  ecx_4.b = *arg5
00427e84                                  
00427e8c                                  if (ecx_4.b u>= *eax_10 && ecx_4.b u<= edx_1)
00427e8c                                      goto label_427e0a
00427e8c                                  
00427e93                                  eax_10 = &eax_10[2]
00427e96                              while (*eax_10 != 0)
00427e96                      
00427e17                      result = CSTR_LESS_THAN
00427e39                  else
00427e3f                      if (cPInfo.MaxCharSize u>= 2)
00427e41                          char* eax_8 = &var_3a
00427e41                          
00427e47                          if (cPInfo.LeadByte[0] != 0)
00427e61                              do
00427e49                                  edx_1 = eax_8[1]
00427e49                                  
00427e4e                                  if (edx_1 == 0)
00427e4e                                      break
00427e4e                                  
00427e53                                  char* ecx_3
00427e53                                  ecx_3.b = *arg3
00427e53                                  
00427e5b                                  if (ecx_3.b u>= *eax_8 && ecx_3.b u<= edx_1)
00427e5b                                      goto label_427e0a
00427e5b                                  
00427e5e                                  eax_8 = &eax_8[2]
00427e61                              while (*eax_8 != 0)
00427e61                      
00427e0c                      result = CSTR_GREATER_THAN
00427e0c  
00427f90  fsbase->NtTib.ExceptionList = ExceptionList
00427f9b  return result


00427ed6    int32_t sub_427ed6() __pure

00427ed9  return 1

00427eda                                                                                8b 65 e8 33 db 89                            .e.3..
00427ee0  5d dc 83 4d fc ff 8b 75 14 6a 01 5f                                                              ]..M...u.j._

00427f45    int32_t sub_427f45() __pure

00427f48  return 1

00427f49                             8b 65 e8 33 db 33 ff 83 4d fc ff 8b 75 e0                                      .e.3.3..M...u.

00427f9c    void* sub_427f9c(char* arg1, int32_t arg2)

00427fa0  char* eax = arg1
00427fa7  int32_t ecx = arg2 - 1
00427fa7  
00427faa  if (arg2 != 0)
00427faf      while (*eax != 0)
00427fb1          eax = &eax[1]
00427fb2          int32_t esi_1 = ecx
00427fb4          ecx -= 1
00427fb4          
00427fb7          if (esi_1 == 0)
00427fb7              break
00427fb7  
00427fbd  if (*eax != 0)
00427fc6      return arg2
00427fc6  
00427fc3  return eax - arg1


00427fc7    int32_t sub_427fc7(char* arg1, int32_t arg2)

00427fca  int32_t ecx
00427fca  int32_t var_8 = ecx
00427fcb  int32_t var_c = ecx
00427fcb  
00427fd4  if (arg1 != 0)
00427fdb      void* eax_1 = sub_428345(arg1, 0x3d)
00427fdb      
00427fee      if (eax_1 != 0 && arg1 != eax_1)
00427ff0          void* eax_2 = data_430b94
00427ffa          int32_t ebx_1
00427ffa          ebx_1.b = *(eax_1 + 1) == 0
00427ffa          
00428003          if (eax_2 == data_430b98)
00428006              eax_2 = sub_4281a6(eax_2)
0042800c              data_430b94 = eax_2
0042800c          
00428013          if (eax_2 != 0)
00428013              goto label_42806c
00428013          
00428020          if (arg2 == 0 || data_430b9c == 0)
00428035              if (ebx_1 != 0)
00428147                  return 0
00428147              
0042803d              void* eax_5 = sub_41e583(4)
00428045              data_430b94 = eax_5
00428045              
0042804a              if (eax_5 != 0)
0042804c                  *eax_5 = 0
0042804c                  
00428054                  if (data_430b9c != 0)
00428054                      goto label_42806c
00428054                  
00428058                  void* eax_6 = sub_41e583(4)
00428060                  data_430b9c = eax_6
00428060                  
00428065                  if (eax_6 != 0)
00428067                      *eax_6 = 0
0042806c                      label_42806c:
0042806c                      int32_t* edi_1 = data_430b94
0042807e                      int32_t esi_3 = sub_42814e(arg1, eax_1 - arg1)
00428089                      void* eax_11
00428089                      
00428089                      if (esi_3 s>= 0 && *edi_1 != 0)
0042808d                          if (ebx_1 == 0)
004280c4                              edi_1[esi_3] = arg1
0042808d                          else
00428092                              void* edi_2 = &edi_1[esi_3]
00428095                              sub_41e29e(edi_1[esi_3])
00428095                              
0042809e                              while (*edi_2 != 0)
004280a3                                  esi_3 += 1
004280a4                                  *edi_2 = *(edi_2 + 4)
004280a6                                  edi_2 += 4
004280a6                              
004280b4                              eax_11 = sub_42820d(edi_1, esi_3 << 2)
004280b4                              
004280bd                              if (eax_11 != 0)
004280bd                                  goto label_4280f6
004280bd                          
004280fb                          label_4280fb:
004280fb                          
004280ff                          if (arg2 == 0)
00428147                              return 0
00428147                          
00428111                          PSTR lpName = sub_41e583(sub_422550(arg1) + 2)
00428111                          
00428117                          if (lpName != 0)
0042811d                              sub_4230a0(lpName, arg1)
00428129                              void* eax_20 = lpName - arg1 + eax_1
0042812c                              *eax_20 = 0
00428130                              int32_t ebx_2 = neg.d(ebx_1)
0042813a                              SetEnvironmentVariableA(lpName, 
0042813a                                  lpValue: not.d(sbb.d(ebx_2, ebx_2, ebx_1 != 0))
0042813a                                      & (eax_20 + 1))
00428141                              sub_41e29e(lpName)
00428141                          
00428147                          return 0
00428147                      
004280cb                      if (ebx_1 != 0)
00428147                          return 0
00428147                      
004280cf                      if (esi_3 s< 0)
004280d1                          esi_3 = neg.d(esi_3)
004280d1                      
004280dc                      eax_11 = sub_42820d(edi_1, (esi_3 << 2) + 8)
004280dc                      
004280e5                      if (eax_11 != 0)
004280ee                          *(eax_11 + (esi_3 << 2)) = arg1
004280f1                          *(eax_11 + (esi_3 << 2) + 4) = 0
004280f6                          label_4280f6:
004280f6                          data_430b94 = eax_11
004280f6                          goto label_4280fb
00428020          else if (sub_427cb1() == 0)
00428029              goto label_42806c
00428029  
0042802b  return 0xffffffff


0042814e    int32_t sub_42814e(char* arg1, void* arg2)

0042814f  int32_t* esi = data_430b94
00428156  uint8_t* i = *esi
00428156  
0042815a  while (i != 0)
00428170      if (sub_427c72(arg1, i, arg2) == 0)
00428174          char* eax_1
00428174          eax_1.b = *(*esi + arg2)
00428174          
0042817d          if (eax_1.b == 0x3d || eax_1.b == 0)
004281a1              return (esi - data_430b94) s>> 2
004281a1      
0042817f      i = esi[1]
00428182      esi = &esi[1]
00428182  
00428194  return neg.d((esi - data_430b94) s>> 2)


004281a6    void* sub_4281a6(int32_t* arg1)

004281ab  int32_t ecx = 0
004281ab  
004281af  if (arg1 == 0)
004281b4      return 0
004281b4  
004281b8  int32_t* eax_1 = &arg1[1]
004281b8  
004281bb  if (*arg1 != 0)
004281c5      int32_t i
004281c5      
004281c5      do
004281bd          i = *eax_1
004281bf          ecx += 1
004281c0          eax_1 = &eax_1[1]
004281c5      while (i != 0)
004281c5  
004281d7  void* result_1 = sub_41e583((ecx << 2) + 4)
004281dc  void* result = result_1
004281dc  
004281de  if (result_1 == 0)
004281e2      sub_41f9c5(9)
004281e2  
004281e8  char* i_1 = *arg1
004281ea  int32_t* ebx = arg1
004281ea  
004281ee  while (i_1 != 0)
004281f1      ebx = &ebx[1]
004281f9      *result_1 = sub_4283dc(i_1)
004281fb      i_1 = *ebx
004281fe      result_1 += 4
004281fe  
00428203  *result_1 = 0
0042820c  return result


0042820d    void* sub_42820d(char* arg1, int32_t* arg2)

00428218  if (arg1 == 0)
00428344      return sub_41e583(arg2)
00428344  
00428228  void* dwBytes = arg2
00428228  
0042822d  if (dwBytes != 0)
00428333      bool cond:1_1
00428333      
00428333      do
00428242          if (dwBytes u<= 0xffffffe0)
0042824a              sub_421919(9)
00428250              void* eax_2 = sub_4219cd(arg1)
00428256              arg2 = eax_2
0042825c              void* result
0042825c              
0042825c              if (eax_2 == 0)
004282f8                  sub_42197a(9)
004282f8                  
00428300                  if (dwBytes == 0)
00428304                      dwBytes = 1
00428304                  
00428308                  dwBytes = (dwBytes + 0xf) & 0xfffffff0
0042831b                  result = HeapReAlloc(hHeap: data_2823868, dwFlags: HEAP_NONE, 
0042831b                      lpMem: arg1, dwBytes)
0042825c              else
00428268                  if (dwBytes u> data_42f8d4)
004282ae                      label_4282ae:
004282ae                      
004282ae                      if (dwBytes == 0)
004282b2                          dwBytes = 1
004282b2                      
004282b6                      dwBytes = (dwBytes + 0xf) & 0xfffffff0
004282c8                      result = HeapAlloc(hHeap: data_2823868, dwFlags: HEAP_NONE, dwBytes)
004282c8                      
004282cc                      if (result != 0)
004282d1                          void* dwBytes_2 = *(arg1 - 4) - 1
004282d1                          
004282d4                          if (dwBytes_2 u>= dwBytes)
004282d6                              dwBytes_2 = dwBytes
004282d6                          
004282db                          sub_420bf0(result, arg1, dwBytes_2)
004282e4                          sub_4219f8(arg2, arg1)
00428268                  else
00428277                      if (sub_4221d8(eax_2, arg1, dwBytes) == 0)
00428283                          result = sub_421d23(dwBytes)
00428283                          
00428288                          if (result == 0)
00428288                              goto label_4282ae
00428288                          
0042828d                          void* dwBytes_1 = *(arg1 - 4) - 1
0042828d                          
00428290                          if (dwBytes_1 u>= dwBytes)
00428292                              dwBytes_1 = dwBytes
00428292                          
00428297                          sub_420bf0(result, arg1, dwBytes_1)
004282a0                          sub_4219f8(arg2, arg1)
004282a5                          goto label_4282a8
004282a5                      
00428279                      result = arg1
004282a8                      label_4282a8:
004282a8                      
004282aa                      if (result == 0)
004282aa                          goto label_4282ae
004282aa                  
004282ee                  sub_42197a(9)
004282ee              
0042831f              if (result != 0 || data_430c70 == 0)
0042833e                  return result
00428242          else if (data_430c70 == 0)
0042833e              return nullptr
0042833e          
00428330          cond:1_1 = sub_42307c(dwBytes) != 0
00428333      while (cond:1_1)
0042822d  else
00428230      sub_41e29e(arg1)
00428230  
00428236  return nullptr


00428345    void* sub_428345(void* arg1, int32_t arg2)

0042834f  int32_t ebx
0042834f  int32_t var_8 = ebx
0042834f  
00428351  if (data_282363c == 0)
004283db      return sub_423270(arg1, arg2.b)
004283db  
00428364  sub_421919(0x19)
00428369  void* esi_1 = arg1
00428369  
0042836d  while (true)
0042836d      ebx.w = zx.w(*esi_1)
0042836d      
00428374      if (ebx.w == 0)
00428374          break
00428374      
00428380      if ((*(zx.d(ebx.b) + 0x2823741) & 4) != 0)
00428382          uint32_t eax_2
00428382          eax_2.b = *(esi_1 + 1)
00428385          esi_1 += 1
00428385          
00428388          if (eax_2.b == 0)
004283a9              sub_42197a(0x19)
004283af              return nullptr
004283af          
00428398          if (arg2 == (zx.d(ebx.w) << 8 | zx.d(eax_2.b)))
004283b5              sub_42197a(0x19)
004283bb              return esi_1 - 1
00428380      else if (arg2 == zx.d(ebx.w))
004283a2          break
004283a2      
004283a4      esi_1 += 1
004283a4  
004283c2  sub_42197a(0x19)
004283ce  int32_t eax_6 = arg2 - zx.d(ebx.w)
004283d0  int32_t eax_7 = neg.d(eax_6)
004283d6  return not.d(sbb.d(eax_7, eax_7, eax_6 != 0)) & esi_1


004283dc    char* sub_4283dc(char* arg1)

004283e3  if (arg1 != 0)
004283ed      void* eax_3 = sub_41e583(sub_422550(arg1) + 1)
004283ed      
004283f6      if (eax_3 != 0)
00428402          return sub_4230a0(eax_3, arg1)
00428402  
00428406  return 0

00428407                       cc cc cc cc cc cc cc cc cc                                                         .........

00428410    void __stdcall RtlUnwind(void* TargetFrame, void* TargetIp, EXCEPTION_RECORD* ExceptionRecord, void* ReturnValue)

00428410  return RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue) __tailcall


00428416    int32_t sub_428416(PSTR arg1, char arg2)

0042841a  uint32_t eax = GetFileAttributesA(lpFileName: arg1)
0042841a  
00428423  if (eax != 0xffffffff)
0042843f      if ((eax.b & 1) == 0 || (arg2 & 2) == 0)
0042845b          return 0
0042845b      
00428446      *sub_41e9bd() = 0xd
00428451      *sub_41e9c6() = 5
00428423  else
0042842c      sub_41e94a(GetLastError())
0042842c  
00428435  return 0xffffffff

.text section ended  {0x401000-0x42845c}

.rdata section started  {0x429000-0x42a31e}
00429000  BOOL (__stdcall* const KERNEL32:FindNextFileA)(HANDLE hFindFile, WIN32_FIND_DATAA* lpFindFileData) = FindNextFileA
00429004  HANDLE (__stdcall* const KERNEL32:FindFirstFileA)(PSTR lpFileName, WIN32_FIND_DATAA* lpFindFileData) = FindFirstFileA
00429008  void (__stdcall* const KERNEL32:GetSystemInfo)(SYSTEM_INFO* lpSystemInfo) = GetSystemInfo
0042900c  void (__stdcall* const KERNEL32:EnterCriticalSection)(CRITICAL_SECTION* lpCriticalSection) = EnterCriticalSection
00429010  void (__stdcall* const KERNEL32:LeaveCriticalSection)(CRITICAL_SECTION* lpCriticalSection) = LeaveCriticalSection
00429014  void (__stdcall* const KERNEL32:InitializeCriticalSection)(CRITICAL_SECTION* lpCriticalSection) = InitializeCriticalSection
00429018  void (__stdcall* const KERNEL32:DeleteCriticalSection)(CRITICAL_SECTION* lpCriticalSection) = DeleteCriticalSection
0042901c  enum WAIT_EVENT (__stdcall* const KERNEL32:WaitForSingleObject)(HANDLE hHandle, uint32_t dwMilliseconds) = WaitForSingleObject
00429020  HANDLE (__stdcall* const KERNEL32:CreateThread)(SECURITY_ATTRIBUTES* lpThreadAttributes, uint32_t dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, enum THREAD_CREATION_FLAGS dwCreationFlags, uint32_t* lpThreadId) = CreateThread
00429024  BOOL (__stdcall* const KERNEL32:HeapFree)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem) = HeapFree
00429028  void (__stdcall* const KERNEL32:ExitProcess)(uint32_t uExitCode) __noreturn = ExitProcess
0042902c  BOOL (__stdcall* const KERNEL32:TerminateProcess)(HANDLE hProcess, uint32_t uExitCode) = TerminateProcess
00429030  HANDLE (__stdcall* const KERNEL32:GetCurrentProcess)() = GetCurrentProcess
00429034  enum WIN32_ERROR (__stdcall* const KERNEL32:GetLastError)() = GetLastError
00429038  BOOL (__stdcall* const KERNEL32:DeleteFileA)(PSTR lpFileName) = DeleteFileA
0042903c  void* (__stdcall* const KERNEL32:HeapAlloc)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, uint32_t dwBytes) = HeapAlloc
00429040  BOOL (__stdcall* const KERNEL32:FileTimeToSystemTime)(FILETIME* lpFileTime, SYSTEMTIME* lpSystemTime) = FileTimeToSystemTime
00429044  BOOL (__stdcall* const KERNEL32:FileTimeToLocalFileTime)(FILETIME* lpFileTime, FILETIME* lpLocalFileTime) = FileTimeToLocalFileTime
00429048  uint32_t (__stdcall* const KERNEL32:GetTimeZoneInformation)(TIME_ZONE_INFORMATION* lpTimeZoneInformation) = GetTimeZoneInformation
0042904c  void (__stdcall* const KERNEL32:GetSystemTime)(SYSTEMTIME* lpSystemTime) = GetSystemTime
00429050  void (__stdcall* const KERNEL32:GetLocalTime)(SYSTEMTIME* lpSystemTime) = GetLocalTime
00429054  int32_t (* const KERNEL32:InterlockedDecrement)() = InterlockedDecrement
00429058  int32_t (* const KERNEL32:InterlockedIncrement)() = InterlockedIncrement
0042905c  uint32_t (__stdcall* const KERNEL32:HeapSize)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem) = HeapSize
00429060  uint32_t (__stdcall* const KERNEL32:GetDriveTypeA)(PSTR lpRootPathName) = GetDriveTypeA
00429064  PSTR (__stdcall* const KERNEL32:GetCommandLineA)() = GetCommandLineA
00429068  uint32_t (__stdcall* const KERNEL32:GetVersion)() = GetVersion
0042906c  FARPROC (__stdcall* const KERNEL32:GetProcAddress)(HMODULE hModule, PSTR lpProcName) = GetProcAddress
00429070  HMODULE (__stdcall* const KERNEL32:GetModuleHandleA)(PSTR lpModuleName) = GetModuleHandleA
00429074  BOOL (__stdcall* const KERNEL32:ReadFile)(HANDLE hFile, uint8_t* lpBuffer, uint32_t nNumberOfBytesToRead, uint32_t* lpNumberOfBytesRead, OVERLAPPED* lpOverlapped) = ReadFile
00429078  BOOL (__stdcall* const KERNEL32:CloseHandle)(HANDLE hObject) = CloseHandle
0042907c  uint32_t (__stdcall* const KERNEL32:SetFilePointer)(HANDLE hFile, int32_t lDistanceToMove, int32_t* lpDistanceToMoveHigh, enum SET_FILE_POINTER_MOVE_METHOD dwMoveMethod) = SetFilePointer
00429080  BOOL (__stdcall* const KERNEL32:WriteFile)(HANDLE hFile, uint8_t* lpBuffer, uint32_t nNumberOfBytesToWrite, uint32_t* lpNumberOfBytesWritten, OVERLAPPED* lpOverlapped) = WriteFile
00429084  uint32_t (__stdcall* const KERNEL32:SetHandleCount)(uint32_t uNumber) = SetHandleCount
00429088  HANDLE (__stdcall* const KERNEL32:GetStdHandle)(enum STD_HANDLE nStdHandle) = GetStdHandle
0042908c  enum FILE_TYPE (__stdcall* const KERNEL32:GetFileType)(HANDLE hFile) = GetFileType
00429090  void (__stdcall* const KERNEL32:GetStartupInfoA)(STARTUPINFOA* lpStartupInfo) = GetStartupInfoA
00429094  BOOL (__stdcall* const KERNEL32:HeapDestroy)(HANDLE hHeap) = HeapDestroy
00429098  HANDLE (__stdcall* const KERNEL32:HeapCreate)(enum HEAP_FLAGS flOptions, uint32_t dwInitialSize, uint32_t dwMaximumSize) = HeapCreate
0042909c  BOOL (__stdcall* const KERNEL32:VirtualFree)(void* lpAddress, uint32_t dwSize, enum VIRTUAL_FREE_TYPE dwFreeType) = VirtualFree
004290a0  void* (__stdcall* const KERNEL32:VirtualAlloc)(void* lpAddress, uint32_t dwSize, enum VIRTUAL_ALLOCATION_TYPE flAllocationType, enum PAGE_PROTECTION_FLAGS flProtect) = VirtualAlloc
004290a4  void* (__stdcall* const KERNEL32:HeapReAlloc)(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem, uint32_t dwBytes) = HeapReAlloc
004290a8  BOOL (__stdcall* const KERNEL32:FindClose)(HANDLE hFindFile) = FindClose
004290ac  uint32_t (__stdcall* const KERNEL32:GetCurrentThreadId)() = GetCurrentThreadId
004290b0  BOOL (__stdcall* const KERNEL32:TlsSetValue)(uint32_t dwTlsIndex, void* lpTlsValue) = TlsSetValue
004290b4  uint32_t (__stdcall* const KERNEL32:TlsAlloc)() = TlsAlloc
004290b8  void (__stdcall* const KERNEL32:SetLastError)(enum WIN32_ERROR dwErrCode) = SetLastError
004290bc  void* (__stdcall* const KERNEL32:TlsGetValue)(uint32_t dwTlsIndex) = TlsGetValue
004290c0  int32_t (__stdcall* const KERNEL32:WideCharToMultiByte)(uint32_t CodePage, uint32_t dwFlags, wchar16* lpWideCharStr, int32_t cchWideChar, PSTR lpMultiByteStr, int32_t cbMultiByte, PSTR lpDefaultChar, BOOL* lpUsedDefaultChar) = WideCharToMultiByte
004290c4  int32_t (__stdcall* const KERNEL32:MultiByteToWideChar)(uint32_t CodePage, enum MULTI_BYTE_TO_WIDE_CHAR_FLAGS dwFlags, uint8_t* lpMultiByteStr, int32_t cbMultiByte, wchar16* lpWideCharStr, int32_t cchWideChar) = MultiByteToWideChar
004290c8  int32_t (__stdcall* const KERNEL32:LCMapStringA)(uint32_t Locale, uint32_t dwMapFlags, uint8_t* lpSrcStr, int32_t cchSrc, PSTR lpDestStr, int32_t cchDest) = LCMapStringA
004290cc  int32_t (__stdcall* const KERNEL32:LCMapStringW)(uint32_t Locale, uint32_t dwMapFlags, wchar16* lpSrcStr, int32_t cchSrc, PWSTR lpDestStr, int32_t cchDest) = LCMapStringW
004290d0  BOOL (__stdcall* const KERNEL32:FlushFileBuffers)(HANDLE hFile) = FlushFileBuffers
004290d4  void (__stdcall* const KERNEL32:RaiseException)(uint32_t dwExceptionCode, uint32_t dwExceptionFlags, uint32_t nNumberOfArguments, uint32_t* lpArguments) __noreturn = RaiseException
004290d8  uint32_t (__stdcall* const KERNEL32:GetFullPathNameA)(PSTR lpFileName, uint32_t nBufferLength, uint8_t* lpBuffer, PSTR* lpFilePart) = GetFullPathNameA
004290dc  uint32_t (__stdcall* const KERNEL32:GetCurrentDirectoryA)(uint32_t nBufferLength, uint8_t* lpBuffer) = GetCurrentDirectoryA
004290e0  BOOL (__stdcall* const KERNEL32:GetCPInfo)(uint32_t CodePage, CPINFO* lpCPInfo) = GetCPInfo
004290e4  uint32_t (__stdcall* const KERNEL32:GetACP)() = GetACP
004290e8  uint32_t (__stdcall* const KERNEL32:GetOEMCP)() = GetOEMCP
004290ec  int32_t (__stdcall* const KERNEL32:UnhandledExceptionFilter)(EXCEPTION_POINTERS* ExceptionInfo) = UnhandledExceptionFilter
004290f0  uint32_t (__stdcall* const KERNEL32:GetModuleFileNameA)(HMODULE hModule, uint8_t* lpFilename, uint32_t nSize) = GetModuleFileNameA
004290f4  BOOL (__stdcall* const KERNEL32:FreeEnvironmentStringsA)(PSTR penv) = FreeEnvironmentStringsA
004290f8  BOOL (__stdcall* const KERNEL32:FreeEnvironmentStringsW)(PWSTR penv) = FreeEnvironmentStringsW
004290fc  PSTR (__stdcall* const KERNEL32:GetEnvironmentStrings)() = GetEnvironmentStrings
00429100  PWSTR (__stdcall* const KERNEL32:GetEnvironmentStringsW)() = GetEnvironmentStringsW
00429104  void (__stdcall* const KERNEL32:RtlUnwind)(void* TargetFrame, void* TargetIp, EXCEPTION_RECORD* ExceptionRecord, void* ReturnValue) = RtlUnwind
00429108  BOOL (__stdcall* const KERNEL32:SetStdHandle)(enum STD_HANDLE nStdHandle, HANDLE hHandle) = SetStdHandle
0042910c  HANDLE (__stdcall* const KERNEL32:CreateFileA)(PSTR lpFileName, uint32_t dwDesiredAccess, enum FILE_SHARE_MODE dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, enum FILE_CREATION_DISPOSITION dwCreationDisposition, enum FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile) = CreateFileA
00429110  BOOL (__stdcall* const KERNEL32:GetStringTypeA)(uint32_t Locale, uint32_t dwInfoType, uint8_t* lpSrcStr, int32_t cchSrc, uint16_t* lpCharType) = GetStringTypeA
00429114  BOOL (__stdcall* const KERNEL32:GetStringTypeW)(uint32_t dwInfoType, wchar16* lpSrcStr, int32_t cchSrc, uint16_t* lpCharType) = GetStringTypeW
00429118  HMODULE (__stdcall* const KERNEL32:LoadLibraryA)(PSTR lpLibFileName) = LoadLibraryA
0042911c  BOOL (__stdcall* const KERNEL32:SetEndOfFile)(HANDLE hFile) = SetEndOfFile
00429120  enum COMPARESTRING_RESULT (__stdcall* const KERNEL32:CompareStringA)(uint32_t Locale, uint32_t dwCmpFlags, char* lpString1, int32_t cchCount1, char* lpString2, int32_t cchCount2) = CompareStringA
00429124  enum COMPARESTRING_RESULT (__stdcall* const KERNEL32:CompareStringW)(uint32_t Locale, uint32_t dwCmpFlags, wchar16* lpString1, int32_t cchCount1, wchar16* lpString2, int32_t cchCount2) = CompareStringW
00429128  BOOL (__stdcall* const KERNEL32:SetEnvironmentVariableA)(PSTR lpName, PSTR lpValue) = SetEnvironmentVariableA
0042912c  uint32_t (__stdcall* const KERNEL32:GetFileAttributesA)(PSTR lpFileName) = GetFileAttributesA

00429130                                                  00 00 00 00 00 00 00 00                                          ........

00429138  char const data_429138[0x6] = "333333"

0042913e                                                                                            d3 bf                                ..

00429140  int64_t data_429140 = 0x0
00429148  int32_t data_429148 = 0x0
0042914c  int32_t data_42914c = 0x3f800000
00429150  int64_t data_429150 = 0x3f1a36e2eb1c432d
00429158  int64_t data_429158 = 0x3fd999999999999a
00429160  int64_t data_429160 = -0x4010000000000000
00429168  int64_t data_429168 = -0x4036666666666666
00429170  int64_t data_429170 = 0x3ff0000000000000
00429178  int64_t data_429178 = 0x3fc999999999999a
00429180  int64_t data_429180 = -0x4026666666666666
00429188  int32_t data_429188 = -0x40800000

0042918c                                      00 00 00 00                                                              ....

00429190  int64_t data_429190 = -0x4046666666666666
00429198  int32_t data_429198 = 0x47c34f80

0042919c                                                                                      00 00 00 00                              ....

004291a0  int64_t data_4291a0 = -0x40e5c91d14e3bcd3
004291a8  int32_t data_4291a8 = 0x459c4000
004291ac  int32_t data_4291ac = -0x3a63c000
004291b0  int64_t data_4291b0 = 0x3fe0000000000000
004291b8  int64_t data_4291b8 = 0x3fb999999999999a
004291c0  int64_t data_4291c0 = 0x3f847ae147ae147b
004291c8  int64_t data_4291c8 = 0x3fa999999999999a
004291d0  int64_t data_4291d0 = -0x4056666666666666
004291d8  int32_t data_4291d8 = 0x3eaaaaab

004291dc                                                                                      00 00 00 00                              ....

004291e0  int64_t data_4291e0 = 0x3f50624dd2f1a9fc
004291e8  char const data_4291e8[0x0] = 
004291e8  {
004291e8  }
004291e8                          00 00 fa 45                                                                      ...E

004291ec  int32_t data_4291ec = -0x3a060000
004291f0  int32_t data_4291f0 = 0x40000000
004291f4  int32_t data_4291f4 = 0x41000000
004291f8  int32_t data_4291f8 = 0x41800000
004291fc  int32_t data_4291fc = -0x368bdc10
00429200  int64_t data_429200 = 0x3feff7ced916872b
00429208  int32_t data_429208 = 0x41a00000

0042920c                                      00 00 00 00                                                              ....

00429210  int64_t data_429210 = 0x3f91df46a2529d39
00429218  int32_t data_429218 = 0x46000000
0042921c  int32_t data_42921c = -0x3a000000
00429220  int64_t data_429220 = -0x408b851eb851eb85
00429228  int64_t data_429228 = 0x3f747ae147ae147b
00429230  int64_t data_429230 = -0x401051eb851eb852
00429238  int64_t data_429238 = 0x4024000000000000
00429240  int64_t data_429240 = 0x3f947ae147ae147b
00429248  int32_t data_429248 = 0x43b40000

0042924c                                      00 00 00 00                                                              ....

00429250  int64_t data_429250 = 0x404ca5dc1a63c1f8
00429258  int64_t data_429258 = -0x3fa9800000000000
00429260  int64_t data_429260 = 0x4056800000000000
00429268  int32_t data_429268 = 0x45800000
0042926c  int32_t data_42926c = -0x3a800000
00429270  int64_t data_429270 = 0x3fefae147ae147ae
00429278  int64_t data_429278 = 0x400921fb54442d18
00429280  char const data_429280[0x1] = "a"

00429281     0b b6 3b                                                                                       ..;

00429284  char const data_429284[0x5] = ".com", 0

00429289                             00 00 00                                                                       ...

0042928c  char const data_42928c[0x5] = ".bat", 0

00429291                                                     00 00 00                                                       ...

00429294  char const data_429294[0x5] = ".cmd", 0

00429299                                                                             00 00 00                                       ...

0042929c  char const data_42929c[0x5] = ".exe", 0

004292a1     00 00 00                                                                                       ...
004292a4  data_4292a4:
004292a4              2e 2f 5c 00                                                                              ./\.
004292a8  data_4292a8:
004292a8                          3f 2a 00 00 00 00 00 00 ff ff ff ff a6 f9 41 00 ba f9 41 00 00 00 00 00          ?*............A...A.....

004292c0  int64_t data_4292c0 = 0x4150017ec0000000
004292c8  int64_t data_4292c8 = 0x4147ffff80000000
004292d0  char const data_4292d0[0x1a] = "IsProcessorFeaturePresent", 0

004292ea                                00 00                                                                        ..

004292ec  char const data_4292ec[0x9] = "KERNEL32", 0

004292f5                                                                 00 00 00                                               ...

004292f8  char const data_4292f8[0x6] = "e+000", 0

004292fe                                                                                            00 00                                ..
00429300  06 00 00 06 00 01 00 00 10 00 03 06 00 06 02 10 04 45 45 45 05 05 05 05 05 35 30 00 50 00 00 00  .................EEE.....50.P...
00429320  00 20 28 38 50 58 07 08 00 37 30 30 57 50 07 00 00 20 20 08 00 00 00 00 08 60 68 60 60 60 60 00  . (8PX...700WP...  ......`h````.
00429340  00 70 70 78 78 78 78 08 07 08 00 00 07 00 08 08 08 00 00 08 00 08 00 07 08 00 00 00              .ppxxxx.....................

0042935c  wchar16 const data_42935c[0x7] = "(null)", 0

0042936a                                00 00                                                                        ..

0042936c  char const data_42936c[0x7] = "(null)", 0

00429373                                                           00                                                         .

00429374  char const data_429374[0x16] = "Illegal byte sequence", 0

0042938a                                00 00                                                                        ..

0042938c  char const data_42938c[0x14] = "Directory not empty", 0
004293a0  char const data_4293a0[0x19] = "Function not implemented", 0

004293b9                                                                             00 00 00                                       ...

004293bc  char const data_4293bc[0x13] = "No locks available", 0

004293cf                                               00                                                                 .

004293d0  char const data_4293d0[0x12] = "Filename too long", 0

004293e2        00 00                                                                                        ..

004293e4  char const data_4293e4[0x1a] = "Resource deadlock avoided", 0

004293fe                                                                                            00 00                                ..

00429400  char const data_429400[0x11] = "Result too large", 0

00429411                                                     00 00 00                                                       ...

00429414  char const data_429414[0xd] = "Domain error", 0

00429421     00 00 00                                                                                       ...

00429424  char const data_429424[0xc] = "Broken pipe", 0
00429430  char const data_429430[0xf] = "Too many links", 0

0042943f                                                                                               00                                 .

00429440  char const data_429440[0x16] = "Read-only file system", 0

00429456                                                                    00 00                                                ..

00429458  char const data_429458[0xd] = "Invalid seek", 0

00429465                 00 00 00                                                                               ...

00429468  char const data_429468[0x18] = "No space left on device", 0
00429480  char const data_429480[0xf] = "File too large", 0

0042948f                                               00                                                                 .

00429490  char const data_429490[0x24] = "Inappropriate I/O control operation", 0
004294b4  char const data_4294b4[0x14] = "Too many open files", 0
004294c8  char const data_4294c8[0x1e] = "Too many open files in system", 0

004294e6                    00 00                                                                                ..

004294e8  char const data_4294e8[0x11] = "Invalid argument", 0

004294f9                                                                             00 00 00                                       ...

004294fc  char const data_4294fc[0xf] = "Is a directory", 0

0042950b                                   00                                                                         .

0042950c  char const data_42950c[0x10] = "Not a directory", 0
0042951c  char const data_42951c[0xf] = "No such device", 0

0042952b                                   00                                                                         .

0042952c  char const data_42952c[0xe] = "Improper link", 0

0042953a                                                                                00 00                                        ..

0042953c  char const data_42953c[0xc] = "File exists", 0
00429548  char const data_429548[0x10] = "Resource device", 0
00429558  char const data_429558[0xe] = "Unknown error", 0

00429566                    00 00                                                                                ..

00429568  char const data_429568[0xc] = "Bad address", 0
00429574  char const data_429574[0x12] = "Permission denied", 0

00429586                    00 00                                                                                ..

00429588  char const data_429588[0x11] = "Not enough space", 0

00429599                                                                             00 00 00                                       ...

0042959c  char const data_42959c[0x21] = "Resource temporarily unavailable", 0

004295bd                                                                                         00 00 00                               ...

004295c0  char const data_4295c0[0x13] = "No child processes", 0

004295d3                                                           00                                                         .

004295d4  char const data_4295d4[0x14] = "Bad file descriptor", 0
004295e8  char const data_4295e8[0x12] = "Exec format error", 0

004295fa                                                                                00 00                                        ..

004295fc  char const data_4295fc[0x12] = "Arg list too long", 0

0042960e                                            00 00                                                                ..

00429610  char const data_429610[0x1a] = "No such device or address", 0

0042962a                                00 00                                                                        ..

0042962c  char const data_42962c[0x13] = "Input/output error", 0

0042963f                                                                                               00                                 .

00429640  char const data_429640[0x1a] = "Interrupted function call", 0

0042965a                                                                                00 00                                        ..

0042965c  char const data_42965c[0x10] = "No such process", 0
0042966c  char const data_42966c[0x1a] = "No such file or directory", 0

00429686                    00 00                                                                                ..

00429688  char const data_429688[0x18] = "Operation not permitted", 0
004296a0  char const data_4296a0[0x9] = "No error", 0

004296a9                             00 00 00                                                                       ...
004296ac  data_4296ac:
004296ac                                      00 00 00 00                                                              ....
004296b0  data_4296b0:
004296b0                                                  00 00 00 00 00 00 00 00 ff ff ff ff                              ............

004296bc  void* data_4296bc = sub_42350a

004296c0  0e 35 42 00 ff ff ff ff                                                                          .5B.....

004296c8  void* data_4296c8 = sub_4235be

004296cc                                      c2 35 42 00 5f 79 6e 00 5f 79 31 00 5f 79 30 00                          .5B._yn._y1._y0.

004296dc  char const data_4296dc[0x6] = "frexp", 0

004296e2        00 00                                                                                        ..

004296e4  char const data_4296e4[0x5] = "fmod", 0

004296e9                             00 00 00                                                                       ...

004296ec  char const data_4296ec[0x7] = "_hypot", 0

004296f3                                                           00                                                         .

004296f4  char const data_4296f4[0x6] = "_cabs", 0

004296fa                                                                                00 00                                        ..

004296fc  char const data_4296fc[0x6] = "ldexp", 0

00429702        00 00                                                                                        ..

00429704  char const data_429704[0x5] = "modf", 0

00429709                             00 00 00                                                                       ...

0042970c  char const data_42970c[0x5] = "fabs", 0

00429711                                                     00 00 00                                                       ...

00429714  char const data_429714[0x6] = "floor", 0

0042971a                                                                                00 00                                        ..

0042971c  char const data_42971c[0x5] = "ceil", 0

00429721     00 00 00 74 61 6e 00 63 6f 73 00 73 69 6e 00                                                   ...tan.cos.sin.

00429730  char const data_429730[0x5] = "sqrt", 0

00429735                                                                 00 00 00                                               ...

00429738  char const data_429738[0x6] = "atan2", 0

0042973e                                                                                            00 00                                ..

00429740  char const data_429740[0x5] = "atan", 0

00429745                 00 00 00                                                                               ...

00429748  char const data_429748[0x5] = "acos", 0

0042974d                                         00 00 00                                                               ...

00429750  char const data_429750[0x5] = "asin", 0

00429755                                                                 00 00 00                                               ...

00429758  char const data_429758[0x5] = "tanh", 0

0042975d                                                                                         00 00 00                               ...

00429760  char const data_429760[0x5] = "cosh", 0

00429765                 00 00 00                                                                               ...

00429768  char const data_429768[0x5] = "sinh", 0

0042976d                                         00 00 00                                                               ...

00429770  char const data_429770[0x6] = "log10", 0

00429776                                                                    00 00 6c 6f 67 00 70 6f 77 00                        ..log.pow.
00429780  65 78 70 00                                                                                      exp.

00429784  char const data_429784[0xf] = "runtime error ", 0

00429793                                                           00                                                         .

00429794  char const data_429794[0xe] = "TLOSS error\r\n", 0

004297a2        00 00                                                                                        ..

004297a4  char const data_4297a4[0xd] = "SING error\r\n", 0

004297b1                                                     00 00 00                                                       ...

004297b4  char const data_4297b4[0xf] = "DOMAIN error\r\n", 0

004297c3           00                                                                                         .

004297c4  char const data_4297c4[0x25] = "R6028\r\n"
004297c4      "- unable to initialize heap\r\n", 0

004297e9                             00 00 00                                                                       ...

004297ec  char const data_4297ec[0x35] = "R6027\r\n"
004297ec      "- not enough space for lowio initialization\r\n", 0

00429821     00 00 00                                                                                       ...

00429824  char const data_429824[0x35] = "R6026\r\n"
00429824      "- not enough space for stdio initialization\r\n", 0

00429859                                                                             00 00 00                                       ...

0042985c  char const data_42985c[0x26] = "R6025\r\n"
0042985c      "- pure virtual function call\r\n", 0

00429882        00 00                                                                                        ..

00429884  char const data_429884[0x35] = "R6024\r\n"
00429884      "- not enough space for _onexit/atexit table\r\n", 0

004298b9                                                                             00 00 00                                       ...

004298bc  char const data_4298bc[0x29] = "R6019\r\n"
004298bc      "- unable to open console device\r\n", 0

004298e5                 00 00 00                                                                               ...

004298e8  char const data_4298e8[0x21] = "R6018\r\n"
004298e8      "- unexpected heap error\r\n", 0

00429909                             00 00 00                                                                       ...

0042990c  char const data_42990c[0x2d] = "R6017\r\n"
0042990c      "- unexpected multithread lock error\r\n", 0

00429939                                                                             00 00 00                                       ...

0042993c  char const data_42993c[0x2c] = "R6016\r\n"
0042993c      "- not enough space for thread data\r\n", 0
00429968  char const data_429968[0x21] = "\r\nabnormal program termination\r\n", 0

00429989                             00 00 00                                                                       ...

0042998c  char const data_42998c[0x2c] = "R6009\r\n"
0042998c      "- not enough space for environment\r\n", 0
004299b8  char const data_4299b8[0x2a] = "R6008\r\n"
004299b8      "- not enough space for arguments\r\n", 0

004299e2        00 00                                                                                        ..

004299e4  char const data_4299e4[0x25] = "R6002\r\n"
004299e4      "- floating point not loaded\r\n", 0

00429a09                             00 00 00                                                                       ...

00429a0c  char const data_429a0c[0x25] = "Microsoft Visual C++ Runtime Library", 0

00429a31                                                     00 00 00                                                       ...
00429a34  data_429a34:
00429a34                                                              0a 0a 00 00                                              ....

00429a38  char const data_429a38[0x1a] = "Runtime Error!\n\n"
00429a38      "Program: ", 0

00429a52                                                        00 00                                                        ..

00429a54  char const data_429a54[0x17] = "<program name unknown>", 0

00429a6b                                   00 00 00 00 00 ff ff ff ff                                                 .........

00429a74  void* data_429a74 = sub_426202

00429a78                                                                          06 62 42 00 53 75 6e 4d                          .bB.SunM
00429a80  6f 6e 54 75 65 57 65 64 54 68 75 46 72 69 53 61 74 00 00 00 4a 61 6e 46 65 62 4d 61 72 41 70 72  onTueWedThuFriSat...JanFebMarApr
00429aa0  4d 61 79 4a 75 6e 4a 75 6c 41 75 67 53 65 70 4f 63 74 4e 6f 76 44 65 63 00 00 00 00              MayJunJulAugSepOctNovDec....
00429abc  data_429abc:
00429abc                                                                                      54 5a 00 00                              TZ..

00429ac0  char const data_429ac0[0x13] = "GetLastActivePopup", 0

00429ad3                                                           00                                                         .

00429ad4  char const data_429ad4[0x10] = "GetActiveWindow", 0
00429ae4  char const data_429ae4[0xc] = "MessageBoxA", 0
00429af0  char const data_429af0[0xb] = "user32.dll", 0

00429afb                                                                                   00                                         .

00429afc  char const data_429afc[0x7] = "1#QNAN", 0

00429b03           00                                                                                         .

00429b04  char const data_429b04[0x6] = "1#INF", 0

00429b0a                                00 00                                                                        ..

00429b0c  char const data_429b0c[0x6] = "1#IND", 0

00429b12                                                        00 00                                                        ..

00429b14  char const data_429b14[0x7] = "1#SNAN", 0

00429b1b                                                                                   00                                         .

00429b1c  char const data_429b1c[0x8] = "H:mm:ss", 0
00429b24  char const data_429b24[0x14] = "dddd, MMMM dd, yyyy", 0
00429b38  char const data_429b38[0x7] = "M/d/yy", 0

00429b3f                                                                                               00                                 .
00429b40  50 4d 00 00 41 4d 00 00                                                                          PM..AM..

00429b48  char const data_429b48[0x9] = "December", 0

00429b51                                                     00 00 00                                                       ...

00429b54  char const data_429b54[0x9] = "November", 0

00429b5d                                                                                         00 00 00                               ...

00429b60  char const data_429b60[0x8] = "October", 0
00429b68  char const data_429b68[0xa] = "September", 0

00429b72                                                        00 00                                                        ..

00429b74  char const data_429b74[0x7] = "August", 0

00429b7b                                                                                   00                                         .

00429b7c  char const data_429b7c[0x5] = "July", 0

00429b81     00 00 00                                                                                       ...

00429b84  char const data_429b84[0x5] = "June", 0

00429b89                             00 00 00                                                                       ...

00429b8c  char const data_429b8c[0x6] = "April", 0

00429b92                                                        00 00                                                        ..

00429b94  char const data_429b94[0x6] = "March", 0

00429b9a                                                                                00 00                                        ..

00429b9c  char const data_429b9c[0x9] = "February", 0

00429ba5                 00 00 00                                                                               ...

00429ba8  char const data_429ba8[0x8] = "January", 0

00429bb0                                                  44 65 63 00 4e 6f 76 00 4f 63 74 00 53 65 70 00                  Dec.Nov.Oct.Sep.
00429bc0  41 75 67 00 4a 75 6c 00 4a 75 6e 00 4d 61 79 00 41 70 72 00 4d 61 72 00 46 65 62 00 4a 61 6e 00  Aug.Jul.Jun.May.Apr.Mar.Feb.Jan.

00429be0  char const data_429be0[0x9] = "Saturday", 0

00429be9                             00 00 00                                                                       ...

00429bec  char const data_429bec[0x7] = "Friday", 0

00429bf3                                                           00                                                         .

00429bf4  char const data_429bf4[0x9] = "Thursday", 0

00429bfd                                                                                         00 00 00                               ...

00429c00  char const data_429c00[0xa] = "Wednesday", 0

00429c0a                                00 00                                                                        ..

00429c0c  char const data_429c0c[0x8] = "Tuesday", 0
00429c14  char const data_429c14[0x7] = "Monday", 0

00429c1b                                                                                   00                                         .

00429c1c  char const data_429c1c[0x7] = "Sunday", 0

00429c23           00 53 61 74 00 46 72 69 00 54 68 75 00 57 65 64 00 54 75 65 00 4d 6f 6e 00 53 75 6e 00     .Sat.Fri.Thu.Wed.Tue.Mon.Sun.
00429c40  ff ff ff ff                                                                                      ....

00429c44  void* data_429c44 = sub_427ed6

00429c48                          da 7e 42 00 ff ff ff ff                                                          .~B.....

00429c50  void* data_429c50 = sub_427f45

00429c54                                                              49 7f 42 00                                              I.B.
00429c58  struct Import_Directory_Table __import_directory_entries[0x2] = 
00429c58  {
00429c58      [0x0] = 
00429c58      {
00429c58          uint32_t importLookupTableRva = 0x29c80
00429c5c          uint32_t timeDateStamp = 0x0
00429c60          uint32_t forwarderChain = 0x0
00429c64          uint32_t nameRva = 0x29e7c
00429c68          uint32_t importAddressTableRva = 0x29000
00429c6c      }
00429c6c      [0x1] = 
00429c6c      {
00429c6c          uint32_t importLookupTableRva = 0x0
00429c70          uint32_t timeDateStamp = 0x0
00429c74          uint32_t forwarderChain = 0x0
00429c78          uint32_t nameRva = 0x0
00429c7c          uint32_t importAddressTableRva = 0x0
00429c80      }
00429c80  }
00429c80  uint32_t __import_lookup_table_0(KERNEL32:FindNextFileA) = 0x29dc0
00429c84  uint32_t __import_lookup_table_0(KERNEL32:FindFirstFileA) = 0x29dd0
00429c88  uint32_t __import_lookup_table_0(KERNEL32:GetSystemInfo) = 0x29de2
00429c8c  uint32_t __import_lookup_table_0(KERNEL32:EnterCriticalSection) = 0x29df2
00429c90  uint32_t __import_lookup_table_0(KERNEL32:LeaveCriticalSection) = 0x29e0a
00429c94  uint32_t __import_lookup_table_0(KERNEL32:InitializeCriticalSection) = 0x29e22
00429c98  uint32_t __import_lookup_table_0(KERNEL32:DeleteCriticalSection) = 0x29e3e
00429c9c  uint32_t __import_lookup_table_0(KERNEL32:WaitForSingleObject) = 0x29e56
00429ca0  uint32_t __import_lookup_table_0(KERNEL32:CreateThread) = 0x29e6c
00429ca4  uint32_t __import_lookup_table_0(KERNEL32:HeapFree) = 0x29e8a
00429ca8  uint32_t __import_lookup_table_0(KERNEL32:ExitProcess) = 0x29e96
00429cac  uint32_t __import_lookup_table_0(KERNEL32:TerminateProcess) = 0x29ea4
00429cb0  uint32_t __import_lookup_table_0(KERNEL32:GetCurrentProcess) = 0x29eb8
00429cb4  uint32_t __import_lookup_table_0(KERNEL32:GetLastError) = 0x29ecc
00429cb8  uint32_t __import_lookup_table_0(KERNEL32:DeleteFileA) = 0x29edc
00429cbc  uint32_t __import_lookup_table_0(KERNEL32:HeapAlloc) = 0x29eea
00429cc0  uint32_t __import_lookup_table_0(KERNEL32:FileTimeToSystemTime) = 0x29ef6
00429cc4  uint32_t __import_lookup_table_0(KERNEL32:FileTimeToLocalFileTime) = 0x29f0e
00429cc8  uint32_t __import_lookup_table_0(KERNEL32:GetTimeZoneInformation) = 0x29f28
00429ccc  uint32_t __import_lookup_table_0(KERNEL32:GetSystemTime) = 0x29f42
00429cd0  uint32_t __import_lookup_table_0(KERNEL32:GetLocalTime) = 0x29f52
00429cd4  uint32_t __import_lookup_table_0(KERNEL32:InterlockedDecrement) = 0x29f62
00429cd8  uint32_t __import_lookup_table_0(KERNEL32:InterlockedIncrement) = 0x29f7a
00429cdc  uint32_t __import_lookup_table_0(KERNEL32:HeapSize) = 0x29f92
00429ce0  uint32_t __import_lookup_table_0(KERNEL32:GetDriveTypeA) = 0x29f9e
00429ce4  uint32_t __import_lookup_table_0(KERNEL32:GetCommandLineA) = 0x29fae
00429ce8  uint32_t __import_lookup_table_0(KERNEL32:GetVersion) = 0x29fc0
00429cec  uint32_t __import_lookup_table_0(KERNEL32:GetProcAddress) = 0x29fce
00429cf0  uint32_t __import_lookup_table_0(KERNEL32:GetModuleHandleA) = 0x29fe0
00429cf4  uint32_t __import_lookup_table_0(KERNEL32:ReadFile) = 0x29ff4
00429cf8  uint32_t __import_lookup_table_0(KERNEL32:CloseHandle) = 0x2a000
00429cfc  uint32_t __import_lookup_table_0(KERNEL32:SetFilePointer) = 0x2a00e
00429d00  uint32_t __import_lookup_table_0(KERNEL32:WriteFile) = 0x2a020
00429d04  uint32_t __import_lookup_table_0(KERNEL32:SetHandleCount) = 0x2a02c
00429d08  uint32_t __import_lookup_table_0(KERNEL32:GetStdHandle) = 0x2a03e
00429d0c  uint32_t __import_lookup_table_0(KERNEL32:GetFileType) = 0x2a04e
00429d10  uint32_t __import_lookup_table_0(KERNEL32:GetStartupInfoA) = 0x2a05c
00429d14  uint32_t __import_lookup_table_0(KERNEL32:HeapDestroy) = 0x2a06e
00429d18  uint32_t __import_lookup_table_0(KERNEL32:HeapCreate) = 0x2a07c
00429d1c  uint32_t __import_lookup_table_0(KERNEL32:VirtualFree) = 0x2a08a
00429d20  uint32_t __import_lookup_table_0(KERNEL32:VirtualAlloc) = 0x2a098
00429d24  uint32_t __import_lookup_table_0(KERNEL32:HeapReAlloc) = 0x2a0a8
00429d28  uint32_t __import_lookup_table_0(KERNEL32:FindClose) = 0x29db4
00429d2c  uint32_t __import_lookup_table_0(KERNEL32:GetCurrentThreadId) = 0x2a0b6
00429d30  uint32_t __import_lookup_table_0(KERNEL32:TlsSetValue) = 0x2a0cc
00429d34  uint32_t __import_lookup_table_0(KERNEL32:TlsAlloc) = 0x2a0da
00429d38  uint32_t __import_lookup_table_0(KERNEL32:SetLastError) = 0x2a0e6
00429d3c  uint32_t __import_lookup_table_0(KERNEL32:TlsGetValue) = 0x2a0f6
00429d40  uint32_t __import_lookup_table_0(KERNEL32:WideCharToMultiByte) = 0x2a104
00429d44  uint32_t __import_lookup_table_0(KERNEL32:MultiByteToWideChar) = 0x2a11a
00429d48  uint32_t __import_lookup_table_0(KERNEL32:LCMapStringA) = 0x2a130
00429d4c  uint32_t __import_lookup_table_0(KERNEL32:LCMapStringW) = 0x2a140
00429d50  uint32_t __import_lookup_table_0(KERNEL32:FlushFileBuffers) = 0x2a150
00429d54  uint32_t __import_lookup_table_0(KERNEL32:RaiseException) = 0x2a164
00429d58  uint32_t __import_lookup_table_0(KERNEL32:GetFullPathNameA) = 0x2a176
00429d5c  uint32_t __import_lookup_table_0(KERNEL32:GetCurrentDirectoryA) = 0x2a18a
00429d60  uint32_t __import_lookup_table_0(KERNEL32:GetCPInfo) = 0x2a1a2
00429d64  uint32_t __import_lookup_table_0(KERNEL32:GetACP) = 0x2a1ae
00429d68  uint32_t __import_lookup_table_0(KERNEL32:GetOEMCP) = 0x2a1b8
00429d6c  uint32_t __import_lookup_table_0(KERNEL32:UnhandledExceptionFilter) = 0x2a1c4
00429d70  uint32_t __import_lookup_table_0(KERNEL32:GetModuleFileNameA) = 0x2a1e0
00429d74  uint32_t __import_lookup_table_0(KERNEL32:FreeEnvironmentStringsA) = 0x2a1f6
00429d78  uint32_t __import_lookup_table_0(KERNEL32:FreeEnvironmentStringsW) = 0x2a210
00429d7c  uint32_t __import_lookup_table_0(KERNEL32:GetEnvironmentStrings) = 0x2a22a
00429d80  uint32_t __import_lookup_table_0(KERNEL32:GetEnvironmentStringsW) = 0x2a242
00429d84  uint32_t __import_lookup_table_0(KERNEL32:RtlUnwind) = 0x2a25c
00429d88  uint32_t __import_lookup_table_0(KERNEL32:SetStdHandle) = 0x2a268
00429d8c  uint32_t __import_lookup_table_0(KERNEL32:CreateFileA) = 0x2a278
00429d90  uint32_t __import_lookup_table_0(KERNEL32:GetStringTypeA) = 0x2a286
00429d94  uint32_t __import_lookup_table_0(KERNEL32:GetStringTypeW) = 0x2a298
00429d98  uint32_t __import_lookup_table_0(KERNEL32:LoadLibraryA) = 0x2a2aa
00429d9c  uint32_t __import_lookup_table_0(KERNEL32:SetEndOfFile) = 0x2a2ba
00429da0  uint32_t __import_lookup_table_0(KERNEL32:CompareStringA) = 0x2a2ca
00429da4  uint32_t __import_lookup_table_0(KERNEL32:CompareStringW) = 0x2a2dc
00429da8  uint32_t __import_lookup_table_0(KERNEL32:SetEnvironmentVariableA) = 0x2a2ee
00429dac  uint32_t __import_lookup_table_0(KERNEL32:GetFileAttributesA) = 0x2a308
00429db0  uint32_t data_429db0 = 0x0
00429db4  uint16_t __export_name_ptr_table_0(KERNEL32:FindClose) = 0x90
00429db6  char __import_name_0(KERNEL32:FindClose)[0xa] = "FindClose", 0
00429dc0  uint16_t __export_name_ptr_table_0(KERNEL32:FindNextFileA) = 0x9d
00429dc2  char __import_name_0(KERNEL32:FindNextFileA)[0xe] = "FindNextFileA", 0
00429dd0  uint16_t __export_name_ptr_table_0(KERNEL32:FindFirstFileA) = 0x94
00429dd2  char __import_name_0(KERNEL32:FindFirstFileA)[0xf] = "FindFirstFileA", 0

00429de1     00                                                                                             .

00429de2  uint16_t __export_name_ptr_table_0(KERNEL32:GetSystemInfo) = 0x15b
00429de4  char __import_name_0(KERNEL32:GetSystemInfo)[0xe] = "GetSystemInfo", 0
00429df2  uint16_t __export_name_ptr_table_0(KERNEL32:EnterCriticalSection) = 0x66
00429df4  char __import_name_0(KERNEL32:EnterCriticalSection)[0x15] = "EnterCriticalSection", 0

00429e09                             00                                                                             .

00429e0a  uint16_t __export_name_ptr_table_0(KERNEL32:LeaveCriticalSection) = 0x1c1
00429e0c  char __import_name_0(KERNEL32:LeaveCriticalSection)[0x15] = "LeaveCriticalSection", 0

00429e21     00                                                                                             .

00429e22  uint16_t __export_name_ptr_table_0(KERNEL32:InitializeCriticalSection) = 0x1aa
00429e24  char __import_name_0(KERNEL32:InitializeCriticalSection)[0x1a] = "InitializeCriticalSection", 0
00429e3e  uint16_t __export_name_ptr_table_0(KERNEL32:DeleteCriticalSection) = 0x55
00429e40  char __import_name_0(KERNEL32:DeleteCriticalSection)[0x16] = "DeleteCriticalSection", 0
00429e56  uint16_t __export_name_ptr_table_0(KERNEL32:WaitForSingleObject) = 0x2ce
00429e58  char __import_name_0(KERNEL32:WaitForSingleObject)[0x14] = "WaitForSingleObject", 0
00429e6c  uint16_t __export_name_ptr_table_0(KERNEL32:CreateThread) = 0x4a
00429e6e  char __import_name_0(KERNEL32:CreateThread)[0xd] = "CreateThread", 0

00429e7b                                                                                   00                                         .

00429e7c  char __import_dll_name(KERNEL32)[0xd] = "KERNEL32.dll", 0

00429e89                             00                                                                             .

00429e8a  uint16_t __export_name_ptr_table_0(KERNEL32:HeapFree) = 0x19f
00429e8c  char __import_name_0(KERNEL32:HeapFree)[0x9] = "HeapFree", 0

00429e95                                                                 00                                                     .

00429e96  uint16_t __export_name_ptr_table_0(KERNEL32:ExitProcess) = 0x7d
00429e98  char __import_name_0(KERNEL32:ExitProcess)[0xc] = "ExitProcess", 0
00429ea4  uint16_t __export_name_ptr_table_0(KERNEL32:TerminateProcess) = 0x29e
00429ea6  char __import_name_0(KERNEL32:TerminateProcess)[0x11] = "TerminateProcess", 0

00429eb7                                                                       00                                                 .

00429eb8  uint16_t __export_name_ptr_table_0(KERNEL32:GetCurrentProcess) = 0xf7
00429eba  char __import_name_0(KERNEL32:GetCurrentProcess)[0x12] = "GetCurrentProcess", 0
00429ecc  uint16_t __export_name_ptr_table_0(KERNEL32:GetLastError) = 0x11a
00429ece  char __import_name_0(KERNEL32:GetLastError)[0xd] = "GetLastError", 0

00429edb                                                                                   00                                         .

00429edc  uint16_t __export_name_ptr_table_0(KERNEL32:DeleteFileA) = 0x57
00429ede  char __import_name_0(KERNEL32:DeleteFileA)[0xc] = "DeleteFileA", 0
00429eea  uint16_t __export_name_ptr_table_0(KERNEL32:HeapAlloc) = 0x199
00429eec  char __import_name_0(KERNEL32:HeapAlloc)[0xa] = "HeapAlloc", 0
00429ef6  uint16_t __export_name_ptr_table_0(KERNEL32:FileTimeToSystemTime) = 0x8a
00429ef8  char __import_name_0(KERNEL32:FileTimeToSystemTime)[0x15] = "FileTimeToSystemTime", 0

00429f0d                                         00                                                                     .

00429f0e  uint16_t __export_name_ptr_table_0(KERNEL32:FileTimeToLocalFileTime) = 0x89
00429f10  char __import_name_0(KERNEL32:FileTimeToLocalFileTime)[0x18] = "FileTimeToLocalFileTime", 0
00429f28  uint16_t __export_name_ptr_table_0(KERNEL32:GetTimeZoneInformation) = 0x170
00429f2a  char __import_name_0(KERNEL32:GetTimeZoneInformation)[0x17] = "GetTimeZoneInformation", 0

00429f41     00                                                                                             .

00429f42  uint16_t __export_name_ptr_table_0(KERNEL32:GetSystemTime) = 0x15d
00429f44  char __import_name_0(KERNEL32:GetSystemTime)[0xe] = "GetSystemTime", 0
00429f52  uint16_t __export_name_ptr_table_0(KERNEL32:GetLocalTime) = 0x11b
00429f54  char __import_name_0(KERNEL32:GetLocalTime)[0xd] = "GetLocalTime", 0

00429f61     00                                                                                             .

00429f62  uint16_t __export_name_ptr_table_0(KERNEL32:InterlockedDecrement) = 0x1ad
00429f64  char __import_name_0(KERNEL32:InterlockedDecrement)[0x15] = "InterlockedDecrement", 0

00429f79                                                                             00                                             .

00429f7a  uint16_t __export_name_ptr_table_0(KERNEL32:InterlockedIncrement) = 0x1b0
00429f7c  char __import_name_0(KERNEL32:InterlockedIncrement)[0x15] = "InterlockedIncrement", 0

00429f91                                                     00                                                             .

00429f92  uint16_t __export_name_ptr_table_0(KERNEL32:HeapSize) = 0x1a3
00429f94  char __import_name_0(KERNEL32:HeapSize)[0x9] = "HeapSize", 0

00429f9d                                                                                         00                                     .

00429f9e  uint16_t __export_name_ptr_table_0(KERNEL32:GetDriveTypeA) = 0x104
00429fa0  char __import_name_0(KERNEL32:GetDriveTypeA)[0xe] = "GetDriveTypeA", 0
00429fae  uint16_t __export_name_ptr_table_0(KERNEL32:GetCommandLineA) = 0xca
00429fb0  char __import_name_0(KERNEL32:GetCommandLineA)[0x10] = "GetCommandLineA", 0
00429fc0  uint16_t __export_name_ptr_table_0(KERNEL32:GetVersion) = 0x174
00429fc2  char __import_name_0(KERNEL32:GetVersion)[0xb] = "GetVersion", 0

00429fcd                                         00                                                                     .

00429fce  uint16_t __export_name_ptr_table_0(KERNEL32:GetProcAddress) = 0x13e
00429fd0  char __import_name_0(KERNEL32:GetProcAddress)[0xf] = "GetProcAddress", 0

00429fdf                                                                                               00                                 .

00429fe0  uint16_t __export_name_ptr_table_0(KERNEL32:GetModuleHandleA) = 0x126
00429fe2  char __import_name_0(KERNEL32:GetModuleHandleA)[0x11] = "GetModuleHandleA", 0

00429ff3                                                           00                                                         .

00429ff4  uint16_t __export_name_ptr_table_0(KERNEL32:ReadFile) = 0x218
00429ff6  char __import_name_0(KERNEL32:ReadFile)[0x9] = "ReadFile", 0

00429fff                                                                                               00                                 .

0042a000  uint16_t __export_name_ptr_table_0(KERNEL32:CloseHandle) = 0x1b
0042a002  char __import_name_0(KERNEL32:CloseHandle)[0xc] = "CloseHandle", 0
0042a00e  uint16_t __export_name_ptr_table_0(KERNEL32:SetFilePointer) = 0x26a
0042a010  char __import_name_0(KERNEL32:SetFilePointer)[0xf] = "SetFilePointer", 0

0042a01f                                                                                               00                                 .

0042a020  uint16_t __export_name_ptr_table_0(KERNEL32:WriteFile) = 0x2df
0042a022  char __import_name_0(KERNEL32:WriteFile)[0xa] = "WriteFile", 0
0042a02c  uint16_t __export_name_ptr_table_0(KERNEL32:SetHandleCount) = 0x26d
0042a02e  char __import_name_0(KERNEL32:SetHandleCount)[0xf] = "SetHandleCount", 0

0042a03d                                                                                         00                                     .

0042a03e  uint16_t __export_name_ptr_table_0(KERNEL32:GetStdHandle) = 0x152
0042a040  char __import_name_0(KERNEL32:GetStdHandle)[0xd] = "GetStdHandle", 0

0042a04d                                         00                                                                     .

0042a04e  uint16_t __export_name_ptr_table_0(KERNEL32:GetFileType) = 0x115
0042a050  char __import_name_0(KERNEL32:GetFileType)[0xc] = "GetFileType", 0
0042a05c  uint16_t __export_name_ptr_table_0(KERNEL32:GetStartupInfoA) = 0x150
0042a05e  char __import_name_0(KERNEL32:GetStartupInfoA)[0x10] = "GetStartupInfoA", 0
0042a06e  uint16_t __export_name_ptr_table_0(KERNEL32:HeapDestroy) = 0x19d
0042a070  char __import_name_0(KERNEL32:HeapDestroy)[0xc] = "HeapDestroy", 0
0042a07c  uint16_t __export_name_ptr_table_0(KERNEL32:HeapCreate) = 0x19b
0042a07e  char __import_name_0(KERNEL32:HeapCreate)[0xb] = "HeapCreate", 0

0042a089                             00                                                                             .

0042a08a  uint16_t __export_name_ptr_table_0(KERNEL32:VirtualFree) = 0x2bf
0042a08c  char __import_name_0(KERNEL32:VirtualFree)[0xc] = "VirtualFree", 0
0042a098  uint16_t __export_name_ptr_table_0(KERNEL32:VirtualAlloc) = 0x2bb
0042a09a  char __import_name_0(KERNEL32:VirtualAlloc)[0xd] = "VirtualAlloc", 0

0042a0a7                       00                                                                                 .

0042a0a8  uint16_t __export_name_ptr_table_0(KERNEL32:HeapReAlloc) = 0x1a2
0042a0aa  char __import_name_0(KERNEL32:HeapReAlloc)[0xc] = "HeapReAlloc", 0
0042a0b6  uint16_t __export_name_ptr_table_0(KERNEL32:GetCurrentThreadId) = 0xfa
0042a0b8  char __import_name_0(KERNEL32:GetCurrentThreadId)[0x13] = "GetCurrentThreadId", 0

0042a0cb                                   00                                                                         .

0042a0cc  uint16_t __export_name_ptr_table_0(KERNEL32:TlsSetValue) = 0x2a5
0042a0ce  char __import_name_0(KERNEL32:TlsSetValue)[0xc] = "TlsSetValue", 0
0042a0da  uint16_t __export_name_ptr_table_0(KERNEL32:TlsAlloc) = 0x2a2
0042a0dc  char __import_name_0(KERNEL32:TlsAlloc)[0x9] = "TlsAlloc", 0

0042a0e5                 00                                                                                     .

0042a0e6  uint16_t __export_name_ptr_table_0(KERNEL32:SetLastError) = 0x271
0042a0e8  char __import_name_0(KERNEL32:SetLastError)[0xd] = "SetLastError", 0

0042a0f5                                                                 00                                                     .

0042a0f6  uint16_t __export_name_ptr_table_0(KERNEL32:TlsGetValue) = 0x2a4
0042a0f8  char __import_name_0(KERNEL32:TlsGetValue)[0xc] = "TlsGetValue", 0
0042a104  uint16_t __export_name_ptr_table_0(KERNEL32:WideCharToMultiByte) = 0x2d2
0042a106  char __import_name_0(KERNEL32:WideCharToMultiByte)[0x14] = "WideCharToMultiByte", 0
0042a11a  uint16_t __export_name_ptr_table_0(KERNEL32:MultiByteToWideChar) = 0x1e4
0042a11c  char __import_name_0(KERNEL32:MultiByteToWideChar)[0x14] = "MultiByteToWideChar", 0
0042a130  uint16_t __export_name_ptr_table_0(KERNEL32:LCMapStringA) = 0x1bf
0042a132  char __import_name_0(KERNEL32:LCMapStringA)[0xd] = "LCMapStringA", 0

0042a13f                                                                                               00                                 .

0042a140  uint16_t __export_name_ptr_table_0(KERNEL32:LCMapStringW) = 0x1c0
0042a142  char __import_name_0(KERNEL32:LCMapStringW)[0xd] = "LCMapStringW", 0

0042a14f                                               00                                                                 .

0042a150  uint16_t __export_name_ptr_table_0(KERNEL32:FlushFileBuffers) = 0xaa
0042a152  char __import_name_0(KERNEL32:FlushFileBuffers)[0x11] = "FlushFileBuffers", 0

0042a163           00                                                                                         .

0042a164  uint16_t __export_name_ptr_table_0(KERNEL32:RaiseException) = 0x20b
0042a166  char __import_name_0(KERNEL32:RaiseException)[0xf] = "RaiseException", 0

0042a175                                                                 00                                                     .

0042a176  uint16_t __export_name_ptr_table_0(KERNEL32:GetFullPathNameA) = 0x116
0042a178  char __import_name_0(KERNEL32:GetFullPathNameA)[0x11] = "GetFullPathNameA", 0

0042a189                             00                                                                             .

0042a18a  uint16_t __export_name_ptr_table_0(KERNEL32:GetCurrentDirectoryA) = 0xf5
0042a18c  char __import_name_0(KERNEL32:GetCurrentDirectoryA)[0x15] = "GetCurrentDirectoryA", 0

0042a1a1     00                                                                                             .

0042a1a2  uint16_t __export_name_ptr_table_0(KERNEL32:GetCPInfo) = 0xbf
0042a1a4  char __import_name_0(KERNEL32:GetCPInfo)[0xa] = "GetCPInfo", 0
0042a1ae  uint16_t __export_name_ptr_table_0(KERNEL32:GetACP) = 0xb9
0042a1b0  char __import_name_0(KERNEL32:GetACP)[0x7] = "GetACP", 0

0042a1b7                                                                       00                                                 .

0042a1b8  uint16_t __export_name_ptr_table_0(KERNEL32:GetOEMCP) = 0x131
0042a1ba  char __import_name_0(KERNEL32:GetOEMCP)[0x9] = "GetOEMCP", 0

0042a1c3           00                                                                                         .

0042a1c4  uint16_t __export_name_ptr_table_0(KERNEL32:UnhandledExceptionFilter) = 0x2ad
0042a1c6  char __import_name_0(KERNEL32:UnhandledExceptionFilter)[0x19] = "UnhandledExceptionFilter", 0

0042a1df                                                                                               00                                 .

0042a1e0  uint16_t __export_name_ptr_table_0(KERNEL32:GetModuleFileNameA) = 0x124
0042a1e2  char __import_name_0(KERNEL32:GetModuleFileNameA)[0x13] = "GetModuleFileNameA", 0

0042a1f5                                                                 00                                                     .

0042a1f6  uint16_t __export_name_ptr_table_0(KERNEL32:FreeEnvironmentStringsA) = 0xb2
0042a1f8  char __import_name_0(KERNEL32:FreeEnvironmentStringsA)[0x18] = "FreeEnvironmentStringsA", 0
0042a210  uint16_t __export_name_ptr_table_0(KERNEL32:FreeEnvironmentStringsW) = 0xb3
0042a212  char __import_name_0(KERNEL32:FreeEnvironmentStringsW)[0x18] = "FreeEnvironmentStringsW", 0
0042a22a  uint16_t __export_name_ptr_table_0(KERNEL32:GetEnvironmentStrings) = 0x106
0042a22c  char __import_name_0(KERNEL32:GetEnvironmentStrings)[0x16] = "GetEnvironmentStrings", 0
0042a242  uint16_t __export_name_ptr_table_0(KERNEL32:GetEnvironmentStringsW) = 0x108
0042a244  char __import_name_0(KERNEL32:GetEnvironmentStringsW)[0x17] = "GetEnvironmentStringsW", 0

0042a25b                                                                                   00                                         .

0042a25c  uint16_t __export_name_ptr_table_0(KERNEL32:RtlUnwind) = 0x22f
0042a25e  char __import_name_0(KERNEL32:RtlUnwind)[0xa] = "RtlUnwind", 0
0042a268  uint16_t __export_name_ptr_table_0(KERNEL32:SetStdHandle) = 0x27c
0042a26a  char __import_name_0(KERNEL32:SetStdHandle)[0xd] = "SetStdHandle", 0

0042a277                                                                       00                                                 .

0042a278  uint16_t __export_name_ptr_table_0(KERNEL32:CreateFileA) = 0x34
0042a27a  char __import_name_0(KERNEL32:CreateFileA)[0xc] = "CreateFileA", 0
0042a286  uint16_t __export_name_ptr_table_0(KERNEL32:GetStringTypeA) = 0x153
0042a288  char __import_name_0(KERNEL32:GetStringTypeA)[0xf] = "GetStringTypeA", 0

0042a297                                                                       00                                                 .

0042a298  uint16_t __export_name_ptr_table_0(KERNEL32:GetStringTypeW) = 0x156
0042a29a  char __import_name_0(KERNEL32:GetStringTypeW)[0xf] = "GetStringTypeW", 0

0042a2a9                             00                                                                             .

0042a2aa  uint16_t __export_name_ptr_table_0(KERNEL32:LoadLibraryA) = 0x1c2
0042a2ac  char __import_name_0(KERNEL32:LoadLibraryA)[0xd] = "LoadLibraryA", 0

0042a2b9                                                                             00                                             .

0042a2ba  uint16_t __export_name_ptr_table_0(KERNEL32:SetEndOfFile) = 0x261
0042a2bc  char __import_name_0(KERNEL32:SetEndOfFile)[0xd] = "SetEndOfFile", 0

0042a2c9                             00                                                                             .

0042a2ca  uint16_t __export_name_ptr_table_0(KERNEL32:CompareStringA) = 0x21
0042a2cc  char __import_name_0(KERNEL32:CompareStringA)[0xf] = "CompareStringA", 0

0042a2db                                                                                   00                                         .

0042a2dc  uint16_t __export_name_ptr_table_0(KERNEL32:CompareStringW) = 0x22
0042a2de  char __import_name_0(KERNEL32:CompareStringW)[0xf] = "CompareStringW", 0

0042a2ed                                         00                                                                     .

0042a2ee  uint16_t __export_name_ptr_table_0(KERNEL32:SetEnvironmentVariableA) = 0x262
0042a2f0  char __import_name_0(KERNEL32:SetEnvironmentVariableA)[0x18] = "SetEnvironmentVariableA", 0
0042a308  uint16_t __export_name_ptr_table_0(KERNEL32:GetFileAttributesA) = 0x10d
0042a30a  char __import_name_0(KERNEL32:GetFileAttributesA)[0x13] = "GetFileAttributesA", 0

0042a31d                                                                                         00                                     .
.rdata section ended  {0x429000-0x42a31e}

.data section started  {0x42b000-0x28249b8}
0042b000  data_42b000:
0042b000  00 00 00 00 00 00 00 00                                                                          ........
0042b008  data_42b008:
0042b008                          00 00 00 00                                                                      ....

0042b00c  void* data_42b00c = sub_41fead
0042b010  void* data_42b010 = sub_42472c

0042b014                                                              00 00 00 00                                              ....
0042b018  data_42b018:
0042b018                                                                          00 00 00 00                                      ....

0042b01c  void* data_42b01c = sub_41ff55

0042b020  00 00 00 00                                                                                      ....
0042b024  data_42b024:
0042b024              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............

0042b030  char data_42b030[0xe] = "AAS_MAX_AREAS", 0

0042b03e                                                                                            00 00                                ..

0042b040  char data_42b040[0x1e] = "face does not belong to area2", 0

0042b05e                                                                                            00 00                                ..

0042b060  char data_42b060[0x1e] = "face does not belong to area1", 0

0042b07e                                                                                            00 00                                ..

0042b080  char data_42b080[0x13] = "\r%6d areas merged\n", 0

0042b093                                                           00                                                         .

0042b094  char data_42b094[0x5] = "\r%6d", 0

0042b099                                                                             00 00 00                                       ...

0042b09c  char data_42b09c[0x11] = "%6d areas merged", 0

0042b0ad                                         00 00 00                                                               ...

0042b0b0  char data_42b0b0[0xf] = "AAS_MergeAreas", 0

0042b0bf                                                                                               00                                 .

0042b0c0  int32_t data_42b0c0 = 0x2

0042b0c4              02 00 00 00 00 00 00 00                                                                  ........
0042b0cc  data_42b0cc:
0042b0cc                                      00 00 80 c1 00 00 80 c1 00 00 c0 c1 00 00 80 41 00 00 80 41              ...............A...A
0042b0e0  00 00 00 42 04 00 00 00 01 00 00 00 00 00 80 c1 00 00 80 c1 00 00 c0 c1 00 00 80 41 00 00 80 41  ...B.......................A...A
0042b100  00 00 80 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ...@............................
0042b120  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042b140  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042b160  00 00 00 00                                                                                      ....

0042b164  int32_t data_42b164 = 0x6
0042b168  int32_t data_42b168 = 0x0
0042b16c  int32_t data_42b16c = 0x0
0042b170  int32_t data_42b170 = -0x40800000
0042b174  char data_42b174[0x6] = "333?)", 0

0042b17a                                                                                00 00                                        ..
0042b17c  data_42b17c:
0042b17c                                                                                      28 00 00 00                              (...
0042b180  2c 00 00 00                                                                                      ,...

0042b184  char data_42b184[0x14] = " of tmp AAS memory\n", 0
0042b198  char data_42b198[0xb] = "allocated ", 0

0042b1a3           00                                                                                         .

0042b1a4  char data_42b1a4[0x7] = "freed ", 0

0042b1ab                                   00                                                                         .

0042b1ac  char data_42b1ac[0x2d] = "AAS_AddFaceSideToArea: already a front area\n", 0

0042b1d9                                                                             00 00 00                                       ...

0042b1dc  char data_42b1dc[0x2c] = "AAS_AddFaceSideToArea: already a back area\n", 0
0042b208  char data_42b208[0x32] = "AAS_RemoveFaceFromArea: face not part of the area", 0

0042b23a                                                                                00 00                                        ..

0042b23c  char data_42b23c[0x2b] = "AAS_CheckArea: area %d face %d is flipped\n", 0

0042b267                       00                                                                                 .

0042b268  char data_42b268[0x1d] = "AAS_CheckArea: invalid area\n", 0

0042b285                 00 00 00                                                                               ...

0042b288  char data_42b288[0x34] = "area %d face %d winding plane unequal to face plane", 0
0042b2bc  char data_42b2bc[0x36] = "area %d face %d flipped: front area %d, back area %d\n", 0

0042b2f2                                                        00 00                                                        ..

0042b2f4  char data_42b2f4[0x1b] = "face %d has no front area\n", 0

0042b30f                                               00                                                                 .

0042b310  char data_42b310[0x18] = "area %d face %d is tiny", 0
0042b328  char data_42b328[0x14] = "AAS_RemoveTinyFaces", 0

0042b33c  data_42b33c:
0042b33c                                                                                      0a 00 00 00                              ....

0042b340  char data_42b340[0x21] = "%6d areas provided with settings", 0

0042b361     00 00 00                                                                                       ...

0042b364  char data_42b364[0x17] = "AAS_CreateAreaSettings", 0

0042b37b                                                                                   00                                         .

0042b37c  char data_42b37c[0xe] = "AAS_MAX_FACES", 0

0042b38a                                00 00                                                                        ..

0042b38c  char data_42b38c[0xe] = "AAS_MAX_NODES", 0

0042b39a                                                                                00 00                                        ..

0042b39c  char data_42b39c[0x20] = "BUG: didn\'t end with root node\n", 0
0042b3bc  char data_42b3bc[0x12] = "%6d areas created", 0

0042b3ce                                            00 00                                                                ..

0042b3d0  char data_42b3d0[0x16] = "AAS_CreateConvexAreas", 0

0042b3e6                    00 00                                                                                ..

0042b3e8  char data_42b3e8[0x41] = "face %d, planenum = %d, face->frontarea = %d face->backarea = %d", 0

0042b429                             00 00 00                                                                       ...

0042b42c  char data_42b42c[0x2d] = "---- tmp area %d and %d have %d shared faces", 0

0042b459                                                                             00 00 00                                       ...

0042b45c  char data_42b45c[0x2d] = "\r%6d areas checked for shared face flipping\n", 0

0042b489                             00 00 00                                                                       ...

0042b48c  char data_42b48c[0x2b] = "%6d areas checked for shared face flipping", 0

0042b4b7                                                                       00                                                 .

0042b4b8  char data_42b4b8[0x12] = "**** leaked ****\n", 0

0042b4ca                                00 00                                                                        ..

0042b4cc  char data_42b4cc[0x1f] = "\nAAS created in %5.0f seconds\n", 0

0042b4eb                                   00                                                                         .

0042b4ec  char data_42b4ec[0x23] = "BSP tree created in %5.0f seconds\n", 0

0042b50f                                               00                                                                 .

0042b510  char data_42b510[0x19] = "face2 %d without winding", 0

0042b529                             00 00 00                                                                       ...

0042b52c  char data_42b52c[0x19] = "face1 %d without winding", 0

0042b545                 00 00 00                                                                               ...

0042b548  char data_42b548[0x13] = "\r%6d edges melted\n", 0

0042b55b                                                                                   00                                         .

0042b55c  char data_42b55c[0x11] = "%6d edges melted", 0

0042b56d                                         00 00 00                                                               ...

0042b570  char data_42b570[0x19] = "AAS_MeltAreaFaceWindings", 0

0042b589                             00 00 00                                                                       ...

0042b58c  char data_42b58c[0x3c] = "face %d and %d, same front and back area but flipped planes", 0
0042b5c8  char data_42b5c8[0x12] = "\r%6d face merges\n", 0

0042b5da                                                                                00 00                                        ..

0042b5dc  char data_42b5dc[0x10] = "%6d face merges", 0
0042b5ec  char data_42b5ec[0x13] = "AAS_MergeAreaFaces", 0

0042b5ff                                                                                               00                                 .

0042b600  char data_42b600[0xf] = "can\'t open %s\n", 0

0042b60f                                               00                                                                 .
0042b610  data_42b610:
0042b610                                                  72 62 00 00                                                      rb..

0042b614  char data_42b614[0x17] = "error writing lump %s\n", 0

0042b62b                                   00                                                                         .

0042b62c  char data_42b62c[0x12] = "error opening %s\n", 0

0042b63e                                                                                            00 00                                ..
0042b640  data_42b640:
0042b640  77 62 00 00                                                                                      wb..

0042b644  char data_42b644[0xc] = "writing %s\n", 0
0042b650  char data_42b650[0x1e] = "AAS_SplitFace: tiny back face", 0

0042b66e                                            00 00                                                                ..

0042b670  char data_42b670[0x32] = "AAS_TestSplitPlane: tried face plane as splitter\n", 0

0042b6a2        00 00                                                                                        ..

0042b6a4  char data_42b6a4[0x28] = "AAS_SplitArea: back area without faces\n", 0
0042b6cc  char data_42b6cc[0x29] = "AAS_SplitArea: front area without faces\n", 0

0042b6f5                                                                 00 00 00                                               ...

0042b6f8  char data_42b6f8[0x38] = "AAS_SplitArea: no split winding when splitting area %d\n", 0
0042b730  char data_42b730[0x2f] = "found %d epsilon faces trying to split area %d", 0

0042b75f                                                                                               00                                 .

0042b760  char data_42b760[0x24] = "gsubdiv: area %d has a tiny winding", 0
0042b784  char data_42b784[0x1f] = "%6i gravitational subdivisions", 0

0042b7a3           00                                                                                         .

0042b7a4  char data_42b7a4[0x1d] = "AAS_GravitationalSubdivision", 0

0042b7c1     00 00 00                                                                                       ...

0042b7c4  char data_42b7c4[0x18] = "%6i ladder subdivisions", 0
0042b7dc  char data_42b7dc[0x16] = "AAS_LadderSubdivision", 0

0042b7f2                                                        00 00                                                        ..

0042b7f4  char data_42b7f4[0x17] = "MAX_MAPFILE_BRUSHSIDES", 0

0042b80b                                   00                                                                         .

0042b80c  char data_42b80c[0x30] = "entity %i, brush %i: no visible sides on brush\n", 0
0042b83c  char data_42b83c[0x11] = "non convex brush", 0

0042b84d                                         00 00 00                                                               ...

0042b850  char data_42b850[0x26] = "ob->mins[%d] = %f, ob->maxs[%d] = %f\n", 0

0042b876                                                                    00 00                                                ..

0042b878  char data_42b878[0x2a] = "entity %i, brush %i: bounds out of range\n", 0

0042b8a2        00 00                                                                                        ..

0042b8a4  char data_42b8a4[0x14] = "MAX_MAPFILE_BRUSHES", 0
0042b8b8  char data_42b8b8[0xb] = "targetname", 0

0042b8c3           00                                                                                         .

0042b8c4  char data_42b8c4[0xf] = "trigger_always", 0

0042b8d3                                                           00                                                         .

0042b8d4  char data_42b8d4[0xa] = "classname", 0

0042b8de                                                                                            00 00                                ..

0042b8e0  char data_42b8e0[0xb] = "spawnflags", 0

0042b8eb                                   00                                                                         .

0042b8ec  char data_42b8ec[0x7] = "target", 0

0042b8f3                                                           00                                                         .

0042b8f4  char data_42b8f4[0x13] = "func_door_rotating", 0

0042b907                       00                                                                                 .

0042b908  char data_42b908[0xa] = "func_wall", 0

0042b912                                                        00 00                                                        ..

0042b914  char data_42b914[0x7] = "angles", 0

0042b91b                                                                                   00                                         .

0042b91c  char data_42b91c[0x9] = "distance", 0

0042b925                 00 00 00                                                                               ...

0042b928  char data_42b928[0x12] = "%6d nodes pruned\n", 0

0042b93a                                                                                00 00                                        ..

0042b93c  char data_42b93c[0xf] = "AAS_PruneNodes", 0

0042b94b                                   00                                                                         .

0042b94c  char data_42b94c[0x10] = " of AAS memory\n", 0
0042b95c  char data_42b95c[0x2c] = "HashVec: point %f %f %f outside valid range", 0
0042b988  char data_42b988[0x16] = "AAS_MAX_VERTEXES = %d", 0

0042b99e                                                                                            00 00                                ..

0042b9a0  char data_42b9a0[0x13] = "AAS_MAX_EDGES = %d", 0

0042b9b3                                                           00                                                         .

0042b9b4  char data_42b9b4[0x14] = "AAS_MAX_PLANES = %d", 0
0042b9c8  char data_42b9c8[0x1e] = "AAS_GetFace: face %d was tiny", 0

0042b9e6                    00 00                                                                                ..

0042b9e8  char data_42b9e8[0x2f] = "AAS_GetFace: face %d had degenerate edge %d-%d", 0

0042ba17                                                                       00                                                 .

0042ba18  char data_42ba18[0x1b] = "AAS_MAX_EDGEINDEXSIZE = %d", 0

0042ba33                                                           00                                                         .

0042ba34  char data_42ba34[0x13] = "AAS_MAX_FACES = %d", 0

0042ba47                       00                                                                                 .

0042ba48  char data_42ba48[0x1b] = "AAS_MAX_FACEINDEXSIZE = %d", 0

0042ba63           00                                                                                         .

0042ba64  char data_42ba64[0x2b] = "AAS_CreateTree_r: face number out of range", 0

0042ba8f                                               00                                                                 .

0042ba90  char data_42ba90[0x13] = "AAS_MAX_AREAS = %d", 0

0042baa3           00                                                                                         .

0042baa4  char data_42baa4[0x2b] = "AAS_StoreArea: tried to store invalid area", 0

0042bacf                                               00                                                                 .

0042bad0  char data_42bad0[0x13] = "AAS_MAX_NODES = %d", 0

0042bae3           00                                                                                         .

0042bae4  char data_42bae4[0x1c] = "more than %d bounding boxes", 0
0042bb00  char data_42bb00[0x12] = "error writing %s\n", 0

0042bb12                                                        00 00                                                        ..

0042bb14  char data_42bb14[0x1b] = "BUG: didn\'t end with root\n", 0

0042bb2f                                               00                                                                 .

0042bb30  char data_42bb30[0x11] = "%6d areas stored", 0

0042bb41     00 00 00                                                                                       ...

0042bb44  char data_42bb44[0xe] = "AAS_StoreFile", 0

0042bb52                                                        00 00 00 00 00 00 01 00 00 00                                ..........

0042bb5c  char (* data_42bb5c)[0xf] = data_42bde4 {"CONTENTS_SOLID"}

0042bb60  02 00 00 00                                                                                      ....

0042bb64  char (* data_42bb64)[0x10] = data_42bdd4 {"CONTENTS_WINDOW"}

0042bb68                          04 00 00 00                                                                      ....

0042bb6c  char (* data_42bb6c)[0xd] = data_42bdc4 {"CONTENTS_AUX"}

0042bb70                                                  08 00 00 00                                                      ....

0042bb74  char (* data_42bb74)[0xe] = data_42bdb4 {"CONTENTS_LAVA"}

0042bb78                                                                          10 00 00 00                                      ....

0042bb7c  char (* data_42bb7c)[0xf] = data_42bda4 {"CONTENTS_SLIME"}

0042bb80  20 00 00 00                                                                                       ...

0042bb84  char (* data_42bb84)[0xf] = data_42bd94 {"CONTENTS_WATER"}

0042bb88                          40 00 00 00                                                                      @...

0042bb8c  char (* data_42bb8c)[0xe] = data_42bd84 {"CONTENTS_MIST"}

0042bb90                                                  40 00 00 00                                                      @...

0042bb94  char (* data_42bb94)[0x16] = data_42bd6c {"LAST_VISIBLE_CONTENTS"}

0042bb98                                                                          00 10 00 00                                      ....

0042bb9c  char (* data_42bb9c)[0x14] = data_42bd58 {"CONTENTS_DUMMYFENCE"}

0042bba0  00 80 00 00                                                                                      ....

0042bba4  char (* data_42bba4)[0x14] = data_42bd44 {"CONTENTS_AREAPORTAL"}

0042bba8                          00 00 01 00                                                                      ....

0042bbac  char (* data_42bbac)[0x14] = data_42bd30 {"CONTENTS_PLAYERCLIP"}

0042bbb0                                                  00 00 02 00                                                      ....

0042bbb4  char (* data_42bbb4)[0x15] = data_42bd18 {"CONTENTS_MONSTERCLIP"}

0042bbb8                                                                          00 00 04 00                                      ....

0042bbbc  char (* data_42bbbc)[0x13] = data_42bd04 {"CONTENTS_CURRENT_0"}

0042bbc0  00 00 08 00                                                                                      ....

0042bbc4  char (* data_42bbc4)[0x14] = data_42bcf0 {"CONTENTS_CURRENT_90"}

0042bbc8                          00 00 10 00                                                                      ....

0042bbcc  char (* data_42bbcc)[0x15] = data_42bcd8 {"CONTENTS_CURRENT_180"}

0042bbd0                                                  00 00 20 00                                                      .. .

0042bbd4  char (* data_42bbd4)[0x15] = data_42bcc0 {"CONTENTS_CURRENT_270"}

0042bbd8                                                                          00 00 40 00                                      ..@.

0042bbdc  char (* data_42bbdc)[0x14] = data_42bcac {"CONTENTS_CURRENT_UP"}

0042bbe0  00 00 80 00                                                                                      ....

0042bbe4  char (* data_42bbe4)[0x16] = data_42bc94 {"CONTENTS_CURRENT_DOWN"}

0042bbe8                          00 00 00 01                                                                      ....

0042bbec  char (* data_42bbec)[0x10] = data_42bc84 {"CONTENTS_ORIGIN"}

0042bbf0                                                  00 00 00 02                                                      ....

0042bbf4  char (* data_42bbf4)[0x11] = data_42bc70 {"CONTENTS_MONSTER"}

0042bbf8                                                                          00 00 00 04                                      ....

0042bbfc  char (* data_42bbfc)[0x15] = data_42bc58 {"CONTENTS_DEADMONSTER"}

0042bc00  00 00 00 08                                                                                      ....

0042bc04  char (* data_42bc04)[0x10] = data_42bc48 {"CONTENTS_DETAIL"}

0042bc08                          00 00 00 10                                                                      ....

0042bc0c  char (* data_42bc0c)[0x15] = data_42bc30 {"CONTENTS_TRANSLUCENT"}

0042bc10                                                  00 00 00 20                                                      ... 

0042bc14  char (* data_42bc14)[0x10] = data_42bc20 {"CONTENTS_LADDER"}

0042bc18                                                                          00 00 00 00 00 00 00 00                          ........

0042bc20  char data_42bc20[0x10] = "CONTENTS_LADDER", 0
0042bc30  char data_42bc30[0x15] = "CONTENTS_TRANSLUCENT", 0

0042bc45                 00 00 00                                                                               ...

0042bc48  char data_42bc48[0x10] = "CONTENTS_DETAIL", 0
0042bc58  char data_42bc58[0x15] = "CONTENTS_DEADMONSTER", 0

0042bc6d                                         00 00 00                                                               ...

0042bc70  char data_42bc70[0x11] = "CONTENTS_MONSTER", 0

0042bc81     00 00 00                                                                                       ...

0042bc84  char data_42bc84[0x10] = "CONTENTS_ORIGIN", 0
0042bc94  char data_42bc94[0x16] = "CONTENTS_CURRENT_DOWN", 0

0042bcaa                                00 00                                                                        ..

0042bcac  char data_42bcac[0x14] = "CONTENTS_CURRENT_UP", 0
0042bcc0  char data_42bcc0[0x15] = "CONTENTS_CURRENT_270", 0

0042bcd5                                                                 00 00 00                                               ...

0042bcd8  char data_42bcd8[0x15] = "CONTENTS_CURRENT_180", 0

0042bced                                         00 00 00                                                               ...

0042bcf0  char data_42bcf0[0x14] = "CONTENTS_CURRENT_90", 0
0042bd04  char data_42bd04[0x13] = "CONTENTS_CURRENT_0", 0

0042bd17                                                                       00                                                 .

0042bd18  char data_42bd18[0x15] = "CONTENTS_MONSTERCLIP", 0

0042bd2d                                         00 00 00                                                               ...

0042bd30  char data_42bd30[0x14] = "CONTENTS_PLAYERCLIP", 0
0042bd44  char data_42bd44[0x14] = "CONTENTS_AREAPORTAL", 0
0042bd58  char data_42bd58[0x14] = "CONTENTS_DUMMYFENCE", 0
0042bd6c  char data_42bd6c[0x16] = "LAST_VISIBLE_CONTENTS", 0

0042bd82        00 00                                                                                        ..

0042bd84  char data_42bd84[0xe] = "CONTENTS_MIST", 0

0042bd92                                                        00 00                                                        ..

0042bd94  char data_42bd94[0xf] = "CONTENTS_WATER", 0

0042bda3           00                                                                                         .

0042bda4  char data_42bda4[0xf] = "CONTENTS_SLIME", 0

0042bdb3                                                           00                                                         .

0042bdb4  char data_42bdb4[0xe] = "CONTENTS_LAVA", 0

0042bdc2        00 00                                                                                        ..

0042bdc4  char data_42bdc4[0xd] = "CONTENTS_AUX", 0

0042bdd1                                                     00 00 00                                                       ...

0042bdd4  char data_42bdd4[0x10] = "CONTENTS_WINDOW", 0
0042bde4  char data_42bde4[0xf] = "CONTENTS_SOLID", 0

0042bdf3                                                           00                                                         .

0042bdf4  char data_42bdf4[0xd] = "bad planenum", 0

0042be01     00 00 00                                                                                       ...

0042be04  char data_42be04[0xd] = "Tried parent", 0

0042be11                                                     00 00 00                                                       ...

0042be14  char data_42be14[0x19] = "PSIDE_FACING with splits", 0

0042be2d                                         00 00 00                                                               ...

0042be30  char data_42be30[0x18] = "split not on both sides", 0
0042be48  char data_42be48[0x14] = "split removed brush", 0
0042be5c  char data_42be5c[0x17] = "tiny volume after clip", 0

0042be73                                                           00                                                         .

0042be74  char data_42be74[0x17] = "bogus brush after clip", 0

0042be8b                                   00                                                                         .

0042be8c  char data_42be8c[0x17] = "WARNING: huge winding\n", 0

0042bea3           00                                                                                         .

0042bea4  char data_42bea4[0x1b] = "child without volume brush", 0

0042bebf                                                                                               00                                 .

0042bec0  char data_42bec0[0xb] = "%6d splits", 0

0042becb                                   00                                                                         .

0042becc  char data_42becc[0x1a] = "depth first bsp building\n", 0

0042bee6                    00 00                                                                                ..

0042bee8  char data_42bee8[0x1b] = "breath first bsp building\n", 0

0042bf03           00                                                                                         .

0042bf04  char data_42bf04[0x11] = "%6d threads max\n", 0

0042bf15                                                                 00 00 00                                               ...

0042bf18  char data_42bf18[0x21] = "%6i KB of peak total bsp memory\n", 0

0042bf39                                                                             00 00 00                                       ...

0042bf3c  char data_42bf3c[0x1f] = "%6i KB of peak winding memory\n", 0

0042bf5b                                                                                   00                                         .

0042bf5c  char data_42bf5c[0x1d] = "%6i KB of peak brush memory\n", 0

0042bf79                                                                             00 00 00                                       ...

0042bf7c  char data_42bf7c[0x17] = "%6i KB of node memory\n", 0

0042bf93                                                           00                                                         .

0042bf94  char data_42bf94[0xd] = "\r%6d splits\n", 0

0042bfa1     00 00 00                                                                                       ...

0042bfa4  char data_42bfa4[0x11] = "%6i total sides\n", 0

0042bfb5                                                                 00 00 00                                               ...

0042bfb8  char data_42bfb8[0x16] = "%6i nonvisible faces\n", 0

0042bfce                                            00 00                                                                ..

0042bfd0  char data_42bfd0[0x13] = "%6i visible faces\n", 0

0042bfe3           00                                                                                         .

0042bfe4  char data_42bfe4[0xd] = "%6i brushes\n", 0

0042bff1                                                     00 00 00                                                       ...

0042bff4  char data_42bff4[0x2a] = "WARNING: entity %i, brush %i: microbrush\n", 0

0042c01e                                                                                            00 00                                ..

0042c020  char data_42c020[0x1e] = "-------- Brush BSP ---------\n", 0

0042c03e                                                                                            00 00                                ..

0042c040  int32_t data_42c040 = 0x3f800000
0042c044  int32_t data_42c044 = 0x1
0042c048  char data_42c048[0x14] = "--- MAP LEAKED ---\n", 0
0042c05c  char data_42c05c[0x2a] = "############### model %i ###############\n", 0

0042c086                    00 00                                                                                ..

0042c088  char data_42c088[0x17] = "%5.0f seconds elapsed\n", 0

0042c09f                                                                                               00                                 .

0042c0a0  char data_42c0a0[0x5] = ".map", 0

0042c0a5                 00 00 00                                                                               ...

0042c0a8  char data_42c0a8[0x7] = "%s.lin", 0

0042c0af                                               00                                                                 .

0042c0b0  char data_42c0b0[0x7] = "%s.prt", 0

0042c0b7                                                                       00                                                 .

0042c0b8  char data_42c0b8[0x7] = "%s.bsp", 0

0042c0bf                                                                                               00                                 .

0042c0c0  char data_42c0c0[0xc0] = "Usage:   bspc [-<switch> [-<switch> ...]]\n"
0042c0c0      "Example 1: bspc -bsp2aas znt2dm?.bsp -output e:\\quake2\\gladiator\n"
0042c0c0      "Example 2: bspc -bsp2aas pak1.pak\\maps/q2dm*.bsp -output e:\\quake2\\gladiator\n\n"
0042c0c0      "Switche"

0042c180  73 3a 0a 20 20 20 6d 61 70 32 62 73 70 20 3c 5b 70 61 6b 66 69 6c 65 66 69 6c 74 65 72 2f 5d 66  s:.   map2bsp <[pakfilefilter/]f
0042c1a0  69 6c 65 66 69 6c 74 65 72 3e 20 3d 20 63 6f 6e 76 65 72 74 20 4d 41 50 20 74 6f 20 42 53 50 0a  ilefilter> = convert MAP to BSP.
0042c1c0  20 20 20 6d 61 70 32 61 61 73 20 3c 5b 70 61 6b 66 69 6c 65 66 69 6c 74 65 72 2f 5d 66 69 6c 65     map2aas <[pakfilefilter/]file
0042c1e0  66 69 6c 74 65 72 3e 20 3d 20 63 6f 6e 76 65 72 74 20 4d 41 50 20 74 6f 20 41 41 53 0a 20 20 20  filter> = convert MAP to AAS.   
0042c200  62 73 70 32 6d 61 70 20 3c 5b 70 61 6b 66 69 6c 65 66 69 6c 74 65 72 2f 5d 66 69 6c 65 66 69 6c  bsp2map <[pakfilefilter/]filefil
0042c220  74 65 72 3e 20 3d 20 63 6f 6e 76 65 72 74 20 42 53 50 20 74 6f 20 4d 41 50 0a 20 20 20 62 73 70  ter> = convert BSP to MAP.   bsp
0042c240  32 62 73 70 20 3c 5b 70 61 6b 66 69 6c 65 66 69 6c 74 65 72 2f 5d 66 69 6c 65 66 69 6c 74 65 72  2bsp <[pakfilefilter/]filefilter
0042c260  3e 20 3d 20 63 6f 6e 76 65 72 74 20 42 53 50 20 74 6f 20 42 53 50 0a 20 20 20 62 73 70 32 61 61  > = convert BSP to BSP.   bsp2aa
0042c280  73 20 3c 5b 70 61 6b 66 69 6c 65 66 69 6c 74 65 72 2f 5d 66 69 6c 65 66 69 6c 74 65 72 3e 20 3d  s <[pakfilefilter/]filefilter> =
0042c2a0  20 63 6f 6e 76 65 72 74 20 42 53 50 20 74 6f 20 41 41 53 0a 20 20 20 6f 75 74 70 75 74 20 3c 6f   convert BSP to AAS.   output <o
0042c2c0  75 74 70 75 74 20 70 61 74 68 3e 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 3d 20 73 65  utput path>                 = se
0042c2e0  74 20 6f 75 74 70 75 74 20 70 61 74 68 0a 20 20 20 6e 6f 76 65 72 62 6f 73 65 20 20 20 20 20 20  t output path.   noverbose      
0042c300  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 3d 20 64 69 73 61 62 6c 65 20                        = disable 
0042c320  76 65 72 62 6f 73 65 20 6f 75 74 70 75 74 0a 20 20 20 74 68 72 65 61 64 73 20 20 20 20 20 20 20  verbose output.   threads       
0042c340  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 3d 20 6e 75 6d 62 65 72 20                         = number 
0042c360  6f 66 20 74 68 72 65 61 64 73 20 74 6f 20 75 73 65 0a 20 20 20 62 72 65 61 74 68 20 20 20 20 20  of threads to use.   breath     
0042c380  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 3d 20 62 72 65 61                            = brea
0042c3a0  74 68 20 66 69 72 73 74 20 62 73 70 20 62 75 69 6c 64 69 6e 67 0a 20 20 20 6e 6f 62 72 75 73 68  th first bsp building.   nobrush
0042c3c0  6d 65 72 67 65 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 3d 20  merge                         = 
0042c3e0  64 6f 6e 27 74 20 6d 65 72 67 65 20 62 72 75 73 68 65 73 0a 20 20 20 6e 6f 6c 69 71 75 69 64 73  don't merge brushes.   noliquids
0042c400  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 3d 20 64 6f                              = do
0042c420  6e 27 74 20 77 72 69 74 65 20 6c 69 71 75 69 64 73 20 74 6f 20 6d 61 70 0a 20 20 20 66 72 65 65  n't write liquids to map.   free
0042c440  74 72 65 65 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20  tree                            
0042c460  20 3d 20 66 72 65 65 20 74 68 65 20 62 73 70 20 74 72 65 65 0a 20 20 20 6e 6f 63 73 67 20 20 20   = free the bsp tree.   nocsg   
0042c480  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 3d 20 64                               = d
0042c4a0  69 73 61 62 6c 65 73 20 62 72 75 73 68 20 63 68 6f 70 70 69 6e 67 0a 0a 00 00 00 00              isables brush chopping......

0042c4bc  char data_42c4bc[0x17] = "don\'t know what to do\n", 0

0042c4d3                                                           00                                                         .

0042c4d4  char data_42c4d4[0x13] = "bsp2aas: %s to %s\n", 0

0042c4e7                       00                                                                                 .

0042c4e8  char data_42c4e8[0x13] = "bsp2bsp: %s to %s\n", 0

0042c4fb                                                                                   00                                         .

0042c4fc  char data_42c4fc[0x1f] = "%s is probably not a BSP file\n", 0

0042c51b                                                                                   00                                         .

0042c51c  char data_42c51c[0x13] = "bsp2map: %s to %s\n", 0

0042c52f                                               00                                                                 .

0042c530  char data_42c530[0x13] = "map2aas: %s to %s\n", 0

0042c543           00                                                                                         .

0042c544  char data_42c544[0x5] = ".aas", 0

0042c549                             00 00 00                                                                       ...

0042c54c  char data_42c54c[0x1f] = "%s is probably not a MAP file\n", 0

0042c56b                                   00                                                                         .

0042c56c  char data_42c56c[0x13] = "map2bsp: %s to %s\n", 0

0042c57f                                                                                               00                                 .

0042c580  char data_42c580[0x5] = ".bsp", 0

0042c585                 00 00 00                                                                               ...

0042c588  char data_42c588[0x10] = "no files found\n", 0
0042c598  char data_42c598[0x16] = "unknows parameter %s\n", 0

0042c5ae                                            00 00                                                                ..

0042c5b0  char data_42c5b0[0xd] = "map2bsp: %s\n", 0

0042c5bd                                                                                         00 00 00                               ...

0042c5c0  char data_42c5c0[0x9] = "-bsp2aas", 0

0042c5c9                             00 00 00                                                                       ...

0042c5cc  char data_42c5cc[0x9] = "-bsp2bsp", 0

0042c5d5                                                                 00 00 00                                               ...

0042c5d8  char data_42c5d8[0x9] = "-bsp2map", 0

0042c5e1     00 00 00                                                                                       ...

0042c5e4  char data_42c5e4[0x9] = "-map2aas", 0

0042c5ed                                         00 00 00                                                               ...

0042c5f0  char data_42c5f0[0x9] = "-map2bsp", 0

0042c5f9                                                                             00 00 00                                       ...

0042c5fc  char data_42c5fc[0x14] = "breathfirst = true\n", 0
0042c610  char data_42c610[0xd] = "-breathfirst", 0

0042c61d                                                                                         00 00 00                               ...

0042c620  char data_42c620[0x1d] = "the folder %s does not exist", 0

0042c63d                                                                                         00 00 00                               ...

0042c640  char data_42c640[0x8] = "-output", 0
0042c648  char data_42c648[0x12] = "noliquids = true\n", 0

0042c65a                                                                                00 00                                        ..

0042c65c  char data_42c65c[0xb] = "-noliquids", 0

0042c667                       00                                                                                 .

0042c668  char data_42c668[0x15] = "nobrushmerge = true\n", 0

0042c67d                                                                                         00 00 00                               ...

0042c680  char data_42c680[0xe] = "-nobrushmerge", 0

0042c68e                                            00 00                                                                ..

0042c690  char data_42c690[0x11] = "freetree = true\n", 0

0042c6a1     00 00 00                                                                                       ...

0042c6a4  char data_42c6a4[0xa] = "-freetree", 0

0042c6ae                                            00 00                                                                ..

0042c6b0  char data_42c6b0[0xd] = "temp output\n", 0

0042c6bd                                                                                         00 00 00                               ...

0042c6c0  char data_42c6c0[0x5] = "/tmp", 0

0042c6c5                 00 00 00                                                                               ...

0042c6c8  char data_42c6c8[0x8] = "-tmpout", 0
0042c6d0  char data_42c6d0[0x15] = "subdivide_size = %f\n", 0

0042c6e5                 00 00 00                                                                               ...

0042c6e8  char data_42c6e8[0x6] = "-chop", 0

0042c6ee                                            00 00                                                                ..

0042c6f0  char data_42c6f0[0x18] = "verboseentities = true\n", 0
0042c708  char data_42c708[0x11] = "-verboseentities", 0

0042c719                                                                             00 00 00                                       ...

0042c71c  char data_42c71c[0x11] = "leaktest = true\n", 0

0042c72d                                         00 00 00                                                               ...

0042c730  char data_42c730[0xa] = "-leaktest", 0

0042c73a                                                                                00 00                                        ..

0042c73c  char data_42c73c[0x12] = "microvolume = %f\n", 0

0042c74e                                            00 00                                                                ..

0042c750  char data_42c750[0x7] = "-micro", 0

0042c757                                                                       00                                                 .

0042c758  char data_42c758[0x11] = "onlyents = true\n", 0

0042c769                             00 00 00                                                                       ...

0042c76c  char data_42c76c[0xa] = "-onlyents", 0

0042c776                                                                    00 00                                                ..

0042c778  char data_42c778[0x13] = "fulldetail = true\n", 0

0042c78b                                   00                                                                         .

0042c78c  char data_42c78c[0xc] = "-fulldetail", 0
0042c798  char data_42c798[0x11] = "nodetail = true\n", 0

0042c7a9                             00 00 00                                                                       ...

0042c7ac  char data_42c7ac[0xa] = "-nodetail", 0

0042c7b6                                                                    00 00                                                ..

0042c7b8  char data_42c7b8[0x11] = "nosubdiv = true\n", 0

0042c7c9                             00 00 00                                                                       ...

0042c7cc  char data_42c7cc[0xa] = "-nosubdiv", 0

0042c7d6                                                                    00 00                                                ..

0042c7d8  char data_42c7d8[0x10] = "nomerge = true\n", 0
0042c7e8  char data_42c7e8[0x9] = "-nomerge", 0

0042c7f1                                                     00 00 00                                                       ...

0042c7f4  char data_42c7f4[0x10] = "noprune = true\n", 0
0042c804  char data_42c804[0x9] = "-noprune", 0

0042c80d                                         00 00 00                                                               ...

0042c810  char data_42c810[0xf] = "noopt = false\n", 0

0042c81f                                                                                               00                                 .

0042c820  char data_42c820[0xa] = "-optimize", 0

0042c82a                                00 00                                                                        ..

0042c82c  char data_42c82c[0x10] = "nowater = true\n", 0
0042c83c  char data_42c83c[0x9] = "-nowater", 0

0042c845                 00 00 00                                                                               ...

0042c848  char data_42c848[0x10] = "notjunc = true\n", 0
0042c858  char data_42c858[0x9] = "-notjunc", 0

0042c861     00 00 00                                                                                       ...

0042c864  char data_42c864[0x10] = "noshare = true\n", 0
0042c874  char data_42c874[0x9] = "-noshare", 0

0042c87d                                                                                         00 00 00                               ...

0042c880  char data_42c880[0xe] = "nocsg = true\n", 0

0042c88e                                            00 00                                                                ..

0042c890  char data_42c890[0x7] = "-nocsg", 0

0042c897                                                                       00                                                 .

0042c898  char data_42c898[0xf] = "noweld = true\n", 0

0042c8a7                       00                                                                                 .

0042c8a8  char data_42c8a8[0x8] = "-noweld", 0
0042c8b0  char data_42c8b0[0x11] = "drawflag = true\n", 0

0042c8c1     00 00 00                                                                                       ...

0042c8c4  char data_42c8c4[0x6] = "-draw", 0

0042c8ca                                00 00                                                                        ..

0042c8cc  char data_42c8cc[0x11] = "verbose = false\n", 0

0042c8dd                                                                                         00 00 00                               ...

0042c8e0  char data_42c8e0[0xb] = "-noverbose", 0

0042c8eb                                   00                                                                         .

0042c8ec  char data_42c8ec[0x8] = "-glview", 0
0042c8f4  char data_42c8f4[0xe] = "threads = %d\n", 0

0042c902        00 00                                                                                        ..

0042c904  char data_42c904[0x9] = "-threads", 0

0042c90d                                         00 00 00                                                               ...

0042c910  char data_42c910[0x27] = "BSPC version 1.2, %s %s by Mr Elusive\n", 0

0042c937                                                                       00                                                 .

0042c938  char data_42c938[0xc] = "May 20 1999", 0
0042c944  char data_42c944[0x9] = "13:46:31", 0

0042c94d                                         00 00 00                                                               ...

0042c950  char data_42c950[0x9] = "bspc.log", 0

0042c959                                                                             00 00 00                                       ...

0042c95c  char data_42c95c[0x8] = "unknown", 0
0042c964  char data_42c964[0x1c] = "brush: bounds out of range\n", 0
0042c980  char data_42c980[0x22] = "brush: no visible sides on brush\n", 0

0042c9a2        00 00                                                                                        ..

0042c9a4  char data_42c9a4[0x17] = "brush duplicate plane\n", 0

0042c9bb                                                                                   00                                         .

0042c9bc  char data_42c9bc[0x5] = "\r%5d", 0

0042c9c1     00 00 00                                                                                       ...

0042c9c4  char data_42c9c4[0x13] = "%5d brushes merged", 0

0042c9d7                                                                       00                                                 .
0042c9d8  data_42c9d8:
0042c9d8                                                                          7d 0a 00 00                                      }...
0042c9dc  data_42c9dc:
0042c9dc                                                                                      7b 0a 00 00                              {...

0042c9e0  char data_42c9e0[0x15] = "\r%6d output brushes\n", 0

0042c9f5                                                                 00 00 00                                               ...

0042c9f8  char data_42c9f8[0x13] = "%6d output brushes", 0

0042ca0b                                   00                                                                         .

0042ca0c  char data_42ca0c[0x16] = "%6d original brushes\n", 0

0042ca22        00 00                                                                                        ..

0042ca24  char data_42ca24[0x1e] = "-------- Brush CSG ---------\n", 0

0042ca42        00 00                                                                                        ..

0042ca44  int32_t data_42ca44 = 0x1
0042ca48  int32_t data_42ca48 = 0x43700000
0042ca4c  char data_42ca4c[0x23] = "HashVec: point outside valid range", 0

0042ca6f                                               00                                                                 .

0042ca70  char data_42ca70[0x1d] = "numvertexes == MAX_MAP_VERTS", 0

0042ca8d                                         00 00 00                                                               ...

0042ca90  char data_42ca90[0xe] = "MAX_MAP_VERTS", 0

0042ca9e                                                                                            00 00                                ..

0042caa0  char data_42caa0[0xf] = "MAX_SUPERVERTS", 0

0042caaf                                               00                                                                 .

0042cab0  char data_42cab0[0x15] = "%5i bad start verts\n", 0

0042cac5                 00 00 00                                                                               ...

0042cac8  char data_42cac8[0x1f] = "%5i faces added by tjunctions\n", 0

0042cae7                       00                                                                                 .

0042cae8  char data_42cae8[0x1f] = "%5i edges added by tjunctions\n", 0

0042cb07                       00                                                                                 .

0042cb08  char data_42cb08[0x17] = "%5i faces degenerated\n", 0

0042cb1f                                                                                               00                                 .

0042cb20  char data_42cb20[0x17] = "%5i edges degenerated\n", 0

0042cb37                                                                       00                                                 .

0042cb38  char data_42cb38[0x11] = "---- tjunc ----\n", 0

0042cb49                             00 00 00                                                                       ...

0042cb4c  char data_42cb4c[0x13] = "%i unique from %i\n", 0

0042cb5f                                                                                               00                                 .

0042cb60  char data_42cb60[0x16] = "---- snap verts ----\n", 0

0042cb76                                                                    00 00                                                ..

0042cb78  char data_42cb78[0x1a] = "numedges == MAX_MAP_EDGES", 0

0042cb92                                                        00 00                                                        ..

0042cb94  char data_42cb94[0x28] = "SubdivideFace: didn\'t split the polygon", 0
0042cbbc  char data_42cbbc[0x10] = "%5i subdivided\n", 0
0042cbcc  char data_42cbcc[0xc] = "%5i merged\n", 0
0042cbd8  char data_42cbd8[0xf] = "%5i makefaces\n", 0

0042cbe7                       00                                                                                 .

0042cbe8  char data_42cbe8[0x13] = "--- MakeFaces ---\n", 0

0042cbfb                                                                                   00 80 00 00 00                             .....
0042cc00  data_42cc00:
0042cc00  25 69 0a 00                                                                                      %i..
0042cc04  data_42cc04:
0042cc04              77 00 00 00                                                                              w...

0042cc08  char data_42cc08[0x10] = " of BSP memory\n", 0
0042cc18  char data_42cc18[0x1e] = "HL_LoadBSPFile: odd lump size", 0

0042cc36                                                                    00 00                                                ..

0042cc38  char data_42cc38[0x19] = "%s is version %i, not %i", 0

0042cc51                                                     00 00 00                                                       ...

0042cc54  char data_42cc54[0x14] = "*Half-Life bsp file", 0
0042cc68  char data_42cc68[0x15] = "Entity text too long", 0

0042cc7d                                                                                         00 00 00                               ...

0042cc80  char data_42cc80[0xb] = "\"%s\" \"%s\"\n", 0

0042cc8b                                   00                                                                         .

0042cc8c  char data_42cc8c[0x1e] = "Q1_LoadBSPFile: odd lump size", 0

0042ccaa                                00 00                                                                        ..

0042ccac  char data_42ccac[0x11] = "*Quake1 bsp file", 0

0042ccbd                                                                                         00 00 00                               ...

0042ccc0  char data_42ccc0[0x44] = "Q2_LoadBSPFile: exceeded max size for lump %d size %d > maxsize %d\n", 0
0042cd04  char data_42cd04[0x1b] = "LoadBSPFile: odd lump size", 0

0042cd1f                                                                                               00                                 .

0042cd20  char data_42cd20[0x16] = "%s is not a IBSP file", 0

0042cd36                                                                    00 00                                                ..

0042cd38  char data_42cd38[0x1e] = "ParseEpair: token %s too long", 0

0042cd56                                                                    00 00                                                ..
0042cd58  data_42cd58:
0042cd58                                                                          7d 00 00 00                                      }...

0042cd5c  char data_42cd5c[0x27] = "ParseEntity: EOF without closing brace", 0

0042cd83           00                                                                                         .

0042cd84  char data_42cd84[0x21] = "num_entities == MAX_MAP_ENTITIES", 0

0042cda5                 00 00 00                                                                               ...

0042cda8  char data_42cda8[0x19] = "ParseEntity: { not found", 0

0042cdc1     00 00 00                                                                                       ...
0042cdc4  data_42cdc4:
0042cdc4              7b 00 00 00                                                                              {...

0042cdc8  char data_42cdc8[0x11] = "*Quake2 bsp file", 0

0042cdd9                                                                             00 00 00                                       ...

0042cddc  char data_42cddc[0xc] = "%lf %lf %lf", 0
0042cde8  char data_42cde8[0x45] = "Sin_LoadBSPFile: exceeded max size for lump %d size %d > maxsize %d\n", 0

0042ce2d                                         00 00 00                                                               ...

0042ce30  char data_42ce30[0x1f] = "Sin_LoadBSPFile: odd lump size", 0

0042ce4f                                               00                                                                 .

0042ce50  char data_42ce50[0xe] = "*sin bsp file", 0

0042ce5e                                                                                            00 00                                ..

0042ce60  int32_t data_42ce60 = 0x1

0042ce64              00 00 21 10 42 20 63 30 84 40 a5 50 c6 60 e7 70 08 81 29 91 4a a1 6b b1 8c c1 ad d1      ..!.B c0.@.P.`.p..).J.k.....
0042ce80  ce e1 ef f1 31 12 10 02 73 32 52 22 b5 52 94 42 f7 72 d6 62 39 93 18 83 7b b3 5a a3 bd d3 9c c3  ....1...s2R".R.B.r.b9...{.Z.....
0042cea0  ff f3 de e3 62 24 43 34 20 04 01 14 e6 64 c7 74 a4 44 85 54 6a a5 4b b5 28 85 09 95 ee e5 cf f5  ....b$C4 ....d.t.D.Tj.K.(.......
0042cec0  ac c5 8d d5 53 36 72 26 11 16 30 06 d7 76 f6 66 95 56 b4 46 5b b7 7a a7 19 97 38 87 df f7 fe e7  ....S6r&..0..v.f.V.F[.z...8.....
0042cee0  9d d7 bc c7 c4 48 e5 58 86 68 a7 78 40 08 61 18 02 28 23 38 cc c9 ed d9 8e e9 af f9 48 89 69 99  .....H.X.h.x@.a..(#8........H.i.
0042cf00  0a a9 2b b9 f5 5a d4 4a b7 7a 96 6a 71 1a 50 0a 33 3a 12 2a fd db dc cb bf fb 9e eb 79 9b 58 8b  ..+..Z.J.z.jq.P.3:.*........y.X.
0042cf20  3b bb 1a ab a6 6c 87 7c e4 4c c5 5c 22 2c 03 3c 60 0c 41 1c ae ed 8f fd ec cd cd dd 2a ad 0b bd  ;....l.|.L.\",.<`.A.........*...
0042cf40  68 8d 49 9d 97 7e b6 6e d5 5e f4 4e 13 3e 32 2e 51 1e 70 0e 9f ff be ef dd df fc cf 1b bf 3a af  h.I..~.n.^.N.>2.Q.p...........:.
0042cf60  59 9f 78 8f 88 91 a9 81 ca b1 eb a1 0c d1 2d c1 4e f1 6f e1 80 10 a1 00 c2 30 e3 20 04 50 25 40  Y.x...........-.N.o......0. .P%@
0042cf80  46 70 67 60 b9 83 98 93 fb a3 da b3 3d c3 1c d3 7f e3 5e f3 b1 02 90 12 f3 22 d2 32 35 42 14 52  Fpg`........=.....^......".25B.R
0042cfa0  77 62 56 72 ea b5 cb a5 a8 95 89 85 6e f5 4f e5 2c d5 0d c5 e2 34 c3 24 a0 14 81 04 66 74 47 64  wbVr........n.O.,....4.$....ftGd
0042cfc0  24 54 05 44 db a7 fa b7 99 87 b8 97 5f e7 7e f7 1d c7 3c d7 d3 26 f2 36 91 06 b0 16 57 66 76 76  $T.D........_.~...<..&.6....Wfvv
0042cfe0  15 46 34 56 4c d9 6d c9 0e f9 2f e9 c8 99 e9 89 8a b9 ab a9 44 58 65 48 06 78 27 68 c0 18 e1 08  .F4VL.m.../.........DXeH.x'h....
0042d000  82 38 a3 28 7d cb 5c db 3f eb 1e fb f9 8b d8 9b bb ab 9a bb 75 4a 54 5a 37 6a 16 7a f1 0a d0 1a  .8.(}.\.?...........uJTZ7j.z....
0042d020  b3 2a 92 3a 2e fd 0f ed 6c dd 4d cd aa bd 8b ad e8 9d c9 8d 26 7c 07 6c 64 5c 45 4c a2 3c 83 2c  .*.:....l.M.........&|.ld\EL.<.,
0042d040  e0 1c c1 0c 1f ef 3e ff 5d cf 7c df 9b af ba bf d9 8f f8 9f 17 6e 36 7e 55 4e 74 5e 93 2e b2 3e  ......>.].|..........n6~UNt^...>
0042d060  d1 0e f0 1e 3f 00 00 00 2a 00 00 00                                                              ....?...*...

0042d06c  char data_42d06c[0xb] = "ERROR: %s\n", 0

0042d077                                                                       00                                                 .

0042d078  char data_42d078[0xd] = "WARNING: %s\n", 0

0042d085                 00 00 00                                                                               ...
0042d088  data_42d088:
0042d088                          5c 00 00 00                                                                      \...

0042d08c  char data_42d08c[0x15] = "Error opening %s: %s", 0

0042d0a1     00 00 00                                                                                       ...

0042d0a4  char data_42d0a4[0x12] = "File read failure", 0

0042d0b6                                                                    00 00                                                ..

0042d0b8  char data_42d0b8[0x13] = "File write failure", 0

0042d0cb                                   00                                                                         .
0042d0cc  data_42d0cc:
0042d0cc                                      72 00 00 00                                                              r...

0042d0d0  char data_42d0d0[0x14] = "openlog <filename>\n", 0
0042d0e4  char data_42d0e4[0xf] = "Opened log %s\n", 0

0042d0f3                                                           00                                                         .

0042d0f4  char data_42d0f4[0x1c] = "can\'t open the log file %s\n", 0
0042d110  char data_42d110[0x1f] = "log file %s is already opened\n", 0

0042d12f                                               00                                                                 .

0042d130  char data_42d130[0xf] = "Closed log %s\n", 0

0042d13f                                                                                               00                                 .

0042d140  char data_42d140[0x19] = "can\'t close log file %s\n", 0

0042d159                                                                             00 00 00                                       ...

0042d15c  char data_42d15c[0x16] = "no log file to close\n", 0

0042d172                                                        00 00                                                        ..
0042d174  data_42d174:
0042d174                                                              0d 0a 00 00                                              ....

0042d178  char data_42d178[0xe] = "out of memory", 0

0042d186                    00 00                                                                                ..

0042d188  char data_42d188[0xa] = "%ld bytes", 0

0042d192                                                        00 00                                                        ..

0042d194  char data_42d194[0x7] = "%ld KB", 0

0042d19b                                                                                   00                                         .

0042d19c  char data_42d19c[0x6] = " and ", 0

0042d1a2        00 00                                                                                        ..

0042d1a4  char data_42d1a4[0x7] = "%ld MB", 0

0042d1ab                                   00                                                                         .

0042d1ac  char data_42d1ac[0x23] = "FreeWinding: freed a freed winding", 0

0042d1cf                                               00                                                                 .

0042d1d0  char data_42d1d0[0x2c] = "RemoveColinearPoints: MAX_POINTS_ON_WINDING", 0
0042d1fc  char data_42d1fc[0x23] = "BaseWindingForPlane: no axis found", 0

0042d21f                                                                                               00                                 .

0042d220  char data_42d220[0x23] = "ClipWinding: MAX_POINTS_ON_WINDING", 0

0042d243           00                                                                                         .

0042d244  char data_42d244[0x26] = "ClipWinding: points exceeded estimate", 0

0042d26a                                00 00                                                                        ..

0042d26c  char data_42d26c[0x1b] = "winding point %d off plane", 0

0042d287                       00                                                                                 .

0042d288  char data_42d288[0x13] = "winding non-convex", 0

0042d29b                                                                                   00                                         .

0042d29c  char data_42d29c[0x1e] = "winding degenerate edge %d-%d", 0

0042d2ba                                                                                00 00                                        ..

0042d2bc  char data_42d2bc[0x28] = "winding point %d BUGUS_RANGE \'%f %f %f\'", 0
0042d2e4  char data_42d2e4[0x10] = "winding %f area", 0
0042d2f4  char data_42d2f4[0x12] = "winding %i points", 0

0042d306                    00 00                                                                                ..

0042d308  char data_42d308[0x19] = "AddWindingPoint: num < 0", 0

0042d321     00 00 00                                                                                       ...

0042d324  char data_42d324[0x24] = "AddWindingPoint: num > w->numpoints", 0
0042d348  char data_42d348[0x31] = "FindPlaneSeperatingWindings: winding2 non-convex", 0

0042d379                                                                             00 00 00                                       ...

0042d37c  char data_42d37c[0x31] = "FindPlaneSeperatingWindings: winding1 non-convex", 0

0042d3ad                                         00 00 00                                                               ...

0042d3b0  char data_42d3b0[0x3b] = "FindPlaneSeperatingWindings: winding2 with degenerate edge", 0

0042d3eb                                   00                                                                         .

0042d3ec  char data_42d3ec[0x3b] = "FindPlaneSeperatingWindings: winding1 with degenerate edge", 0

0042d427                       00                                                                                 .

0042d428  void* data_42d428 = data_43032c

0042d42c  data_42d42c:
0042d42c                                      00 80 00 00                                                              ....

0042d430  char (* data_42d430)[0x5] = data_42d4c0 {".PAK"}

0042d434                                                              01 00 00 00                                              ....

0042d438  char (* data_42d438)[0x5] = data_42d4b8 {".SIN"}

0042d43c                                                                                      01 00 00 00                              ....

0042d440  char (* data_42d440)[0x5] = data_42d4b0 {".BSP"}

0042d444              02 00 00 00                                                                              ....

0042d448  char (* data_42d448)[0x5] = data_42d4a8 {".MAP"}

0042d44c                                      04 00 00 00                                                              ....

0042d450  char (* data_42d450)[0x5] = data_42d4a0 {".MDL"}

0042d454                                                              08 00 00 00                                              ....

0042d458  char (* data_42d458)[0x5] = data_42d498 {".MD2"}

0042d45c                                                                                      10 00 00 00                              ....

0042d460  char (* data_42d460)[0x5] = data_42d490 {".WAL"}

0042d464              20 00 00 00                                                                               ...

0042d468  char (* data_42d468)[0x5] = data_42d488 {".WAV"}

0042d46c                                      40 00 00 00                                                              @...

0042d470  char (* data_42d470)[0x5] = data_42d480 {".AAS"}

0042d474                                                              00 40 00 00 00 00 00 00 00 00 00 00                      .@..........

0042d480  char data_42d480[0x5] = ".AAS", 0

0042d485                 00 00 00                                                                               ...

0042d488  char data_42d488[0x5] = ".WAV", 0

0042d48d                                         00 00 00                                                               ...

0042d490  char data_42d490[0x5] = ".WAL", 0

0042d495                                                                 00 00 00                                               ...

0042d498  char data_42d498[0x5] = ".MD2", 0

0042d49d                                                                                         00 00 00                               ...

0042d4a0  char data_42d4a0[0x5] = ".MDL", 0

0042d4a5                 00 00 00                                                                               ...

0042d4a8  char data_42d4a8[0x5] = ".MAP", 0

0042d4ad                                         00 00 00                                                               ...

0042d4b0  char data_42d4b0[0x5] = ".BSP", 0

0042d4b5                                                                 00 00 00                                               ...

0042d4b8  char data_42d4b8[0x5] = ".SIN", 0

0042d4bd                                                                                         00 00 00                               ...

0042d4c0  char data_42d4c0[0x5] = ".PAK", 0

0042d4c5                 00 00 00                                                                               ...

0042d4c8  int16_t data_42d4c8 = 0x2e

0042d4ca                                00 00                                                                        ..

0042d4cc  char data_42d4cc[0x14] = "invalid pak file %s", 0
0042d4e0  char data_42d4e0[0x30] = "can\'t read the Sin pak file dir entries from %s", 0
0042d510  char data_42d510[0x32] = "can\'t read the Quake pak file dir entries from %s", 0

0042d542        00 00                                                                                        ..

0042d544  char data_42d544[0x17] = "can\'t open pak file %s", 0

0042d55b                                                                                   00                                         .

0042d55c  char data_42d55c[0x5] = ".pak", 0

0042d561     00 00 00 00 00 00 00                                                                           .......
0042d568  data_42d568:
0042d568                          8c d8 42 00 01 00 00 00 00 00 00 00 88 d8 42 00 02 00 00 00 00 00 00 00          ..B...........B.........

0042d580  void* data_42d580 = data_42d884

0042d584              03 00 00 00 00 00 00 00 80 d8 42 00 04 00 00 00 00 00 00 00 7c d8 42 00 05 00 00 00      ..........B.........|.B.....
0042d5a0  00 00 00 00 78 d8 42 00 06 00 00 00 00 00 00 00 74 d8 42 00 07 00 00 00 00 00 00 00 70 d8 42 00  ....x.B.........t.B.........p.B.
0042d5c0  08 00 00 00 00 00 00 00 6c d8 42 00 09 00 00 00 00 00 00 00 68 d8 42 00 0a 00 00 00 00 00 00 00  ........l.B.........h.B.........
0042d5e0  64 d8 42 00 0b 00 00 00 00 00 00 00 60 d8 42 00 0c 00 00 00 00 00 00 00 5c d8 42 00 0d 00 00 00  d.B.........`.B.........\.B.....
0042d600  00 00 00 00 58 d8 42 00 0e 00 00 00 00 00 00 00 54 d8 42 00 0f 00 00 00 00 00 00 00 50 d8 42 00  ....X.B.........T.B.........P.B.
0042d620  10 00 00 00 00 00 00 00 4c d8 42 00 11 00 00 00 00 00 00 00 48 d8 42 00 12 00 00 00 00 00 00 00  ........L.B.........H.B.........
0042d640  44 d8 42 00 13 00 00 00 00 00 00 00 40 d8 42 00 14 00 00 00 00 00 00 00 3c d8 42 00 15 00 00 00  D.B.........@.B.........<.B.....
0042d660  00 00 00 00 38 d8 42 00 16 00 00 00 00 00 00 00 34 d8 42 00 17 00 00 00 00 00 00 00 30 d8 42 00  ....8.B.........4.B.........0.B.
0042d680  18 00 00 00 00 00 00 00 2c d8 42 00 19 00 00 00 00 00 00 00 68 d0 42 00 1a 00 00 00 00 00 00 00  ........,.B.........h.B.........
0042d6a0  28 d8 42 00 1b 00 00 00 00 00 00 00 24 d8 42 00 1c 00 00 00 00 00 00 00 20 d8 42 00 1d 00 00 00  (.B.........$.B......... .B.....
0042d6c0  00 00 00 00 1c d8 42 00 1e 00 00 00 00 00 00 00 18 d8 42 00 1f 00 00 00 00 00 00 00 14 d8 42 00  ......B...........B...........B.
0042d6e0  20 00 00 00 00 00 00 00 10 d8 42 00 21 00 00 00 00 00 00 00 0c d8 42 00 22 00 00 00 00 00 00 00   .........B.!.........B.".......
0042d700  08 d8 42 00 23 00 00 00 00 00 00 00 04 d8 42 00 24 00 00 00 00 00 00 00 00 d8 42 00 25 00 00 00  ..B.#.........B.$.........B.%...
0042d720  00 00 00 00                                                                                      ....

0042d724  wchar32 (* data_42d724)[0xc] = &data_42d7e4[0x6] {0042d7fc} {U"<>!~^|&=-+%/"}

0042d728                          26 00 00 00 00 00 00 00                                                          &.......

0042d730  void* data_42d730 = data_42d4c8

0042d734                                                              27 00 00 00 00 00 00 00 80 b1 42 00                      '.........B.
0042d740  28 00 00 00 00 00 00 00                                                                          (.......

0042d748  wchar32 (* data_42d748)[0xd] = &data_42d7e4[0x5] {0042d7f8} {U";<>!~^|&=-+%/"}

0042d74c                                      29 00 00 00 00 00 00 00                                                  ).......

0042d754  wchar32 (* data_42d754)[0xe] = &data_42d7e4[0x4] {0042d7f4} {U":;<>!~^|&=-+%/"}

0042d758                                                                          2a 00 00 00 00 00 00 00                          *.......
0042d760  64 d0 42 00 2b 00 00 00 00 00 00 00                                                              d.B.+.......

0042d76c  void* data_42d76c = data_42b17c

0042d770                                                  2c 00 00 00 00 00 00 00                                          ,.......

0042d778  char (* data_42d778)[0x2] = &data_42b174[0x4] {0042b178} {")"}

0042d77c                                                                                      2d 00 00 00                              -...
0042d780  00 00 00 00                                                                                      ....

0042d784  void* data_42d784 = data_42cdc4

0042d788                          2e 00 00 00 00 00 00 00                                                          ........

0042d790  void* data_42d790 = data_42cd58

0042d794                                                              2f 00 00 00 00 00 00 00                                  /.......

0042d79c  wchar32 (* data_42d79c)[0xf] = &data_42d7e4[0x3] {0042d7f0} {U"[:;<>!~^|&=-+%/"}

0042d7a0  30 00 00 00 00 00 00 00                                                                          0.......

0042d7a8  wchar32 (* data_42d7a8)[0x10] = &data_42d7e4[0x2] {0042d7ec} {U"][:;<>!~^|&=-+%/"}

0042d7ac                                      31 00 00 00 00 00 00 00                                                  1.......

0042d7b4  void* data_42d7b4 = data_42d088

0042d7b8                                                                          32 00 00 00 00 00 00 00                          2.......

0042d7c0  wchar32 (* data_42d7c0)[0x11] = &data_42d7e4[0x1] {0042d7e8} {U"#][:;<>!~^|&=-+%/"}

0042d7c4              33 00 00 00 00 00 00 00                                                                  3.......

0042d7cc  wchar32 (* data_42d7cc)[0x12] = data_42d7e4 {U"$#][:;<>!~^|&=-+%/"}

0042d7d0                                                  34 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  4...............
0042d7e0  00 00 00 00                                                                                      ....

0042d7e4  wchar32 data_42d7e4[0x12] = "$#][:;<>!~^|&=-+%/"

0042d82c                                      2e 2a 00 00 3a 3a 00 00 2d 3e 00 00 3c 3c 00 00 3e 3e 00 00              .*..::..->..<<..>>..
0042d840  5e 3d 00 00 7c 3d 00 00 26 3d 00 00 2d 2d 00 00 2b 2b 00 00 2d 3d 00 00 2b 3d 00 00 25 3d 00 00  ^=..|=..&=..--..++..-=..+=..%=..
0042d860  2f 3d 00 00 2a 3d 00 00 21 3d 00 00 3d 3d 00 00 3c 3d 00 00 3e 3d 00 00 7c 7c 00 00 26 26 00 00  /=..*=..!=..==..<=..>=..||..&&..
0042d880  23 23 00 00                                                                                      ##..
0042d884  data_42d884:
0042d884              2e 2e 2e 00 3c 3c 3d 00 3e 3e 3d 00                                                      ....<<=.>>=.

0042d890  char data_42d890[0x1d] = "error: file %s, line %d: %s\n", 0

0042d8ad                                         00 00 00                                                               ...

0042d8b0  char data_42d8b0[0x1f] = "warning: file %s, line %d: %s\n", 0

0042d8cf                                               00                                                                 .

0042d8d0  char data_42d8d0[0x24] = "too large value in escape character", 0
0042d8f4  char data_42d8f4[0x14] = "unknown escape char", 0
0042d908  char data_42d908[0x19] = "newline inside string %s", 0

0042d921     00 00 00                                                                                       ...

0042d924  char data_42d924[0x17] = "missing trailing quote", 0

0042d93b                                                                                   00                                         .

0042d93c  char data_42d93c[0x22] = "string longer than MAX_TOKEN = %d", 0

0042d95e                                                                                            00 00                                ..

0042d960  char data_42d960[0x20] = "name longer than MAX_TOKEN = %d", 0
0042d980  char data_42d980[0x22] = "number longer than MAX_TOKEN = %d", 0

0042d9a2        00 00                                                                                        ..

0042d9a4  char data_42d9a4[0x29] = "binary number longer than MAX_TOKEN = %d", 0

0042d9cd                                         00 00 00                                                               ...

0042d9d0  char data_42d9d0[0x2e] = "hexadecimal number longer than MAX_TOKEN = %d", 0

0042d9fe                                                                                            00 00                                ..

0042da00  char data_42da00[0x2b] = "primitive token longer than MAX_TOKEN = %d", 0

0042da2b                                   00                                                                         .

0042da2c  char data_42da2c[0x11] = "can\'t read token", 0

0042da3d                                                                                         00 00 00                               ...

0042da40  char data_42da40[0x16] = "expected %s, found %s", 0

0042da56                                                                    00 00                                                ..

0042da58  char data_42da58[0x1a] = "couldn\'t find expected %s", 0

0042da72                                                        00 00                                                        ..

0042da74  char data_42da74[0x1f] = "BUG: wrong punctuation subtype", 0

0042da93                                                           00                                                         .

0042da94  char data_42da94[0x9] = " integer", 0

0042da9d                                                                                         00 00 00                               ...

0042daa0  char data_42daa0[0x7] = " float", 0

0042daa7                       00                                                                                 .

0042daa8  char data_42daa8[0xa] = " unsigned", 0

0042dab2                                                        00 00                                                        ..

0042dab4  char data_42dab4[0x6] = " long", 0

0042daba                                                                                00 00                                        ..

0042dabc  char data_42dabc[0x7] = "binary", 0

0042dac3           00                                                                                         .

0042dac4  char data_42dac4[0x6] = "octal", 0

0042daca                                00 00                                                                        ..

0042dacc  int32_t data_42dacc = 0x786568
0042dad0  char data_42dad0[0x8] = "decimal", 0
0042dad8  char data_42dad8[0x18] = "expected a %s, found %s", 0
0042daf0  char data_42daf0[0xc] = "punctuation", 0
0042dafc  char data_42dafc[0x5] = "name", 0

0042db01     00 00 00                                                                                       ...

0042db04  char data_42db04[0x7] = "number", 0

0042db0b                                   00                                                                         .

0042db0c  char data_42db0c[0x8] = "literal", 0
0042db14  char data_42db14[0x7] = "string", 0

0042db1b                                                                                   00                                         .

0042db1c  char data_42db1c[0x1d] = "couldn\'t read expected token", 0

0042db39                                                                             00 00 00                                       ...

0042db3c  int32_t data_42db3c = -0x1
0042db40  char data_42db40[0xc] = "%i threads\n", 0
0042db4c  char data_42db4c[0x16] = "Recursive ThreadLock\n", 0

0042db62        00 00                                                                                        ..

0042db64  char data_42db64[0x16] = "ThreadLock: !threaded", 0

0042db7a                                                                                00 00                                        ..

0042db7c  char data_42db7c[0x1b] = "ThreadUnlock without lock\n", 0

0042db97                                                                       00                                                 .

0042db98  char data_42db98[0x18] = "ThreadUnlock: !threaded", 0
0042dbb0  char data_42dbb0[0x17] = "Win32 multi-threading\n", 0

0042dbc7                       00                                                                                 .

0042dbc8  char data_42dbc8[0x22] = "can\'t allocate memory for thread\n", 0

0042dbea                                00 00                                                                        ..

0042dbec  char data_42dbec[0x20] = "couldn\'t find thread with id %d", 0
0042dc0c  char data_42dc0c[0x14] = "%5i point linefile\n", 0
0042dc20  char data_42dc20[0x7] = "origin", 0

0042dc27                       00                                                                                 .

0042dc28  char data_42dc28[0xa] = "%f %f %f\n", 0

0042dc32                                                        00 00                                                        ..

0042dc34  char data_42dc34[0x12] = "Couldn\'t open %s\n", 0

0042dc46                    00 00                                                                                ..

0042dc48  char data_42dc48[0x12] = "--- LeakFile ---\n", 0

0042dc5a                                                                                00 00                                        ..

0042dc5c  char data_42dc5c[0x13] = "MAX_MAPFILE_PLANES", 0

0042dc6f                                               00                                                                 .

0042dc70  char data_42dc70[0x17] = "FloatPlane: bad normal", 0

0042dc87                       00                                                                                 .

0042dc88  char data_42dc88[0x13] = "MAX_MAP_BRUSHSIDES", 0

0042dc9b                                                                                   00                                         .

0042dc9c  char data_42dc9c[0x1d] = "MarkBrushBevels: brush %d %s", 0

0042dcb9                                                                             00 00 00                                       ...

0042dcbc  char data_42dcbc[0x27] = "MarkBrushBevels: brush %d tiny winding", 0

0042dce3           00                                                                                         .

0042dce4  char data_42dce4[0x25] = "MarkBrushBevels: brush %d no winding", 0

0042dd09                             00 00 00                                                                       ...
0042dd0c  data_42dd0c:
0042dd0c                                      20 7d 0a 00                                                               }..

0042dd10  char data_42dd10[0xd] = " %ld %ld %ld", 0

0042dd1d                                                                                         00 00 00                               ...

0042dd20  char data_42dd20[0x5] = " %4f", 0

0042dd25                 00 00 00                                                                               ...
0042dd28  data_42dd28:
0042dd28                          20 25 64 00                                                                       %d.

0042dd2c  char data_42dd2c[0xc] = "%s %d %d %d", 0
0042dd38  char data_42dd38[0x1b] = "generic/misc/red 0 0 0 1 1", 0

0042dd53                                                           00                                                         .

0042dd54  char data_42dd54[0x27] = "generic/misc/volumetric_base 0 0 0 1 1", 0

0042dd7b                                                                                   00                                         .

0042dd7c  char data_42dd7c[0x1d] = "generic/misc/fence 0 0 0 1 1", 0

0042dd99                                                                             00 00 00                                       ...

0042dd9c  char data_42dd9c[0x16] = "brush->contents = %d\n", 0

0042ddb2                                                        00 00                                                        ..

0042ddb4  char data_42ddb4[0x18] = "e1u1/clip_mon 0 0 0 1 1", 0
0042ddcc  char data_42ddcc[0x1f] = "generic/misc/monster 0 0 0 1 1", 0

0042ddeb                                   00                                                                         .

0042ddec  char data_42ddec[0xf] = "clip 0 0 0 1 1", 0

0042ddfb                                                                                   00                                         .

0042ddfc  char data_42ddfc[0x14] = "e1u1/clip 0 0 0 1 1", 0
0042de10  char data_42de10[0x1c] = "generic/misc/clip 0 0 0 1 1", 0
0042de2c  char data_42de2c[0x11] = "( %5i %5i %5i ) ", 0

0042de3d                                                                                         00 00 00                               ...

0042de40  char data_42de40[0x13] = "  ( %5i %5i %5i ) ", 0

0042de53                                                           00                                                         .

0042de54  char data_42de54[0xf] = " { //brush %d\n", 0

0042de63           00                                                                                         .

0042de64  char data_42de64[0x16] = "e1u1/origin 0 0 0 1 1", 0

0042de7a                                                                                00 00                                        ..

0042de7c  char data_42de7c[0x1e] = "generic/misc/origin 0 0 0 1 1", 0

0042de9a                                                                                00 00                                        ..
0042de9c  data_42de9c:
0042de9c                                                                                      20 7b 0a 00                               {..

0042dea0  char data_42dea0[0x20] = "area portal %d brush not found\n", 0
0042dec0  char data_42dec0[0x17] = "//total of %d brushes\n", 0

0042ded7                                                                       00                                                 .

0042ded8  char data_42ded8[0x10] = "func_areaportal", 0
0042dee8  char data_42dee8[0xc] = " \"%s\" \"%s\"\n", 0
0042def4  char data_42def4[0x6] = "model", 0

0042defa                                                                                00 00                                        ..

0042defc  char data_42defc[0x3c] = "//\n//=====================================================\n", 0
0042df38  char data_42df38[0x32] = "// generic/misc/red is used for unknown textures\n", 0

0042df6a                                00 00                                                                        ..

0042df6c  char data_42df6c[0x8c] = "//=====================================================\n"
0042df6c      "//\n// map file created with WinBSPC v1.0\n"
0042df6c      "//\n// WinBSPC is created by Mr Elusive\n"
0042df6c      "//\n", 0
0042dff8  char data_42dff8[0x23] = "map file written in %5.0f seconds\n", 0

0042e01b                                                                                   00                                         .

0042e01c  char data_42e01c[0x14] = "written %d brushes\n", 0
0042e030  char data_42e030[0x1b] = "error writing map file %s\n", 0

0042e04b                                   00                                                                         .

0042e04c  char data_42e04c[0x11] = "%6i brush sides\n", 0

0042e05d                                                                                         00 00 00                               ...

0042e060  char data_42e060[0x29] = "unknown BSP format %c%c%c%c, version %d\n", 0

0042e089                             00 00 00                                                                       ...

0042e08c  char data_42e08c[0x18] = "can\'t read the file %s\n", 0
0042e0a4  char data_42e0a4[0x1e] = "error seeking to the file %s\n", 0

0042e0c2        00 00                                                                                        ..

0042e0c4  char data_42e0c4[0x7] = "!slime", 0

0042e0cb                                   00                                                                         .

0042e0cc  char data_42e0cc[0x6] = "!lava", 0

0042e0d2                                                        00 00                                                        ..
0042e0d4  data_42e0d4:
0042e0d4                                                              73 6b 79 00                                              sky.

0042e0d8  char data_42e0d8[0x21] = "HL_SplitBrush: no split winding\n", 0

0042e0f9                                                                             00 00 00                                       ...

0042e0fc  char data_42e0fc[0x28] = "HL_SplitBrush: split not on both sides\n", 0
0042e124  char data_42e124[0x24] = "HL_SplitBrush: split removed brush\n", 0
0042e148  char data_42e148[0x27] = "HL_SplitBrush: tiny volume after clip\n", 0

0042e16f                                               00                                                                 .

0042e170  char data_42e170[0x1d] = "HL_SplitBrush: numsides < 3\n", 0

0042e18d                                         00 00 00                                                               ...

0042e190  char data_42e190[0x27] = "HL_SplitBrush: bogus brush after clip\n", 0

0042e1b7                                                                       00                                                 .

0042e1b8  char data_42e1b8[0x2b] = "HL_SplitBrush: WARNING huge split winding\n", 0

0042e1e3           00                                                                                         .

0042e1e4  char data_42e1e4[0x1e] = "HL_SplitBrush: only on front\n", 0

0042e202        00 00                                                                                        ..

0042e204  char data_42e204[0x1d] = "HL_SplitBrush: only on back\n", 0

0042e221     00 00 00                                                                                       ...

0042e224  char data_42e224[0x36] = "HL_CreateBrushes_r: WARNING node not splitting brush\n", 0

0042e25a                                                                                00 00                                        ..

0042e25c  char data_42e25c[0x39] = "HL_CreateBrushes_r: unknown contents %d in Half-Life BSP", 0

0042e295                                                                 00 00 00                                               ...

0042e298  char data_42e298[0x37] = "HL_CreateBrushes_r: found contents %d in Half-Life BSP", 0

0042e2cf                                               00                                                                 .

0042e2d0  char data_42e2d0[0x34] = "brush size: %5.0f,%5.0f,%5.0f to %5.0f,%5.0f,%5.0f\n", 0
0042e304  char data_42e304[0x25] = "HL_SplitBrushWithFace: no new brush\n", 0

0042e329                             00 00 00                                                                       ...

0042e32c  char data_42e32c[0x20] = "brush %d: no real texture split", 0
0042e34c  char data_42e34c[0xc] = "%5d brushes", 0
0042e358  char data_42e358[0x13] = "texturing brushes\n", 0

0042e36b                                   00                                                                         .

0042e36c  char data_42e36c[0x27] = "brush contents %d with wrong textures\n", 0

0042e393                                                           00                                                         .

0042e394  char data_42e394[0x25] = "nummapbrushes == MAX_MAPFILE_BRUSHES", 0

0042e3b9                                                                             00 00 00                                       ...

0042e3bc  char data_42e3bc[0x23] = "converting brushes to map brushes\n", 0

0042e3df                                                                                               00                                 .

0042e3e0  char data_42e3e0[0x12] = "%5d clip brushes\n", 0

0042e3f2                                                        00 00                                                        ..

0042e3f4  char data_42e3f4[0x11] = "%5d map brushes\n", 0

0042e405                 00 00 00                                                                               ...

0042e408  char data_42e408[0xb] = "worldspawn", 0

0042e413                                                           00                                                         .

0042e414  char data_42e414[0x1c] = "placing textures correctly\n", 0
0042e430  char data_42e430[0x24] = "creating minimum number of brushes\n", 0
0042e454  char data_42e454[0x1c] = "creating Half-Life brushes\n", 0
0042e470  char data_42e470[0x1b] = "loading map from %s at %d\n", 0

0042e48b                                   00                                                                         .

0042e48c  char data_42e48c[0x19] = "-- HL_LoadMapFromBSP --\n", 0

0042e4a5                 00 00 00                                                                               ...

0042e4a8  char data_42e4a8[0x6] = "slime", 0

0042e4ae                                            00 00                                                                ..

0042e4b0  char data_42e4b0[0x5] = "lava", 0

0042e4b5                                                                 00 00 00                                               ...

0042e4b8  char data_42e4b8[0x5] = "clip", 0

0042e4bd                                                                                         00 00 00                               ...

0042e4c0  char data_42e4c0[0x21] = "Q1_SplitBrush: no split winding\n", 0

0042e4e1     00 00 00                                                                                       ...

0042e4e4  char data_42e4e4[0x28] = "Q1_SplitBrush: split not on both sides\n", 0
0042e50c  char data_42e50c[0x24] = "Q1_SplitBrush: split removed brush\n", 0
0042e530  char data_42e530[0x27] = "Q1_SplitBrush: tiny volume after clip\n", 0

0042e557                                                                       00                                                 .

0042e558  char data_42e558[0x1d] = "Q1_SplitBrush: numsides < 3\n", 0

0042e575                                                                 00 00 00                                               ...

0042e578  char data_42e578[0x27] = "Q1_SplitBrush: bogus brush after clip\n", 0

0042e59f                                                                                               00                                 .

0042e5a0  char data_42e5a0[0x2b] = "Q1_SplitBrush: WARNING huge split winding\n", 0

0042e5cb                                   00                                                                         .

0042e5cc  char data_42e5cc[0x1e] = "Q1_SplitBrush: only on front\n", 0

0042e5ea                                00 00                                                                        ..

0042e5ec  char data_42e5ec[0x1d] = "Q1_SplitBrush: only on back\n", 0

0042e609                             00 00 00                                                                       ...

0042e60c  char data_42e60c[0x36] = "Q1_CreateBrushes_r: WARNING node not splitting brush\n", 0

0042e642        00 00                                                                                        ..

0042e644  char data_42e644[0x39] = "Q1_CreateBrushes_r: unknown contents %d in Half-Life BSP", 0

0042e67d                                                                                         00 00 00                               ...

0042e680  char data_42e680[0x25] = "Q1_SplitBrushWithFace: no new brush\n", 0

0042e6a5                 00 00 00                                                                               ...

0042e6a8  char data_42e6a8[0x19] = "creating Quake1 brushes\n", 0

0042e6c1     00 00 00                                                                                       ...

0042e6c4  char data_42e6c4[0x19] = "-- Q1_LoadMapFromBSP --\n", 0

0042e6dd                                                                                         00 00 00                               ...

0042e6e0  char data_42e6e0[0x13] = "texture name = %s\n", 0

0042e6f3                                                           00                                                         .

0042e6f4  char data_42e6f4[0x2a] = "Entity %i, Brush %i: mixed face contents\n", 0

0042e71e                                                                                            00 00                                ..

0042e720  char data_42e720[0x9] = "%i %i %i", 0

0042e729                             00 00 00                                                                       ...

0042e72c  char data_42e72c[0x39] = "Entity %i, Brush %i: origin brushes not allowed in world", 0

0042e765                 00 00 00                                                                               ...

0042e768  char data_42e768[0x25] = "Entity %i, Brush %i: mirrored plane\n", 0

0042e78d                                         00 00 00                                                               ...

0042e790  char data_42e790[0x26] = "Entity %i, Brush %i: duplicate plane\n", 0

0042e7b6                                                                    00 00                                                ..

0042e7b8  char data_42e7b8[0x2b] = "Entity %i, Brush %i: plane with no normal\n", 0

0042e7e3           00                                                                                         .

0042e7e4  char data_42e7e4[0x6] = "style", 0

0042e7ea                                00 00                                                                        ..
0042e7ec  data_42e7ec:
0042e7ec                                      25 69 00 00                                                              %i..

0042e7f0  char data_42e7f0[0x36] = "Entity %i: func_areaportal can only be a single brush", 0

0042e826                    00 00                                                                                ..

0042e828  char data_42e828[0xb] = "func_group", 0

0042e833                                                           00                                                         .

0042e834  char data_42e834[0x12] = "couldn\'t open %s\n", 0

0042e846                    00 00                                                                                ..

0042e848  char data_42e848[0x16] = "-- Q2_LoadMapFile --\n", 0

0042e85e                                                                                            00 00                                ..

0042e860  char data_42e860[0x22] = "Q2_PushNodeStack: stack overflow\n", 0

0042e882        00 00                                                                                        ..

0042e884  char data_42e884[0x25] = "nummapbrushes >= MAX_MAPFILE_BRUSHES", 0

0042e8a9                             00 00 00                                                                       ...

0042e8ac  char data_42e8ac[0x32] = "Q2_ParseBSPEntity: model number without leading *", 0

0042e8de                                                                                            00 00                                ..

0042e8e0  char data_42e8e0[0x18] = "Loading map from %s...\n", 0
0042e8f8  char data_42e8f8[0x19] = "-- Q2_LoadMapFromBSP --\n", 0

0042e911                                                     00 00 00                                                       ...

0042e914  char data_42e914[0x11] = "generic/misc/red", 0

0042e925                 00 00 00                                                                               ...

0042e928  char data_42e928[0x23] = "Sin_PushNodeStack: stack overflow\n", 0

0042e94b                                   00                                                                         .

0042e94c  char data_42e94c[0x1a] = "-- Sin_LoadMapFromBSP --\n", 0

0042e966                    00 00                                                                                ..

0042e968  char data_42e968[0x1f] = "Portal_EntityFlood: not a leaf", 0

0042e987                       00                                                                                 .

0042e988  char data_42e988[0x23] = "AddPortalToNode: allready included", 0

0042e9ab                                   00                                                                         .

0042e9ac  char data_42e9ac[0x2e] = "RemovePortalFromNode: more than 4096 portals\n", 0

0042e9da                                                                                00 00                                        ..

0042e9dc  char data_42e9dc[0x37] = "RemovePortalFromNodes: portal does not belong to node\n", 0

0042ea13                                                           00                                                         .

0042ea14  char data_42ea14[0x27] = "RemovePortalFromNode: circular linked\n", 0

0042ea3b                                                                                   00                                         .

0042ea3c  char data_42ea3c[0x27] = "RemovePortalFromNode: mislinked portal", 0

0042ea63           00                                                                                         .

0042ea64  char data_42ea64[0x2f] = "RemovePortalFromNode: portal not bounding leaf", 0

0042ea93                                                           00                                                         .

0042ea94  char data_42ea94[0x29] = "RemovePortalFromNode: portal not in leaf", 0

0042eabd                                                                                         00 00 00                               ...

0042eac0  char data_42eac0[0x21] = "MakeNodePortal: mislinked portal", 0

0042eae1     00 00 00                                                                                       ...

0042eae4  char data_42eae4[0x23] = "SplitNodePortals: mislinked portal", 0

0042eb07                       00                                                                                 .

0042eb08  char data_42eb08[0x25] = "WARNING: node with unbounded volume\n", 0

0042eb2d                                         00 00 00                                                               ...

0042eb30  char data_42eb30[0x20] = "WARNING: node without a volume\n", 0
0042eb50  char data_42eb50[0x1a] = "%6i KB of winding memory\n", 0

0042eb6a                                00 00                                                                        ..

0042eb6c  char data_42eb6c[0x19] = "%6d KB of portal memory\n", 0

0042eb85                 00 00 00                                                                               ...

0042eb88  char data_42eb88[0x12] = "%6d tiny portals\n", 0

0042eb9a                                                                                00 00                                        ..

0042eb9c  char data_42eb9c[0x17] = "\r%6d nodes portalized\n", 0

0042ebb3                                                           00                                                         .

0042ebb4  char data_42ebb4[0x15] = "%6d nodes portalized", 0

0042ebc9                             00 00 00                                                                       ...

0042ebcc  char data_42ebcc[0x1e] = "---- Node Portalization ----\n", 0

0042ebea                                00 00                                                                        ..

0042ebec  char data_42ebec[0x21] = "PlaceOccupant: invalid child %d\n", 0

0042ec0d                                         00 00 00                                                               ...

0042ec10  char data_42ec10[0x27] = "PlaceOccupant: invalid node->planenum\n", 0

0042ec37                                                                       00                                                 .

0042ec38  char data_42ec38[0x26] = "WARNING: entity reached from outside\n", 0

0042ec5e                                                                                            00 00                                ..

0042ec60  char data_42ec60[0x1d] = "WARNING: no entities inside\n", 0

0042ec7d                                                                                         00 00 00                               ...

0042ec80  char data_42ec80[0x12] = "info_player_start", 0

0042ec92                                                        00 00                                                        ..

0042ec94  char data_42ec94[0x1e] = "------ FloodEntities -------\n", 0

0042ecb2                                                        00 00                                                        ..

0042ecb4  char data_42ecb4[0x13] = "%5i inside leaves\n", 0

0042ecc7                       00                                                                                 .

0042ecc8  char data_42ecc8[0x13] = "%5i leaves filled\n", 0

0042ecdb                                                                                   00                                         .

0042ecdc  char data_42ecdc[0x12] = "%5i solid leaves\n", 0

0042ecee                                            00 00                                                                ..

0042ecf0  char data_42ecf0[0x1e] = "------- FillOutside --------\n", 0

0042ed0e                                            00 00                                                                ..

0042ed10  char data_42ed10[0x31] = "WARNING: areaportal entity %i touches > 2 areas\n", 0

0042ed41     00 00 00                                                                                       ...

0042ed44  char data_42ed44[0x37] = "WARNING: areaportal entity %i doesn\'t touch two areas\n", 0

0042ed7b                                                                                   00                                         .

0042ed7c  char data_42ed7c[0x14] = "%5i numareaportals\n", 0
0042ed90  char data_42ed90[0xe] = "%5i numareas\n", 0

0042ed9e                                                                                            00 00                                ..

0042eda0  char data_42eda0[0xe] = "MAX_MAP_AREAS", 0

0042edae                                            00 00                                                                ..

0042edb0  char data_42edb0[0xb] = "%5i areas\n", 0

0042edbb                                                                                   00                                         .

0042edbc  char data_42edbc[0x14] = "--- FloodAreas ---\n", 0
0042edd0  char data_42edd0[0x24] = "WARNING: side not found for portal\n", 0
0042edf4  char data_42edf4[0x1a] = "--- MarkVisibleSides ---\n", 0

0042ee0e                                            00 00                                                                ..
0042ee10  data_42ee10:
0042ee10                                                  25 66 20 00                                                      %f .
0042ee14  data_42ee14:
0042ee14                                                              25 69 20 00                                              %i .
0042ee18  data_42ee18:
0042ee18                                                                          29 20 00 00                                      ) ..

0042ee1c  char data_42ee1c[0xa] = "%i %i %i ", 0

0042ee26                    00 00                                                                                ..

0042ee28  char data_42ee28[0x10] = "%5i visportals\n", 0
0042ee38  char data_42ee38[0x11] = "%5i visclusters\n", 0

0042ee49                             00 00 00                                                                       ...
0042ee4c  data_42ee4c:
0042ee4c                                      25 73 0a 00                                                              %s..

0042ee50  char data_42ee50[0x5] = "PRT1", 0

0042ee55                                                                 00 00 00                                               ...

0042ee58  char data_42ee58[0x11] = "Error opening %s", 0

0042ee69                             00 00 00                                                                       ...

0042ee6c  char data_42ee6c[0x19] = "--- WritePortalFile ---\n", 0

0042ee85                 00 00 00 00 00 00 00                                                                   .......
0042ee8c  data_42ee8c:
0042ee8c                                      00 00 00 00 00 00 80 3f 00 00 80 3f 00 00 00 00 00 00 00 00              .......?...?........
0042eea0  00 00 00 00 00 00 80 bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 bf 00 00 80 3f 00 00 00 00  ...........................?....
0042eec0  00 00 00 00 00 00 00 00 00 00 80 bf 00 00 00 00 00 00 80 3f 00 00 00 00 00 00 00 00 00 00 00 00  ...................?............
0042eee0  00 00 80 3f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 bf 00 00 80 bf 00 00 00 00 00 00 00 00  ...?............................
0042ef00  00 00 00 00 00 00 80 3f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 bf 00 00 00 00 00 00 80 3f  .......?.......................?
0042ef20  00 00 00 00 00 00 80 3f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 bf 00 00 00 00  .......?........................
0042ef40  00 00 80 bf 00 00 00 00 00 00 80 3f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 bf  ...........?....................

0042ef60  char data_42ef60[0x12] = "%stextures/%s.wal", 0

0042ef72                                                        00 00                                                        ..

0042ef74  char data_42ef74[0x11] = "MAX_MAP_TEXTURES", 0

0042ef85                 00 00 00                                                                               ...

0042ef88  char data_42ef88[0x11] = " of tree memory\n", 0

0042ef99                                                                             00 00 00                                       ...

0042ef9c  char data_42ef9c[0x8] = "\nfreed ", 0
0042efa4  char data_42efa4[0x1c] = "PruneNodes: node->brushlist", 0
0042efc0  char data_42efc0[0x1b] = "!node->faces with children", 0

0042efdb                                                                                   00                                         .

0042efdc  char data_42efdc[0x26] = "node->faces seperating CONTENTS_SOLID", 0

0042f002        00 00                                                                                        ..

0042f004  char data_42f004[0x12] = "%5i pruned nodes\n", 0

0042f016                                                                    00 00                                                ..

0042f018  char data_42f018[0x1e] = "------- Prune Nodes --------\n", 0

0042f036                                                                    00 00                                                ..

0042f038  char data_42f038[0xf] = "MAX_MAP_PLANES", 0

0042f047                       00                                                                                 .

0042f048  char data_42f048[0x12] = "MAX_MAP_LEAFFACES", 0

0042f05a                                                                                00 00                                        ..

0042f05c  char data_42f05c[0xd] = "Bad leafface", 0

0042f069                             00 00 00                                                                       ...

0042f06c  char data_42f06c[0x14] = "MAX_MAP_LEAFBRUSHES", 0
0042f080  char data_42f080[0xe] = "MAX_MAP_LEAFS", 0

0042f08e                                            00 00                                                                ..

0042f090  char data_42f090[0x22] = "numsurfedges == MAX_MAP_SURFEDGES", 0

0042f0b2                                                        00 00                                                        ..

0042f0b4  char data_42f0b4[0x1a] = "numfaces == MAX_MAP_FACES", 0

0042f0ce                                            00 00                                                                ..

0042f0d0  char data_42f0d0[0x1f] = "WriteDrawNodes_r: odd planenum", 0

0042f0ef                                               00                                                                 .

0042f0f0  char data_42f0f0[0xe] = "MAX_MAP_NODES", 0

0042f0fe                                                                                            00 00                                ..

0042f100  char data_42f100[0xb] = "%5i faces\n", 0

0042f10b                                   00                                                                         .

0042f10c  char data_42f10c[0x19] = "%5i nodes without faces\n", 0

0042f125                 00 00 00                                                                               ...

0042f128  char data_42f128[0x16] = "%5i nodes with faces\n", 0

0042f13e                                                                                            00 00                                ..

0042f140  char data_42f140[0x12] = "--- WriteBSP ---\n", 0

0042f152                                                        00 00                                                        ..
0042f154  data_42f154:
0042f154                                                              2a 25 69 00                                              *%i.

0042f158  char data_42f158[0x20] = "stylenum == MAX_SWITCHED_LIGHTS", 0
0042f178  char data_42f178[0x6] = "light", 0

0042f17e                                                                                            00 00                                ..

0042f180  char data_42f180[0xf] = "MAX_MAP_MODELS", 0

0042f18f                                               00 75 98 00 00 73 98 00 00                                         .u...s...

0042f198  void* data_42f198 = sub_41dc00
0042f19c  void* data_42f19c = sub_41dc17
0042f1a0  void* data_42f1a0 = sub_41dc17

0042f1a4              00 00 00 00 00 00 00 00 00 00 00 00                                                      ............
0042f1b0  data_42f1b0:
0042f1b0                                                  01 00 00 00                                                      ....
0042f1b4  data_42f1b4:
0042f1b4                                                              16 00 00 00 02 00 00 00 02 00 00 00                      ............
0042f1c0  03 00 00 00 02 00 00 00 04 00 00 00 18 00 00 00 05 00 00 00 0d 00 00 00 06 00 00 00 09 00 00 00  ................................
0042f1e0  07 00 00 00 0c 00 00 00 08 00 00 00 0c 00 00 00 09 00 00 00 0c 00 00 00 0a 00 00 00 07 00 00 00  ................................
0042f200  0b 00 00 00 08 00 00 00 0c 00 00 00 16 00 00 00 0d 00 00 00 16 00 00 00 0f 00 00 00 02 00 00 00  ................................
0042f220  10 00 00 00 0d 00 00 00 11 00 00 00 12 00 00 00 12 00 00 00 02 00 00 00 21 00 00 00 0d 00 00 00  ........................!.......
0042f240  35 00 00 00 02 00 00 00 41 00 00 00 0d 00 00 00 43 00 00 00 02 00 00 00 50 00 00 00 11 00 00 00  5.......A.......C.......P.......
0042f260  52 00 00 00 0d 00 00 00 53 00 00 00 0d 00 00 00 57 00 00 00 16 00 00 00 59 00 00 00 0b 00 00 00  R.......S.......W.......Y.......
0042f280  6c 00 00 00 0d 00 00 00 6d 00 00 00 20 00 00 00 70 00 00 00 1c 00 00 00 72 00 00 00 09 00 00 00  l.......m... ...p.......r.......
0042f2a0  06 00 00 00 16 00 00 00 80 00 00 00 0a 00 00 00 81 00 00 00 0a 00 00 00 82 00 00 00 09 00 00 00  ................................
0042f2c0  83 00 00 00 16 00 00 00 84 00 00 00 0d 00 00 00 91 00 00 00 29 00 00 00 9e 00 00 00 0d 00 00 00  ....................)...........
0042f2e0  a1 00 00 00 02 00 00 00 a4 00 00 00 0b 00 00 00 a7 00 00 00 0d 00 00 00 b7 00 00 00 11 00 00 00  ................................
0042f300  ce 00 00 00 02 00 00 00 d7 00 00 00 0b 00 00 00 18 07 00 00 0c 00 00 00                          ........................

0042f318  int32_t data_42f318 = 0x173f

0042f31c                                                                                      00 00 00 00                              ....

0042f320  void* data_42f320 = sub_41e324
0042f324  int32_t data_42f324 = 0x1
0042f328  void* data_42f328 = sub_425828
0042f32c  void* data_42f32c = sub_425828
0042f330  void* data_42f330 = sub_425828
0042f334  void* data_42f334 = sub_425828
0042f338  void* data_42f338 = sub_425828
0042f33c  void* data_42f33c = sub_425828

0042f340  a0 39 82 02 00 00 00 00 a0 39 82 02 01 01 00 00                                                  .9.......9......
0042f350  data_42f350:
0042f350                                                  00 00 00 00 00 00 00 00 00 10 00 00 00 00 00 00                  ................
0042f360  data_42f360:
0042f360  00 00 00 00 00 00 00 00 00 00 00 00 02 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f380  00 00 00 00 00 00 00 00 00 00 00 00 02 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f3a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f3c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f3e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f400  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f460  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f4a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f4c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f4e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f5a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

0042f5c0  char const (* data_42f5c0)[0x7] = data_42936c {"(null)"}
0042f5c4  wchar16 const (* data_42f5c4)[0x7] = data_42935c {u"(null)"}

0042f5c8                          00 00 00 00 00 00 00 00                                                          ........
0042f5d0  data_42f5d0:
0042f5d0                                                  ff ff ff ff 00 0a 00 00 00 00 00 00 00 00 00 00                  ................
0042f5e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                      ....................

0042f5f4  wchar16 (* data_42f5f4)[0x21] = data_42f5fe {u"         (((((                  …"}
0042f5f8  wchar16 (* data_42f5f8)[0x21] = data_42f5fe {u"         (((((                  …"}

0042f5fc                                                                                      00 00                                    ..

0042f5fe  wchar16 data_42f5fe[0x21] = "         (((((                  H"

0042f640  10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00 84 00  ................................
0042f660  84 00 84 00 84 00 84 00 84 00 84 00 84 00 84 00 84 00 10 00 10 00 10 00 10 00 10 00 10 00 10 00  ................................
0042f680  81 00 81 00 81 00 81 00 81 00 81 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00  ................................
0042f6a0  01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 01 00 10 00 10 00 10 00 10 00 10 00 10 00  ................................
0042f6c0  82 00 82 00 82 00 82 00 82 00 82 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00  ................................
0042f6e0  02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 02 00 10 00 10 00 10 00 10 00 20 00 00 00  ............................ ...
0042f700  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f720  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f760  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f7a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f7c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f7e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

0042f800  int32_t data_42f800 = 0x1
0042f804  char data_42f804 = 0x2e

0042f805                 00 00 00 01 00 00 00 00 00 00 00 10 00 00 00                                           ...............
0042f814  data_42f814:
0042f814                                                              00 00 00 00                                              ....

0042f818  int32_t data_42f818 = 0x430c10

0042f81c                                                                                      00 00 00 00                              ....
0042f820  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................

0042f838  int32_t data_42f838 = 0x430c40

0042f83c                                                                                      00 00 00 00                              ....
0042f840  00 00 00 00 00 00 00 00                                                                          ........

0042f848  int32_t data_42f848 = 0x430c58

0042f84c                                      00 00 00 00 00 00 00 00 00 00 00 00                                      ............

0042f858  int32_t data_42f858 = 0x430c28

0042f85c                                                                                      00 00 00 00                              ....
0042f860  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f880  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f8a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f8c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                      ....................

0042f8d4  int32_t data_42f8d4 = 0x3f8

0042f8d8                                                                          00 00 00 00 00 00 00 00                          ........

0042f8e0  char data_42f8e0[0x6] = " \t-\r]", 0

0042f8e6                    00 00                                                                                ..
0042f8e8  data_42f8e8:
0042f8e8                          5d 00 00 00 00 00 00 00                                                          ].......

0042f8f0  char const (* data_42f8f0)[0x9] = data_4296a0 {"No error"}
0042f8f4  char const (* data_42f8f4)[0x18] = data_429688 {"Operation not permitted"}
0042f8f8  char const (* data_42f8f8)[0x1a] = data_42966c {"No such file or directory"}
0042f8fc  char const (* data_42f8fc)[0x10] = data_42965c {"No such process"}
0042f900  char const (* data_42f900)[0x1a] = data_429640 {"Interrupted function call"}
0042f904  char const (* data_42f904)[0x13] = data_42962c {"Input/output error"}
0042f908  char const (* data_42f908)[0x1a] = data_429610 {"No such device or address"}
0042f90c  char const (* data_42f90c)[0x12] = data_4295fc {"Arg list too long"}
0042f910  char const (* data_42f910)[0x12] = data_4295e8 {"Exec format error"}
0042f914  char const (* data_42f914)[0x14] = data_4295d4 {"Bad file descriptor"}
0042f918  char const (* data_42f918)[0x13] = data_4295c0 {"No child processes"}
0042f91c  char const (* data_42f91c)[0x21] = data_42959c {"Resource temporarily unavailable"}
0042f920  char const (* data_42f920)[0x11] = data_429588 {"Not enough space"}
0042f924  char const (* data_42f924)[0x12] = data_429574 {"Permission denied"}
0042f928  char const (* data_42f928)[0xc] = data_429568 {"Bad address"}
0042f92c  char const (* data_42f92c)[0xe] = data_429558 {"Unknown error"}
0042f930  char const (* data_42f930)[0x10] = data_429548 {"Resource device"}
0042f934  char const (* data_42f934)[0xc] = data_42953c {"File exists"}
0042f938  char const (* data_42f938)[0xe] = data_42952c {"Improper link"}
0042f93c  char const (* data_42f93c)[0xf] = data_42951c {"No such device"}
0042f940  char const (* data_42f940)[0x10] = data_42950c {"Not a directory"}
0042f944  char const (* data_42f944)[0xf] = data_4294fc {"Is a directory"}
0042f948  char const (* data_42f948)[0x11] = data_4294e8 {"Invalid argument"}
0042f94c  char const (* data_42f94c)[0x1e] = data_4294c8 {"Too many open files in system"}
0042f950  char const (* data_42f950)[0x14] = data_4294b4 {"Too many open files"}
0042f954  char const (* data_42f954)[0x24] = data_429490 {"Inappropriate I/O control operat…"}
0042f958  char const (* data_42f958)[0xe] = data_429558 {"Unknown error"}
0042f95c  char const (* data_42f95c)[0xf] = data_429480 {"File too large"}
0042f960  char const (* data_42f960)[0x18] = data_429468 {"No space left on device"}
0042f964  char const (* data_42f964)[0xd] = data_429458 {"Invalid seek"}
0042f968  char const (* data_42f968)[0x16] = data_429440 {"Read-only file system"}
0042f96c  char const (* data_42f96c)[0xf] = data_429430 {"Too many links"}
0042f970  char const (* data_42f970)[0xc] = data_429424 {"Broken pipe"}
0042f974  char const (* data_42f974)[0xd] = data_429414 {"Domain error"}
0042f978  char const (* data_42f978)[0x11] = data_429400 {"Result too large"}
0042f97c  char const (* data_42f97c)[0xe] = data_429558 {"Unknown error"}
0042f980  char const (* data_42f980)[0x1a] = data_4293e4 {"Resource deadlock avoided"}
0042f984  char const (* data_42f984)[0xe] = data_429558 {"Unknown error"}
0042f988  char const (* data_42f988)[0x12] = data_4293d0 {"Filename too long"}
0042f98c  char const (* data_42f98c)[0x13] = data_4293bc {"No locks available"}
0042f990  char const (* data_42f990)[0x19] = data_4293a0 {"Function not implemented"}
0042f994  char const (* data_42f994)[0x14] = data_42938c {"Directory not empty"}
0042f998  char const (* data_42f998)[0x16] = data_429374 {"Illegal byte sequence"}
0042f99c  char const (* data_42f99c)[0xe] = data_429558 {"Unknown error"}
0042f9a0  int32_t data_42f9a0 = 0x2b
0042f9a4  int32_t data_42f9a4 = -0x1

0042f9a8                          43 00 00 00 43 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          C...C...................
0042f9c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042f9e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042fa00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042fa20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 43 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................C...............
0042fa40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042fa60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042fa80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042faa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................
0042fab8  data_42fab8:
0042fab8                                                                          14 00 00 00                                      ....
0042fabc  data_42fabc:
0042fabc                                                                                      80 97 42 00                              ..B.
0042fac0  1d 00 00 00 7c 97 42 00 1a 00 00 00 78 97 42 00 1b 00 00 00                                      ....|.B.....x.B.....

0042fad4  char const (* data_42fad4)[0x6] = data_429770 {"log10"}

0042fad8                                                                          1f 00 00 00                                      ....

0042fadc  char const (* data_42fadc)[0x5] = data_429768 {"sinh"}

0042fae0  13 00 00 00                                                                                      ....

0042fae4  char const (* data_42fae4)[0x5] = data_429760 {"cosh"}

0042fae8                          21 00 00 00                                                                      !...

0042faec  char const (* data_42faec)[0x5] = data_429758 {"tanh"}

0042faf0                                                  0e 00 00 00                                                      ....

0042faf4  char const (* data_42faf4)[0x5] = data_429750 {"asin"}

0042faf8                                                                          0d 00 00 00                                      ....

0042fafc  char const (* data_42fafc)[0x5] = data_429748 {"acos"}

0042fb00  0f 00 00 00                                                                                      ....

0042fb04  char const (* data_42fb04)[0x5] = data_429740 {"atan"}

0042fb08                          10 00 00 00                                                                      ....

0042fb0c  char const (* data_42fb0c)[0x6] = data_429738 {"atan2"}

0042fb10                                                  05 00 00 00                                                      ....

0042fb14  char const (* data_42fb14)[0x5] = data_429730 {"sqrt"}

0042fb18                                                                          1e 00 00 00 2c 97 42 00                          ....,.B.
0042fb20  12 00 00 00 28 97 42 00 20 00 00 00 24 97 42 00 0c 00 00 00                                      ....(.B. ...$.B.....

0042fb34  char const (* data_42fb34)[0x5] = data_42971c {"ceil"}

0042fb38                                                                          0b 00 00 00                                      ....

0042fb3c  char const (* data_42fb3c)[0x6] = data_429714 {"floor"}

0042fb40  15 00 00 00                                                                                      ....

0042fb44  char const (* data_42fb44)[0x5] = data_42970c {"fabs"}

0042fb48                          1c 00 00 00                                                                      ....

0042fb4c  char const (* data_42fb4c)[0x5] = data_429704 {"modf"}

0042fb50                                                  19 00 00 00                                                      ....

0042fb54  char const (* data_42fb54)[0x6] = data_4296fc {"ldexp"}

0042fb58                                                                          11 00 00 00                                      ....

0042fb5c  char const (* data_42fb5c)[0x6] = data_4296f4 {"_cabs"}

0042fb60  18 00 00 00                                                                                      ....

0042fb64  char const (* data_42fb64)[0x7] = data_4296ec {"_hypot"}

0042fb68                          16 00 00 00                                                                      ....

0042fb6c  char const (* data_42fb6c)[0x5] = data_4296e4 {"fmod"}

0042fb70                                                  17 00 00 00                                                      ....

0042fb74  char const (* data_42fb74)[0x6] = data_4296dc {"frexp"}

0042fb78                                                                          22 00 00 00 d8 96 42 00                          ".....B.
0042fb80  23 00 00 00 d4 96 42 00 24 00 00 00 d0 96 42 00                                                  #.....B.$.....B.

0042fb90  int64_t data_42fb90 = 0x7ff0000000000000

0042fb98                                                                          00 00 00 00 00 00 f8 ff                          ........

0042fba0  int64_t data_42fba0 = 0x7fefffffffffffff

0042fba8                          00 00 00 00 00 00 10 00 00 00 00 00 00 00 00 80                                  ................

0042fbb8  int80_t data_42fbb8 = 
0042fbb8                                                                          00 00 00 00 00 00 00 80                          ........
0042fbc0  10 44                                                                                            .D

0042fbc2        00 00                                                                                        ..

0042fbc4  int80_t data_42fbc4 = 
0042fbc4              01 00 00 00 00 00 00 80 00 30                                                            .........0

0042fbce                                            00 00 01 02 04 08 00 00 00 00                                        ..........
0042fbd8  data_42fbd8:
0042fbd8                                                                          a4 03 00 00 60 82 79 82                          ....`.y.
0042fbe0  21 00 00 00 00 00 00 00 a6 df 00 00 00 00 00 00 a1 a5 00 00 00 00 00 00 81 9f e0 fc 00 00 00 00  !...............................
0042fc00  40 7e 80 fc 00 00 00 00 a8 03 00 00 c1 a3 da a3 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  @~.............. ...............
0042fc20  00 00 00 00 00 00 00 00 81 fe 00 00 00 00 00 00 40 fe 00 00 00 00 00 00 b5 03 00 00 c1 a3 da a3  ................@...............
0042fc40  20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 81 fe 00 00 00 00 00 00   ...............................
0042fc60  41 fe 00 00 00 00 00 00 b6 03 00 00 cf a2 e4 a2 1a 00 e5 a2 e8 a2 5b 00 00 00 00 00 00 00 00 00  A.....................[.........
0042fc80  00 00 00 00 00 00 00 00 81 fe 00 00 00 00 00 00 40 7e a1 fe 00 00 00 00 51 05 00 00 51 da 5e da  ................@~......Q...Q.^.
0042fca0  20 00 5f da 6a da 32 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 81 d3 d8 de e0 f9 00 00   ._.j.2.........................
0042fcc0  31 7e 81 fe 00 00 00 00 05 00 00 c0 0b 00 00 00 00 00 00 00 1d 00 00 c0 04 00 00 00 00 00 00 00  1~..............................
0042fce0  96 00 00 c0 04 00 00 00 00 00 00 00 8d 00 00 c0 08 00 00 00 00 00 00 00 8e 00 00 c0 08 00 00 00  ................................
0042fd00  00 00 00 00 8f 00 00 c0 08 00 00 00 00 00 00 00 90 00 00 c0 08 00 00 00 00 00 00 00 91 00 00 c0  ................................
0042fd20  08 00 00 00 00 00 00 00 92 00 00 c0 08 00 00 00 00 00 00 00 93 00 00 c0 08 00 00 00 00 00 00 00  ................................

0042fd40  int32_t data_42fd40 = 0x3
0042fd44  int32_t data_42fd44 = 0x7

0042fd48                          78 00 00 00                                                                      x...

0042fd4c  int32_t data_42fd4c = 0xa

0042fd50                                                  20 05 93 19                                                       ...

0042fd54  int32_t data_42fd54 = 0x0
0042fd58  int32_t data_42fd58 = 0x0
0042fd5c  int32_t data_42fd5c = 0x0

0042fd60  data_42fd60:
0042fd60  02 00 00 00                                                                                      ....

0042fd64  char const (* data_42fd64)[0x25] = data_4299e4 {"R6002\r\n- floating point not lo…"}

0042fd68                          08 00 00 00                                                                      ....

0042fd6c  char const (* data_42fd6c)[0x2a] = data_4299b8 {"R6008\r\n- not enough space for …"}

0042fd70                                                  09 00 00 00                                                      ....

0042fd74  char const (* data_42fd74)[0x2c] = data_42998c {"R6009\r\n- not enough space for …"}

0042fd78                                                                          0a 00 00 00                                      ....

0042fd7c  char const (* data_42fd7c)[0x21] = data_429968 {"\r\nabnormal program termination…"}

0042fd80  10 00 00 00                                                                                      ....

0042fd84  char const (* data_42fd84)[0x2c] = data_42993c {"R6016\r\n- not enough space for …"}

0042fd88                          11 00 00 00                                                                      ....

0042fd8c  char const (* data_42fd8c)[0x2d] = data_42990c {"R6017\r\n- unexpected multithrea…"}

0042fd90                                                  12 00 00 00                                                      ....

0042fd94  char const (* data_42fd94)[0x21] = data_4298e8 {"R6018\r\n- unexpected heap error…"}

0042fd98                                                                          13 00 00 00                                      ....

0042fd9c  char const (* data_42fd9c)[0x29] = data_4298bc {"R6019\r\n- unable to open consol…"}

0042fda0  18 00 00 00                                                                                      ....

0042fda4  char const (* data_42fda4)[0x35] = data_429884 {"R6024\r\n- not enough space for …"}

0042fda8                          19 00 00 00                                                                      ....

0042fdac  char const (* data_42fdac)[0x26] = data_42985c {"R6025\r\n- pure virtual function…"}

0042fdb0                                                  1a 00 00 00                                                      ....

0042fdb4  char const (* data_42fdb4)[0x35] = data_429824 {"R6026\r\n- not enough space for …"}

0042fdb8                                                                          1b 00 00 00                                      ....

0042fdbc  char const (* data_42fdbc)[0x35] = data_4297ec {"R6027\r\n- not enough space for …"}

0042fdc0  1c 00 00 00                                                                                      ....

0042fdc4  char const (* data_42fdc4)[0x25] = data_4297c4 {"R6028\r\n- unable to initialize …"}

0042fdc8                          78 00 00 00                                                                      x...

0042fdcc  char const (* data_42fdcc)[0xf] = data_4297b4 {"DOMAIN error\r\n"}

0042fdd0                                                  79 00 00 00                                                      y...

0042fdd4  char const (* data_42fdd4)[0xd] = data_4297a4 {"SING error\r\n"}

0042fdd8                                                                          7a 00 00 00                                      z...

0042fddc  char const (* data_42fddc)[0xe] = data_429794 {"TLOSS error\r\n"}

0042fde0  fc 00 00 00                                                                                      ....

0042fde4  void* data_42fde4 = data_42d174

0042fde8                          ff 00 00 00                                                                      ....

0042fdec  char const (* data_42fdec)[0xf] = data_429784 {"runtime error "}

0042fdf0  data_42fdf0:
0042fdf0                                                  00 04 00 00 01 fc ff ff 35 00 00 00 0b 00 00 00                  ........5.......
0042fe00  40 00 00 00 ff 03 00 00                                                                          @.......
0042fe08  data_42fe08:
0042fe08                          80 00 00 00 81 ff ff ff 18 00 00 00 08 00 00 00 20 00 00 00 7f 00 00 00          ................ .......

0042fe20  int32_t data_42fe20 = 0x7080
0042fe24  int32_t data_42fe24 = 0x1
0042fe28  int32_t data_42fe28 = -0xe10

0042fe2c                                      50 53 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              PST.................
0042fe40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042fe60  00 00 00 00 00 00 00 00 00 00 00 00 50 44 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ............PDT.................
0042fe80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
0042fea0  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............

0042feac  int32_t data_42feac = 0x42fe2c
0042feb0  int32_t data_42feb0 = 0x42fe6c

0042feb4                                                              00 00 00 00                                              ....

0042feb8  int32_t data_42feb8 = -0x1
0042febc  int32_t data_42febc = 0x0
0042fec0  int32_t data_42fec0 = 0x0

0042fec4              00 00 00 00                                                                              ....

0042fec8  int32_t data_42fec8 = -0x1
0042fecc  int32_t data_42fecc = 0x0
0042fed0  int32_t data_42fed0 = 0x0

0042fed4                                                              ff ff ff ff 1e 00 00 00 3b 00 00 00                      ........;...
0042fee0  5a 00 00 00 78 00 00 00 97 00 00 00 b5 00 00 00 d4 00 00 00 f3 00 00 00 11 01 00 00 30 01 00 00  Z...x.......................0...
0042ff00  4e 01 00 00                                                                                      N...
0042ff04  data_42ff04:
0042ff04              6d 01 00 00 ff ff ff ff 1e 00 00 00 3a 00 00 00 59 00 00 00 77 00 00 00 96 00 00 00      m...........:...Y...w.......
0042ff20  b4 00 00 00 d3 00 00 00 f2 00 00 00 10 01 00 00 2f 01 00 00 4d 01 00 00 6c 01 00 00 00 00 00 00  ................/...M...l.......

0042ff40  int32_t data_42ff40 = 0x2694

0042ff44              00 00 00 00 00 00 00 00 00 00 00 00 58 ff 42 00 00 00 00 00 3c 9c 42 00 38 9c 42 00      ............X.B.....<.B.8.B.
0042ff60  34 9c 42 00 30 9c 42 00 2c 9c 42 00 28 9c 42 00 24 9c 42 00                                      4.B.0.B.,.B.(.B.$.B.

0042ff74  char const (* data_42ff74)[0x7] = data_429c1c {"Sunday"}
0042ff78  char const (* data_42ff78)[0x7] = data_429c14 {"Monday"}
0042ff7c  char const (* data_42ff7c)[0x8] = data_429c0c {"Tuesday"}
0042ff80  char const (* data_42ff80)[0xa] = data_429c00 {"Wednesday"}
0042ff84  char const (* data_42ff84)[0x9] = data_429bf4 {"Thursday"}
0042ff88  char const (* data_42ff88)[0x7] = data_429bec {"Friday"}
0042ff8c  char const (* data_42ff8c)[0x9] = data_429be0 {"Saturday"}

0042ff90                                                  dc 9b 42 00 d8 9b 42 00 d4 9b 42 00 d0 9b 42 00                  ..B...B...B...B.
0042ffa0  cc 9b 42 00 c8 9b 42 00 c4 9b 42 00 c0 9b 42 00 bc 9b 42 00 b8 9b 42 00 b4 9b 42 00 b0 9b 42 00  ..B...B...B...B...B...B...B...B.

0042ffc0  char const (* data_42ffc0)[0x8] = data_429ba8 {"January"}
0042ffc4  char const (* data_42ffc4)[0x9] = data_429b9c {"February"}
0042ffc8  char const (* data_42ffc8)[0x6] = data_429b94 {"March"}
0042ffcc  char const (* data_42ffcc)[0x6] = data_429b8c {"April"}

0042ffd0                                                  cc 9b 42 00                                                      ..B.

0042ffd4  char const (* data_42ffd4)[0x5] = data_429b84 {"June"}
0042ffd8  char const (* data_42ffd8)[0x5] = data_429b7c {"July"}
0042ffdc  char const (* data_42ffdc)[0x7] = data_429b74 {"August"}
0042ffe0  char const (* data_42ffe0)[0xa] = data_429b68 {"September"}
0042ffe4  char const (* data_42ffe4)[0x8] = data_429b60 {"October"}
0042ffe8  char const (* data_42ffe8)[0x9] = data_429b54 {"November"}
0042ffec  char const (* data_42ffec)[0x9] = data_429b48 {"December"}

0042fff0                                                  44 9b 42 00 40 9b 42 00                                          D.B.@.B.

0042fff8  char const (* data_42fff8)[0x7] = data_429b38 {"M/d/yy"}
0042fffc  char const (* data_42fffc)[0x14] = data_429b24 {"dddd, MMMM dd, yyyy"}
00430000  char const (* data_430000)[0x8] = data_429b1c {"H:mm:ss"}

00430004              00 00 00 00 2e 00 00 00 00 00 00 00 08 00 43 00 0c 0f 43 00 0c 0f 43 00 0c 0f 43 00      ..............C...C...C...C.
00430020  0c 0f 43 00 0c 0f 43 00 0c 0f 43 00 0c 0f 43 00 0c 0f 43 00 0c 0f 43 00 7f 7f 7f 7f 7f 7f 7f 7f  ..C...C...C...C...C...C.........
00430040  10 00 43 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 a0 02 40 00 00 00 00  ..C........................@....
00430060  00 00 00 00 00 c8 05 40 00 00 00 00 00 00 00 00 00 fa 08 40 00 00 00 00 00 00 00 00 40 9c 0c 40  .......@...........@........@..@
00430080  00 00 00 00 00 00 00 00 50 c3 0f 40 00 00 00 00 00 00 00 00 24 f4 12 40 00 00 00 00 00 00 00 80  ........P..@........$..@........
004300a0  96 98 16 40 00 00 00 00 00 00 00 20 bc be 19 40 00 00 00 00 00 04 bf c9 1b 8e 34 40 00 00 00 a1  ...@....... ...@..........4@....
004300c0  ed cc ce 1b c2 d3 4e 40 20 f0 9e b5 70 2b a8 ad c5 9d 69 40 d0 5d fd 25 e5 1a 8e 4f 19 eb 83 40  ......N@ ...p+....i@.].%...O...@
004300e0  71 96 d7 95 43 0e 05 8d 29 af 9e 40 f9 bf a0 44 ed 81 12 8f 81 82 b9 40 bf 3c d5 a6 cf ff 49 1f  q...C...)..@...D.......@.<....I.
00430100  78 c2 d3 40 6f c6 e0 8c e9 80 c9 47 ba 93 a8 41 bc 85 6b 55 27 39 8d f7 70 e0 7c 42 bc dd 8e de  x..@o......G...A..kU'9..p.|B....
00430120  f9 9d fb eb 7e aa 51 43 a1 e6 76 e3 cc f2 29 2f 84 81 26 44 28 10 17 aa f8 ae 10 e3 c5 c4 fa 44  ....~.QC..v...)/..&D(..........D
00430140  eb a7 d4 f3 f7 eb e1 4a 7a 95 cf 45 65 cc c7 91 0e a6 ae a0 19 e3 a3 46 0d 65 17 0c 75 81 86 75  .......Jz..Ee..........F.e..u..u
00430160  76 c9 48 4d 58 42 e4 a7 93 39 3b 35 b8 b2 ed 53 4d a7 e5 5d 3d c5 5d 3b 8b 9e 92 5a ff 5d a6 f0  v.HMXB...9;5...SM..]=.];...Z.]..
00430180  a1 20 c0 54 a5 8c 37 61 d1 fd 8b 5a 8b d8 25 5d 89 f9 db 67 aa 95 f8 f3 27 bf a2 c8 5d dd 80 6e  . .T..7a...Z..%]...g....'...]..n
004301a0  4c c9 9b 97 20 8a 02 52 60 c4 25 75 00 00 00 00 cd cc cd cc cc cc cc cc cc cc fb 3f 71 3d 0a d7  L... ..R`.%u...............?q=..
004301c0  a3 70 3d 0a d7 a3 f8 3f 5a 64 3b df 4f 8d 97 6e 12 83 f5 3f c3 d3 2c 65 19 e2 58 17 b7 d1 f1 3f  .p=....?Zd;.O..n...?..,e..X....?
004301e0  d0 0f 23 84 47 1b 47 ac c5 a7 ee 3f 40 a6 b6 69 6c af 05 bd 37 86 eb 3f 33 3d bc 42 7a e5 d5 94  ..#.G.G....?@..il...7..?3=.Bz...
00430200  bf d6 e7 3f c2 fd fd ce 61 84 11 77 cc ab e4 3f 2f 4c 5b e1 4d c4 be 94 95 e6 c9 3f 92 c4 53 3b  ...?....a..w...?/L[.M......?..S;
00430220  75 44 cd 14 be 9a af 3f de 67 ba 94 39 45 ad 1e b1 cf 94 3f 24 23 c6 e2 bc ba 3b 31 61 8b 7a 3f  uD.....?.g..9E.....?$#....;1a.z?
00430240  61 55 59 c1 7e b1 53 7c 12 bb 5f 3f d7 ee 2f 8d 06 be 92 85 15 fb 44 3f 24 3f a5 e9 39 a5 27 ea  aUY.~.S|.._?../.......D?$?..9.'.
00430260  7f a8 2a 3f 7d ac a1 e4 bc 64 7c 46 d0 dd 55 3e 63 7b 06 cc 23 54 77 83 ff 91 81 3d 91 fa 3a 19  ..*?}....d|F..U>c{..#Tw....=..:.
00430280  7a 63 25 43 31 c0 ac 3c 21 89 d1 38 82 47 97 b8 00 fd d7 3b dc 88 58 08 1b b1 e8 e3 86 a6 03 3b  zc%C1..<!..8.G.....;..X........;
004302a0  c6 84 45 42 07 b6 99 75 37 db 2e 3a 33 71 1c d2 23 db 32 ee 49 90 5a 39 a6 87 be c0 57 da a5 82  ..EB...u7..:3q..#.2.I.Z9....W...
004302c0  a6 a2 b5 32 e2 68 b2 11 a7 52 9f 44 59 b7 10 2c 25 49 e4 2d 36 34 4f 53 ae ce 6b 25 8f 59 04 a4  ...2.h...R.DY..,%I.-64OS..k%.Y..
004302e0  c0 de c2 7d fb e8 c6 1e 9e e7 88 5a 57 91 3c bf 50 83 22 18 4e 4b 65 62 fd 83 8f af 06 94 7d 11  ...}.......ZW.<.P.".NKeb......}.
00430300  e4 2d de 9f ce d2 c8 04 dd a6 d8 0a 00 00 00 00                                                  .-..............

00430310  int32_t data_430310 = 0x0
00430314  int32_t data_430314 = 0x0
00430318  int32_t data_430318 = 0x0
0043031c  int32_t data_43031c = 0x0

00430320  00 00 00 00                                                                                      ....

00430324  int32_t data_430324 = 0x0
00430328  int32_t data_430328 = 0x0
0043032c  char data_43032c = 0x0

0043032d                                         00 00 00 00 00 00 00                                                   .......

00430334  int32_t data_430334 = 0x0

00430338                                                                          00 00 00 00                                      ....

0043033c  int32_t data_43033c = 0x0

00430340  00 00 00 00                                                                                      ....

00430344  int32_t data_430344 = 0x0

00430348                          00 00 00 00                                                                      ....

0043034c  int32_t data_43034c = 0x0

00430350  data_430350:
00430350                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
00430360  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430380  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004303a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004303c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004303e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430400  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430420  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430440  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430460  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430480  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004304a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004304c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004304e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430500  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430520  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430540  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430560  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430580  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004305a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004305c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004305e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430600  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430620  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430640  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430660  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430680  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004306a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004306c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004306e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430700  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430720  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430740  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430760  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430780  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004307a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004307c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004307e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430800  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430820  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430840  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430860  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430880  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004308a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004308c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004308e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430900  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430920  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430940  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430960  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430980  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004309a0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004309c0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
004309e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430a00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430a20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430a40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430a60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430a80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430aa0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ac0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ae0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430b00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430b20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430b40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00430b50  int32_t data_430b50 = 0x0
00430b54  int32_t data_430b54 = 0x0
00430b58  int32_t data_430b58 = 0x0
00430b5c  int32_t data_430b5c = 0x0

00430b60  00 00 00 00                                                                                      ....

00430b64  int32_t data_430b64 = 0x0
00430b68  int32_t data_430b68 = 0x0

00430b6c                                      00 00 00 00                                                              ....

00430b70  int32_t data_430b70 = 0x0
00430b74  int32_t data_430b74 = 0x0
00430b78  int32_t data_430b78 = 0x0
00430b7c  int32_t data_430b7c = 0x0
00430b80  int32_t data_430b80 = 0x0
00430b84  int32_t data_430b84 = 0x0
00430b88  int32_t data_430b88 = 0x0
00430b8c  int32_t data_430b8c = 0x0

00430b90                                                  00 00 00 00                                                      ....

00430b94  int32_t data_430b94 = 0x0
00430b98  int32_t data_430b98 = 0x0
00430b9c  int32_t data_430b9c = 0x0

00430ba0  00 00 00 00                                                                                      ....

00430ba4  int32_t data_430ba4 = 0x0

00430ba8                          00 00 00 00                                                                      ....

00430bac  char data_430bac = 0x0

00430bad                                         00 00 00                                                               ...

00430bb0  int32_t data_430bb0 = 0x0
00430bb4  int32_t data_430bb4 = 0x0
00430bb8  int32_t data_430bb8 = 0x0

00430bbc  data_430bbc:
00430bbc                                                                                      00 00 00 00                              ....

00430bc0  int16_t data_430bc0 = 0x0
00430bc2  int16_t data_430bc2 = 0x0

00430bc4  data_430bc4:
00430bc4              00 00                                                                                    ..

00430bc6  int16_t data_430bc6 = 0x0
00430bc8  int16_t data_430bc8 = 0x0
00430bca  int16_t data_430bca = 0x0

00430bcc                                      00 00 00 00                                                              ....
00430bd0  data_430bd0:
00430bd0                                                  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ................
00430be0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                          ........................

00430bf8  int32_t data_430bf8 = 0x0

00430bfc                                                                                      00 00 00 00                              ....

00430c00  int32_t data_430c00 = 0x0
00430c04  int32_t data_430c04 = 0x0

00430c08  data_430c08:
00430c08                          00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00          ........................
00430c20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430c40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430c60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00430c70  int32_t data_430c70 = 0x0
00430c74  int32_t data_430c74 = 0x0

00430c78                                                                          00 00 00 00 00 00 00 00                          ........
00430c80  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............

00430c8c  int32_t data_430c8c = 0x0

00430c90                                                  00 00 00 00 00 00 00 00 00 00 00 00                              ............

00430c9c  int32_t data_430c9c = 0x0

00430ca0  00 00 00 00                                                                                      ....

00430ca4  int32_t data_430ca4 = 0x0
00430ca8  int32_t data_430ca8 = 0x0

00430cac  data_430cac:
00430cac                                      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ....................
00430cc0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ce0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d60  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430d80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430da0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                                                  ................

00430db0  int32_t data_430db0 = 0x0
00430db4  int32_t data_430db4 = 0x0
00430db8  int32_t data_430db8 = 0x0
00430dbc  int32_t data_430dbc = 0x0
00430dc0  int32_t data_430dc0 = 0x0

00430dc4              00 00 00 00                                                                              ....

00430dc8  int32_t data_430dc8 = 0x0

00430dcc  data_430dcc:
00430dcc                                      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ....................
00430de0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430e00  00 00 00 00 00 00 00 00 00 00 00 00                                                              ............

00430e0c  int16_t data_430e0c = 0x0
00430e0e  int16_t data_430e0e = 0x0
00430e10  int16_t data_430e10 = 0x0
00430e12  int16_t data_430e12 = 0x0
00430e14  int16_t data_430e14 = 0x0
00430e16  int16_t data_430e16 = 0x0
00430e18  int16_t data_430e18 = 0x0
00430e1a  int16_t data_430e1a = 0x0
00430e1c  int32_t data_430e1c = 0x0

00430e20  data_430e20:
00430e20  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430e40  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00430e60  int16_t data_430e60 = 0x0
00430e62  int16_t data_430e62 = 0x0
00430e64  int16_t data_430e64 = 0x0
00430e66  int16_t data_430e66 = 0x0
00430e68  int16_t data_430e68 = 0x0
00430e6a  int16_t data_430e6a = 0x0
00430e6c  int16_t data_430e6c = 0x0
00430e6e  int16_t data_430e6e = 0x0
00430e70  int32_t data_430e70 = 0x0
00430e74  int32_t data_430e74 = 0x0
00430e78  int32_t data_430e78 = 0x0

00430e7c                                                                                      00 00 00 00                              ....
00430e80  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ea0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................
00430ec0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................................

00430ee0  int32_t data_430ee0 = 0x0
00430ee4  int32_t data_430ee4 = 0x0
00430ee8  int32_t data_430ee8 = 0x0

00430eec                                      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00              ....................

00430f00  int32_t data_430f00 = 0x0

00430f04              00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00                  ........................

00430f1c  int32_t data_430f1c = 0x0

028249a0  int32_t data_28249a0 = 0x0
028249a4  int32_t data_28249a4 = 0x0
028249a8  int32_t data_28249a8 = 0x0
028249ac  int32_t data_28249ac = 0x0
028249b0  int32_t data_28249b0 = 0x0
028249b4  int32_t data_28249b4 = 0x0
.data section ended  {0x42b000-0x28249b8}

.extern section started  {0x28249c0-0x2824af0}
028249c0  extern BOOL __stdcall CloseHandle(HANDLE hObject)
028249c4  extern enum COMPARESTRING_RESULT __stdcall CompareStringA(uint32_t Locale, uint32_t dwCmpFlags, char* lpString1, int32_t cchCount1, char* lpString2, int32_t cchCount2)
028249c8  extern enum COMPARESTRING_RESULT __stdcall CompareStringW(uint32_t Locale, uint32_t dwCmpFlags, wchar16* lpString1, int32_t cchCount1, wchar16* lpString2, int32_t cchCount2)
028249cc  extern HANDLE __stdcall CreateFileA(PSTR lpFileName, uint32_t dwDesiredAccess, enum FILE_SHARE_MODE dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, enum FILE_CREATION_DISPOSITION dwCreationDisposition, enum FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile)
028249d0  extern HANDLE __stdcall CreateThread(SECURITY_ATTRIBUTES* lpThreadAttributes, uint32_t dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, enum THREAD_CREATION_FLAGS dwCreationFlags, uint32_t* lpThreadId)
028249d4  extern void __stdcall DeleteCriticalSection(CRITICAL_SECTION* lpCriticalSection)
028249d8  extern BOOL __stdcall DeleteFileA(PSTR lpFileName)
028249dc  extern void __stdcall EnterCriticalSection(CRITICAL_SECTION* lpCriticalSection)
028249e0  extern void __stdcall ExitProcess(uint32_t uExitCode) __noreturn
028249e4  extern BOOL __stdcall FileTimeToLocalFileTime(FILETIME* lpFileTime, FILETIME* lpLocalFileTime)
028249e8  extern BOOL __stdcall FileTimeToSystemTime(FILETIME* lpFileTime, SYSTEMTIME* lpSystemTime)
028249ec  extern BOOL __stdcall FindClose(HANDLE hFindFile)
028249f0  extern HANDLE __stdcall FindFirstFileA(PSTR lpFileName, WIN32_FIND_DATAA* lpFindFileData)
028249f4  extern BOOL __stdcall FindNextFileA(HANDLE hFindFile, WIN32_FIND_DATAA* lpFindFileData)
028249f8  extern BOOL __stdcall FlushFileBuffers(HANDLE hFile)
028249fc  extern BOOL __stdcall FreeEnvironmentStringsA(PSTR penv)
02824a00  extern BOOL __stdcall FreeEnvironmentStringsW(PWSTR penv)
02824a04  extern uint32_t __stdcall GetACP()
02824a08  extern BOOL __stdcall GetCPInfo(uint32_t CodePage, CPINFO* lpCPInfo)
02824a0c  extern PSTR __stdcall GetCommandLineA()
02824a10  extern uint32_t __stdcall GetCurrentDirectoryA(uint32_t nBufferLength, uint8_t* lpBuffer)
02824a14  extern HANDLE __stdcall GetCurrentProcess()
02824a18  extern uint32_t __stdcall GetCurrentThreadId()
02824a1c  extern uint32_t __stdcall GetDriveTypeA(PSTR lpRootPathName)
02824a20  extern PSTR __stdcall GetEnvironmentStrings()
02824a24  extern PWSTR __stdcall GetEnvironmentStringsW()
02824a28  extern uint32_t __stdcall GetFileAttributesA(PSTR lpFileName)
02824a2c  extern enum FILE_TYPE __stdcall GetFileType(HANDLE hFile)
02824a30  extern uint32_t __stdcall GetFullPathNameA(PSTR lpFileName, uint32_t nBufferLength, uint8_t* lpBuffer, PSTR* lpFilePart)
02824a34  extern enum WIN32_ERROR __stdcall GetLastError()
02824a38  extern void __stdcall GetLocalTime(SYSTEMTIME* lpSystemTime)
02824a3c  extern uint32_t __stdcall GetModuleFileNameA(HMODULE hModule, uint8_t* lpFilename, uint32_t nSize)
02824a40  extern HMODULE __stdcall GetModuleHandleA(PSTR lpModuleName)
02824a44  extern uint32_t __stdcall GetOEMCP()
02824a48  extern FARPROC __stdcall GetProcAddress(HMODULE hModule, PSTR lpProcName)
02824a4c  extern void __stdcall GetStartupInfoA(STARTUPINFOA* lpStartupInfo)
02824a50  extern HANDLE __stdcall GetStdHandle(enum STD_HANDLE nStdHandle)
02824a54  extern BOOL __stdcall GetStringTypeA(uint32_t Locale, uint32_t dwInfoType, uint8_t* lpSrcStr, int32_t cchSrc, uint16_t* lpCharType)
02824a58  extern BOOL __stdcall GetStringTypeW(uint32_t dwInfoType, wchar16* lpSrcStr, int32_t cchSrc, uint16_t* lpCharType)
02824a5c  extern void __stdcall GetSystemInfo(SYSTEM_INFO* lpSystemInfo)
02824a60  extern void __stdcall GetSystemTime(SYSTEMTIME* lpSystemTime)
02824a64  extern uint32_t __stdcall GetTimeZoneInformation(TIME_ZONE_INFORMATION* lpTimeZoneInformation)
02824a68  extern uint32_t __stdcall GetVersion()
02824a6c  extern void* __stdcall HeapAlloc(HANDLE hHeap, enum HEAP_FLAGS dwFlags, uint32_t dwBytes)
02824a70  extern HANDLE __stdcall HeapCreate(enum HEAP_FLAGS flOptions, uint32_t dwInitialSize, uint32_t dwMaximumSize)
02824a74  extern BOOL __stdcall HeapDestroy(HANDLE hHeap)
02824a78  extern BOOL __stdcall HeapFree(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem)
02824a7c  extern void* __stdcall HeapReAlloc(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem, uint32_t dwBytes)
02824a80  extern uint32_t __stdcall HeapSize(HANDLE hHeap, enum HEAP_FLAGS dwFlags, void* lpMem)
02824a84  extern void __stdcall InitializeCriticalSection(CRITICAL_SECTION* lpCriticalSection)
02824a88  extern InterlockedDecrement
02824a8c  extern InterlockedIncrement
02824a90  extern int32_t __stdcall LCMapStringA(uint32_t Locale, uint32_t dwMapFlags, uint8_t* lpSrcStr, int32_t cchSrc, PSTR lpDestStr, int32_t cchDest)
02824a94  extern int32_t __stdcall LCMapStringW(uint32_t Locale, uint32_t dwMapFlags, wchar16* lpSrcStr, int32_t cchSrc, PWSTR lpDestStr, int32_t cchDest)
02824a98  extern void __stdcall LeaveCriticalSection(CRITICAL_SECTION* lpCriticalSection)
02824a9c  extern HMODULE __stdcall LoadLibraryA(PSTR lpLibFileName)
02824aa0  extern int32_t __stdcall MultiByteToWideChar(uint32_t CodePage, enum MULTI_BYTE_TO_WIDE_CHAR_FLAGS dwFlags, uint8_t* lpMultiByteStr, int32_t cbMultiByte, wchar16* lpWideCharStr, int32_t cchWideChar)
02824aa4  extern void __stdcall RaiseException(uint32_t dwExceptionCode, uint32_t dwExceptionFlags, uint32_t nNumberOfArguments, uint32_t* lpArguments) __noreturn
02824aa8  extern BOOL __stdcall ReadFile(HANDLE hFile, uint8_t* lpBuffer, uint32_t nNumberOfBytesToRead, uint32_t* lpNumberOfBytesRead, OVERLAPPED* lpOverlapped)
02824aac  extern void __stdcall RtlUnwind(void* TargetFrame, void* TargetIp, EXCEPTION_RECORD* ExceptionRecord, void* ReturnValue)
02824ab0  extern BOOL __stdcall SetEndOfFile(HANDLE hFile)
02824ab4  extern BOOL __stdcall SetEnvironmentVariableA(PSTR lpName, PSTR lpValue)
02824ab8  extern uint32_t __stdcall SetFilePointer(HANDLE hFile, int32_t lDistanceToMove, int32_t* lpDistanceToMoveHigh, enum SET_FILE_POINTER_MOVE_METHOD dwMoveMethod)
02824abc  extern uint32_t __stdcall SetHandleCount(uint32_t uNumber)
02824ac0  extern void __stdcall SetLastError(enum WIN32_ERROR dwErrCode)
02824ac4  extern BOOL __stdcall SetStdHandle(enum STD_HANDLE nStdHandle, HANDLE hHandle)
02824ac8  extern BOOL __stdcall TerminateProcess(HANDLE hProcess, uint32_t uExitCode)
02824acc  extern uint32_t __stdcall TlsAlloc()
02824ad0  extern void* __stdcall TlsGetValue(uint32_t dwTlsIndex)
02824ad4  extern BOOL __stdcall TlsSetValue(uint32_t dwTlsIndex, void* lpTlsValue)
02824ad8  extern int32_t __stdcall UnhandledExceptionFilter(EXCEPTION_POINTERS* ExceptionInfo)
02824adc  extern void* __stdcall VirtualAlloc(void* lpAddress, uint32_t dwSize, enum VIRTUAL_ALLOCATION_TYPE flAllocationType, enum PAGE_PROTECTION_FLAGS flProtect)
02824ae0  extern BOOL __stdcall VirtualFree(void* lpAddress, uint32_t dwSize, enum VIRTUAL_FREE_TYPE dwFreeType)
02824ae4  extern enum WAIT_EVENT __stdcall WaitForSingleObject(HANDLE hHandle, uint32_t dwMilliseconds)
02824ae8  extern int32_t __stdcall WideCharToMultiByte(uint32_t CodePage, uint32_t dwFlags, wchar16* lpWideCharStr, int32_t cchWideChar, PSTR lpMultiByteStr, int32_t cbMultiByte, PSTR lpDefaultChar, BOOL* lpUsedDefaultChar)
02824aec  extern BOOL __stdcall WriteFile(HANDLE hFile, uint8_t* lpBuffer, uint32_t nNumberOfBytesToWrite, uint32_t* lpNumberOfBytesWritten, OVERLAPPED* lpOverlapped)
.extern section ended  {0x28249c0-0x2824af0}

.synthetic_builtins section started  {0x2824af0-0x2824b04}
02824af0  extern void* __builtin_memcpy(void* dest, void const* src, uint32_t n)
02824af4  extern void* __builtin_memset(void* s, int32_t c, uint32_t n)
02824af8  extern char* __builtin_strcpy(char* dest, char const* src)
02824afc  extern char* __builtin_strncpy(char* dest, char const* src, uint32_t n)
02824b00  extern wchar16* __builtin_wcscpy(wchar16* dest, wchar16 const* src)
.synthetic_builtins section ended  {0x2824af0-0x2824b04}

