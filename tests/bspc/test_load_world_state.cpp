#include <cassert>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <string>

#include "bsp_builder.hpp"
#include "filesystem_helper.h"

#ifndef PROJECT_SOURCE_DIR
#error "PROJECT_SOURCE_DIR must be defined so regression tests can resolve asset paths."
#endif

namespace
{

std::filesystem::path MapAsset()
{
    return std::filesystem::path(PROJECT_SOURCE_DIR) / "tests/support/assets/bspc/simple_room.map";
}

std::filesystem::path BspAsset()
{
    static const std::uint8_t kMinimalBsp[] = {
        0x1d,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x1d,0x00,0x00,0x00,0x9c,0x00,0x00,0x00,
        0x14,0x00,0x00,0x00,0xb0,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,
        0x18,0x00,0x00,0x00,0xf8,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x20,0x01,0x00,0x00,
        0x14,0x00,0x00,0x00,0x34,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x34,0x01,0x00,0x00,
        0x00,0x00,0x00,0x00,0x34,0x01,0x00,0x00,0x18,0x00,0x00,0x00,0x4c,0x01,0x00,0x00,
        0x02,0x00,0x00,0x00,0x50,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x01,0x00,0x00,
        0x00,0x00,0x00,0x00,0x50,0x01,0x00,0x00,0x40,0x00,0x00,0x00,0x7b,0x0a,0x22,0x63,
        0x6c,0x61,0x73,0x73,0x6e,0x61,0x6d,0x65,0x22,0x20,0x22,0x77,0x6f,0x72,0x6c,0x64,
        0x73,0x70,0x61,0x77,0x6e,0x22,0x0a,0x7d,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3f,0x00,0x00,0x80,0x42,0x00,0x00,0x00,0x00,
        0x01,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x73,0x74,0x6f,0x6e,0x65,0x66,0x6c,0x6f,
        0x6f,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xf0,0xff,0xf0,0xff,0xf0,0xff,0x10,0x00,
        0x10,0x00,0x10,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x80,0x3f,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3f,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,
        0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0xf0,0xff,0xf0,0xff,0xf0,0xff,0x10,0x00,
        0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x80,0xc1,0x00,0x00,0x80,0xc1,0x00,0x00,0x80,0xc1,0x00,0x00,0x80,0x41,
        0x00,0x00,0x80,0x41,0x00,0x00,0x80,0x41,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
        0xff,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00
    };

    static const std::filesystem::path bsp_path = [] {
        auto path = std::filesystem::temp_directory_path() / "bspc_minimal_fixture.bsp";
        std::ofstream stream(path, std::ios::binary | std::ios::trunc);
        stream.write(reinterpret_cast<const char *>(kMinimalBsp), sizeof(kMinimalBsp));
        stream.flush();
        assert(stream.good());
        return path;
    }();

    return bsp_path;
}

bool HasClassname(const bspc::builder::ParsedWorld::Entity &entity, const std::string &expected)
{
    for (const auto &kv : entity.properties)
    {
        if (kv.key == "classname")
        {
            return kv.value == expected;
        }
    }
    return false;
}

} // namespace

int main()
{
    bspc::InputFile map_input;
    map_input.path = MapAsset();
    map_input.original = map_input.path.generic_string();

    bspc::builder::ParsedWorld map_world;
    std::string error;
    bool ok = bspc::builder::LoadWorldState(map_input, map_world, error);
    assert(ok && error.empty());
    assert(map_world.format == bspc::builder::ParsedWorld::SourceFormat::kMap);
    assert(!map_world.brushes.empty());
    assert(!map_world.planes.empty());
    assert(!map_world.surfaces.empty());
    assert(!map_world.textures.empty());
    assert(!map_world.entities.empty());
    assert(HasClassname(map_world.entities.front(), "worldspawn"));
    assert(!map_world.lines.empty());

    bspc::InputFile bsp_input;
    bsp_input.path = BspAsset();
    bsp_input.original = bsp_input.path.generic_string();

    bspc::builder::ParsedWorld bsp_world;
    error.clear();
    ok = bspc::builder::LoadWorldState(bsp_input, bsp_world, error);
    assert(ok && error.empty());
    assert(bsp_world.format == bspc::builder::ParsedWorld::SourceFormat::kQuake1Bsp);
    assert(bsp_world.bsp_version == 29);
    assert(bsp_world.planes.size() == 1);
    assert(bsp_world.surfaces.size() == 1);
    assert(bsp_world.nodes.size() == 1);
    assert(bsp_world.leaves.size() == 1);
    assert(bsp_world.textures.size() == 1);
    assert(bsp_world.brushes.empty());
    assert(!bsp_world.entities_text.empty());
    assert(!bsp_world.lines.empty());
    assert(bsp_world.textures.front().name == "stonefloor");

    return 0;
}

